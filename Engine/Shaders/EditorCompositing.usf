// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	EditorCompositing.usf: Shared code for editor compositing
=============================================================================*/
  
#pragma once

#include "Common.usf"

#define EDITOR_ALPHA2COVERAGE (USE_EDITOR_COMPOSITING && FEATURE_LEVEL >= FEATURE_LEVEL_SM5 && !COMPILER_GLSL)


#if USE_EDITOR_COMPOSITING
	bool bEnableEditorPrimitiveDepthTest;
	int MSAASampleCount;

	// depth in the red channel in DeviceZ
	Texture2D		FilteredSceneDepthTexture;
	SamplerState	FilteredSceneDepthTextureSampler;
#endif


// @return 0:translucent..1:opaque
float ClipForEditorPrimitives(FMaterialPixelParameters MaterialParameters)
{
	float Ret = 1;

#if USE_EDITOR_COMPOSITING && (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 || MOBILE_EMULATION)
	// Depth test manually if compositing editor primitives since the depth buffer is different (MSAA only)
	BRANCH
	if (bEnableEditorPrimitiveDepthTest)
	{
#if HAS_INVERTED_Z_BUFFER
		//@todo-briank
		bool bIsPerspective = (ResolvedView.ViewToClip._m33 < 1.0f);
#endif	// HAS_INVERTED_Z_BUFFER
 		
		// dejitter the sample position and make a filtered lookup - for planes this allows to reconstruct a much less jittery depth comparison function, it however doesn't fix silhuetes
		float DeviceZ = Texture2DSampleLevel(FilteredSceneDepthTexture, FilteredSceneDepthTextureSampler, (MaterialParameters.SvPosition.xy - Frame.TemporalAAParams.zw) * Frame.BufferSizeAndInvSize.zw, 0).r;

		float PixelDeviceZ = MaterialParameters.SvPosition.z;

		// Soft Bias with DeviceZ for best quality
		const float DeviceDepthFade = 0.00005f;

		// 0.5f is to bias around the actual value, 1 or 0 are another option
		Ret = saturate(0.5f - (DeviceZ - PixelDeviceZ) / DeviceDepthFade);
	}
#endif	// USE_EDITOR_COMPOSITING && (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 || MOBILE_EMULATION)

	// Note: multiple returns cause strange HLSL compiler error for CV_Coverage in later code
	return Ret;
}


#if EDITOR_ALPHA2COVERAGE != 0
uint CustomAlpha2Coverage(inout float4 InOutColor)
{
	uint MaskedCoverage = 0xff;

	MaskedCoverage = 0;

	uint EnabledSampleCount = 1;

	// todo: support non 4xMSAA as well

	// conservatively on but can be 0 if the opacity is too low
	if(InOutColor.a > 0.01f) { MaskedCoverage |= 0x1; }
	if(InOutColor.a > 0.25f) { MaskedCoverage |= 0x2; ++EnabledSampleCount; }
	if(InOutColor.a > 0.50f) { MaskedCoverage |= 0x4; ++EnabledSampleCount; }
	if(InOutColor.a > 0.75f) { MaskedCoverage |= 0x8; ++EnabledSampleCount; }

	// renormalize to make this sample the correct weight
	InOutColor *= (float)MSAASampleCount / EnabledSampleCount;

	return MaskedCoverage;
}
#endif
