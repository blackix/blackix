--- ../../../../UE4-QA/Engine/Plugins/OculusRift/OculusRift.uplugin	2014-06-27 12:39:26.000000000 -0700
+++ ./Engine/Plugins/OculusRift/OculusRift.uplugin	2014-07-19 19:21:45.000000000 -0700
@@ -16,7 +16,8 @@
 		{
 			"Name" : "OculusRift",
 			"Type" : "Runtime",
-			"WhitelistPlatforms" : [ "Win64", "Win32", "Mac" ]
+			"WhitelistPlatforms" : [ "Win64", "Win32", "Mac" ],
+			"LoadingPhase" : "PostConfigInit"
 		}
 	]
 }
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/OculusRift.Build.cs	2014-07-05 08:47:48.000000000 -0700
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/OculusRift.Build.cs	2014-08-08 15:17:34.991478300 -0700
@@ -10,8 +10,6 @@
 				new string[] {
 					"OculusRift/Private",
  					"../../../Source/Runtime/Renderer/Private",
-// 					"../../../Runtime/Windows/D3D11RHI/Private",
-// 					"Runtime/OpenGLDrv/Private",
 					// ... add other private include paths required here ...
 				}
 				);
@@ -22,6 +20,7 @@
 					"Core",
 					"CoreUObject",
 					"Engine",
+					"InputCore",
 					"RHI",
 					"RenderCore",
 					"Renderer",
@@ -39,6 +38,11 @@
                 if (Target.Platform == UnrealTargetPlatform.Win32 || Target.Platform == UnrealTargetPlatform.Win64)
                 {
                     PrivateDependencyModuleNames.AddRange(new string[] { "D3D11RHI" });
+					PublicAdditionalLibraries.Add("atls.lib");
+                }
+                if (Target.Platform == UnrealTargetPlatform.Mac)
+                {
+               		AddThirdPartyPrivateStaticDependencies(Target, "OpenGL");
                 }
             }
 		}
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.cpp	2014-07-06 06:17:24.000000000 -0700
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.cpp	2014-08-07 17:21:43.502549100 -0700
@@ -3,8 +3,6 @@
 #include "OculusRiftPrivate.h"
 #include "OculusRiftHMD.h"
 
-#define DEFAULT_PREDICTION_IN_SECONDS 0.035
-
 #if !UE_BUILD_SHIPPING
 // Should be changed to CAPI when available.
 #if PLATFORM_SUPPORTS_PRAGMA_PACK
@@ -48,6 +46,9 @@
 {
 	/** IHeadMountedDisplayModule implementation */
 	virtual TSharedPtr< class IHeadMountedDisplay > CreateHeadMountedDisplay() override;
+
+	// Pre-init the HMD module (optional).
+	virtual void PreInit() override;
 };
 
 IMPLEMENT_MODULE( FOculusRiftPlugin, OculusRift )
@@ -64,6 +65,11 @@
 	return NULL;
 }
 
+void FOculusRiftPlugin::PreInit()
+{
+	FOculusRiftHMD::PreInit();
+}
+
 //////////////////////////////////////////////////////////////////////////
 class ConditionalLocker
 {
@@ -90,6 +96,11 @@
 
 #if OCULUS_RIFT_SUPPORTED_PLATFORMS
 
+void FOculusRiftHMD::PreInit()
+{
+	ovr_Initialize();
+}
+
 bool FOculusRiftHMD::IsHMDEnabled() const
 {
 	return bHMDEnabled;
@@ -110,14 +121,14 @@
 
 bool FOculusRiftHMD::GetHMDMonitorInfo(MonitorInfo& MonitorDesc) const
 {
-	if (IsInitialized())
+	if (IsInitialized() && Hmd)
 	{
-		MonitorDesc.MonitorName = HmdDesc.DisplayDeviceName;
-		MonitorDesc.MonitorId	= HmdDesc.DisplayId;
-		MonitorDesc.DesktopX	= HmdDesc.WindowsPos.x;
-		MonitorDesc.DesktopY	= HmdDesc.WindowsPos.y;
-		MonitorDesc.ResolutionX = HmdDesc.Resolution.w;
-		MonitorDesc.ResolutionY = HmdDesc.Resolution.h;
+		MonitorDesc.MonitorName = Hmd->DisplayDeviceName;
+		MonitorDesc.MonitorId	= Hmd->DisplayId;
+		MonitorDesc.DesktopX	= Hmd->WindowsPos.x;
+		MonitorDesc.DesktopY	= Hmd->WindowsPos.y;
+		MonitorDesc.ResolutionX = Hmd->Resolution.w;
+		MonitorDesc.ResolutionY = Hmd->Resolution.h;
 		return true;
 	}
 	else
@@ -129,10 +140,15 @@
 	return false;
 }
 
+bool FOculusRiftHMD::IsFullScreenAllowed() const
+{
+	return (Hmd && (Hmd->HmdCaps & ovrHmdCap_ExtendDesktop) != 0) ? true : false;
+}
+
 bool FOculusRiftHMD::DoesSupportPositionalTracking() const
 {
 #ifdef OVR_VISION_ENABLED
-	 return bHmdPosTracking && (SupportedSensorCaps & ovrSensorCap_Position) != 0;
+	 return bHmdPosTracking && (SupportedTrackingCaps & ovrTrackingCap_Position) != 0;
 #else
 	return false;
 #endif //OVR_VISION_ENABLED
@@ -181,7 +197,7 @@
 void FOculusRiftHMD::EnableLowPersistenceMode(bool Enable)
 {
 	bLowPersistenceMode = Enable;
-	UpdateSensorHmdCaps();
+	UpdateHmdCaps();
 }
 
 float FOculusRiftHMD::GetInterpupillaryDistance() const
@@ -214,18 +230,32 @@
 	OutOrientation.Normalize();
 }
 
-void FOculusRiftHMD::GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) const
+void FOculusRiftHMD::GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition)
+{
+	// only supposed to be used from the game thread
+	checkf(IsInGameThread());
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
+	CurrentOrientation = LastHmdOrientation = CurHmdOrientation;
+	
+	// @TODO: we can't actually return just CurHmdPosition here, it should be rotated by CurrentOrientation.
+	// Another problem: if we return rotated position here, we shouldn't apply position in CalculateStereoViewOffset, otherwise the
+	// position will be applied twice.
+	// Currently, position will be applied automatically in CalculateStereoViewOffset and adjusted on Render Thread by UpdatePlayerViewPoint()
+	//CurrentPosition = FVector::ZeroVector; 
+}
+
+void FOculusRiftHMD::GetCurrentPose(FQuat& CurrentOrientation, FVector& CurrentPosition) const
 {
-	const ovrSensorState ss = ovrHmd_GetSensorState(Hmd, ovr_GetTimeInSeconds() + MotionPredictionInSeconds);
-	const ovrPosef& pose = ss.Predicted.Pose;
-	PoseToOrientationAndPosition(pose, CurrentOrientation, CurrentPosition);
+	const ovrTrackingState ts = ovrHmd_GetTrackingState(Hmd, ovr_GetTimeInSeconds() + MotionPredictionInSeconds);
+	const ovrPosef& ThePose = ts.HeadPose.ThePose;
+	PoseToOrientationAndPosition(ThePose, CurrentOrientation, CurrentPosition);
 	//UE_LOG(LogHMD, Log, TEXT("P: %.3f %.3f %.3f"), CurrentPosition.X, CurrentPosition.Y, CurrentPosition.Y);
 #ifdef OVR_VISION_ENABLED
 	if (bHmdPosTracking)
 	{
 #if !UE_BUILD_SHIPPING
 		bool hadVisionTracking = bHaveVisionTracking;
-		bHaveVisionTracking = (ss.StatusFlags & ovrStatus_PositionTracked) != 0;
+		bHaveVisionTracking = (ts.StatusFlags & ovrStatus_PositionTracked) != 0;
 		if (bHaveVisionTracking && !hadVisionTracking)
 			UE_LOG(LogHMD, Warning, TEXT("Vision Tracking Acquired"));
 		if (!bHaveVisionTracking && hadVisionTracking)
@@ -262,7 +292,7 @@
 
 	ViewRotation.Normalize();
 
-	GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
 	LastHmdOrientation = CurHmdOrientation;
 
 	const FRotator DeltaRot = ViewRotation - PC->GetControlRotation();
@@ -292,7 +322,7 @@
 #endif
 	ConditionalLocker lock(bUpdateOnRT, &UpdateOnRTLock);
 
-	GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
 	LastHmdOrientation = CurHmdOrientation;
 
 	static const FName NAME_Fixed = FName(TEXT("Fixed"));
@@ -569,10 +599,36 @@
 			{
 				bLowPersistenceMode = !bLowPersistenceMode;
 			}
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			Ar.Logf(TEXT("Low Persistence is currently %s"), (bLowPersistenceMode) ? TEXT("ON") : TEXT("OFF"));
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("MIRROR"))) // to mirror or not to mirror?...
+		{
+			FString CmdName = FParse::Token(Cmd, 0);
+			if (!CmdName.IsEmpty())
+			{
+				if (!FCString::Stricmp(*CmdName, TEXT("ON")))
+				{
+					bMirrorToWindow = true;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("OFF")))
+				{
+					bMirrorToWindow = false;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("TOGGLE"))) 
+				{
+					bMirrorToWindow = !bMirrorToWindow;
+				}
+			}
+			else
+			{
+				bMirrorToWindow = !bMirrorToWindow;
+			}
+			UpdateHmdCaps();
+			Ar.Logf(TEXT("Mirroring is currently %s"), (bMirrorToWindow) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 		else if (FParse::Command(&Cmd, TEXT("UPDATEONRT"))) // update on renderthread
 		{
 			FString CmdName = FParse::Token(Cmd, 0);
@@ -602,6 +658,36 @@
 			Ar.Logf(TEXT("Update on render thread is currently %s"), (bUpdateOnRT) ? TEXT("ON") : TEXT("OFF"));
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("OVERDRIVE"))) // 2 frame raise overdrive
+		{
+			FString CmdName = FParse::Token(Cmd, 0);
+			if (!CmdName.IsEmpty())
+			{
+				if (!FCString::Stricmp(*CmdName, TEXT("ON")))
+				{
+					bOverdrive = true;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("OFF")))
+				{
+					bOverdrive = false;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("TOGGLE")))
+				{
+					bOverdrive = !bOverdrive;
+				}
+				else
+				{
+					return false;
+				}
+			}
+			else
+			{
+				bOverdrive = !bOverdrive;
+			}
+			UpdateDistortionCaps();
+			Ar.Logf(TEXT("Overdrive is currently %s"), (bOverdrive) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 #ifdef OVR_DIRECT_RENDERING
 		else if (FParse::Command(&Cmd, TEXT("TIMEWARP"))) 
 		{
@@ -629,13 +715,8 @@
 			{
 				bTimeWarp = !bTimeWarp;
 			}
+			UpdateDistortionCaps();
 			Ar.Logf(TEXT("TimeWarp is currently %s"), (bTimeWarp) ? TEXT("ON") : TEXT("OFF"));
-#ifdef OVR_DIRECT_RENDERING 
-			if (GetActiveRHIBridgeImpl())
-			{
-				GetActiveRHIBridgeImpl()->SetNeedReinitRendererAPI();
-			}
-#endif // OVR_DIRECT_RENDERING
 			return true;
 		}
 #endif // #ifdef OVR_DIRECT_RENDERING
@@ -679,6 +760,13 @@
 			bDrawGrid = !bDrawGrid;
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("PROFILE"))) // profile
+		{
+			bProfiling = !bProfiling;
+			UpdateDistortionCaps();
+			Ar.Logf(TEXT("Profiling mode is currently %s"), (bProfiling) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 #endif //UE_BUILD_SHIPPING
 	}
 	else if (FParse::Command(&Cmd, TEXT("HMDMAG")))
@@ -686,13 +774,13 @@
 		if (FParse::Command(&Cmd, TEXT("ON")))
 		{
 			bYawDriftCorrectionEnabled = true;
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			return true;
 		}
 		else if (FParse::Command(&Cmd, TEXT("OFF")))
 		{
 			bYawDriftCorrectionEnabled = false;
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			return true;
 		}
 		else if (FParse::Command(&Cmd, TEXT("SHOW")))
@@ -703,37 +791,50 @@
 		}
 		return false;
 	}
-	else if (FParse::Command(&Cmd, TEXT("HMDTILT")))
+	else if (FParse::Command(&Cmd, TEXT("HMDWARP")))
 	{
-		if (FParse::Command(&Cmd, TEXT("ON")))
+#ifndef OVR_DIRECT_RENDERING
+        if (FParse::Command( &Cmd, TEXT("ON") ))
 		{
-			bTiltCorrectionEnabled = true;
+            bHmdDistortion = true;
 			return true;
 		}
-		else if (FParse::Command(&Cmd, TEXT("OFF")))
+        else if (FParse::Command( &Cmd, TEXT("OFF") ))
 		{
-			bTiltCorrectionEnabled = false;
+            bHmdDistortion = false;
 			return true;
 		}
-		else if (FParse::Command(&Cmd, TEXT("SHOW")))
+#endif //OVR_DIRECT_RENDERING
+		if (FParse::Command(&Cmd, TEXT("CHA")))
 		{
- 			Ar.Logf(TEXT("tilt correction %s"), bTiltCorrectionEnabled ? 
- 				TEXT("on") : TEXT("off"));
+			bChromaAbCorrectionEnabled = true;
+			UpdateDistortionCaps();
  			return true;
 		}
-		return false;
+		else if (FParse::Command(&Cmd, TEXT("NOCHA")))
+		{
+			bChromaAbCorrectionEnabled = false;
+			UpdateDistortionCaps();
+			return true;
 	}
-#ifndef OVR_DIRECT_RENDERING
-	else if (FParse::Command(&Cmd, TEXT("HMDWARP")))
+		else if (FParse::Command( &Cmd, TEXT("HQ") ))
     {
+			// High quality distortion
         if (FParse::Command( &Cmd, TEXT("ON") ))
         {
-            bHmdDistortion = true;
-            return true;
+				bHQDistortion = true;
         }
-        else if (FParse::Command( &Cmd, TEXT("OFF") ))
+			else if (FParse::Command(&Cmd, TEXT("OFF")))
         {
-            bHmdDistortion = false;
+				bHQDistortion = false;
+			}
+			else
+			{
+				bHQDistortion = !bHQDistortion;
+			}
+			Ar.Logf(TEXT("High quality distortion is currently %s"), (bHQDistortion) ? TEXT("ON") : TEXT("OFF") ?
+				TEXT("on") : TEXT("off"));
+			UpdateDistortionCaps();
             return true;
         }
 
@@ -745,7 +846,6 @@
 		}
 		return true;
     }
-#endif //OVR_DIRECT_RENDERING
 	else if (FParse::Command(&Cmd, TEXT("HMDPOS")))
 	{
 		if (FParse::Command(&Cmd, TEXT("RESET")))
@@ -763,21 +863,21 @@
 		else if (FParse::Command(&Cmd, TEXT("ON")) || FParse::Command(&Cmd, TEXT("ENABLE")))
 		{
 			bHmdPosTracking = true;
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			return true;
 		}
 		else if (FParse::Command(&Cmd, TEXT("OFF")) || FParse::Command(&Cmd, TEXT("DISABLE")))
 		{
 			bHmdPosTracking = false;
 			bHaveVisionTracking = false;
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			return true;
 		}
 		else if (FParse::Command(&Cmd, TEXT("TOGGLE")))
 		{
 			bHmdPosTracking = !bHmdPosTracking;
 			bHaveVisionTracking = false;
-			UpdateSensorHmdCaps();
+			UpdateHmdCaps();
 			return true;
 		}
 #if !UE_BUILD_SHIPPING
@@ -875,10 +975,6 @@
 			{
 				MotionPredictionInSeconds = 0.0;
 			}
-			else if (!FCString::Stricmp(*Value, TEXT("OFF")))
-			{
-				MotionPredictionInSeconds = DEFAULT_PREDICTION_IN_SECONDS;
-			}
 			else
 			{
 				MotionPredictionInSeconds = FCString::Atod(*Value);
@@ -887,6 +983,7 @@
 		}
 		return false;
 	}
+#ifndef OVR_DIRECT_RENDERING
 	else if (FParse::Command(&Cmd, TEXT("SETFINISHFRAME")))
 	{
 		static IConsoleVariable* CFinishFrameVar = IConsoleManager::Get().FindConsoleVariable(TEXT("r.FinishCurrentFrame"));
@@ -911,6 +1008,7 @@
 		}
 		return false;
 	}
+#endif
 	else if (FParse::Command(&Cmd, TEXT("UNCAPFPS")))
 	{
 		GEngine->bSmoothFrameRate = false;
@@ -918,7 +1016,7 @@
 	}
 	else if (FParse::Command(&Cmd, TEXT("OVRVERSION")))
 	{
-		static const char* Results = OVR_VERSION_STRING;
+		static const char* Results = ovr_GetVersionString() + 7; // +7 is temporary, until libovr returns just numbers
 		Ar.Logf(TEXT("%s, LibOVR: %s, built %s, %s"), *GEngineVersion.ToString(), UTF8_TO_TCHAR(Results), 
 			UTF8_TO_TCHAR(__DATE__), UTF8_TO_TCHAR(__TIME__));
 		return true;
@@ -1019,14 +1117,13 @@
 		{
 			static IConsoleVariable* CVSyncVar = IConsoleManager::Get().FindConsoleVariable(TEXT("r.VSync"));
 			bVSync = CVSyncVar->GetInt() != 0;
-
-			#ifdef OVR_DIRECT_RENDERING 
-			GetActiveRHIBridgeImpl()->SetNeedReinitRendererAPI();
-			#endif
 		}
+		UpdateHmdCaps();
 
+#ifndef OVR_DIRECT_RENDERING
 		static IConsoleVariable* CFinishFrameVar = IConsoleManager::Get().FindConsoleVariable(TEXT("r.FinishCurrentFrame"));
 		CFinishFrameVar->Set(bAllowFinishCurrentFrame);
+#endif
 	}
 }
 
@@ -1114,8 +1211,8 @@
 
 void FOculusRiftHMD::ResetOrientationAndPosition(float yaw)
 {
-	const ovrSensorState ss = ovrHmd_GetSensorState(Hmd, ovr_GetTimeInSeconds());
-	const ovrPosef& pose = ss.Recorded.Pose;
+	const ovrTrackingState ss = ovrHmd_GetTrackingState(Hmd, ovr_GetTimeInSeconds());
+	const ovrPosef& pose = ss.HeadPose.ThePose;
 	const OVR::Quatf orientation = OVR::Quatf(pose.Orientation);
 
 	// Reset position
@@ -1305,30 +1402,33 @@
 	, SavedScrPerc(100.f)
 	, bOverrideScreenPercentage(false)
 	, ScreenPercentage(100.f)
-	, bAllowFinishCurrentFrame(false)
+	, bAllowFinishCurrentFrame(true)
 	, InterpupillaryDistance(OVR_DEFAULT_IPD)
 	, WorldToMetersScale(100.f)
 	, bWorldToMetersOverride(false)
 	, UserDistanceToScreenModifier(0.f)
 	, VFOVInRadians(FMath::DegreesToRadians(90.f))
 	, HFOVInRadians(FMath::DegreesToRadians(90.f))
-	, MotionPredictionInSeconds(DEFAULT_PREDICTION_IN_SECONDS)
+	, MotionPredictionInSeconds(0)
 	, AccelGain(0.f)
 	, bHmdDistortion(true)
 	, bChromaAbCorrectionEnabled(true)
 	, bYawDriftCorrectionEnabled(true)
-	, bTiltCorrectionEnabled(true)
 	, bOverride2D(false)
 	, HudOffset(0.f)
 	, CanvasCenterOffset(0.f)
 	, bLowPersistenceMode(true) // on by default (DK2+ only)
 	, bUpdateOnRT(true)
+	, bOverdrive(true)
+	, bHQDistortion(true)
 	, bHeadTrackingEnforced(false)
+	, bMirrorToWindow(true)
 #if !UE_BUILD_SHIPPING
 	, bDoNotUpdateOnGT(false)
 	, bDrawTrackingCameraFrustum(false)
 	, bShowStats(false)
 	, bDrawGrid(false)
+	, bProfiling(false)
 #endif
 	, bTimeWarp(true)
 	, NearClippingPlane(0)
@@ -1342,7 +1442,7 @@
 	, BaseOffset(0, 0, 0)
 	, BaseOrientation(FQuat::Identity)
 	, Hmd(nullptr)
-	, SensorCaps(0)
+	, TrackingCaps(0)
 	, DistortionCaps(0)
 	, HmdCaps(0)
 	, EyeViewportSize(0, 0)
@@ -1356,7 +1456,8 @@
 #ifndef OVR_DIRECT_RENDERING
 	bTimeWarp = false;
 #endif
-	SupportedSensorCaps = SupportedDistortionCaps = SupportedHmdCaps = 0;
+	SupportedTrackingCaps = SupportedDistortionCaps = SupportedHmdCaps = 0;
+	OSWindowHandle = nullptr;
 	Startup();
 }
 
@@ -1381,6 +1482,7 @@
 
 	// Initializes LibOVR. This LogMask_All enables maximum logging.
 	// Custom allocator can also be specified here.
+	// Actually, most likely, the ovr_Initialize is already called from PreInit.
 	ovr_Initialize();
 
 #if !UE_BUILD_SHIPPING
@@ -1394,20 +1496,44 @@
 	{
 		InitStatus |= eInitialized;
 
-		ovrHmd_GetDesc(Hmd, &HmdDesc);
-		SupportedDistortionCaps = HmdDesc.DistortionCaps;
-		SupportedHmdCaps		= HmdDesc.HmdCaps;
-		SupportedSensorCaps		= HmdDesc.SensorCaps;
+		// one frame prediction for the game thread. TODO: fugure out a better way to do this.
+		// In any case, the pose will be corrected by timewarp.
+		if (Hmd->Type >= ovrHmd_DK2)
+		{
+			MotionPredictionInSeconds = 1. / 75;
+		}
+		else
+		{
+			MotionPredictionInSeconds = 1. / 60;
+		}
+		SupportedDistortionCaps = Hmd->DistortionCaps;
+		SupportedHmdCaps		= Hmd->HmdCaps;
+		SupportedTrackingCaps	= Hmd->TrackingCaps;
 
+#ifndef OVR_DIRECT_RENDERING
+		SupportedDistortionCaps &= ~ovrDistortionCap_Overdrive;
+#endif
 #ifndef OVR_VISION_ENABLED
-		SupportedSensorCaps &= ~ovrSensorCap_Position;
+		SupportedTrackingCaps &= ~ovrTrackingCap_Position;
 #endif
 
-		DistortionCaps	= SupportedDistortionCaps | ovrDistortionCap_TimeWarp;
-		SensorCaps		= SupportedSensorCaps;
-		HmdCaps			= SupportedHmdCaps & ~ovrHmdCap_NoVSync;
+		DistortionCaps	= SupportedDistortionCaps & (ovrDistortionCap_Chromatic | ovrDistortionCap_TimeWarp | ovrDistortionCap_Vignette | ovrDistortionCap_Overdrive);
+		TrackingCaps	= SupportedTrackingCaps & (ovrTrackingCap_Orientation | ovrTrackingCap_MagYawCorrection | ovrTrackingCap_Position);
+		HmdCaps			= SupportedHmdCaps & (ovrHmdCap_DynamicPrediction | ovrHmdCap_LowPersistence);
 		HmdCaps |= (bVSync ? 0 : ovrHmdCap_NoVSync);
 
+		if (!(SupportedDistortionCaps & ovrDistortionCap_TimeWarp))
+		{
+			bTimeWarp = false;
+		}
+
+		if (!bTimeWarp)
+		{
+			// Without Timewarp we may safely multiply the prediction by two.
+			MotionPredictionInSeconds *= 2;
+		}
+
+		UpdateDistortionCaps();
 		UpdateHmdRenderInfo();
 		UpdateStereoRenderingParams();
 		UE_LOG(LogHMD, Log, TEXT("Oculus initialized."));
@@ -1417,13 +1543,13 @@
 	}
 	else
 	{
-		UE_LOG(LogHMD, Warning, TEXT("No Oculus HMD detected!"));
+		UE_LOG(LogHMD, Warning, TEXT("No Oculus HMD detected! Is Oculus Run-Time installed and service is running?"));
 	}
 
 	LoadFromIni();
 	SaveSystemValues();
 
-	UpdateSensorHmdCaps();
+	UpdateHmdCaps();
 
 #ifdef OVR_DIRECT_RENDERING
 #if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
@@ -1443,6 +1569,8 @@
 
 void FOculusRiftHMD::Shutdown()
 {
+	ovrHmd_AttachToWindow(Hmd, NULL, NULL, NULL);
+
 	if (!(InitStatus & eStartupExecuted))
 	{
 		return;
@@ -1477,26 +1605,49 @@
 	UE_LOG(LogHMD, Log, TEXT("Oculus shutdown."));
 }
 
-void FOculusRiftHMD::UpdateSensorHmdCaps()
+void FOculusRiftHMD::UpdateDistortionCaps()
+{
+	if (IsOpenGLPlatform(GRHIShaderPlatform))
+	{
+		DistortionCaps &= ~ovrDistortionCap_SRGB;
+		DistortionCaps |= ovrDistortionCap_FlipInput;
+	}
+	(bTimeWarp) ? DistortionCaps |= ovrDistortionCap_TimeWarp : DistortionCaps &= ~ovrDistortionCap_TimeWarp;
+	(bOverdrive) ? DistortionCaps |= ovrDistortionCap_Overdrive : DistortionCaps &= ~ovrDistortionCap_Overdrive;
+	//(bHQDistortion) ? DistortionCaps |= ovrDistortionCap_HqDistortion : DistortionCaps &= ~ovrDistortionCap_HqDistortion;
+	(bChromaAbCorrectionEnabled) ? DistortionCaps |= ovrDistortionCap_Chromatic : DistortionCaps &= ~ovrDistortionCap_Chromatic;
+#if !UE_BUILD_SHIPPING
+	(bProfiling) ? DistortionCaps |= ovrDistortionCap_ProfileNoTimewarpSpinWaits : DistortionCaps &= ~ovrDistortionCap_ProfileNoTimewarpSpinWaits;
+#endif // #if !UE_BUILD_SHIPPING
+
+#ifdef OVR_DIRECT_RENDERING 
+	if (GetActiveRHIBridgeImpl())
+	{
+		GetActiveRHIBridgeImpl()->SetNeedReinitRendererAPI();
+	}
+#endif // OVR_DIRECT_RENDERING
+}
+
+void FOculusRiftHMD::UpdateHmdCaps()
 {
 	if (Hmd)
 	{
-		SensorCaps = ovrSensorCap_Orientation;
+		TrackingCaps = ovrTrackingCap_Orientation;
 		if (bYawDriftCorrectionEnabled)
 		{
-			SensorCaps |= ovrSensorCap_YawCorrection;
+			TrackingCaps |= ovrTrackingCap_MagYawCorrection;
 		}
 		else
 		{
-			SensorCaps &= ~ovrSensorCap_YawCorrection;
+			TrackingCaps &= ~ovrTrackingCap_MagYawCorrection;
 		}
 		if (bHmdPosTracking)
 		{
-			SensorCaps |= ovrSensorCap_Position;
+			TrackingCaps |= ovrTrackingCap_Position;
 		}
 		else
 		{
-			SensorCaps &= ~ovrSensorCap_Position;
+			TrackingCaps &= ~ovrTrackingCap_Position;
 		}
 
 		if (bLowPersistenceMode)
@@ -1507,21 +1658,28 @@
 		{
 			HmdCaps &= ~ovrHmdCap_LowPersistence;
 		}
-		HmdCaps |= ovrHmdCap_LatencyTest;
-		ovrHmd_SetEnabledCaps(Hmd, HmdCaps);
 
-		ovrHmd_StartSensor(Hmd, SensorCaps, 0);
+		if (bVSync)
+		{
+			HmdCaps &= ~ovrHmdCap_NoVSync;
+		}
+		else
+		{
+			HmdCaps |= ovrHmdCap_NoVSync;
 	}
-}
 
-static ovrFovPort SymmetricalFOV(const ovrFovPort& fov)
-{
-	ovrFovPort newFov;
-	const float VHalfTan = FMath::Max(fov.DownTan, fov.UpTan);
-	const float HHalfTan = FMath::Max(fov.LeftTan, fov.RightTan);
-	newFov.DownTan = newFov.UpTan		= VHalfTan; //FMath::Max(VHalfTan, HHalfTan);
-	newFov.LeftTan = newFov.RightTan	= HHalfTan; //FMath::Max(VHalfTan, HHalfTan);
-	return newFov;
+		if (bMirrorToWindow)
+		{
+			HmdCaps &= ~ovrHmdCap_NoMirrorToWindow;
+		}
+		else
+		{
+			HmdCaps |= ovrHmdCap_NoMirrorToWindow;
+		}
+		ovrHmd_SetEnabledCaps(Hmd, HmdCaps);
+
+		ovrHmd_ConfigureTracking(Hmd, TrackingCaps, 0);
+	}
 }
 
 FORCEINLINE static float GetVerticalFovRadians(const ovrFovPort& fov)
@@ -1538,18 +1696,15 @@
 {
 	check(Hmd);
 
-	// Assuming we've successfully grabbed the device, read the configuration data from it, which we'll use for projection
-	ovrHmd_GetDesc(Hmd, &HmdDesc);
-
-	UE_LOG(LogHMD, Warning, TEXT("HMD %s, Monitor %s, res = %d x %d, windowPos = {%d, %d}"), ANSI_TO_TCHAR(HmdDesc.ProductName), 
-		ANSI_TO_TCHAR(HmdDesc.DisplayDeviceName), HmdDesc.Resolution.w, HmdDesc.Resolution.h, HmdDesc.WindowsPos.x, HmdDesc.WindowsPos.y); 
+	UE_LOG(LogHMD, Warning, TEXT("HMD %s, Monitor %s, res = %d x %d, windowPos = {%d, %d}"), ANSI_TO_TCHAR(Hmd->ProductName), 
+		ANSI_TO_TCHAR(Hmd->DisplayDeviceName), Hmd->Resolution.w, Hmd->Resolution.h, Hmd->WindowsPos.x, Hmd->WindowsPos.y); 
 
 	// Calc FOV
 	if (!bOverrideFOV)
 	{
 		// Calc FOV, symmetrical, for each eye. 
-		EyeFov[0] = SymmetricalFOV(HmdDesc.DefaultEyeFov[0]);
-		EyeFov[1] = SymmetricalFOV(HmdDesc.DefaultEyeFov[1]);
+		EyeFov[0] = Hmd->DefaultEyeFov[0];
+		EyeFov[1] = Hmd->DefaultEyeFov[1];
 
 		// Calc FOV in radians
 		VFOVInRadians = FMath::Max(GetVerticalFovRadians(EyeFov[0]), GetVerticalFovRadians(EyeFov[1]));
@@ -1563,8 +1718,8 @@
 	idealRenderTargetSize.w = recommenedTex0Size.w + recommenedTex1Size.w;
 	idealRenderTargetSize.h = FMath::Max(recommenedTex0Size.h, recommenedTex1Size.h);
 
-	IdealScreenPercentage = FMath::Max(float(idealRenderTargetSize.w) / float(HmdDesc.Resolution.w) * 100.f,
-									   float(idealRenderTargetSize.h) / float(HmdDesc.Resolution.h) * 100.f);
+	IdealScreenPercentage = FMath::Max(float(idealRenderTargetSize.w) / float(Hmd->Resolution.w) * 100.f,
+									   float(idealRenderTargetSize.h) / float(Hmd->Resolution.h) * 100.f);
 
 	// Override eye distance by the value from HMDInfo (stored in Profile).
 	if (!bOverrideIPD)
@@ -1573,7 +1728,7 @@
 	}
 
 	// Default texture size (per eye) is equal to half of W x H resolution. Will be overridden in SetupView.
-	EyeViewportSize = FIntPoint(HmdDesc.Resolution.w / 2, HmdDesc.Resolution.h);
+	EyeViewportSize = FIntPoint(Hmd->Resolution.w / 2, Hmd->Resolution.h);
 
 	bNeedUpdateStereoRenderingParams = true;
 }
@@ -1622,8 +1777,8 @@
 			// Recenter projection (normalized)
 			const float LensRecenter = 4.0f * LensRecenterM / ScreenSizeInMeters[0];
 
-			HudOffset = 0.25f * InterpupillaryDistance * (HmdDesc.Resolution.w / ScreenSizeInMeters[0]) / 15.0f;
-			CanvasCenterOffset = (0.25f * LensRecenter) * HmdDesc.Resolution.w;
+			HudOffset = 0.25f * InterpupillaryDistance * (Hmd->Resolution.w / ScreenSizeInMeters[0]) / 15.0f;
+			CanvasCenterOffset = (0.25f * LensRecenter) * Hmd->Resolution.w;
 		}
 
 		PrecalculatePostProcess_NoLock();
@@ -1655,14 +1810,6 @@
 	{
 		bDevSettingsEnabled = v;
 	}
-	if (GConfig->GetBool(OculusSettings, TEXT("bTiltCorrectionEnabled"), v, GEngineIni))
-	{
-		bTiltCorrectionEnabled = v;
-	}
-	if (GConfig->GetFloat(OculusSettings, TEXT("MotionPrediction"), f, GEngineIni))
-	{
-		MotionPredictionInSeconds = f;
-	}
 	if (GConfig->GetBool(OculusSettings, TEXT("bOverrideIPD"), v, GEngineIni))
 	{
 		bOverrideIPD = v;
@@ -1739,8 +1886,6 @@
 	GConfig->SetBool(OculusSettings, TEXT("bChromaAbCorrectionEnabled"), bChromaAbCorrectionEnabled, GEngineIni);
 	GConfig->SetBool(OculusSettings, TEXT("bYawDriftCorrectionEnabled"), bYawDriftCorrectionEnabled, GEngineIni);
 	GConfig->SetBool(OculusSettings, TEXT("bDevSettingsEnabled"), bDevSettingsEnabled, GEngineIni);
-	GConfig->SetBool(OculusSettings, TEXT("bTiltCorrectionEnabled"), bTiltCorrectionEnabled, GEngineIni);
-	GConfig->SetFloat(OculusSettings, TEXT("MotionPrediction"), float(MotionPredictionInSeconds), GEngineIni);
 
 	GConfig->SetBool(OculusSettings, TEXT("bOverrideIPD"), bOverrideIPD, GEngineIni);
 	if (bOverrideIPD)
@@ -1779,5 +1924,18 @@
 	GConfig->SetFloat(OculusSettings, TEXT("NearClippingPlane"), NearClippingPlane, GEngineIni);
 }
 
+bool FOculusRiftHMD::HandleInputKey(UPlayerInput* pPlayerInput,
+	const FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)
+{
+	if (EventType == IE_Pressed && Hmd && IsStereoEnabled())
+	{
+		if (!Key.IsMouseButton())
+		{
+			ovrHmd_DismissHSWDisplay(Hmd);
+		}
+	}
+	return false;
+}
+
 #endif //OCULUS_RIFT_SUPPORTED_PLATFORMS
 
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.h	2014-07-09 17:28:41.000000000 -0700
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.h	2014-08-11 11:08:55.156202700 -0700
@@ -18,6 +18,10 @@
 	#define OVR_DIRECT_RENDERING
 	#define OVR_D3D_VERSION 11
 	#define OVR_GL
+#elif PLATFORM_MAC
+	#define OVR_VISION_ENABLED
+    //#define OVR_DIRECT_RENDERING
+    //#define OVR_GL
 #endif
 
 #ifdef OVR_VISION_ENABLED
@@ -28,16 +32,16 @@
 
 #if OCULUS_RIFT_SUPPORTED_PLATFORMS
 	
-	#include "OVRVersion.h"
+	#include "OVR.h"
+	#include "OVR_Version.h"
+	#include "OVR_Kernel.h"
 
-	#include "../Src/Kernel/OVR_Math.h"
 	#include "../Src/Kernel/OVR_Threads.h"
-	#include "../Src/OVR_CAPI.h"
-	#include "../Src/Kernel/OVR_Color.h"
-	#include "../Src/Kernel/OVR_Timer.h"
 
 #ifdef OVR_DIRECT_RENDERING
+    #if PLATFORM_WINDOWS
 	#include "AllowWindowsPlatformTypes.h"
+    #endif
 	#ifdef OVR_D3D_VERSION
 		#include "../Src/OVR_CAPI_D3D.h"
 	#endif // OVR_D3D_VERSION
@@ -60,8 +64,9 @@
  */
 class FOculusRiftHMD : public IHeadMountedDisplay, public ISceneViewExtension
 {
-
 public:
+	static void PreInit();
+
 	/** IHeadMountedDisplay interface */
 	virtual bool IsHMDEnabled() const override;
 	virtual void EnableHMD(bool allow = true) override;
@@ -77,7 +82,7 @@
     //virtual float GetFieldOfViewInRadians() const override;
 	virtual void GetFieldOfView(float& OutHFOVInDegrees, float& OutVFOVInDegrees) const override;
 
-    virtual void GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) const override;
+	virtual void GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) override;
 	virtual void ApplyHmdRotation(APlayerController* PC, FRotator& ViewRotation) override;
 	virtual void UpdatePlayerCameraRotation(APlayerCameraManager*, struct FMinimalViewInfo& POV) override;
 
@@ -87,6 +92,8 @@
 	virtual bool Exec( UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar ) override;
 	virtual void OnScreenModeChange(EWindowMode::Type WindowMode) override;
 
+	virtual bool IsFullScreenAllowed() const override;
+
 	/** IStereoRendering interface */
 	virtual bool IsStereoEnabled() const override;
 	virtual bool EnableStereo(bool stereo = true) override;
@@ -100,8 +107,9 @@
 	virtual void GetEyeRenderParams_RenderThread(EStereoscopicPass StereoPass, FVector2D& EyeToSrcUVScaleValue, FVector2D& EyeToSrcUVOffsetValue) const override;
 	virtual void GetTimewarpMatrices_RenderThread(EStereoscopicPass StereoPass, FMatrix& EyeRotationStart, FMatrix& EyeRotationEnd) const override;
 
-#ifdef OVR_DIRECT_RENDERING
 	virtual void UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& Viewport) override;
+
+#ifdef OVR_DIRECT_RENDERING
 	virtual void CalculateRenderTargetSize(uint32& InOutSizeX, uint32& InOutSizeY) const override;
 	virtual bool NeedReAllocateViewportRenderTarget(const FViewport& Viewport) const override;
 #endif//OVR_DIRECT_RENDERING
@@ -139,8 +147,13 @@
 	virtual void DrawDistortionMesh_RenderThread(struct FRenderingCompositePassContext& Context, const FSceneView& View, const FIntPoint& TextureSize) override;
 	virtual void UpdateScreenSettings(const FViewport*) override;
 
+	virtual bool HandleInputKey(class UPlayerInput*, const FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad) override;
+
 	virtual void DrawDebug(UCanvas* Canvas, EStereoscopicPass StereoPass) override;
 
+	void GetCurrentPose(FQuat& CurrentOrientation, FVector& CurrentPosition) const;
+	void BeginRendering_RenderThread();
+
 #ifdef OVR_DIRECT_RENDERING
 	class BridgeBaseImpl : public FRHICustomPresent
 	{
@@ -237,13 +250,11 @@
 #endif // OVR_GL
 	BridgeBaseImpl* GetActiveRHIBridgeImpl();
 
-	void BeginRendering_RenderThread();
-	void FinishRendering_RenderThread();
 	void ShutdownRendering();
 
 #else
 
-virtual void FinishRenderingFrame_RenderThread(FRHICommandListImmediate& RHICmdList) override;
+	virtual void FinishRenderingFrame_RenderThread(FRHICommandListImmediate& RHICmdList) override;
 
 #endif // #ifdef OVR_DIRECT_RENDERING
 
@@ -366,14 +377,10 @@
 
 	void ResetControlRotation() const;
 
-	/** Get/set head model. Units are meters, not UU! 
-	    Use ToFVector and ToFVector_M2U conversion routines. */
-	OVR::Vector3f	GetHeadModel() const;
-	void			SetHeadModel(const OVR::Vector3f&);
-
 	void PrecalculatePostProcess_NoLock();
 
-	void UpdateSensorHmdCaps();
+	void UpdateDistortionCaps();
+	void UpdateHmdCaps();
 
 	void PoseToOrientationAndPosition(const ovrPosef& InPose, FQuat& OutOrientation, FVector& OutPosition) const;
 
@@ -458,9 +465,6 @@
 	/** Gain for gravity correction (should not need to be changed) */
 	float AccelGain;
 
-	/** Whether or not to use a head model offset to determine view position */
-	bool bUseHeadModel;
-
     /** Distortion on/off */
     bool bHmdDistortion;
 
@@ -470,9 +474,6 @@
 	/** Yaw drift correction on/off */
 	bool bYawDriftCorrectionEnabled;
 
-	/** HMD tilt correction on/off */
-	bool bTiltCorrectionEnabled;
-
 	/** Whether or not 2D stereo settings overridden. */
 	bool bOverride2D;
 	/** HUD stereo offset */
@@ -490,10 +491,19 @@
 	bool				bUpdateOnRT;
 	mutable OVR::Lock	UpdateOnRTLock;
 
+	/** Overdrive brightness transitions to reduce artifacts on DK2+ displays */
+	bool bOverdrive;
+
+	/** High-quality sampling of distortion buffer for anti-aliasing */
+	bool bHQDistortion;
+
 	/** Enforces headtracking to work even in non-stereo mode (for debugging or screenshots). 
 	    See 'MOTION ENFORCE' console command. */
 	bool bHeadTrackingEnforced;
 
+	/** Is mirroring enabled or not (see 'HMD MIRROR' console cmd) */
+	bool bMirrorToWindow;
+
 #if !UE_BUILD_SHIPPING
 	/** Draw tracking camera frustum, for debugging purposes. 
 	 *  See 'HMDPOS SHOWCAMERA ON|OFF' console command.
@@ -508,6 +518,9 @@
 
 	/** Draw lens centered grid */
 	bool				bDrawGrid;
+
+	/** Profiling mode, removed extra waits in Present (Direct Rendering). See 'hmd profile' cmd */
+	bool				bProfiling;
 #endif
 
 	/** Whether timewarp is enabled or not */
@@ -534,7 +547,6 @@
 	FQuat					BaseOrientation; // base orientation
 
 	ovrHmd					Hmd;
-	ovrHmdDesc				HmdDesc;
 	ovrEyeRenderDesc		EyeRenderDesc[2];			// 0 - left, 1 - right, same as Views
 	ovrMatrix4f				EyeProjectionMatrices[2];	// 0 - left, 1 - right, same as Views
 	ovrFovPort				EyeFov[2];					// 0 - left, 1 - right, same as Views
@@ -542,11 +554,11 @@
 	ovrRecti				EyeRenderViewport[2];		// 0 - left, 1 - right, same as Views
 	ovrSizei				TextureSize; // texture size (for both eyes)
 
-	unsigned				SensorCaps;
+	unsigned				TrackingCaps;
 	unsigned				DistortionCaps;
 	unsigned				HmdCaps;
 
-	unsigned				SupportedSensorCaps;
+	unsigned				SupportedTrackingCaps;
 	unsigned				SupportedDistortionCaps;
 	unsigned				SupportedHmdCaps;
 
@@ -616,6 +628,8 @@
 	/** True, if pos tracking is enabled */
 	bool						bHmdPosTracking;
 	mutable bool				bHaveVisionTracking;
+
+	void*						OSWindowHandle;
 };
 
 DEFINE_LOG_CATEGORY_STATIC(LogHMD, Log, All);
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftRender.cpp	2014-07-05 09:18:12.000000000 -0700
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftRender.cpp	2014-08-07 17:24:32.900549100 -0700
@@ -161,22 +161,6 @@
 		RenderParams_RenderThread.pDistortionMesh[1] = pDistortionMesh[1];
 		RenderParams_RenderThread.bTimeWarp = bTimeWarp;
 	}
-	RenderParams_RenderThread.bFrameBegun = true;
-
-	// get latest orientation/position and cache it
-	if (bUpdateOnRT)
-	{
-		Lock::Locker lock(&UpdateOnRTLock);
-		if (!RenderParams_RenderThread.bTimeWarp)
-		{
-			GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
-			RenderParams_RenderThread.CurHmdOrientation = CurHmdOrientation;
-			RenderParams_RenderThread.CurHmdPosition = CurHmdPosition;
-		}
-
-		RenderParams_RenderThread.LastHmdPosition = LastHmdPosition;
-		RenderParams_RenderThread.DeltaControlOrientation = DeltaControlOrientation;
-	}
 #else
 	{
 		// make a copy of StereoParams to access from the RenderThread.
@@ -187,6 +171,7 @@
 		RenderParams_RenderThread.EyeFov[1] = EyeFov[1];
 		RenderParams_RenderThread.bTimeWarp = bTimeWarp;
 	}
+#endif
 	// get latest orientation/position and cache it
 	if (bUpdateOnRT)
 	{
@@ -196,7 +181,6 @@
 	}
 
 	BeginRendering_RenderThread();
-#endif
 }
 
 void FOculusRiftHMD::PreRenderView_RenderThread(FSceneView& View)
@@ -207,37 +191,13 @@
 		return;
 
 	const ovrEyeType eyeIdx = (View.StereoPass == eSSP_LEFT_EYE) ? ovrEye_Left : ovrEye_Right;
-#ifdef OVR_DIRECT_RENDERING
-	FQuat		CurrentHmdOrientation;
-	FVector		CurrentHmdPosition;
-	if (RenderParams_RenderThread.bFrameBegun)
-	{
-		// Get new predicted pose to corresponding eye.
-		RenderParams_RenderThread.EyeRenderPose[eyeIdx] = ovrHmd_BeginEyeRender(Hmd, eyeIdx);
-		PoseToOrientationAndPosition(RenderParams_RenderThread.EyeRenderPose[eyeIdx], CurrentHmdOrientation, CurrentHmdPosition);
-	}
-	else
-	{
-		CurrentHmdOrientation = FQuat::Identity;
-		CurrentHmdPosition    = FVector::ZeroVector;
-	}
-#else
 	FQuat	CurrentHmdOrientation;
 	FVector	CurrentHmdPosition;
 
-	if (RenderParams_RenderThread.bTimeWarp)
-	{
 		// Get new predicted pose to corresponding eye.
 		ovrPosef eyeRenderPose = ovrHmd_GetEyePose(Hmd, eyeIdx);
 		PoseToOrientationAndPosition(eyeRenderPose, CurrentHmdOrientation, CurrentHmdPosition);
 		RenderParams_RenderThread.EyeRenderPose[eyeIdx] = eyeRenderPose;
-	}
-	else
-	{
-		CurrentHmdOrientation = RenderParams_RenderThread.CurHmdOrientation;
-		CurrentHmdPosition    = RenderParams_RenderThread.CurHmdPosition;
-	}
-#endif
 
 	if (bUpdateOnRT)
 	{
@@ -250,27 +210,15 @@
 	}
 }
 
-#ifdef OVR_DIRECT_RENDERING 
-FOculusRiftHMD::BridgeBaseImpl* FOculusRiftHMD::GetActiveRHIBridgeImpl()
+void FOculusRiftHMD::BeginRendering_RenderThread()
 {
-#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
-	if (pD3D11Bridge)
-	{
-		return pD3D11Bridge;
-	}
-#endif
-#if defined(OVR_GL)
-	if (pOGLBridge)
+	check(IsInRenderingThread());
+	if (RenderParams_RenderThread.bFrameBegun)
 	{
-		return pOGLBridge;
+		return;
 	}
-#endif
-	return nullptr;
-}
 
-void FOculusRiftHMD::BeginRendering_RenderThread()
-{
-	check(IsInRenderingThread());
+#ifdef OVR_DIRECT_RENDERING 
 	{
 		Lock::Locker lock(&StereoParamsLock);
 
@@ -278,23 +226,29 @@
 	}
 
 	ovrHmd_BeginFrame(Hmd, 0);
+#else
+	ovrHmd_BeginFrameTiming(Hmd, 0);
+#endif
 	RenderParams_RenderThread.bFrameBegun = true;
 }
 
-void FOculusRiftHMD::FinishRendering_RenderThread()
-{
-	check(IsInRenderingThread())
 
-	if (RenderParams_RenderThread.bFrameBegun)
+#ifdef OVR_DIRECT_RENDERING 
+FOculusRiftHMD::BridgeBaseImpl* FOculusRiftHMD::GetActiveRHIBridgeImpl()
+{
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+	if (pD3D11Bridge)
 	{
-		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
-		ovrHmd_EndFrame(Hmd); // This function will present
-		RenderParams_RenderThread.bFrameBegun = false;
+		return pD3D11Bridge;
 	}
-	else
+#endif
+#if defined(OVR_GL)
+	if (pOGLBridge)
 	{
-		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
+		return pOGLBridge;
 	}
+#endif
+	return nullptr;
 }
 
 void FOculusRiftHMD::CalculateRenderTargetSize(uint32& InOutSizeX, uint32& InOutSizeY) const
@@ -514,7 +468,7 @@
 		Str = FString::Printf(TEXT("W-to-m scale: %.2f uu/m"), WorldToMetersScale);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
 
-		if ((HmdDesc.HmdCaps & ovrHmdCap_LatencyTest) != 0)
+		if ((SupportedHmdCaps & ovrHmdCap_DynamicPrediction) != 0)
 		{
 			float latencies[3] = { 0.0f, 0.0f, 0.0f };
 			if (ovrHmd_GetFloatArray(Hmd, "DK2Latency", latencies, 3) == 3)
@@ -538,7 +492,7 @@
 		X = (int32)LeftPos + 200;
 		Y = (int32)TopPos;
 
-		StatusStr = ((SupportedSensorCaps & ovrSensorCap_Position) != 0) ?
+		StatusStr = ((SupportedTrackingCaps & ovrTrackingCap_Position) != 0) ?
 			((bHmdPosTracking) ? TEXT("ON") : TEXT("OFF")) : TEXT("UNSUP");
 		Str = FString::Printf(TEXT("PosTr: %s"), *StatusStr);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
@@ -557,49 +511,55 @@
 		Str = FString::Printf(TEXT("LowPers: %s"), *StatusStr);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
 		Y += RowHeight;
+
+		StatusStr = ((SupportedDistortionCaps & ovrDistortionCap_Overdrive) != 0) ?
+			((bOverdrive) ? TEXT("ON") : TEXT("OFF")) : TEXT("UNSUP");
+		Str = FString::Printf(TEXT("Overdrive: %s"), *StatusStr);
+		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
+		Y += RowHeight;
 	}
 #endif // #if !UE_BUILD_SHIPPING
 }
 
-#ifdef OVR_DIRECT_RENDERING
-void FOculusRiftHMD::ShutdownRendering()
+void FOculusRiftHMD::UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& InViewport)
 {
-#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
-	if (pD3D11Bridge)
+	check(IsInGameThread());
+
+	FRHIViewport* const ViewportRHI = InViewport.GetViewportRHI().GetReference();
+
+	if (!IsStereoEnabled())
 	{
-		pD3D11Bridge->Shutdown();
-		pD3D11Bridge = NULL;
+		if (!bUseSeparateRenderTarget)
+		{
+			ViewportRHI->SetCustomPresent(nullptr);
 	}
-#endif
-#if defined(OVR_GL)
-	if (pOGLBridge)
+#if PLATFORM_WINDOWS
+		if (OSWindowHandle)
 	{
-		pOGLBridge->Shutdown();
-		pOGLBridge = NULL;
+			ovrHmd_AttachToWindow(Hmd, NULL, NULL, NULL);
+			OSWindowHandle = nullptr;
 	}
 #endif
+		return;
+	}
 
-	ovrHmd_Destroy(Hmd);
-	Hmd = nullptr;
-}
-
-void FOculusRiftHMD::UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& Viewport)
-{
-	check(IsInGameThread());
-
-	FRHIViewport* const ViewportRHI = Viewport.GetViewportRHI().GetReference();
-	
-	if (!bUseSeparateRenderTarget || !IsStereoEnabled())
+#if PLATFORM_WINDOWS
+	void *wnd = ViewportRHI->GetNativeWindow();
+	if (wnd && wnd != OSWindowHandle)
 	{
-		ViewportRHI->SetCustomPresent(nullptr);
-		return;
+		OSWindowHandle = wnd;
+		HWND Window = *(HWND*)wnd;
+		ovrHmd_AttachToWindow(Hmd, Window, NULL, NULL);
 	}
+#endif
+
+#ifdef OVR_DIRECT_RENDERING
 
 	check(GetActiveRHIBridgeImpl());
 
-	const FTexture2DRHIRef& RT   = Viewport.GetRenderTargetTexture();
+	const FTexture2DRHIRef& RT = InViewport.GetRenderTargetTexture();
 	check(IsValidRef(RT));
-	const FIntPoint NewEyeRTSize = FIntPoint((RT->GetSizeX() + 1)/2, RT->GetSizeY());
+	const FIntPoint NewEyeRTSize = FIntPoint((RT->GetSizeX() + 1) / 2, RT->GetSizeY());
 	if (EyeViewportSize != NewEyeRTSize)
 	{
 		EyeViewportSize.X = NewEyeRTSize.X;
@@ -610,7 +570,30 @@
 	{
 		UpdateStereoRenderingParams();
 	}
-	GetActiveRHIBridgeImpl()->UpdateViewport(Viewport, ViewportRHI);
+	GetActiveRHIBridgeImpl()->UpdateViewport(InViewport, ViewportRHI);
+#endif // #ifdef OVR_DIRECT_RENDERING
+}
+
+#ifdef OVR_DIRECT_RENDERING
+void FOculusRiftHMD::ShutdownRendering()
+{
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+	if (pD3D11Bridge)
+	{
+		pD3D11Bridge->Shutdown();
+		pD3D11Bridge = NULL;
+	}
+#endif
+#if defined(OVR_GL)
+	if (pOGLBridge)
+	{
+		pOGLBridge->Shutdown();
+		pOGLBridge = NULL;
+	}
+#endif
+
+	ovrHmd_Destroy(Hmd);
+	Hmd = nullptr;
 }
 
 #if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
@@ -632,8 +615,7 @@
 		{
 			OVR::Lock::Locker lock(&ModifyLock);
 			check(Cfg.D3D11.pSwapChain); // make sure Config is initialized
-			(Plugin->bTimeWarp) ? Plugin->DistortionCaps |= ovrDistortionCap_TimeWarp : Plugin->DistortionCaps &= ~ovrDistortionCap_TimeWarp;
-			(Plugin->bVSync) ? Plugin->HmdCaps &= ~ovrHmdCap_NoVSync : Plugin->HmdCaps |= ovrHmdCap_NoVSync;
+			Plugin->UpdateDistortionCaps();
 			if (!ovrHmd_ConfigureRendering(Plugin->Hmd, &Cfg.Config, Plugin->DistortionCaps, 
 				Plugin->RenderParams_RenderThread.EyeFov, Plugin->RenderParams_RenderThread.EyeRenderDesc))
 			{
@@ -696,11 +678,14 @@
 	check(IsInRenderingThread());
 	if (Plugin->RenderParams_RenderThread.bFrameBegun)
 	{
-		if (Plugin->RenderParams_RenderThread.ShowFlags.Rendering)
-		{
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Left, Plugin->RenderParams_RenderThread.EyeRenderPose[0], &EyeTexture_RenderThread[0].Texture);
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Right, Plugin->RenderParams_RenderThread.EyeRenderPose[1], &EyeTexture_RenderThread[1].Texture);
+		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
+		const ovrTexture eyeTextures[2] = { EyeTexture_RenderThread[0].Texture, EyeTexture_RenderThread[1].Texture };
+		ovrHmd_EndFrame(Plugin->Hmd, Plugin->RenderParams_RenderThread.EyeRenderPose, eyeTextures); // This function will present
+		Plugin->RenderParams_RenderThread.bFrameBegun = false;
 		}
+	else
+	{
+		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
 	}
 }
 
@@ -903,8 +888,6 @@
 
 	FinishRendering();
 
-	Plugin->FinishRendering_RenderThread();
-
 	return false; // indicates that we are presenting here, UE shouldn't do Present.
 }
 #endif // #if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
@@ -928,10 +911,7 @@
 		if (bNeedReinitRendererAPI)
 		{
 			OVR::Lock::Locker lock(&ModifyLock);
-			Plugin->DistortionCaps &= ~ovrDistortionCap_SRGB;
-			Plugin->DistortionCaps |= ovrDistortionCap_FlipInput;
-			(Plugin->bTimeWarp) ? Plugin->DistortionCaps |= ovrDistortionCap_TimeWarp : Plugin->DistortionCaps &= ~ovrDistortionCap_TimeWarp;
-			(Plugin->bVSync) ? Plugin->HmdCaps &= ~ovrHmdCap_NoVSync : Plugin->HmdCaps |= ovrHmdCap_NoVSync;
+			Plugin->UpdateDistortionCaps();
 			if (!ovrHmd_ConfigureRendering(Plugin->Hmd, &Cfg.Config, Plugin->DistortionCaps, 
 				Plugin->RenderParams_RenderThread.EyeFov, Plugin->RenderParams_RenderThread.EyeRenderDesc))
 			{
@@ -953,13 +933,18 @@
 
 void FOculusRiftHMD::OGLBridge::FinishRendering()
 {
+	check(IsInRenderingThread());
+
 	if (Plugin->RenderParams_RenderThread.bFrameBegun)
 	{
-		if (Plugin->RenderParams_RenderThread.ShowFlags.Rendering)
-		{
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Left, Plugin->RenderParams_RenderThread.EyeRenderPose[0], &EyeTexture_RenderThread[0].Texture);
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Right, Plugin->RenderParams_RenderThread.EyeRenderPose[1], &EyeTexture_RenderThread[1].Texture);
+		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
+		const ovrTexture eyeTextures[2] = { EyeTexture_RenderThread[0].Texture, EyeTexture_RenderThread[1].Texture };
+		ovrHmd_EndFrame(Plugin->Hmd, Plugin->RenderParams_RenderThread.EyeRenderPose, eyeTextures); // This function will present
+		Plugin->RenderParams_RenderThread.bFrameBegun = false;
 		}
+	else
+	{
+		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
 	}
 }
 
@@ -1058,8 +1043,6 @@
 
 	FinishRendering();
 
-	Plugin->FinishRendering_RenderThread();
-
 	return false; // indicates that we are presenting here, UE shouldn't do Present.
 }
 #endif // #if defined(OVR_GL)
--- ../../../../UE4-QA/Engine/Source/Programs/AutomationTool/IOS/IOSPlatform.Automation.cs	2014-07-13 06:33:15.000000000 -0700
+++ ./Engine/Source/Programs/AutomationTool/IOS/IOSPlatform.Automation.cs	2014-08-08 11:20:19.474096900 -0700
@@ -145,6 +145,10 @@
 			if (bNeedToSign)
 			{
 				IPPArguments += " -sign";
+				if (Params.Distribution)
+				{
+					IPPArguments += " -distribution";
+				}
 			}
 
 			IPPArguments += (cookonthefly ? " -cookonthefly" : "");
@@ -154,10 +158,10 @@
 			// rename the .ipa if not code based
 			if (!Params.IsCodeBasedProject)
 			{
-				ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", Params.ShortProjectName + ".ipa");
+				ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", (Params.Distribution ? "Distro_" : "") + Params.ShortProjectName + ".ipa");
 				if (TargetConfiguration != UnrealTargetConfiguration.Development)
 				{
-					ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", Params.ShortProjectName + "-" + PlatformType.ToString() + "-" + TargetConfiguration.ToString() + ".ipa");
+					ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", (Params.Distribution ? "Distro_" : "") + Params.ShortProjectName + "-" + PlatformType.ToString() + "-" + TargetConfiguration.ToString() + ".ipa");
 				}
 			}
 
@@ -234,6 +238,19 @@
 		{
 			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", ShortProjectName + "-Info.plist");
 		}
+		else if (File.Exists(ProjectRoot + "/Build/IOS/Info.plist"))
+		{
+			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", "Info.plist");
+		}
+		else if (Directory.Exists(ProjectRoot + "/Build/IOS"))
+		{
+			// look for any plist file
+			string[] Plists = Directory.GetFiles(ProjectRoot + "/Build/IOS", "*.plist");
+			if (Plists.Length > 0)
+			{
+				SourcePListFile = Plists[0];
+			}
+		}
 
 		//@TODO: This is writing to the engine directory!
 		string SourcePath = CombinePaths((IsCodeBasedProject ? ProjectRoot : LocalRoot + "\\Engine"), "Intermediate", "IOS");
@@ -564,10 +581,10 @@
 		// rename the .ipa if not code based
 		if (!Params.IsCodeBasedProject)
 		{
-			ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", Params.ShortProjectName + ".ipa");
+			ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", (Params.Distribution ? "Distro_" : "") + Params.ShortProjectName + ".ipa");
 			if (TargetConfiguration != UnrealTargetConfiguration.Development)
 			{
-				ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", Params.ShortProjectName + "-" + PlatformType.ToString() + "-" + TargetConfiguration.ToString() + ".ipa");
+				ProjectIPA = Path.Combine(Path.GetDirectoryName(Params.RawProjectPath), "Binaries", "IOS", (Params.Distribution ? "Distro_" : "") + Params.ShortProjectName + "-" + PlatformType.ToString() + "-" + TargetConfiguration.ToString() + ".ipa");
 			}
 		}
 
@@ -588,6 +605,10 @@
 			{
 				throw new AutomationException ("iOS is currently only able to package one target configuration at a time, but StageTargetConfigurations contained {0} configurations", SC.StageTargetConfigurations.Count);
 			}
+			if (Params.Distribution)
+			{
+				throw new AutomationException("iOS cannot deploy a package made for distribution.");
+			}
 			var TargetConfiguration = SC.StageTargetConfigurations[0];
 
 //			var ProjectStub = Params.ProjectGameExeFilename;	
--- ../../../../UE4-QA/Engine/Source/Programs/IOS/iPhonePackager/MobileProvisionUtilities.cs	2014-07-13 06:34:06.000000000 -0700
+++ ./Engine/Source/Programs/IOS/iPhonePackager/MobileProvisionUtilities.cs	2014-08-08 11:19:03.246474900 -0700
@@ -48,6 +48,8 @@
 
 			#region remove after we provide an install mechanism
 			// copy all of the provisions from the game directory to the library
+			if (Directory.Exists(Path.GetDirectoryName(Config.ProjectFile) + "/Build/IOS/"))
+			{
 			foreach (string Provision in Directory.EnumerateFiles(Path.GetDirectoryName(Config.ProjectFile) + "/Build/IOS/", "*.mobileprovision", SearchOption.AllDirectories))
 			{
 				if (!File.Exists(Config.ProvisionDirectory + Path.GetFileName(Provision)))
@@ -57,8 +59,11 @@
 					DestFileInfo.Attributes = DestFileInfo.Attributes & ~FileAttributes.ReadOnly;
 				}
 			}
+			}
 
 			// copy all of the provisions from the egine directory to the library
+			if (Directory.Exists(Config.EngineBuildDirectory))
+			{
 			foreach (string Provision in Directory.EnumerateFiles(Config.EngineBuildDirectory, "*.mobileprovision", SearchOption.AllDirectories))
 			{
 				if (!File.Exists(Config.ProvisionDirectory + Path.GetFileName(Provision)))
@@ -68,6 +73,7 @@
 					DestFileInfo.Attributes = DestFileInfo.Attributes & ~FileAttributes.ReadOnly;
 				}
 			}
+			}
 			#endregion
 
 			// cache the provision library
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/Linux/UEBuildLinux.cs	2014-07-11 11:55:51.000000000 -0700
+++ ./Engine/Source/Programs/UnrealBuildTool/Linux/UEBuildLinux.cs	2014-08-08 11:18:21.093260000 -0700
@@ -96,6 +96,12 @@
             return SDKStatus.Invalid;
         }
 
+        public override bool CanUseXGE()
+        {
+            // disabled until XGE crash is fixed
+            return false;
+        }
+        
         /**
          *	Register the platform with the UEBuildPlatform class
          */
@@ -223,7 +229,6 @@
         public override void ValidateUEBuildConfiguration()
         {
             BuildConfiguration.bUseUnityBuild = true;
-            BuildConfiguration.bAllowXGE = false;   // disable XGE until Xoreax figures out the reason of and fixes Incredibuild crashes (e.g. TTP #341174).
 
             // Don't stop compilation at first error...
             BuildConfiguration.bStopXGECompilationAfterErrors = true;
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Misc/Parse.cpp	2014-03-21 12:08:17.000000000 -0700
+++ ./Engine/Source/Runtime/Core/Private/Misc/Parse.cpp	2014-07-22 11:10:54.000000000 -0700
@@ -1069,6 +1069,11 @@
 					WindowMode = EWindowMode::WindowedFullscreen;
 					StringTripLen = 2;
 				}
+				else if (WindowFullScreenChars == TEXT("wm"))
+				{
+					WindowMode = EWindowMode::WindowedMirror;
+					StringTripLen = 2;
+				}
 				else if (FullScreenChar == TEXT("f"))
 				{
 					WindowMode = EWindowMode::Fullscreen;
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformMisc.cpp	2014-06-18 10:02:02.000000000 -0700
+++ ./Engine/Source/Runtime/Core/Private/Windows/WindowsPlatformMisc.cpp	2014-08-07 17:25:08.622549100 -0700
@@ -1858,7 +1858,7 @@
 bool FWindowsPlatformMisc::CoInitialize()
 {
 	HRESULT hr = ::CoInitialize(NULL);
-	return hr == S_OK || hr == S_FALSE;
+	return hr == S_OK || hr == S_FALSE || hr == RPC_E_CHANGED_MODE; // RPC_E_CHANGED_MODE maybe returned if CoInit is called several times with different type of threading model. @todo: revise.
 }
 
 void FWindowsPlatformMisc::CoUninitialize()
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Windows/WindowsWindow.cpp	2014-05-15 08:56:27.000000000 -0700
+++ ./Engine/Source/Runtime/Core/Private/Windows/WindowsWindow.cpp	2014-07-22 17:44:50.000000000 -0700
@@ -453,13 +453,16 @@
 		const LONG RestoredFlags = WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_OVERLAPPED | WS_BORDER;
 
 		// If we're not in fullscreen, make it so
-		if( NewWindowMode == EWindowMode::WindowedFullscreen || NewWindowMode == EWindowMode::Fullscreen )
+		if( NewWindowMode == EWindowMode::WindowedFullscreen || NewWindowMode == EWindowMode::Fullscreen || NewWindowMode == EWindowMode::WindowedMirror)
 		{
 			::GetWindowPlacement(HWnd, &PreFullscreenWindowPlacement);
 
 			// Setup Win32 flags for fullscreen window
+			if (NewWindowMode != EWindowMode::WindowedMirror)
+			{
 			WindowFlags &= ~RestoredFlags;
 			WindowFlags |= FullscreenFlags;
+			}
 			SetWindowLong(HWnd, GWL_STYLE, WindowFlags);
 
 			if (!bTrueFullscreen)
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Public/GenericPlatform/GenericWindow.h	2014-05-15 08:56:27.000000000 -0700
+++ ./Engine/Source/Runtime/Core/Public/GenericPlatform/GenericWindow.h	2014-07-21 22:48:37.000000000 -0700
@@ -12,11 +12,15 @@
 	enum Type
 	{
 		/** The window is in true fullscreen mode */
-		Fullscreen,
+		Fullscreen = 0,
 		/** The window has no border and takes up the entire area of the screen */
-		WindowedFullscreen,
+		WindowedFullscreen = 1,
 		/** The window has a border and may not take up the entire screen area */
-		Windowed
+		Windowed = 2, 
+
+		WindowedMirror = 3,
+
+		_Total
 	};
 
 	static inline Type ConvertIntToWindowMode(int32 InWindowMode)
@@ -30,6 +34,9 @@
 			case 1:
 				WindowMode = WindowedFullscreen;
 				break;
+			case 3:
+				WindowMode = WindowedMirror;
+				break;
 			case 2:
 			default:
 				WindowMode = Windowed;
--- ../../../../UE4-QA/Engine/Source/Runtime/CoreUObject/Private/UObject/LinkerLoad.cpp	2014-06-28 12:49:57.000000000 -0700
+++ ./Engine/Source/Runtime/CoreUObject/Private/UObject/LinkerLoad.cpp	2014-08-08 11:13:20.600213700 -0700
@@ -2953,6 +2953,24 @@
 					return NULL;
 				}
 			}
+			else
+			{
+				// SuperStruct needs to be fully linked so that UStruct::Link will have access to UObject::SuperStruct->PropertySize. 
+				// There are other attempts to force our super struct to load, and I have not verified that they can all be removed
+				// in favor of this one:
+				if (!SuperStruct->HasAnyFlags(RF_LoadCompleted)
+					&& !SuperStruct->HasAnyFlags(RF_Native)
+					&& SuperStruct->GetLinker()
+					&& Export.SuperIndex.IsImport())
+				{
+					const UClass* AsClass = Cast<UClass>(SuperStruct);
+					if (AsClass && !AsClass->ClassDefaultObject)
+					{
+						SuperStruct->SetFlags(RF_NeedLoad);
+						Preload(SuperStruct);
+					}
+				}
+			}
 		}
 
 		// Only UClass objects and UProperty objects of intrinsic classes can have RF_Native set. Those property objects are never
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Classes/GameFramework/GameUserSettings.h	2014-06-20 07:02:31.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Classes/GameFramework/GameUserSettings.h	2014-07-21 20:30:44.000000000 -0700
@@ -139,6 +139,7 @@
 	 *	0 = Fullscreen
 	 *	1 = Windowed fullscreen
 	 *	2 = Windowed
+	 *	3 = WindowedMirror
 	 */
 	UPROPERTY(config)
 	int32 FullscreenMode;
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameEngine.cpp	2014-07-09 06:27:06.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/GameEngine.cpp	2014-07-21 22:48:34.000000000 -0700
@@ -68,7 +68,7 @@
 	{
 		int32 Value = CVar->GetValueOnGameThread();
 
-		if(Value >= 0 && Value <= 2)
+		if(Value >= 0 && Value < EWindowMode::_Total)
 		{
 			return Value;
 		}
@@ -88,7 +88,7 @@
 			return WindowMode;
 		}
 
-		if (GEngine && GEngine->HMDDevice.IsValid())
+		if (GEngine && GEngine->HMDDevice.IsValid() && GEngine->HMDDevice->IsFullScreenAllowed())
 		{
 			return EWindowMode::Fullscreen;
 		}
@@ -189,7 +189,7 @@
 	}
 
 	//fullscreen is always supported, but don't allow windowed mode on platforms that dont' support it.
-	WindowMode = (!FPlatformProperties::SupportsWindowedMode() && (WindowMode == EWindowMode::Windowed || WindowMode == EWindowMode::WindowedFullscreen)) ? EWindowMode::Fullscreen : WindowMode;
+	WindowMode = (!FPlatformProperties::SupportsWindowedMode() && (WindowMode == EWindowMode::Windowed || WindowMode == EWindowMode::WindowedMirror || WindowMode == EWindowMode::WindowedFullscreen)) ? EWindowMode::Fullscreen : WindowMode;
 
 	FParse::Value(FCommandLine::Get(), TEXT("ResX="), ResolutionX);
 	FParse::Value(FCommandLine::Get(), TEXT("ResY="), ResolutionY);
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameUserSettings.cpp	2014-06-20 07:03:24.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/GameUserSettings.cpp	2014-07-21 20:43:57.000000000 -0700
@@ -56,6 +56,9 @@
 		case EWindowMode::WindowedFullscreen:
 			FullscreenMode = 1;
 			break;
+		case EWindowMode::WindowedMirror:
+			FullscreenMode = 3;
+			break;
 		case EWindowMode::Windowed:
 		default:
 			FullscreenMode = 2;
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameViewportClient.cpp	2014-07-07 14:10:43.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/GameViewportClient.cpp	2014-07-22 18:55:35.000000000 -0700
@@ -2519,13 +2519,25 @@
 		const TCHAR* CmdTemp = FCString::Strchr(Cmd,'x') ? FCString::Strchr(Cmd,'x')+1 : FCString::Strchr(Cmd,'X') ? FCString::Strchr(Cmd,'X')+1 : TEXT("");
 		int32 Y=FCString::Atoi(CmdTemp);
 		Cmd = CmdTemp;
-		EWindowMode::Type WindowMode = Viewport->IsFullscreen() ? EWindowMode::Fullscreen : EWindowMode::Windowed;
+		EWindowMode::Type WindowMode;
+		if (GEngine->HMDDevice.IsValid() && GEngine->HMDDevice->IsHMDEnabled() && !GEngine->HMDDevice->IsFullScreenAllowed())
+		{
+			WindowMode = Viewport->IsFullscreen() ? EWindowMode::WindowedMirror : EWindowMode::Windowed;
+		}
+		else
+		{
+			WindowMode = Viewport->IsFullscreen() ? EWindowMode::Fullscreen : EWindowMode::Windowed;
+		}
 		if(FCString::Strchr(Cmd,'w') || FCString::Strchr(Cmd,'W'))
 		{
 			if(FCString::Strchr(Cmd, 'f') || FCString::Strchr(Cmd, 'F'))
 			{
 				WindowMode = EWindowMode::WindowedFullscreen;
 			}
+			else if (FCString::Strchr(Cmd, 'm') || FCString::Strchr(Cmd, 'M'))
+			{
+				WindowMode = EWindowMode::WindowedMirror;
+			}
 			else
 			{
 				WindowMode = EWindowMode::Windowed;
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/PhysicsEngine/RadialForceComponent.cpp	2014-05-16 03:44:50.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/PhysicsEngine/RadialForceComponent.cpp	2014-08-08 11:17:19.701121400 -0700
@@ -50,8 +50,11 @@
 				PokeComp->AddRadialForce( Origin, Radius, ForceStrength, Falloff );
 
 				// see if this is a target for a movement component
+				AActor* PokeOwner = PokeComp->GetOwner();
+				if(PokeOwner)
+				{
 				TArray<UMovementComponent*> MovementComponents;
-				PokeComp->GetOwner()->GetComponents<UMovementComponent>(MovementComponents);
+					PokeOwner->GetComponents<UMovementComponent>(MovementComponents);
 				for(const auto& MovementComponent : MovementComponents)
 				{
 					if(MovementComponent->UpdatedComponent == PokeComp)
@@ -61,6 +64,7 @@
 					}
 				}
 			}
+			}
 		}
 	}
 }
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/PlayerController.cpp	2014-06-20 13:23:32.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/PlayerController.cpp	2014-07-19 19:07:41.000000000 -0700
@@ -1944,6 +1944,14 @@
 {
 	bool bResult = false;
 
+	if (GEngine->HMDDevice.IsValid() && GEngine->IsStereoscopic3D())
+	{
+		bResult = GEngine->HMDDevice->HandleInputKey(
+			PlayerInput, Key, EventType, AmountDepressed, bGamepad);
+		if (bResult)
+			return bResult;
+	}
+
 	if (PlayerInput)
 	{
 		bResult = PlayerInput->InputKey(Key, EventType, AmountDepressed, bGamepad);
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/Slate/SceneViewport.cpp	2014-07-06 06:17:24.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/Slate/SceneViewport.cpp	2014-07-23 16:47:41.000000000 -0700
@@ -830,7 +830,15 @@
 						GEngine->HMDDevice->GetHMDMonitorInfo(MonitorInfo);
 						NewSizeX = MonitorInfo.ResolutionX;
 						NewSizeY = MonitorInfo.ResolutionY;
+						if (GEngine->HMDDevice->IsFullScreenAllowed())
+						{
 						WindowToResize->ReshapeWindow(FVector2D(MonitorInfo.DesktopX, MonitorInfo.DesktopY), FVector2D(MonitorInfo.ResolutionX, MonitorInfo.ResolutionY));
+						}
+						else
+						{
+							WindowToResize->Resize(FVector2D(MonitorInfo.ResolutionX, MonitorInfo.ResolutionY));
+							DesiredWindowMode = EWindowMode::WindowedMirror;
+						}
 
 						GEngine->HMDDevice->PushPreFullScreenRect(PreFullScreenRect);
 					}
@@ -845,7 +853,7 @@
 					{
 						FSlateRect PreFullScreenRect;
 						GEngine->HMDDevice->PopPreFullScreenRect(PreFullScreenRect);
-						if (PreFullScreenRect.GetSize().X > 0 && PreFullScreenRect.GetSize().Y > 0)
+						if (PreFullScreenRect.GetSize().X > 0 && PreFullScreenRect.GetSize().Y > 0 && GEngine->HMDDevice->IsFullScreenAllowed())
 						{
 							NewSizeX = PreFullScreenRect.GetSize().X;
 							NewSizeY = PreFullScreenRect.GetSize().Y;
@@ -865,7 +873,8 @@
 				int32 NewWindowSizeX = NewSizeX;
 				int32 NewWindowSizeY = NewSizeY;
 
-				if (DesiredWindowMode != EWindowMode::Windowed && CVarValue != 0)
+				if (DesiredWindowMode != EWindowMode::Windowed && CVarValue != 0 && 
+					(!GEngine->HMDDevice.IsValid() || GEngine->HMDDevice->IsFullScreenAllowed()))
 				{
 					FSlateRect Rect = WindowToResize->GetFullScreenInfo();
 
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/SplineMeshComponent.cpp	2014-06-09 11:01:17.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/SplineMeshComponent.cpp	2014-08-08 11:17:48.926043600 -0700
@@ -132,20 +132,32 @@
 
 		if (!RenderData->VertexBuffer.GetUseFullPrecisionUVs())
 		{
-			for (uint32 UVIndex = 0; UVIndex < RenderData->VertexBuffer.GetNumTexCoords(); UVIndex++)
+			int32 UVIndex;
+			for (UVIndex = 0; UVIndex < (int32)RenderData->VertexBuffer.GetNumTexCoords() - 1; UVIndex += 2)
 			{
 				Data.TextureCoordinates.Add(FVertexStreamComponent(
 					&RenderData->VertexBuffer,
-					STRUCT_OFFSET(TStaticMeshFullVertexFloat16UVs<MAX_TEXCOORDS>, UVs) + sizeof(FVector2DHalf)* UVIndex,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat16UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2DHalf) * UVIndex,
+					RenderData->VertexBuffer.GetStride(),
+					VET_Half4
+					));
+			}
+			// possible last UV channel if we have an odd number
+			if (UVIndex < (int32)RenderData->VertexBuffer.GetNumTexCoords())
+			{
+				Data.TextureCoordinates.Add(FVertexStreamComponent(
+					&RenderData->VertexBuffer,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat16UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2DHalf) * UVIndex,
 					RenderData->VertexBuffer.GetStride(),
 					VET_Half2
 					));
 			}
+
 			if (Parent->LightMapCoordinateIndex >= 0 && (uint32)Parent->LightMapCoordinateIndex < RenderData->VertexBuffer.GetNumTexCoords())
 			{
 				Data.LightMapCoordinateComponent = FVertexStreamComponent(
 					&RenderData->VertexBuffer,
-					STRUCT_OFFSET(TStaticMeshFullVertexFloat16UVs<MAX_TEXCOORDS>, UVs) + sizeof(FVector2DHalf)* Parent->LightMapCoordinateIndex,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat16UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2DHalf) * Parent->LightMapCoordinateIndex,
 					RenderData->VertexBuffer.GetStride(),
 					VET_Half2
 					);
@@ -153,11 +165,22 @@
 		}
 		else
 		{
-			for (uint32 UVIndex = 0; UVIndex < RenderData->VertexBuffer.GetNumTexCoords(); UVIndex++)
+			int32 UVIndex;
+			for (UVIndex = 0; UVIndex < (int32)RenderData->VertexBuffer.GetNumTexCoords() - 1; UVIndex += 2)
+			{
+				Data.TextureCoordinates.Add(FVertexStreamComponent(
+					&RenderData->VertexBuffer,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat32UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2D) * UVIndex,
+					RenderData->VertexBuffer.GetStride(),
+					VET_Float4
+					));
+			}
+			// possible last UV channel if we have an odd number
+			if (UVIndex < (int32)RenderData->VertexBuffer.GetNumTexCoords())
 			{
 				Data.TextureCoordinates.Add(FVertexStreamComponent(
 					&RenderData->VertexBuffer,
-					STRUCT_OFFSET(TStaticMeshFullVertexFloat32UVs<MAX_TEXCOORDS>, UVs) + sizeof(FVector2D)* UVIndex,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat32UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2D) * UVIndex,
 					RenderData->VertexBuffer.GetStride(),
 					VET_Float2
 					));
@@ -167,7 +190,7 @@
 			{
 				Data.LightMapCoordinateComponent = FVertexStreamComponent(
 					&RenderData->VertexBuffer,
-					STRUCT_OFFSET(TStaticMeshFullVertexFloat32UVs<MAX_TEXCOORDS>, UVs) + sizeof(FVector2D)* Parent->LightMapCoordinateIndex,
+					STRUCT_OFFSET(TStaticMeshFullVertexFloat32UVs<MAX_STATIC_TEXCOORDS>, UVs) + sizeof(FVector2D) * Parent->LightMapCoordinateIndex,
 					RenderData->VertexBuffer.GetStride(),
 					VET_Float2
 					);
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp	2014-07-08 13:03:53.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp	2014-07-22 11:12:21.000000000 -0700
@@ -9703,6 +9703,10 @@
 		{
 			WindowModeSuffix = TEXT("w");
 		} break;
+		case EWindowMode::WindowedMirror:
+		{
+			WindowModeSuffix = TEXT("wm");
+		} break;
 		case EWindowMode::WindowedFullscreen:
 		{
 			WindowModeSuffix = TEXT("wf");
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Public/StereoRendering.h	2014-07-05 09:09:27.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Public/StereoRendering.h	2014-07-19 20:43:43.000000000 -0700
@@ -22,7 +22,7 @@
     /**
      * Adjusts the viewport rectangle for stereo, based on which eye pass is being rendered.
      */
-    virtual void AdjustViewRect(EStereoscopicPass StereoPass, int32& X, int32& Y, uint32& SizeX, uint32& SizeY) const = 0;
+    virtual void AdjustViewRect(enum EStereoscopicPass StereoPass, int32& X, int32& Y, uint32& SizeX, uint32& SizeY) const = 0;
 
     /**
 	 * Calculates the offset for the camera position, given the specified position, rotation, and world scale
@@ -37,35 +37,35 @@
 	/**
 	 * Sets view-specific params (such as view projection matrix) for the canvas.
 	 */
-	virtual void InitCanvasFromView(FSceneView* InView, UCanvas* Canvas) = 0;
+	virtual void InitCanvasFromView(class FSceneView* InView, class UCanvas* Canvas) = 0;
 
 	/**
 	 * Pushes transformations based on specified viewport into canvas. Necessary to call PopTransform on
 	 * FCanvas object afterwards.
 	 */
-	virtual void PushViewportCanvas(EStereoscopicPass StereoPass, FCanvas *InCanvas, UCanvas *InCanvasObject, FViewport *InViewport) const = 0;
+	virtual void PushViewportCanvas(enum EStereoscopicPass StereoPass, class FCanvas *InCanvas, class UCanvas *InCanvasObject, class FViewport *InViewport) const = 0;
 
 	/**
 	 * Pushes transformations based on specified view into canvas. Necessary to call PopTransform on FCanvas 
 	 * object afterwards.
 	 */
-	virtual void PushViewCanvas(EStereoscopicPass StereoPass, FCanvas *InCanvas, UCanvas *InCanvasObject, FSceneView *InView) const = 0;
+	virtual void PushViewCanvas(enum EStereoscopicPass StereoPass, class FCanvas *InCanvas, class UCanvas *InCanvasObject, class FSceneView *InView) const = 0;
 
 	/**
 	 * Returns eye render params, used from PostProcessHMD, RenderThread.
 	 */
-	virtual void GetEyeRenderParams_RenderThread(EStereoscopicPass StereoPass, FVector2D& EyeToSrcUVScaleValue, FVector2D& EyeToSrcUVOffsetValue) const {}
+	virtual void GetEyeRenderParams_RenderThread(enum EStereoscopicPass StereoPass, FVector2D& EyeToSrcUVScaleValue, FVector2D& EyeToSrcUVOffsetValue) const {}
 
 	/**
 	 * Returns timewarp matrices, used from PostProcessHMD, RenderThread.
 	 */
-	virtual void GetTimewarpMatrices_RenderThread(EStereoscopicPass StereoPass, FMatrix& EyeRotationStart, FMatrix& EyeRotationEnd) const {}
+	virtual void GetTimewarpMatrices_RenderThread(enum EStereoscopicPass StereoPass, FMatrix& EyeRotationStart, FMatrix& EyeRotationEnd) const {}
 
 	// Optional methods to support rendering into a texture.
 	/**
 	 * Updates viewport for direct rendering of distortion. Should be called on a game thread.
 	 */
-	virtual void UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& Viewport) {}
+	virtual void UpdateViewport(bool bUseSeparateRenderTarget, const class FViewport& Viewport) {}
 
 	/**
 	 * Calculates dimensions of the render target texture for direct rendering of distortion.
@@ -75,17 +75,17 @@
 	/**
 	 * Returns true, if render target texture must be re-calculated. 
 	 */
-	virtual bool NeedReAllocateViewportRenderTarget(const FViewport& Viewport) const { return false; }
+	virtual bool NeedReAllocateViewportRenderTarget(const class FViewport& Viewport) const { return false; }
 
 	// Whether separate render target should be used or not.
 	virtual bool ShouldUseSeparateRenderTarget() const { return false; }
 
 	// Renders texture into a backbuffer. Could be empty if no rendertarget texture is used, or if direct-rendering 
 	// through RHI bridge is implemented. 
-	virtual void RenderTexture_RenderThread(FRHICommandListImmediate& RHICmdList, FTexture2DRHIParamRef BackBuffer, FTexture2DRHIParamRef SrcTexture) const {}
+	virtual void RenderTexture_RenderThread(class FRHICommandListImmediate& RHICmdList, class FRHITexture2D* BackBuffer, class FRHITexture2D* SrcTexture) const {}
 
 	/**
 	 * Called after Present is called.
 	 */
-	virtual void FinishRenderingFrame_RenderThread(FRHICommandListImmediate& RHICmdList) {}
+	virtual void FinishRenderingFrame_RenderThread(class FRHICommandListImmediate& RHICmdList) {}
 };
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Public/UnrealClient.h	2014-06-26 10:34:09.000000000 -0700
+++ ./Engine/Source/Runtime/Engine/Public/UnrealClient.h	2014-07-21 20:28:56.000000000 -0700
@@ -281,7 +281,7 @@
 	virtual float GetTabletPressure() { return 0.f; }
 	virtual bool IsPenActive() { return false; }
 	virtual void SetMouse(int32 x, int32 y) = 0;
-	virtual bool IsFullscreen()	const { return WindowMode == EWindowMode::Fullscreen || WindowMode == EWindowMode::WindowedFullscreen; }
+	virtual bool IsFullscreen()	const { return WindowMode == EWindowMode::Fullscreen || WindowMode == EWindowMode::WindowedFullscreen || WindowMode == EWindowMode::WindowedMirror; }
 	virtual void ProcessInput( float DeltaTime ) = 0;
 
 	/**
--- ../../../../UE4-QA/Engine/Source/Runtime/HeadMountedDisplay/Private/HeadMountedDisplayModule.cpp	2014-06-04 02:54:00.000000000 -0700
+++ ./Engine/Source/Runtime/HeadMountedDisplay/Private/HeadMountedDisplayModule.cpp	2014-07-19 21:45:08.000000000 -0700
@@ -1,6 +1,7 @@
 // Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.
 
 #include "HeadMountedDisplayPrivate.h"
+#include "Layout/SlateRect.h"
 
 class FHeadMountedDisplayModule : public IHeadMountedDisplayModule
 {
@@ -15,16 +16,19 @@
 
 IHeadMountedDisplay::IHeadMountedDisplay()
 {
-	PreFullScreenRect = FSlateRect(-1.f, -1.f, -1.f, -1.f);
+	PreFullScreenRect.Left = PreFullScreenRect.Right = PreFullScreenRect.Top = PreFullScreenRect.Bottom = -1.f;
 }
 
 void IHeadMountedDisplay::PushPreFullScreenRect(const FSlateRect& InPreFullScreenRect)
 {
-	PreFullScreenRect = InPreFullScreenRect;
+	PreFullScreenRect.Left	= InPreFullScreenRect.Left;
+	PreFullScreenRect.Top	= InPreFullScreenRect.Top;
+	PreFullScreenRect.Right	= InPreFullScreenRect.Right;
+	PreFullScreenRect.Bottom = InPreFullScreenRect.Bottom;
 }
 
 void IHeadMountedDisplay::PopPreFullScreenRect(FSlateRect& OutPreFullScreenRect)
 {
-	OutPreFullScreenRect = PreFullScreenRect;
-	PreFullScreenRect = FSlateRect(-1.f, -1.f, -1.f, -1.f);
+	OutPreFullScreenRect = FSlateRect(PreFullScreenRect.Left, PreFullScreenRect.Top, PreFullScreenRect.Right, PreFullScreenRect.Bottom);
+	PreFullScreenRect.Left = PreFullScreenRect.Right = PreFullScreenRect.Top = PreFullScreenRect.Bottom = -1.f;
 }
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/Runtime/HeadMountedDisplay/Public/IHeadMountedDisplay.h	2014-07-06 06:17:24.000000000 -0700
+++ ./Engine/Source/Runtime/HeadMountedDisplay/Public/IHeadMountedDisplay.h	2014-08-05 21:22:52.302499300 -0700
@@ -2,8 +2,7 @@
 
 #pragma once
 
-#include "StereoRendering.h"
-#include "Layout/SlateRect.h"
+#include "Runtime/Engine/Public/StereoRendering.h"
 
 // depending on your kit and SDK, you may want to use this.
 // new distortion handling still in development.
@@ -97,7 +96,7 @@
     /**
      * Get the current orientation and position reported by the HMD.
      */
-    virtual void GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) const = 0;
+    virtual void GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) = 0;
 
     /**
      * Get the ISceneViewExtension for this HMD, or none.
@@ -149,11 +148,16 @@
     virtual bool Exec( UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar ) = 0;
 
 	/**
+	 * Returns true, if HMD allows fullscreen mode.
+	 */
+	virtual bool IsFullScreenAllowed() const { return true; }
+
+	/**
 	 * Saves / loads pre-fullscreen rectangle. Could be used to store saved original window position 
 	 * before switching to fullscreen mode.
 	 */
-	virtual void PushPreFullScreenRect(const FSlateRect& InPreFullScreenRect);
-	virtual void PopPreFullScreenRect(FSlateRect& OutPreFullScreenRect);
+	virtual void PushPreFullScreenRect(const class FSlateRect& InPreFullScreenRect);
+	virtual void PopPreFullScreenRect(class FSlateRect& OutPreFullScreenRect);
 
 	/**
 	 * A callback that is called when screen mode is changed (fullscreen <-> window). 
@@ -209,6 +213,14 @@
 	 */
 	virtual void DrawDebug(UCanvas* Canvas, EStereoscopicPass StereoPass) {}
 
+
+	/**
+	 * Passing key events to HMD (for debugging purposes).
+	 * If returns 'false' then key will be handled by PlayerController;
+	 * otherwise, key won't be handled by the PlayerController.
+	 */
+	virtual bool HandleInputKey(class UPlayerInput*, const struct FKey& Key, enum EInputEvent EventType, float AmountDepressed, bool bGamepad) { return false; }
+
 	/** 
 	 * Additional optional distorion rendering parameters
 	 * @todo:  Once we can move shaders into plugins, remove these!
@@ -233,5 +245,11 @@
 
 private:
 	/** Stores the dimensions of the window before we moved into fullscreen mode, so they can be restored */
-	FSlateRect PreFullScreenRect;
+	struct Rect
+	{
+		float Left;
+		float Top;
+		float Right;
+		float Bottom;
+	} PreFullScreenRect;
 };
--- ../../../../UE4-QA/Engine/Source/Runtime/HeadMountedDisplay/Public/IHeadMountedDisplayModule.h	2014-06-13 02:17:02.000000000 -0700
+++ ./Engine/Source/Runtime/HeadMountedDisplay/Public/IHeadMountedDisplayModule.h	2014-07-19 19:15:17.000000000 -0700
@@ -52,4 +52,6 @@
 	 */
 	virtual TSharedPtr< class IHeadMountedDisplay > CreateHeadMountedDisplay() = 0;
 
+	// Pre-init the HMD module (optional).
+	virtual void PreInit() {}
 };
--- ../../../../UE4-QA/Engine/Source/Runtime/Launch/Launch.Build.cs	2014-07-07 07:01:07.000000000 -0700
+++ ./Engine/Source/Runtime/Launch/Launch.Build.cs	2014-07-19 21:37:06.000000000 -0700
@@ -34,8 +34,10 @@
 				"Slate",
 				"SlateCore",
 				"Sockets",
+				"HeadMountedDisplay",
 			}
 		);
+		DynamicallyLoadedModuleNames.Add("HeadMountedDisplay");
         
         if( !UEBuildConfiguration.bBuildDedicatedServer)
         {
--- ../../../../UE4-QA/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp	2014-07-12 13:43:09.000000000 -0700
+++ ./Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp	2014-07-19 21:37:13.000000000 -0700
@@ -18,6 +18,10 @@
 #include "UProjectInfo.h"
 #include "EngineVersion.h"
 
+#if WITH_ENGINE
+	#include "HeadMountedDisplay.h"
+#endif
+
 #if WITH_EDITOR
 	#include "EditorStyle.h"
 	#include "AutomationController.h"
@@ -2348,6 +2352,8 @@
 		IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostConfigInit);
 	}
 
+	PreInitHMDDevice();
+
 	// Put the command line and config info into the suppression system
 	FLogSuppressionInterface::Get().ProcessConfigAndCommandLine();
 
@@ -2559,4 +2565,22 @@
 	FInternationalization::TearDown();
 }
 
+void FEngineLoop::PreInitHMDDevice()
+{
+#if WITH_ENGINE
+	if (!GIsEditor)
+	{
+		if (!FParse::Param(FCommandLine::Get(), TEXT("nohmd")) && !FParse::Param(FCommandLine::Get(), TEXT("emulatestereo")))
+		{
+			// Get a list of plugins that implement this feature
+			TArray<IHeadMountedDisplayModule*> HMDImplementations = IModularFeatures::Get().GetModularFeatureImplementations<IHeadMountedDisplayModule>(IHeadMountedDisplayModule::GetModularFeatureName());
+			for (auto HMDModuleIt = HMDImplementations.CreateIterator(); HMDModuleIt; ++HMDModuleIt)
+			{
+				(*HMDModuleIt)->PreInit();
+			}
+		}
+	}
+#endif // #if WITH_ENGINE
+}
+
 #undef LOCTEXT_NAMESPACE
--- ../../../../UE4-QA/Engine/Source/Runtime/Launch/Public/LaunchEngineLoop.h	2014-06-18 02:22:00.000000000 -0700
+++ ./Engine/Source/Runtime/Launch/Public/LaunchEngineLoop.h	2014-07-19 19:21:44.000000000 -0700
@@ -101,6 +101,9 @@
 
 #endif // WITH_ENGINE
 
+	/** Pre-init HMD device (if necessary) */
+	static void PreInitHMDDevice();
+
 public:
 
 	/**
--- ../../../../UE4-QA/Engine/Source/Runtime/OpenGLDrv/Private/Mac/OpenGLMac.cpp	2014-07-06 12:41:44.000000000 -0700
+++ ./Engine/Source/Runtime/OpenGLDrv/Private/Mac/OpenGLMac.cpp	2014-08-10 18:53:27.000000000 -0700
@@ -731,6 +731,22 @@
 				[Context->OpenGLContext update];
 			}
 			
+            if (Viewport.GetCustomPresent())
+            {
+				SCOPED_AUTORELEASE_POOL;
+                
+				// Clear the Alpha channel
+				glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_TRUE);
+				glClearColor(0.f,0.f,0.f,1.f);
+				glClear(GL_COLOR_BUFFER_BIT);
+				glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);
+				glClearColor(0.f,0.f,0.f,0.f);
+
+                glDisable(GL_FRAMEBUFFER_SRGB);
+                Viewport.GetCustomPresent()->Present(SyncInterval);
+                glEnable(GL_FRAMEBUFFER_SRGB);
+                return false;
+            }
 			// OpenGL state necessary for blit is set up in PlatformResizeGLContext(), and should be correct here,
 			// as viewport contexts aren't bound at any other occasion.
 			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
--- ../../../../UE4-QA/Engine/Source/Runtime/OpenGLDrv/Private/OpenGLCommands.cpp	2014-06-26 07:42:26.000000000 -0700
+++ ./Engine/Source/Runtime/OpenGLDrv/Private/OpenGLCommands.cpp	2014-07-28 20:02:37.968581700 -0700
@@ -1590,8 +1590,15 @@
 	else if( NewDepthStencilTargetRHI )
 	{
 		// Set viewport size to new depth target size.
+		//PendingState.Viewport.Max.X = GetOpenGLTextureSizeXFromRHITexture(NewDepthStencilTargetRHI);
+		//PendingState.Viewport.Max.Y = GetOpenGLTextureSizeYFromRHITexture(NewDepthStencilTargetRHI);
+		// OCULUS BEGIN, see https://udn.unrealengine.com/questions/211264/opengl-windows-crash-and-slowdown.html
+		// Set viewport size to new depth target size.
 		PendingState.Viewport.Max.X = GetOpenGLTextureSizeXFromRHITexture(NewDepthStencilTargetRHI);
 		PendingState.Viewport.Max.Y = GetOpenGLTextureSizeYFromRHITexture(NewDepthStencilTargetRHI);
+		PendingState.Viewport.Min.X = FMath::Min<uint32>(PendingState.Viewport.Min.X, PendingState.Viewport.Max.X);
+		PendingState.Viewport.Min.Y = FMath::Min<uint32>(PendingState.Viewport.Min.Y, PendingState.Viewport.Max.Y);
+		// OCULUS END
 	}
 }
 
--- ../../../../UE4-QA/Engine/Source/Runtime/SlateRHIRenderer/Private/SlateRHIRenderer.cpp	2014-07-06 06:21:16.000000000 -0700
+++ ./Engine/Source/Runtime/SlateRHIRenderer/Private/SlateRHIRenderer.cpp	2014-08-08 11:14:13.438497000 -0700
@@ -639,6 +639,12 @@
 						Params.Renderer->DrawWindow_RenderThread(RHICmdList, *Params.ViewportInfo, *Params.WindowElementList, Params.bLockToVsync);
 					});
 
+					// Mark this window as 'drawn'
+					if (!Window->HasEverBeenDrawn())
+					{
+						Window->MarkAsDrawn();
+					}
+
 					SlateWindowRendered.Broadcast( *Params.SlateWindow, &ViewInfo->ViewportRHI );
 
 					if ( bTakingAScreenShot )
--- ../../../../UE4-QA/Engine/Source/Runtime/Windows/D3D11RHI/Private/D3D11Viewport.cpp	2014-07-06 06:17:25.000000000 -0700
+++ ./Engine/Source/Runtime/Windows/D3D11RHI/Private/D3D11Viewport.cpp	2014-07-19 19:11:00.000000000 -0700
@@ -96,7 +96,7 @@
 	// create the render target view
 	TRefCountPtr<ID3D11RenderTargetView> BackBufferRenderTargetView;
 	D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
-	RTVDesc.Format = (DXGI_FORMAT)FD3D11Viewport::GetBackBufferFormat();
+	RTVDesc.Format = DXGI_FORMAT_UNKNOWN;
 	RTVDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
 	RTVDesc.Texture2D.MipSlice = 0;
 	VERIFYD3D11RESULT(D3DRHI->GetDevice()->CreateRenderTargetView(BackBufferResource,&RTVDesc,BackBufferRenderTargetView.GetInitReference()));
@@ -110,7 +110,7 @@
 	// create a shader resource view to allow using the backbuffer as a texture
 	TRefCountPtr<ID3D11ShaderResourceView> BackBufferShaderResourceView;
 	D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
-	SRVDesc.Format = (DXGI_FORMAT)FD3D11Viewport::GetBackBufferFormat();
+	SRVDesc.Format = DXGI_FORMAT_UNKNOWN;
 	SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
 	SRVDesc.Texture2D.MostDetailedMip = 0;
 	SRVDesc.Texture2D.MipLevels = 1;
--- ../../../../UE4-QA/Engine/Source/Runtime/Windows/D3D11RHI/Public/D3D11Viewport.h	2014-07-06 06:17:25.000000000 -0700
+++ ./Engine/Source/Runtime/Windows/D3D11RHI/Public/D3D11Viewport.h	2014-07-19 19:17:01.000000000 -0700
@@ -79,6 +79,8 @@
 	{
 		CustomPresent = InCustomPresent;
 	}
+	virtual void* GetNativeWindow(void** AddParam = nullptr) const override { return (void*)&WindowHandle; }
+
 private:
 
 	/** Presents the frame synchronizing with DWM. */
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR.build.cs	2014-07-05 08:57:15.000000000 -0700
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR.build.cs	2014-07-29 15:30:37.426897500 -0700
@@ -7,15 +7,18 @@
 	public LibOVR(TargetInfo Target)
 	{
 		/** Mark the current version of the Oculus SDK */
-		string LibOVRVersion = "";
+		string LibOVRVersion = "_04";
 		Type = ModuleType.External;
 
+		string OculusThirdPartyDirectory = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion;
+
 		if ((Target.Platform == UnrealTargetPlatform.Win64) ||
 			(Target.Platform == UnrealTargetPlatform.Win32))
 		{
-            PublicIncludePaths.Add(UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Include");
 
-            string LibraryPath = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Lib/";
+            PublicIncludePaths.Add(OculusThirdPartyDirectory + "/Include");
+
+            string LibraryPath = OculusThirdPartyDirectory + "/Lib/";
 			string LibraryName = "libovr";
 			if (Target.Platform == UnrealTargetPlatform.Win64)
 			{
@@ -26,17 +29,22 @@
             {
                 LibraryPath += "Win32/";
             }
+
+			//LibraryName += "_sp";
+
 			LibraryPath += "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName() + "/";
 			PublicLibraryPaths.Add(LibraryPath);
 			PublicAdditionalLibraries.Add(LibraryName + ".lib");
+
+			PublicAdditionalLibraries.Add("Wtsapi32.lib");
             //PublicAdditionalLibraries.Add(LibraryName + "d.lib");
 			//PublicDelayLoadDLLs.Add(LibraryName + ".dll");
 		}
 		else if ((Target.Platform == UnrealTargetPlatform.Mac))
 		{
-            PublicIncludePaths.Add(UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Include");
+            PublicIncludePaths.Add(OculusThirdPartyDirectory + "/Include");
 
-            string LibraryPath = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Lib/MacOS/Release/";
+            string LibraryPath = OculusThirdPartyDirectory + "/Lib/MacOS/Release/";
 			string LibraryName = "libovr";
 			PublicLibraryPaths.Add(LibraryPath);
 			PublicAdditionalLibraries.Add(LibraryPath + LibraryName + ".a");
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR.h	2014-08-11 16:10:28.000000000 -0700
@@ -0,0 +1,36 @@
+/************************************************************************************
+
+Filename    :   OVR.h
+Content     :   The main public interface to Oculus for C++ Developers.
+                Includes C API and helper classes.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_h
+#define OVR_h
+
+#include "OVR_Version.h"
+
+#include "../Src/Kernel/OVR_Math.h"
+
+#include "../Src/OVR_CAPI.h"
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Kernel.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Kernel.h	2014-08-11 16:10:28.000000000 -0700
@@ -0,0 +1,42 @@
+/************************************************************************************
+
+Filename    :   OVRKernel.h
+Content     :   This contains references to all OVR Kernel headers in Src folder.
+                Should be generated automatically based on PublicHeader tags.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_h
+#define OVR_h
+
+#include "../Src/Kernel/OVR_Types.h"
+#include "../Src/Kernel/OVR_Allocator.h"
+#include "../Src/Kernel/OVR_RefCount.h"
+#include "../Src/Kernel/OVR_Log.h"
+#include "../Src/Kernel/OVR_Math.h"
+#include "../Src/Kernel/OVR_System.h"
+#include "../Src/Kernel/OVR_Nullptr.h"
+#include "../Src/Kernel/OVR_String.h"
+#include "../Src/Kernel/OVR_Array.h"
+#include "../Src/Kernel/OVR_Timer.h"
+#include "../Src/Kernel/OVR_SysFile.h"
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Version.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Version.h	2014-08-11 16:10:28.000000000 -0700
@@ -0,0 +1,33 @@
+/************************************************************************************
+
+Filename    :   OVRVersion.h
+Content     :   
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef _OVR_VERSION_H
+#define _OVR_VERSION_H
+
+#define OVR_MAJOR_VERSION 0
+#define OVR_MINOR_VERSION 4
+#define OVR_BUILD_VERSION 1
+#define OVR_VERSION_STRING "0.4.1"
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Projects/Win32/VS2013/LibOVR.vcxproj	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Projects/Win32/VS2013/LibOVR.vcxproj	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,479 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_FrameTimeManager.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HMDRenderState.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HMDState.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HSWDisplay.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_HSWDisplay.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_HSWDisplay.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_Util.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_HSWDisplay.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_DistortionRenderer.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_HSWDisplay.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_Util.h" />
+    <ClInclude Include="..\..\..\Src\CAPI\Textures\healthAndSafety.tga.h" />
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Display.h" />
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_Display.h" />
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_Dxgi_Display.h" />
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_FocusReader.h" />
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_ShimFunctions.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Alg.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Allocator.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Array.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Atomic.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Color.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Compiler.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_ContainerAllocator.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_CRC32.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Delegates.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Deque.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_File.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Hash.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_KeyCodes.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_List.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Lockless.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Log.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Math.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Nullptr.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_RefCount.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_SharedMemory.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Std.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_String.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_StringHash.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_SysFile.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_System.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_ThreadCommandQueue.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Threads.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Timer.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Types.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_UTF8Util.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_BitStream.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_NetworkPlugin.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_NetworkTypes.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_PacketizedTCPSocket.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_RPC1.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_Session.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_Socket.h" />
+    <ClInclude Include="..\..\..\Src\Net\OVR_Win32_Socket.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI_D3D.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI_GL.h" />
+    <ClInclude Include="..\..\..\Src\OVR_JSON.h" />
+    <ClInclude Include="..\..\..\Src\OVR_Profile.h" />
+    <ClInclude Include="..\..\..\Src\OVR_SerialFormat.h" />
+    <ClInclude Include="..\..\..\Src\OVR_Stereo.h" />
+    <ClInclude Include="..\..\..\Src\Sensors\OVR_DeviceConstants.h" />
+    <ClInclude Include="..\..\..\Src\Service\Service_NetClient.h" />
+    <ClInclude Include="..\..\..\Src\Service\Service_NetSessionCommon.h" />
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_PoseState.h" />
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_SensorState.h" />
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_SensorStateReader.h" />
+    <ClInclude Include="..\..\..\Src\Util\Util_ImageWindow.h" />
+    <ClInclude Include="..\..\..\Src\Util\Util_Interface.h" />
+    <ClInclude Include="..\..\..\Src\Util\Util_LatencyTest2Reader.h" />
+    <ClInclude Include="..\..\..\Src\Util\Util_LatencyTest2State.h" />
+    <ClInclude Include="..\..\..\Src\Util\Util_Render_Stereo.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_DistortionRenderer.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_FrameTimeManager.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HMDRenderState.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HMDState.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HSWDisplay.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_DistortionRenderer.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_HSWDisplay.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_DistortionRenderer.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_HSWDisplay.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_DistortionRenderer.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_Util.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_DistortionRenderer.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_HSWDisplay.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_Util.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_DistortionRenderer.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_HSWDisplay.cpp" />
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_Util.cpp" />
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_Display.cpp" />
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_FocusReader.cpp" />
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_RenderShim.cpp" />
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_ShimFunctions.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Alg.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Allocator.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Atomic.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_CRC32.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_File.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_FileFILE.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Lockless.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Log.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Math.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_RefCount.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_SharedMemory.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Std.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String_FormatUtil.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String_PathUtil.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_SysFile.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_System.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_ThreadCommandQueue.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_ThreadsWinAPI.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Timer.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_UTF8Util.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_BitStream.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_NetworkPlugin.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_PacketizedTCPSocket.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_RPC1.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_Session.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_Socket.cpp" />
+    <ClCompile Include="..\..\..\Src\Net\OVR_Win32_Socket.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_CAPI.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_JSON.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_Profile.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_SerialFormat.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_Stereo.cpp" />
+    <ClCompile Include="..\..\..\Src\Service\Service_NetClient.cpp" />
+    <ClCompile Include="..\..\..\Src\Service\Service_NetSessionCommon.cpp" />
+    <ClCompile Include="..\..\..\Src\Tracking\Tracking_SensorStateReader.cpp" />
+    <ClCompile Include="..\..\..\Src\Util\Util_ImageWindow.cpp" />
+    <ClCompile Include="..\..\..\Src\Util\Util_Interface.cpp" />
+    <ClCompile Include="..\..\..\Src\Util\Util_LatencyTest2Reader.cpp" />
+    <ClCompile Include="..\..\..\Src\Util\Util_Render_Stereo.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionChroma_ps.psh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionChroma_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionTimewarpChroma_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionTimewarp_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\Distortion_ps.psh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\Distortion_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+    </CustomBuild>
+  </ItemGroup>
+  <ItemGroup>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleQuad_ps.psh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleQuad_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+  </ItemGroup>
+  <ItemGroup>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleTexturedQuad_ps.psh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genPixelShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleTexturedQuad_vs.vsh">
+      <FileType>Document</FileType>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">call %(RelativeDir)genVertexShaderHeader.bat %(Filename) "%(Fullpath)"</Command>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(RelativeDir)%(Filename).h</Outputs>
+      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(RelativeDir)%(Filename).h</Outputs>
+    </CustomBuild>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EA50E705-5113-49E5-B105-2512EDC8DDC6}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>LibOVR</RootNamespace>
+    <ProjectName>LibOVR</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>../../../Lib/$(Platform)/VS2013/</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>../../../Lib/$(Platform)/VS2013/</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <IntDir>../../../Obj/$(Platform)/VS2013/$(Configuration)/</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <IntDir>../../../Obj/$(Platform)/VS2013/$(Configuration)/</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <TargetName>libovrd</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <TargetName>libovr64d</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>../../../Lib/$(Platform)/VS2013/</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>../../../Lib/$(Platform)/VS2013/</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <IntDir>../../../Obj/$(Platform)/VS2013/$(Configuration)/</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <IntDir>../../../Obj/$(Platform)/VS2013/$(Configuration)/</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <TargetName>libovr</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <TargetName>libovr64</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>OVR_BUILD_DEBUG;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <OmitDefaultLibName>true</OmitDefaultLibName>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <AdditionalIncludeDirectories>../../../../3rdParty/glext/;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <ShowIncludes>false</ShowIncludes>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalDependencies>Setupapi.lib</AdditionalDependencies>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>OVR_BUILD_DEBUG;_WIN64;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <OmitDefaultLibName>true</OmitDefaultLibName>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <AdditionalIncludeDirectories>../../../../3rdParty/glext/;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <OmitFramePointers>false</OmitFramePointers>
+      <ShowIncludes>false</ShowIncludes>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalDependencies>Setupapi.lib</AdditionalDependencies>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitDefaultLibName>true</OmitDefaultLibName>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalIncludeDirectories>../../../../3rdParty/glext/;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <AdditionalOptions>/d2Zi+ %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalDependencies>Setupapi.lib</AdditionalDependencies>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN64;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitDefaultLibName>true</OmitDefaultLibName>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalIncludeDirectories>../../../../3rdParty/glext/;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <AdditionalOptions>/d2Zi+ %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalDependencies>Setupapi.lib</AdditionalDependencies>
+    </Lib>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Projects/Win32/VS2013/LibOVR.vcxproj.filters	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Projects/Win32/VS2013/LibOVR.vcxproj.filters	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,470 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_DistortionRenderer.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_Util.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_DistortionRenderer.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_Util.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_DistortionRenderer.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_DistortionRenderer.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_DistortionRenderer.cpp">
+      <Filter>CAPI</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_FrameTimeManager.cpp">
+      <Filter>CAPI</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HMDRenderState.cpp">
+      <Filter>CAPI</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HMDState.cpp">
+      <Filter>CAPI</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Util\Util_Render_Stereo.cpp">
+      <Filter>Util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Util\Util_ImageWindow.cpp">
+      <Filter>Util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Util\Util_Interface.cpp">
+      <Filter>Util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_DistortionRenderer.cpp">
+      <Filter>CAPI\GL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_Util.cpp">
+      <Filter>CAPI\GL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\OVR_Profile.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_SerialFormat.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_Stereo.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_CAPI.cpp" />
+    <ClCompile Include="..\..\..\Src\OVR_JSON.cpp" />
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Alg.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Allocator.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Atomic.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_CRC32.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_File.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_FileFILE.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Lockless.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Log.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Math.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_RefCount.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_SharedMemory.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Std.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String_FormatUtil.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_String_PathUtil.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_SysFile.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_System.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_ThreadsWinAPI.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_Timer.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_UTF8Util.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_NetworkPlugin.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_PacketizedTCPSocket.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_RPC1.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_Session.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_Socket.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_Win32_Socket.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Net\OVR_BitStream.cpp">
+      <Filter>Net</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_RenderShim.cpp">
+      <Filter>Displays</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_ShimFunctions.cpp">
+      <Filter>Displays</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Service\Service_NetSessionCommon.cpp">
+      <Filter>Service</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Service\Service_NetClient.cpp">
+      <Filter>Service</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Tracking\Tracking_SensorStateReader.cpp">
+      <Filter>Tracking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_Display.cpp">
+      <Filter>Displays</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Util\Util_LatencyTest2Reader.cpp">
+      <Filter>Util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Displays\OVR_Win32_FocusReader.cpp">
+      <Filter>Displays</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\Kernel\OVR_ThreadCommandQueue.cpp">
+      <Filter>Kernel</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\CAPI_HSWDisplay.cpp">
+      <Filter>CAPI</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_HSWDisplay.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_HSWDisplay.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_HSWDisplay.cpp">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\Src\CAPI\GL\CAPI_GL_HSWDisplay.cpp">
+      <Filter>CAPI\GL</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_DistortionRenderer.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D1X_Util.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_DistortionRenderer.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_DistortionRenderer.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_DistortionRenderer.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_DistortionRenderer.h">
+      <Filter>CAPI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_FrameTimeManager.h">
+      <Filter>CAPI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HMDRenderState.h">
+      <Filter>CAPI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HMDState.h">
+      <Filter>CAPI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Util\Util_Interface.h">
+      <Filter>Util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Util\Util_Render_Stereo.h">
+      <Filter>Util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Util\Util_ImageWindow.h">
+      <Filter>Util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_DistortionRenderer.h">
+      <Filter>CAPI\GL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_Util.h">
+      <Filter>CAPI\GL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\OVR_JSON.h" />
+    <ClInclude Include="..\..\..\Src\OVR_Profile.h" />
+    <ClInclude Include="..\..\..\Src\OVR_SerialFormat.h" />
+    <ClInclude Include="..\..\..\Src\OVR_Stereo.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI_D3D.h" />
+    <ClInclude Include="..\..\..\Src\OVR_CAPI_GL.h" />
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Alg.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Allocator.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Array.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Atomic.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Color.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Compiler.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_ContainerAllocator.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_CRC32.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Delegates.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Deque.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_File.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Hash.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_KeyCodes.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_List.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Lockless.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Log.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Math.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Nullptr.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_RefCount.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_SharedMemory.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Std.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_String.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_StringHash.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_SysFile.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_System.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Threads.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Timer.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_Types.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_UTF8Util.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_NetworkPlugin.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_NetworkTypes.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_PacketizedTCPSocket.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_RPC1.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_Session.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_Socket.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_Win32_Socket.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Net\OVR_BitStream.h">
+      <Filter>Net</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_ShimFunctions.h">
+      <Filter>Displays</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Service\Service_NetClient.h">
+      <Filter>Service</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Service\Service_NetSessionCommon.h">
+      <Filter>Service</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_SensorStateReader.h">
+      <Filter>Tracking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_Dxgi_Display.h">
+      <Filter>Displays</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_Display.h">
+      <Filter>Displays</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Util\Util_LatencyTest2Reader.h">
+      <Filter>Util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Win32_FocusReader.h">
+      <Filter>Displays</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_SensorState.h">
+      <Filter>Tracking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Tracking\Tracking_PoseState.h">
+      <Filter>Tracking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Util\Util_LatencyTest2State.h">
+      <Filter>Util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Sensors\OVR_DeviceConstants.h">
+      <Filter>Sensors</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Kernel\OVR_ThreadCommandQueue.h">
+      <Filter>Kernel</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\Displays\OVR_Display.h">
+      <Filter>Displays</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\CAPI_HSWDisplay.h">
+      <Filter>CAPI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\Textures\healthAndSafety.tga.h">
+      <Filter>CAPI\Textures</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D9_HSWDisplay.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D10_HSWDisplay.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\D3D1X\CAPI_D3D11_HSWDisplay.h">
+      <Filter>CAPI\D3D1X</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\Src\CAPI\GL\CAPI_GL_HSWDisplay.h">
+      <Filter>CAPI\GL</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionTimewarpChroma_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionTimewarp_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionChroma_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\DistortionChroma_ps.psh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\Distortion_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\Distortion_ps.psh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleQuad_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleQuad_ps.psh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleTexturedQuad_ps.psh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+    <CustomBuild Include="..\..\..\Src\CAPI\Shaders\SimpleTexturedQuad_vs.vsh">
+      <Filter>CAPI\Shaders</Filter>
+    </CustomBuild>
+  </ItemGroup>
+  <ItemGroup>
+    <Filter Include="CAPI">
+      <UniqueIdentifier>{42ff86e1-b618-4432-99ce-e6b92c7460eb}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="CAPI\Shaders">
+      <UniqueIdentifier>{a65a3889-6d00-4a76-acfe-6db1249f104d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="CAPI\D3D1X">
+      <UniqueIdentifier>{77e1d16e-00a1-4130-8ee6-f81d1e850859}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Kernel">
+      <UniqueIdentifier>{b5206073-e32d-413b-804b-6c4f6984365c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Util">
+      <UniqueIdentifier>{470c25c2-99a2-439b-9f6b-761e8c70f84e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="CAPI\GL">
+      <UniqueIdentifier>{47ac92b1-d962-4180-90a5-846feef19a6b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Net">
+      <UniqueIdentifier>{908d5c2d-305b-4a8a-9b25-b551a42677d1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Displays">
+      <UniqueIdentifier>{166e9ffc-558b-46ca-be9f-de9ac0ed89e9}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Service">
+      <UniqueIdentifier>{5ef4cc4f-f0f2-4653-96fa-aafafd95f77e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Tracking">
+      <UniqueIdentifier>{16de1b27-4167-429c-a964-44e476ec9c95}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Sensors">
+      <UniqueIdentifier>{9b464232-8a47-404b-8120-b6e8dc016c36}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="CAPI\Textures">
+      <UniqueIdentifier>{4133d45b-be4b-4813-afea-9ad61ce3fe11}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+</Project>
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,150 @@
+/************************************************************************************
+
+Filename    :   CAPI_DistortionRenderer.cpp
+Content     :   Combines all of the rendering state associated with the HMD
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_DistortionRenderer.h"
+
+#if defined (OVR_OS_WIN32)
+
+// TBD: Move to separate config file that handles back-ends.
+#define OVR_D3D_VERSION 11
+#include "D3D1X/CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#define OVR_D3D_VERSION 10
+#include "D3D1X/CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#define OVR_D3D_VERSION 9
+#include "D3D1X/CAPI_D3D9_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#endif
+
+#include "GL/CAPI_GL_DistortionRenderer.h"
+
+namespace OVR { namespace CAPI {
+
+//-------------------------------------------------------------------------------------
+// ***** DistortionRenderer
+
+// TBD: Move to separate config file that handles back-ends.
+
+DistortionRenderer::CreateFunc DistortionRenderer::APICreateRegistry[ovrRenderAPI_Count] =
+{
+    0, // None
+    &GL::DistortionRenderer::Create,
+    0, // Android_GLES
+#if defined (OVR_OS_WIN32)
+    &D3D9::DistortionRenderer::Create,
+    &D3D10::DistortionRenderer::Create,
+    &D3D11::DistortionRenderer::Create
+#else
+    0,
+    0,
+    0
+#endif
+};
+
+void DistortionRenderer::SetLatencyTestColor(unsigned char* color)
+{
+    if(color)
+    {
+        LatencyTestDrawColor[0] = color[0];
+        LatencyTestDrawColor[1] = color[1];
+        LatencyTestDrawColor[2] = color[2];
+    }
+
+    LatencyTestActive = color != NULL;
+}
+
+void DistortionRenderer::SetLatencyTest2Color(unsigned char* color)
+{
+    if(color)
+    {
+        LatencyTest2DrawColor[0] = color[0];
+        LatencyTest2DrawColor[1] = color[1];
+        LatencyTest2DrawColor[2] = color[2];
+    }
+
+    LatencyTest2Active = color != NULL;
+}
+
+double DistortionRenderer::WaitTillTime(double absTime)
+{
+    double initialTime = ovr_GetTimeInSeconds();
+    if (initialTime >= absTime)
+        return 0.0;
+
+    double newTime = initialTime;
+    volatile int i;
+
+    while (newTime < absTime)
+    {
+// TODO: Needs further testing before enabling it on all Windows configs
+#if 0 //def OVR_OS_WIN32
+        double remainingWaitTime = absTime - newTime;
+
+        // don't yield if <2ms
+        if(remainingWaitTime > 0.002)
+        {
+            // round down wait time to closest 1 ms
+            int roundedWaitTime = (remainingWaitTime * 1000);
+
+            waitableTimerInterval.QuadPart = -10000LL; // 10000 * 100 ns = 1 ms
+            waitableTimerInterval.QuadPart *= roundedWaitTime;
+
+            SetWaitableTimer(timer, &waitableTimerInterval, 0, NULL, NULL, TRUE);
+            DWORD waitResult = WaitForSingleObject(timer, roundedWaitTime + 3);   // give 3 ms extra time
+
+            double sleptTime = ovr_GetTimeInSeconds() - newTime;
+            // Make sure this is reliable (should be waiting for 1ms, make sure it's <2ms)
+            if (sleptTime > remainingWaitTime)
+            {
+                OVR_DEBUG_LOG_TEXT(
+                    ("[DistortionRenderer::FlushGpuAndWaitTillTime] Sleep interval too long: %f\n", sleptTime));
+            }
+            else
+            {
+                OVR_ASSERT(WAIT_OBJECT_0 == waitResult);
+                OVR_UNUSED(waitResult);
+            }
+        }
+        else
+#endif
+        {
+            for (int j = 0; j < 50; j++)
+                i = 0;
+        }			
+
+        newTime = ovr_GetTimeInSeconds();
+    }
+
+    // How long we waited
+    return newTime - initialTime;
+}
+
+}} // namespace OVR::CAPI
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,163 @@
+/************************************************************************************
+
+Filename    :   CAPI_DistortionRenderer.h
+Content     :   Abstract interface for platform-specific rendering of distortion
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_DistortionRenderer_h
+#define OVR_CAPI_DistortionRenderer_h
+
+#include "CAPI_HMDRenderState.h"
+#include "CAPI_FrameTimeManager.h"
+
+typedef void (*PostDistortionCallback)(void* pRenderContext);
+
+namespace OVR { namespace CAPI {
+
+//-------------------------------------------------------------------------------------
+// ***** CAPI::DistortionRenderer
+
+// DistortionRenderer implements rendering of distortion and other overlay elements
+// in platform-independent way.
+// Platform-specific renderer back ends for CAPI are derived from this class.
+
+class  DistortionRenderer : public RefCountBase<DistortionRenderer>
+{
+    // Quiet assignment compiler warning.
+    void operator = (const DistortionRenderer&) { }
+public:
+    
+    DistortionRenderer(ovrRenderAPIType api, ovrHmd hmd,
+                       FrameTimeManager& timeManager,              
+                       const HMDRenderState& renderState) :
+        RenderAPI(api),
+        HMD(hmd),
+        TimeManager(timeManager),
+        RState(renderState),
+        RegisteredPostDistortionCallback(NULL),
+		LastUsedOverdriveTextureIndex(-1),
+        LatencyTestActive(false),
+        LatencyTest2Active(false)
+    {
+#ifdef OVR_OS_WIN32
+        timer = CreateWaitableTimer(NULL, TRUE, NULL);
+        OVR_ASSERT(timer != NULL);
+#endif
+    }
+    virtual ~DistortionRenderer()
+    {
+    }
+    
+
+    // Configures the Renderer based on externally passed API settings. Must be
+    // called before use.
+    // Under D3D, apiConfig includes D3D Device pointer, back buffer and other
+    // needed structures.
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps) = 0;
+
+    // Submits one eye texture for rendering. This is in the separate method to
+    // allow "submit as you render" scenarios on horizontal screens where one
+    // eye can be scanned out before the other.
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture) = 0;
+
+    // Finish the frame, optionally swapping buffers.
+    // Many implementations may actually apply the distortion here.
+    virtual void EndFrame(bool swapBuffers) = 0;
+    
+    void RegisterPostDistortionCallback(PostDistortionCallback postDistortionCallback)
+    {
+        RegisteredPostDistortionCallback = postDistortionCallback;
+    }
+
+	// Stores the current graphics pipeline state so it can be restored later.
+	void SaveGraphicsState() { if (!(RState.DistortionCaps & ovrDistortionCap_NoRestore)) GfxState->Save(); }
+
+	// Restores the saved graphics pipeline state.
+	void RestoreGraphicsState() { if (!(RState.DistortionCaps & ovrDistortionCap_NoRestore)) GfxState->Restore(); }
+
+    // *** Creation Factory logic
+    
+    ovrRenderAPIType GetRenderAPI() const { return RenderAPI; }
+
+    // Creation function for this interface, registered for API.
+    typedef DistortionRenderer* (*CreateFunc)(ovrHmd hmd,
+                                              FrameTimeManager &timeManager,
+                                              const HMDRenderState& renderState);
+
+    static CreateFunc APICreateRegistry[ovrRenderAPI_Count];
+
+    // Color is expected to be 3 byte RGB
+    void SetLatencyTestColor(unsigned char* color);
+    void SetLatencyTest2Color(unsigned char* color);
+    
+protected:
+	// Used for pixel luminance overdrive on DK2 displays
+	// A copy of back buffer images will be ping ponged
+	// TODO: figure out 0 dynamically based on DK2 latency?
+	static const int	NumOverdriveTextures = 2;
+	int					LastUsedOverdriveTextureIndex;
+
+    bool                LatencyTestActive;
+    unsigned char       LatencyTestDrawColor[3];
+    bool                LatencyTest2Active;
+    unsigned char       LatencyTest2DrawColor[3];
+
+    bool IsOverdriveActive()
+	{
+		// doesn't make sense to use overdrive when vsync is disabled as we cannot guarantee
+		// when the rendered frame will be displayed
+		return LastUsedOverdriveTextureIndex >= 0 && !((RState.EnabledHmdCaps & ovrHmdCap_NoVSync) > 0);
+	}
+
+    double WaitTillTime(double absTime);
+
+#ifdef OVR_OS_WIN32
+    HANDLE timer;
+    LARGE_INTEGER waitableTimerInterval;
+#endif
+
+    class GraphicsState : public RefCountBase<GraphicsState>
+    {
+    public:
+        GraphicsState() : IsValid(false) {}
+        virtual ~GraphicsState() {}
+        virtual void Save() = 0;
+        virtual void Restore() = 0;
+        
+    protected:
+        bool IsValid;
+    };
+    
+    const ovrRenderAPIType  RenderAPI;
+    const ovrHmd            HMD;
+    FrameTimeManager&       TimeManager;
+    const HMDRenderState&   RState;
+    Ptr<GraphicsState>      GfxState;
+    PostDistortionCallback  RegisteredPostDistortionCallback;
+};
+
+}} // namespace OVR::CAPI
+
+
+#endif // OVR_CAPI_DistortionRenderer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,855 @@
+/************************************************************************************
+
+Filename    :   CAPI_FrameTimeManager.cpp
+Content     :   Manage frame timing and pose prediction for rendering
+Created     :   November 30, 2013
+Authors     :   Volga Aksoy, Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_FrameTimeManager.h"
+
+#include "../Kernel/OVR_Log.h"
+
+namespace OVR { namespace CAPI {
+
+
+//-------------------------------------------------------------------------------------
+// ***** FrameLatencyTracker
+    
+
+FrameLatencyTracker::FrameLatencyTracker()
+{
+   Reset();
+}
+
+void FrameLatencyTracker::Reset()
+{
+    TrackerEnabled         = true;
+    WaitMode               = SampleWait_Zeroes;
+    FrameIndex             = 0;    
+    MatchCount             = 0;
+    RenderLatencySeconds   = 0.0;
+    TimewarpLatencySeconds = 0.0;
+    LatencyRecordTime      = 0.0;
+    
+    FrameDeltas.Clear();
+}
+
+
+unsigned char FrameLatencyTracker::GetNextDrawColor()
+{   
+    if (!TrackerEnabled || (WaitMode == SampleWait_Zeroes) ||
+        (FrameIndex >= FramesTracked))
+    {        
+        return (unsigned char)Util::FrameTimeRecord::ReadbackIndexToColor(0);
+    }
+
+    OVR_ASSERT(FrameIndex < FramesTracked);    
+    return (unsigned char)Util::FrameTimeRecord::ReadbackIndexToColor(FrameIndex+1);
+}
+
+
+void FrameLatencyTracker::SaveDrawColor(unsigned char drawColor, double endFrameTime,
+                                        double renderIMUTime, double timewarpIMUTime )
+{
+    if (!TrackerEnabled || (WaitMode == SampleWait_Zeroes))
+        return;
+
+    if (FrameIndex < FramesTracked)
+    {
+        OVR_ASSERT(Util::FrameTimeRecord::ReadbackIndexToColor(FrameIndex+1) == drawColor);
+        OVR_UNUSED(drawColor);
+
+        // saves {color, endFrame time}
+        FrameEndTimes[FrameIndex].ReadbackIndex         = FrameIndex + 1;
+        FrameEndTimes[FrameIndex].TimeSeconds           = endFrameTime;
+        FrameEndTimes[FrameIndex].RenderIMUTimeSeconds  = renderIMUTime;
+        FrameEndTimes[FrameIndex].TimewarpIMUTimeSeconds= timewarpIMUTime;
+        FrameEndTimes[FrameIndex].MatchedRecord         = false;
+        FrameIndex++;
+    }
+    else
+    {
+        // If the request was outstanding for too long, switch to zero mode to restart.
+        if (endFrameTime > (FrameEndTimes[FrameIndex-1].TimeSeconds + 0.15))
+        {
+            if (MatchCount == 0)
+            {
+                // If nothing was matched, we have no latency reading.
+                RenderLatencySeconds   = 0.0;
+                TimewarpLatencySeconds = 0.0;
+            }
+
+            WaitMode   =  SampleWait_Zeroes;
+            MatchCount = 0;
+            FrameIndex = 0;
+        }
+    }
+}
+
+
+void FrameLatencyTracker::MatchRecord(const Util::FrameTimeRecordSet &r)
+{
+    if (!TrackerEnabled)
+        return;
+
+    if (WaitMode == SampleWait_Zeroes)
+    {
+        // Do we have all zeros?
+        if (r.IsAllZeroes())
+        {
+            OVR_ASSERT(FrameIndex == 0);
+            WaitMode = SampleWait_Match;
+            MatchCount = 0;
+        }
+        return;
+    }
+
+    // We are in Match Mode. Wait until all colors are matched or timeout,
+    // at which point we go back to zeros.
+
+    for (int i = 0; i < FrameIndex; i++)
+    {
+        int recordIndex = 0;
+        int consecutiveMatch  = 0;
+
+        OVR_ASSERT(FrameEndTimes[i].ReadbackIndex != 0);
+
+        if (r.FindReadbackIndex(&recordIndex, FrameEndTimes[i].ReadbackIndex))
+        {
+            // Advance forward to see that we have several more matches.
+            int  ri = recordIndex + 1;
+            int  j  = i + 1;
+
+            consecutiveMatch++;
+
+            for (; (j < FrameIndex) && (ri < Util::FrameTimeRecordSet::RecordCount); j++, ri++)
+            {
+                if (r[ri].ReadbackIndex != FrameEndTimes[j].ReadbackIndex)
+                    break;
+                consecutiveMatch++;
+            }
+
+            // Match at least 2 items in the row, to avoid accidentally matching color.
+            if (consecutiveMatch > 1)
+            {
+                // Record latency values for all but last samples. Keep last 2 samples
+                // for the future to simplify matching.
+                for (int q = 0; q < consecutiveMatch; q++)
+                {
+                    const Util::FrameTimeRecord &scanoutFrame = r[recordIndex+q];
+                    FrameTimeRecordEx           &renderFrame  = FrameEndTimes[i+q];
+                    
+                    if (!renderFrame.MatchedRecord)
+                    {
+                        double deltaSeconds = scanoutFrame.TimeSeconds - renderFrame.TimeSeconds;
+                        if (deltaSeconds > 0.0)
+                        {
+                            FrameDeltas.AddTimeDelta(deltaSeconds);
+
+                            // FIRMWARE HACK: don't take new readings if they're 10ms higher than previous reading
+                            // but only do that for 1 second, after that accept it regardless of the timing difference
+                            double newRenderLatency = scanoutFrame.TimeSeconds - renderFrame.RenderIMUTimeSeconds;                            
+                            if( newRenderLatency < RenderLatencySeconds + 0.01 ||
+                                scanoutFrame.TimeSeconds > LatencyRecordTime + 1.0)
+                            {
+                                LatencyRecordTime      = scanoutFrame.TimeSeconds;
+                                RenderLatencySeconds   = scanoutFrame.TimeSeconds - renderFrame.RenderIMUTimeSeconds;
+                                TimewarpLatencySeconds = (renderFrame.TimewarpIMUTimeSeconds == 0.0)  ?  0.0 :
+                                                         (scanoutFrame.TimeSeconds - renderFrame.TimewarpIMUTimeSeconds);
+                            }
+                        }
+
+                        renderFrame.MatchedRecord = true;
+                        MatchCount++;
+                    }
+                }
+
+                // Exit for.
+                break;
+            }
+        }
+    } // for ( i => FrameIndex )
+
+
+    // If we matched all frames, start over.
+    if (MatchCount == FramesTracked)
+    {
+        WaitMode   =  SampleWait_Zeroes;
+        MatchCount = 0;
+        FrameIndex = 0;
+    }
+}
+
+bool FrameLatencyTracker::IsLatencyTimingAvailable()
+{
+    return ovr_GetTimeInSeconds() < (LatencyRecordTime + 2.0);
+}
+
+void FrameLatencyTracker::GetLatencyTimings(float latencies[3])
+{
+    if (!IsLatencyTimingAvailable())
+    {
+        latencies[0] = 0.0f;
+        latencies[1] = 0.0f;
+        latencies[2] = 0.0f;
+    }
+    else
+    {
+        latencies[0] = (float)RenderLatencySeconds;
+        latencies[1] = (float)TimewarpLatencySeconds;
+        latencies[2] = (float)FrameDeltas.GetMedianTimeDelta();
+    }    
+}
+    
+    
+//-------------------------------------------------------------------------------------
+
+FrameTimeManager::FrameTimeManager(bool vsyncEnabled)
+    : VsyncEnabled(vsyncEnabled), DynamicPrediction(true), SdkRender(false),
+      FrameTiming()
+{    
+    RenderIMUTimeSeconds = 0.0;
+    TimewarpIMUTimeSeconds = 0.0;
+    
+    // HACK: SyncToScanoutDelay observed close to 1 frame in video cards.
+    //       Overwritten by dynamic latency measurement on DK2.
+    VSyncToScanoutDelay   = 0.013f;
+    NoVSyncToScanoutDelay = 0.004f;
+}
+
+void FrameTimeManager::Init(HmdRenderInfo& renderInfo)
+{
+    // Set up prediction distances.
+    // With-Vsync timings.
+    RenderInfo = renderInfo;
+
+    ScreenSwitchingDelay = RenderInfo.Shutter.PixelSettleTime * 0.5f + 
+                           RenderInfo.Shutter.PixelPersistence * 0.5f;
+}
+
+void FrameTimeManager::ResetFrameTiming(unsigned frameIndex,
+                                        bool dynamicPrediction,
+                                        bool sdkRender)
+{    
+    DynamicPrediction   = dynamicPrediction;
+    SdkRender           = sdkRender;
+
+    FrameTimeDeltas.Clear();
+    DistortionRenderTimes.Clear();
+    ScreenLatencyTracker.Reset();
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    //TimewarpAdjuster.Reset();
+
+    FrameTiming.FrameIndex               = frameIndex;
+    FrameTiming.NextFrameTime            = 0.0;
+    FrameTiming.ThisFrameTime            = 0.0;
+    FrameTiming.Inputs.FrameDelta        = calcFrameDelta();
+    // This one is particularly critical, and has been missed in the past because
+    // this init function wasn't called for app-rendered.
+    FrameTiming.Inputs.ScreenDelay       = calcScreenDelay();
+    FrameTiming.Inputs.TimewarpWaitDelta = 0.0f;
+
+    LocklessTiming.SetState(FrameTiming);
+}
+
+
+double  FrameTimeManager::calcFrameDelta() const
+{
+    // Timing difference between frame is tracked by FrameTimeDeltas, or
+    // is a hard-coded value of 1/FrameRate.
+    double  frameDelta;    
+
+    if (!VsyncEnabled)
+    {
+        frameDelta = 0.0;
+    }
+    else if (FrameTimeDeltas.GetCount() > 3)
+    {
+        frameDelta = FrameTimeDeltas.GetMedianTimeDelta();
+        if (frameDelta > (RenderInfo.Shutter.VsyncToNextVsync + 0.001))
+            frameDelta = RenderInfo.Shutter.VsyncToNextVsync;
+    }
+    else
+    {
+        frameDelta = RenderInfo.Shutter.VsyncToNextVsync;
+    }
+
+    return frameDelta;
+}
+
+
+double  FrameTimeManager::calcScreenDelay() const
+{
+    double  screenDelay = ScreenSwitchingDelay;
+    double  measuredVSyncToScanout;
+
+    // Use real-time DK2 latency tester HW for prediction if its is working.
+    // Do sanity check under 60 ms
+    if (!VsyncEnabled)
+    {
+        screenDelay += NoVSyncToScanoutDelay;
+    }
+    else if ( DynamicPrediction &&
+              (ScreenLatencyTracker.FrameDeltas.GetCount() > 3) &&
+              (measuredVSyncToScanout = ScreenLatencyTracker.FrameDeltas.GetMedianTimeDelta(),
+               (measuredVSyncToScanout > 0.0001) && (measuredVSyncToScanout < 0.06)) ) 
+    {
+        screenDelay += measuredVSyncToScanout;
+    }
+    else
+    {
+        screenDelay += VSyncToScanoutDelay;
+    }
+
+    return screenDelay;
+}
+
+
+double  FrameTimeManager::calcTimewarpWaitDelta() const
+{
+    // If timewarp timing hasn't been calculated, we should wait.
+    if (!VsyncEnabled)
+        return 0.0;
+
+    if (SdkRender)
+    {
+        if (NeedDistortionTimeMeasurement())
+            return 0.0;
+        return -(DistortionRenderTimes.GetMedianTimeDelta() + 0.0035);
+
+        //Revisit dynamic pre-Timewarp delay adjustment logic
+        /*return -(DistortionRenderTimes.GetMedianTimeDelta() + 0.002 +
+                 TimewarpAdjuster.GetDelayReduction());*/
+    }
+   
+    // Just a hard-coded "high" value for game-drawn code.
+    // TBD: Just return 0 and let users calculate this themselves?
+    return -0.004;
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    //return -(0.003 + TimewarpAdjuster.GetDelayReduction());
+}
+
+//Revisit dynamic pre-Timewarp delay adjustment logic
+/*
+void FrameTimeManager::updateTimewarpTiming()
+{
+    // If timewarp timing changes based on this sample, update it.
+    double newTimewarpWaitDelta = calcTimewarpWaitDelta();
+    if (newTimewarpWaitDelta != FrameTiming.Inputs.TimewarpWaitDelta)
+    {
+        FrameTiming.Inputs.TimewarpWaitDelta = newTimewarpWaitDelta;
+        LocklessTiming.SetState(FrameTiming);
+    }
+}
+*/
+
+void FrameTimeManager::Timing::InitTimingFromInputs(const FrameTimeManager::TimingInputs& inputs,
+                                                    HmdShutterTypeEnum shutterType,
+                                                    double thisFrameTime, unsigned int frameIndex)
+{    
+    // ThisFrameTime comes from the end of last frame, unless it it changed.  
+    double  nextFrameBase;
+    double  frameDelta = inputs.FrameDelta;
+
+    FrameIndex        = frameIndex;
+
+    ThisFrameTime     = thisFrameTime;
+    NextFrameTime     = ThisFrameTime + frameDelta;
+    nextFrameBase     = NextFrameTime + inputs.ScreenDelay;
+    MidpointTime      = nextFrameBase + frameDelta * 0.5;
+    TimewarpPointTime = (inputs.TimewarpWaitDelta == 0.0) ?
+                        0.0 : (NextFrameTime + inputs.TimewarpWaitDelta);
+
+    // Calculate absolute points in time when eye rendering or corresponding time-warp
+    // screen edges will become visible.
+    // This only matters with VSync.
+    switch(shutterType)
+    {            
+    case HmdShutter_RollingTopToBottom:
+        EyeRenderTimes[0]               = MidpointTime;
+        EyeRenderTimes[1]               = MidpointTime;
+        TimeWarpStartEndTimes[0][0]     = nextFrameBase;
+        TimeWarpStartEndTimes[0][1]     = nextFrameBase + frameDelta;
+        TimeWarpStartEndTimes[1][0]     = nextFrameBase;
+        TimeWarpStartEndTimes[1][1]     = nextFrameBase + frameDelta;
+        break;
+    case HmdShutter_RollingLeftToRight:
+        EyeRenderTimes[0]               = nextFrameBase + frameDelta * 0.25;
+        EyeRenderTimes[1]               = nextFrameBase + frameDelta * 0.75;
+
+        /*
+        // TBD: MA: It is probably better if mesh sets it up per-eye.
+        // Would apply if screen is 0 -> 1 for each eye mesh
+        TimeWarpStartEndTimes[0][0]     = nextFrameBase;
+        TimeWarpStartEndTimes[0][1]     = MidpointTime;
+        TimeWarpStartEndTimes[1][0]     = MidpointTime;
+        TimeWarpStartEndTimes[1][1]     = nextFrameBase + frameDelta;
+        */
+
+        // Mesh is set up to vary from Edge of scree 0 -> 1 across both eyes
+        TimeWarpStartEndTimes[0][0]     = nextFrameBase;
+        TimeWarpStartEndTimes[0][1]     = nextFrameBase + frameDelta;
+        TimeWarpStartEndTimes[1][0]     = nextFrameBase;
+        TimeWarpStartEndTimes[1][1]     = nextFrameBase + frameDelta;
+
+        break;
+    case HmdShutter_RollingRightToLeft:
+
+        EyeRenderTimes[0]               = nextFrameBase + frameDelta * 0.75;
+        EyeRenderTimes[1]               = nextFrameBase + frameDelta * 0.25;
+        
+        // This is *Correct* with Tom's distortion mesh organization.
+        TimeWarpStartEndTimes[0][0]     = nextFrameBase ;
+        TimeWarpStartEndTimes[0][1]     = nextFrameBase + frameDelta;
+        TimeWarpStartEndTimes[1][0]     = nextFrameBase ;
+        TimeWarpStartEndTimes[1][1]     = nextFrameBase + frameDelta;
+        break;
+    case HmdShutter_Global:
+        // TBD
+        EyeRenderTimes[0]               = MidpointTime;
+        EyeRenderTimes[1]               = MidpointTime;
+        TimeWarpStartEndTimes[0][0]     = MidpointTime;
+        TimeWarpStartEndTimes[0][1]     = MidpointTime;
+        TimeWarpStartEndTimes[1][0]     = MidpointTime;
+        TimeWarpStartEndTimes[1][1]     = MidpointTime;
+        break;
+    default:
+        break;
+    }
+}
+
+  
+double FrameTimeManager::BeginFrame(unsigned frameIndex)
+{    
+    RenderIMUTimeSeconds = 0.0;
+    TimewarpIMUTimeSeconds = 0.0;
+
+    // TPH - putting an assert so this doesn't remain a hidden problem.
+    OVR_ASSERT(FrameTiming.Inputs.ScreenDelay != 0);
+
+    // ThisFrameTime comes from the end of last frame, unless it it changed.
+    double thisFrameTime = (FrameTiming.NextFrameTime != 0.0) ?
+                           FrameTiming.NextFrameTime : ovr_GetTimeInSeconds();
+    
+    // We are starting to process a new frame...
+    FrameTiming.InitTimingFromInputs(FrameTiming.Inputs, RenderInfo.Shutter.Type,
+                                     thisFrameTime, frameIndex);
+
+    return FrameTiming.ThisFrameTime;
+}
+
+
+void FrameTimeManager::EndFrame()
+{
+    // Record timing since last frame; must be called after Present & sync.
+    FrameTiming.NextFrameTime = ovr_GetTimeInSeconds();    
+    if (FrameTiming.ThisFrameTime > 0.0)
+    {
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    /*
+        double actualFrameDelta = FrameTiming.NextFrameTime - FrameTiming.ThisFrameTime;
+
+        if (VsyncEnabled)
+            TimewarpAdjuster.UpdateTimewarpWaitIfSkippedFrames(this, actualFrameDelta,
+                                                               FrameTiming.NextFrameTime);
+
+        FrameTimeDeltas.AddTimeDelta(actualFrameDelta);
+    */
+        FrameTimeDeltas.AddTimeDelta(FrameTiming.NextFrameTime - FrameTiming.ThisFrameTime);
+        FrameTiming.Inputs.FrameDelta = calcFrameDelta();
+    }
+
+    // Write to Lock-less
+    LocklessTiming.SetState(FrameTiming);
+}
+
+
+// Thread-safe function to query timing for a future frame
+
+FrameTimeManager::Timing FrameTimeManager::GetFrameTiming(unsigned frameIndex)
+{
+    Timing frameTiming = LocklessTiming.GetState();
+
+    if (frameTiming.ThisFrameTime != 0.0)
+    {
+        // If timing hasn't been initialized, starting based on "now" is the best guess.
+        frameTiming.InitTimingFromInputs(frameTiming.Inputs, RenderInfo.Shutter.Type,
+                                         ovr_GetTimeInSeconds(), frameIndex);
+    }
+    
+    else if (frameIndex > frameTiming.FrameIndex)
+    {
+        unsigned frameDelta    = frameIndex - frameTiming.FrameIndex;
+        double   thisFrameTime = frameTiming.NextFrameTime +
+                                 double(frameDelta-1) * frameTiming.Inputs.FrameDelta;
+        // Don't run away too far into the future beyond rendering.
+        OVR_ASSERT(frameDelta < 6);
+
+        frameTiming.InitTimingFromInputs(frameTiming.Inputs, RenderInfo.Shutter.Type,
+                                         thisFrameTime, frameIndex);
+    }    
+     
+    return frameTiming;
+}
+
+
+double FrameTimeManager::GetEyePredictionTime(ovrEyeType eye)
+{
+    if (VsyncEnabled)
+    {
+        return FrameTiming.EyeRenderTimes[eye];
+    }
+
+    // No VSync: Best guess for the near future
+    return ovr_GetTimeInSeconds() + ScreenSwitchingDelay + NoVSyncToScanoutDelay;
+}
+
+Posef FrameTimeManager::GetEyePredictionPose(ovrHmd hmd, ovrEyeType eye)
+{
+    double           eyeRenderTime = GetEyePredictionTime(eye);
+    ovrTrackingState eyeState      = ovrHmd_GetTrackingState(hmd, eyeRenderTime);
+        
+    // Record view pose sampling time for Latency reporting.
+    if (RenderIMUTimeSeconds == 0.0)
+    {
+        // TODO: Figure out why this are not as accurate as ovr_GetTimeInSeconds()
+        //RenderIMUTimeSeconds = eyeState.RawSensorData.TimeInSeconds;
+        RenderIMUTimeSeconds = ovr_GetTimeInSeconds();
+    }
+
+    return eyeState.HeadPose.ThePose;
+}
+
+
+void FrameTimeManager::GetTimewarpPredictions(ovrEyeType eye, double timewarpStartEnd[2])
+{
+    if (VsyncEnabled)
+    {
+        timewarpStartEnd[0] = FrameTiming.TimeWarpStartEndTimes[eye][0];
+        timewarpStartEnd[1] = FrameTiming.TimeWarpStartEndTimes[eye][1];
+        return;
+    }    
+
+    // Free-running, so this will be displayed immediately.
+    // Unfortunately we have no idea which bit of the screen is actually going to be displayed.
+    // TODO: guess which bit of the screen is being displayed!
+    // (e.g. use DONOTWAIT on present and see when the return isn't WASSTILLWAITING?)
+
+    // We have no idea where scan-out is currently, so we can't usefully warp the screen spatially.
+    timewarpStartEnd[0] = ovr_GetTimeInSeconds() + ScreenSwitchingDelay + NoVSyncToScanoutDelay;
+    timewarpStartEnd[1] = timewarpStartEnd[0];
+}
+
+
+void FrameTimeManager::GetTimewarpMatrices(ovrHmd hmd, ovrEyeType eyeId,
+                                           ovrPosef renderPose, ovrMatrix4f twmOut[2])
+{
+    if (!hmd)
+    {
+        return;
+    }
+
+    double timewarpStartEnd[2] = { 0.0, 0.0 };    
+    GetTimewarpPredictions(eyeId, timewarpStartEnd);
+      
+    //HMDState* p = (HMDState*)hmd;
+    ovrTrackingState startState = ovrHmd_GetTrackingState(hmd, timewarpStartEnd[0]);
+    ovrTrackingState endState   = ovrHmd_GetTrackingState(hmd, timewarpStartEnd[1]);
+
+    if (TimewarpIMUTimeSeconds == 0.0)
+    {
+        // TODO: Figure out why this are not as accurate as ovr_GetTimeInSeconds()
+        //TimewarpIMUTimeSeconds = startState.RawSensorData.TimeInSeconds;
+        TimewarpIMUTimeSeconds = ovr_GetTimeInSeconds();
+    }
+
+    Quatf quatFromStart = startState.HeadPose.ThePose.Orientation;
+    Quatf quatFromEnd   = endState.HeadPose.ThePose.Orientation;
+    Quatf quatFromEye   = renderPose.Orientation; //EyeRenderPoses[eyeId].Orientation;
+    quatFromEye.Invert();
+    
+    Quatf timewarpStartQuat = quatFromEye * quatFromStart;
+    Quatf timewarpEndQuat   = quatFromEye * quatFromEnd;
+
+    Matrix4f timewarpStart(timewarpStartQuat);
+    Matrix4f timewarpEnd(timewarpEndQuat);
+    
+
+    // The real-world orientations have:                                  X=right, Y=up,   Z=backwards.
+    // The vectors inside the mesh are in NDC to keep the shader simple: X=right, Y=down, Z=forwards.
+    // So we need to perform a similarity transform on this delta matrix.
+    // The verbose code would look like this:
+    /*
+    Matrix4f matBasisChange;
+    matBasisChange.SetIdentity();
+    matBasisChange.M[0][0] =  1.0f;
+    matBasisChange.M[1][1] = -1.0f;
+    matBasisChange.M[2][2] = -1.0f;
+    Matrix4f matBasisChangeInv = matBasisChange.Inverted();
+    matRenderFromNow = matBasisChangeInv * matRenderFromNow * matBasisChange;
+    */
+    // ...but of course all the above is a constant transform and much more easily done.
+    // We flip the signs of the Y&Z row, then flip the signs of the Y&Z column,
+    // and of course most of the flips cancel:
+    // +++                        +--                     +--
+    // +++ -> flip Y&Z columns -> +-- -> flip Y&Z rows -> -++
+    // +++                        +--                     -++
+    timewarpStart.M[0][1] = -timewarpStart.M[0][1];
+    timewarpStart.M[0][2] = -timewarpStart.M[0][2];
+    timewarpStart.M[1][0] = -timewarpStart.M[1][0];
+    timewarpStart.M[2][0] = -timewarpStart.M[2][0];
+
+    timewarpEnd  .M[0][1] = -timewarpEnd  .M[0][1];
+    timewarpEnd  .M[0][2] = -timewarpEnd  .M[0][2];
+    timewarpEnd  .M[1][0] = -timewarpEnd  .M[1][0];
+    timewarpEnd  .M[2][0] = -timewarpEnd  .M[2][0];
+
+    twmOut[0] = timewarpStart;
+    twmOut[1] = timewarpEnd;
+}
+
+
+// Used by renderer to determine if it should time distortion rendering.
+bool  FrameTimeManager::NeedDistortionTimeMeasurement() const
+{
+    if (!VsyncEnabled)
+        return false;
+    return DistortionRenderTimes.GetCount() < DistortionRenderTimes.Capacity;
+}
+
+
+void  FrameTimeManager::AddDistortionTimeMeasurement(double distortionTimeSeconds)
+{
+    DistortionRenderTimes.AddTimeDelta(distortionTimeSeconds);
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    //updateTimewarpTiming();
+
+    // If timewarp timing changes based on this sample, update it.
+    double newTimewarpWaitDelta = calcTimewarpWaitDelta();
+    if (newTimewarpWaitDelta != FrameTiming.Inputs.TimewarpWaitDelta)
+    {
+        FrameTiming.Inputs.TimewarpWaitDelta = newTimewarpWaitDelta;
+        LocklessTiming.SetState(FrameTiming);
+    }
+}
+
+
+void FrameTimeManager::UpdateFrameLatencyTrackingAfterEndFrame(
+                                    unsigned char frameLatencyTestColor[3],
+                                    const Util::FrameTimeRecordSet& rs)
+{    
+    // FrameTiming.NextFrameTime in this context (after EndFrame) is the end frame time.
+    ScreenLatencyTracker.SaveDrawColor(frameLatencyTestColor[0],
+                                       FrameTiming.NextFrameTime,
+                                       RenderIMUTimeSeconds,
+                                       TimewarpIMUTimeSeconds);
+
+    ScreenLatencyTracker.MatchRecord(rs);
+
+    // If screen delay changed, update timing.
+    double newScreenDelay = calcScreenDelay();
+    if (newScreenDelay != FrameTiming.Inputs.ScreenDelay)
+    {
+        FrameTiming.Inputs.ScreenDelay = newScreenDelay;
+        LocklessTiming.SetState(FrameTiming);
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+//Revisit dynamic pre-Timewarp delay adjustment logic
+/*
+void FrameTimeManager::TimewarpDelayAdjuster::Reset()    
+{
+    State                           = State_WaitingToReduceLevel;
+    DelayLevel                      = 0;
+    InitialFrameCounter             = 0;
+    TimewarpDelayReductionSeconds   = 0.0;
+    DelayLevelFinishTime            = 0.0;
+
+    memset(WaitTimeIndexForLevel, 0, sizeof(WaitTimeIndexForLevel));
+    // If we are at level 0, waits are infinite.
+    WaitTimeIndexForLevel[0] = MaxTimeIndex;
+}
+
+
+void FrameTimeManager::TimewarpDelayAdjuster::
+        UpdateTimewarpWaitIfSkippedFrames(FrameTimeManager* manager,
+                                          double measuredFrameDelta, double nextFrameTime)
+{    
+    // Times in seconds
+    const static double delayTimingTiers[7] = { 1.0, 5.0, 15.0, 30.0, 60.0, 120.0, 1000000.0 };
+
+    const double currentFrameDelta = manager->FrameTiming.Inputs.FrameDelta;
+
+
+    // Once we detected frame spike, we skip several frames before testing again.    
+    if (InitialFrameCounter > 0)
+    {
+        InitialFrameCounter --;
+        return;
+    }
+
+    // Skipped frame would usually take 2x longer then regular frame
+    if (measuredFrameDelta > currentFrameDelta * 1.8)
+    {        
+        if (State == State_WaitingToReduceLevel)
+        {
+            // If we got here, escalate the level again. 
+            if (DelayLevel < MaxDelayLevel)
+            {
+                DelayLevel++;
+                InitialFrameCounter = 3;
+            }
+        }
+
+        else if (State == State_VerifyingAfterReduce)
+        {
+            // So we went down to this level and tried to wait to see if there was
+            // as skipped frame and there is -> go back up a level and incrment its timing tier
+            if (DelayLevel < MaxDelayLevel)
+            {
+                DelayLevel++;
+                State = State_WaitingToReduceLevel;
+                
+                // For higher level delays reductions, i.e. more then half a frame,
+                // we don't go into the infinite wait tier.
+                int maxTimingTier = MaxTimeIndex;
+                if (DelayLevel > MaxInfiniteTimingLevel)
+                    maxTimingTier--;
+
+                if (WaitTimeIndexForLevel[DelayLevel] < maxTimingTier )
+                    WaitTimeIndexForLevel[DelayLevel]++;
+            }
+        }
+
+        DelayLevelFinishTime          = nextFrameTime +
+                                        delayTimingTiers[WaitTimeIndexForLevel[DelayLevel]];
+        TimewarpDelayReductionSeconds = currentFrameDelta * 0.125 * DelayLevel;
+        manager->updateTimewarpTiming();
+
+    }
+
+    else if (nextFrameTime > DelayLevelFinishTime)
+    {        
+        if (State == State_WaitingToReduceLevel)
+        {
+            if (DelayLevel > 0)
+            {
+                DelayLevel--;
+                State = State_VerifyingAfterReduce;
+                // Always use 1 sec to see if "down sampling mode" caused problems
+                DelayLevelFinishTime = nextFrameTime + 1.0f; 
+            }
+        }
+        else if (State == State_VerifyingAfterReduce)
+        {
+            // Prior display level successfully reduced,
+            // try to see we we could go down further after wait.
+            WaitTimeIndexForLevel[DelayLevel+1] = 0;            
+            State                               = State_WaitingToReduceLevel;
+            DelayLevelFinishTime                = nextFrameTime +
+                                                  delayTimingTiers[WaitTimeIndexForLevel[DelayLevel]];
+        }
+
+        // TBD: Update TimeWarpTiming
+        TimewarpDelayReductionSeconds = currentFrameDelta * 0.125 * DelayLevel;
+        manager->updateTimewarpTiming();
+    }
+
+
+    //static int oldDelayLevel = 0;
+
+    //if (oldDelayLevel != DelayLevel)
+    //{
+        //OVR_DEBUG_LOG(("DelayLevel:%d tReduction = %0.5f ", DelayLevel, TimewarpDelayReductionSeconds));
+        //oldDelayLevel = DelayLevel;
+    //}
+    }
+    */
+
+//-----------------------------------------------------------------------------------
+// ***** TimeDeltaCollector
+
+void TimeDeltaCollector::AddTimeDelta(double timeSeconds)
+{
+    // avoid adding invalid timing values
+    if(timeSeconds < 0.0f)
+        return;
+
+    if (Count == Capacity)
+    {
+        for(int i=0; i< Count-1; i++)
+            TimeBufferSeconds[i] = TimeBufferSeconds[i+1];
+        Count--;
+    }
+    TimeBufferSeconds[Count++] = timeSeconds;
+
+    ReCalcMedian = true;
+}
+
+double TimeDeltaCollector::GetMedianTimeDelta() const
+{
+    if(ReCalcMedian)
+    {
+        double  SortedList[Capacity];
+        bool    used[Capacity];
+
+        memset(used, 0, sizeof(used));
+        SortedList[0] = 0.0; // In case Count was 0...
+
+        // Probably the slowest way to find median...
+        for (int i=0; i<Count; i++)
+        {
+            double smallestDelta = 1000000.0;
+            int    index = 0;
+
+            for (int j = 0; j < Count; j++)
+            {
+                if (!used[j])
+                {                
+                    if (TimeBufferSeconds[j] < smallestDelta)
+                    {
+                        smallestDelta = TimeBufferSeconds[j];
+                        index = j;
+                    }
+                }
+            }
+
+            // Mark as used
+            used[index]   = true;
+            SortedList[i] = smallestDelta;
+        }
+
+        Median = SortedList[Count/4];
+        ReCalcMedian = false;
+    }
+
+    // FIRMWARE HACK: Don't take the actual median, but err on the low time side
+    return Median;
+}
+      
+
+}} // namespace OVR::CAPI
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,323 @@
+/************************************************************************************
+
+Filename    :   CAPI_FrameTimeManager.h
+Content     :   Manage frame timing and pose prediction for rendering
+Created     :   November 30, 2013
+Authors     :   Volga Aksoy, Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_FrameTimeManager_h
+#define OVR_CAPI_FrameTimeManager_h
+
+#include "../OVR_CAPI.h"
+#include "../Kernel/OVR_Timer.h"
+#include "../Kernel/OVR_Math.h"
+#include "../Util/Util_Render_Stereo.h"
+
+namespace OVR { namespace CAPI {
+
+//-------------------------------------------------------------------------------------
+
+// Helper class to collect median times between frames, so that we know
+// how long to wait. 
+struct TimeDeltaCollector
+{
+    TimeDeltaCollector() : Count(0), ReCalcMedian(true), Median(-1.0) { }
+
+    void    AddTimeDelta(double timeSeconds);    
+    void    Clear() { Count = 0; }    
+
+    double  GetMedianTimeDelta() const;
+
+    double  GetCount() const { return Count; }
+
+    enum { Capacity = 12 };
+private:
+	double  TimeBufferSeconds[Capacity];
+	mutable double  Median;
+	int     Count;
+    mutable bool    ReCalcMedian;
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** FrameLatencyTracker
+
+// FrameLatencyTracker tracks frame Present to display Scan-out timing, as reported by
+// the DK2 internal latency tester pixel read-back. The computed value is used in
+// FrameTimeManager for prediction. View Render and TimeWarp to scan-out latencies are
+// also reported for debugging.
+//
+// The class operates by generating color values from GetNextDrawColor() that must
+// be rendered on the back end and then looking for matching values in FrameTimeRecordSet
+// structure as reported by HW.
+
+class FrameLatencyTracker
+{
+public:
+
+    enum { FramesTracked = Util::LT2_IncrementCount-1 };
+
+    FrameLatencyTracker();
+
+    // DrawColor == 0 is special in that it doesn't need saving of timestamp
+    unsigned char GetNextDrawColor();
+
+    void SaveDrawColor(unsigned char drawColor, double endFrameTime,
+                       double renderIMUTime, double timewarpIMUTime );
+
+    void MatchRecord(const Util::FrameTimeRecordSet &r);   
+
+    bool IsLatencyTimingAvailable();
+    void GetLatencyTimings(float latencies[3]);
+
+    void Reset();
+
+public:
+
+    struct FrameTimeRecordEx : public Util::FrameTimeRecord
+    {
+        bool    MatchedRecord;
+        double  RenderIMUTimeSeconds;
+        double  TimewarpIMUTimeSeconds;
+    };
+
+    // True if rendering read-back is enabled.
+    bool                  TrackerEnabled;
+
+    enum SampleWaitType {
+        SampleWait_Zeroes, // We are waiting for a record with all zeros.
+        SampleWait_Match   // We are issuing & matching colors.
+    };
+    
+    SampleWaitType        WaitMode;
+    int                   MatchCount;
+    // Records of frame timings that we are trying to measure.
+    FrameTimeRecordEx     FrameEndTimes[FramesTracked];
+    int                   FrameIndex;
+    // Median filter for (ScanoutTimeSeconds - PostPresent frame time)
+    TimeDeltaCollector    FrameDeltas;
+    // Latency reporting results
+    double                RenderLatencySeconds;
+    double                TimewarpLatencySeconds;
+    double                LatencyRecordTime;
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** FrameTimeManager
+
+// FrameTimeManager keeps track of rendered frame timing and handles predictions for
+// orientations and time-warp.
+
+class FrameTimeManager
+{
+public:
+    FrameTimeManager(bool vsyncEnabled = true);
+
+    // Data that affects frame timing computation.
+    struct TimingInputs
+    {
+        // Hard-coded value or dynamic as reported by FrameTimeDeltas.GetMedianTimeDelta().
+        double              FrameDelta;
+        // Screen delay from present to scan-out, as potentially reported by ScreenLatencyTracker.
+        double              ScreenDelay;
+        // Negative value of how many seconds before EndFrame we start timewarp. 0.0 if not used.
+        double              TimewarpWaitDelta;
+        
+        TimingInputs()
+            : FrameDelta(0), ScreenDelay(0), TimewarpWaitDelta(0)
+        { }
+    };
+
+    // Timing values for a specific frame.
+    struct Timing
+    {
+        TimingInputs        Inputs;
+        
+        // Index of a frame that started at ThisFrameTime.
+        unsigned int        FrameIndex;
+        // Predicted absolute times for when this frame will show up on screen.
+        // Generally, all values will be >= NextFrameTime, since that's the time we expect next
+        // vsync to succeed.
+        double              ThisFrameTime;
+        double              TimewarpPointTime;
+        double              NextFrameTime;        
+        double              MidpointTime;
+        double              EyeRenderTimes[2];
+        double              TimeWarpStartEndTimes[2][2];
+
+        Timing()
+        {
+            memset(this, 0, sizeof(Timing));
+        }
+
+        void InitTimingFromInputs(const TimingInputs& inputs, HmdShutterTypeEnum shutterType,
+                                  double thisFrameTime, unsigned int frameIndex);
+    };
+
+   
+    // Called on startup to provided data on HMD timing.
+    void    Init(HmdRenderInfo& renderInfo);
+
+    // Called with each new ConfigureRendering.
+    void    ResetFrameTiming(unsigned frameIndex,
+                             bool dynamicPrediction, bool sdkRender);
+
+    void    SetVsync(bool enabled) { VsyncEnabled = enabled; }
+
+    // BeginFrame returns time of the call
+    // TBD: Should this be a predicted time value instead ?
+    double  BeginFrame(unsigned frameIndex);
+    void    EndFrame();    
+
+    // Thread-safe function to query timing for a future frame
+    Timing  GetFrameTiming(unsigned frameIndex);
+ 
+    double  GetEyePredictionTime(ovrEyeType eye);
+    Posef   GetEyePredictionPose(ovrHmd hmd, ovrEyeType eye);
+
+    void    GetTimewarpPredictions(ovrEyeType eye, double timewarpStartEnd[2]); 
+    void    GetTimewarpMatrices(ovrHmd hmd, ovrEyeType eye, ovrPosef renderPose, ovrMatrix4f twmOut[2]);
+
+    // Used by renderer to determine if it should time distortion rendering.
+    bool    NeedDistortionTimeMeasurement() const;
+    void    AddDistortionTimeMeasurement(double distortionTimeSeconds);
+
+    
+    // DK2 Latency test interface
+    
+    // Get next draw color for DK2 latency tester (3-byte RGB)
+    void GetFrameLatencyTestDrawColor(unsigned char outColor[3])
+    {
+        outColor[0] = ScreenLatencyTracker.GetNextDrawColor();
+        outColor[1] = ScreenLatencyTracker.IsLatencyTimingAvailable() ? 255 : 0;
+        outColor[2] = ScreenLatencyTracker.IsLatencyTimingAvailable() ? 0 : 255;
+    }
+
+    // Must be called after EndFrame() to update latency tester timings.
+    // Must pass color reported by NextFrameColor for this frame.
+    void    UpdateFrameLatencyTrackingAfterEndFrame(unsigned char frameLatencyTestColor[3],
+                                                    const Util::FrameTimeRecordSet& rs);
+
+    void    GetLatencyTimings(float latencies[3])
+    { return ScreenLatencyTracker.GetLatencyTimings(latencies); }
+
+
+    const Timing& GetFrameTiming() const { return FrameTiming; }
+
+private:
+
+    double  calcFrameDelta() const;
+    double  calcScreenDelay() const;
+    double  calcTimewarpWaitDelta() const;
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    /*
+    void    updateTimewarpTiming();
+
+
+    
+    // TimewarpDelayAdjuster implements a simple state machine that reduces the amount
+    // of time-warp waiting based on skipped frames. 
+    struct TimewarpDelayAdjuster
+    {
+        enum StateInLevel
+        {        
+            // We are ok at this level, and will be waiting for some time before trying to reduce.
+            State_WaitingToReduceLevel,  
+            // After decrementing a level, we are verifying that this won't cause skipped frames.
+            State_VerifyingAfterReduce
+       };
+    
+        enum {
+            MaxDelayLevel          = 5,
+            MaxInfiniteTimingLevel = 3,
+            MaxTimeIndex           = 6
+        };
+
+        StateInLevel State;   
+        // Current level. Higher levels means larger delay reduction (smaller overall time-warp delay).
+        int          DelayLevel;
+        // Index for the amount of time we'd wait in this level. If attempt to decrease level fails,
+        // with is incrementing causing the level to become "sticky". 
+        int          WaitTimeIndexForLevel[MaxTimeIndex + 1];
+        // We skip few frames after each escalation to avoid too rapid of a reduction.
+        int          InitialFrameCounter;
+        // What th currect "reduction" currently is.
+        double       TimewarpDelayReductionSeconds;
+        // When we should try changing the level again.
+        double       DelayLevelFinishTime;
+
+    public:
+        TimewarpDelayAdjuster() { Reset(); }
+
+        void    Reset();
+
+        void    UpdateTimewarpWaitIfSkippedFrames(FrameTimeManager* manager,
+                                                  double measuredFrameDelta,
+                                                  double nextFrameTime);
+
+        double  GetDelayReduction() const { return TimewarpDelayReductionSeconds; }
+    };
+    */
+
+    
+    HmdRenderInfo       RenderInfo;
+    // Timings are collected through a median filter, to avoid outliers.
+    TimeDeltaCollector  FrameTimeDeltas;
+    TimeDeltaCollector  DistortionRenderTimes;
+    FrameLatencyTracker ScreenLatencyTracker;
+
+    // Timing changes if we have no Vsync (all prediction is reduced to fixed interval).
+    bool                VsyncEnabled;
+    // Set if we are rendering via the SDK, so DistortionRenderTimes is valid.
+    bool                DynamicPrediction;
+    // Set if SDk is doing teh rendering.
+    bool                SdkRender;
+
+    // Total frame delay due to VsyncToFirstScanline, persistence and settle time.
+    // Computed from RenderInfor.Shutter.
+    double              VSyncToScanoutDelay;
+    double              NoVSyncToScanoutDelay;
+    double              ScreenSwitchingDelay;
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    //TimewarpDelayAdjuster  TimewarpAdjuster;
+
+    // Current (or last) frame timing info. Used as a source for LocklessTiming.
+    Timing                  FrameTiming;
+    // TBD: Don't we need NextFrame here as well?
+    LocklessUpdater<Timing, Timing> LocklessTiming;
+
+
+    // IMU Read timings
+    double              RenderIMUTimeSeconds;
+    double              TimewarpIMUTimeSeconds;
+};
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_FrameTimeManager_h
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,137 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI_HMDRenderState.cpp
+Content     :   Combines all of the rendering state associated with the HMD
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_HMDRenderState.h"
+
+namespace OVR { namespace CAPI {
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDRenderState
+
+ovrHmdDesc HMDRenderState::GetDesc() const
+{
+    ovrHmdDesc d;
+    memset(&d, 0, sizeof(d));
+    
+    d.Type = ovrHmd_Other;
+     
+    d.ProductName       = OurHMDInfo.ProductName;    
+    d.Manufacturer      = OurHMDInfo.Manufacturer;
+    d.Resolution.w      = OurHMDInfo.ResolutionInPixels.w;
+    d.Resolution.h      = OurHMDInfo.ResolutionInPixels.h;
+    d.WindowsPos.x      = OurHMDInfo.DesktopX;
+    d.WindowsPos.y      = OurHMDInfo.DesktopY;
+    d.DisplayDeviceName = OurHMDInfo.DisplayDeviceName;
+    d.DisplayId         = OurHMDInfo.DisplayId;
+    d.VendorId          = (short)OurHMDInfo.VendorId;
+    d.ProductId         = (short)OurHMDInfo.ProductId;
+    d.FirmwareMajor     = (short)OurHMDInfo.FirmwareMajor;
+    d.FirmwareMinor     = (short)OurHMDInfo.FirmwareMinor;
+    d.CameraFrustumFarZInMeters  = OurHMDInfo.CameraFrustumFarZInMeters;
+    d.CameraFrustumHFovInRadians = OurHMDInfo.CameraFrustumHFovInRadians;
+    d.CameraFrustumNearZInMeters = OurHMDInfo.CameraFrustumNearZInMeters;
+    d.CameraFrustumVFovInRadians = OurHMDInfo.CameraFrustumVFovInRadians;
+
+    OVR_strcpy(d.SerialNumber, sizeof(d.SerialNumber), OurHMDInfo.PrintedSerial.ToCStr());
+
+    d.HmdCaps           = ovrHmdCap_Present | ovrHmdCap_NoVSync;
+    d.TrackingCaps      = ovrTrackingCap_MagYawCorrection | ovrTrackingCap_Orientation;
+    d.DistortionCaps    = ovrDistortionCap_Chromatic | ovrDistortionCap_TimeWarp |
+                          ovrDistortionCap_Vignette | ovrDistortionCap_SRGB |
+                          ovrDistortionCap_FlipInput | ovrDistortionCap_ProfileNoTimewarpSpinWaits;
+
+    if( OurHMDInfo.InCompatibilityMode )
+        d.HmdCaps |= ovrHmdCap_ExtendDesktop;
+
+    if (strstr(OurHMDInfo.ProductName, "DK1"))
+    {
+        d.Type = ovrHmd_DK1;        
+    }
+    else if (strstr(OurHMDInfo.ProductName, "DK2"))
+    {
+        d.Type        = ovrHmd_DK2;
+        d.HmdCaps    |= ovrHmdCap_LowPersistence | ovrHmdCap_DynamicPrediction;
+        d.TrackingCaps |= ovrTrackingCap_Position;
+		d.DistortionCaps |= ovrDistortionCap_Overdrive;
+    }
+        
+    const DistortionRenderDesc& leftDistortion  = Distortion[0];
+    const DistortionRenderDesc& rightDistortion = Distortion[1];
+  
+    // The suggested FOV (assuming eye rotation)
+    d.DefaultEyeFov[0] = CalculateFovFromHmdInfo(StereoEye_Left, leftDistortion, RenderInfo, OVR_DEFAULT_EXTRA_EYE_ROTATION);
+    d.DefaultEyeFov[1] = CalculateFovFromHmdInfo(StereoEye_Right, rightDistortion, RenderInfo, OVR_DEFAULT_EXTRA_EYE_ROTATION);
+
+    // FOV extended across the entire screen
+    d.MaxEyeFov[0] = GetPhysicalScreenFov(StereoEye_Left, leftDistortion);
+    d.MaxEyeFov[1] = GetPhysicalScreenFov(StereoEye_Right, rightDistortion);
+    
+    if (OurHMDInfo.Shutter.Type == HmdShutter_RollingRightToLeft)
+    {
+        d.EyeRenderOrder[0] = ovrEye_Right;
+        d.EyeRenderOrder[1] = ovrEye_Left;
+    }
+    else
+    {
+        d.EyeRenderOrder[0] = ovrEye_Left;
+        d.EyeRenderOrder[1] = ovrEye_Right;
+    }    
+
+    // MA: Taking this out on purpose.
+	// Important information for those that are required to do their own timing,
+    // because of shortfalls in timing code.
+	//d.VsyncToNextVsync = OurHMDInfo.Shutter.VsyncToNextVsync;
+	//d.PixelPersistence = OurHMDInfo.Shutter.PixelPersistence;
+
+    return d;
+}
+
+
+ovrSizei HMDRenderState::GetFOVTextureSize(int eye, ovrFovPort fov, float pixelsPerDisplayPixel) const
+{
+    OVR_ASSERT((unsigned)eye < 2);
+    StereoEye seye = (eye == ovrEye_Left) ? StereoEye_Left : StereoEye_Right;
+    return CalculateIdealPixelSize(seye, Distortion[eye], fov, pixelsPerDisplayPixel);
+}
+
+ovrEyeRenderDesc HMDRenderState::CalcRenderDesc(ovrEyeType eyeType, const ovrFovPort& fov) const
+{    
+    const HmdRenderInfo&   hmdri = RenderInfo;
+    StereoEye        eye   = (eyeType == ovrEye_Left) ? StereoEye_Left : StereoEye_Right;
+    ovrEyeRenderDesc e0;
+    
+    e0.Eye                       = eyeType;
+    e0.Fov                       = fov;
+    e0.ViewAdjust                = CalculateEyeVirtualCameraOffset(hmdri, eye, false);
+    e0.DistortedViewport         = GetFramebufferViewport(eye, hmdri);
+    e0.PixelsPerTanAngleAtCenter = Distortion[0].PixelsPerTanAngleAtCenter;
+
+    return e0;
+}
+
+}} // namespace OVR::CAPI
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,74 @@
+/************************************************************************************
+
+Filename    :   CAPI_HMDRenderState.h
+Content     :   Combines all of the rendering state associated with the HMD
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HMDRenderState_h
+#define OVR_CAPI_HMDRenderState_h
+
+#include "../OVR_CAPI.h"
+#include "../Kernel/OVR_Math.h"
+#include "../Util/Util_Render_Stereo.h"
+#include "../Service/Service_NetSessionCommon.h"
+
+namespace OVR { namespace CAPI {
+
+using namespace OVR::Util::Render;
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDRenderState
+
+// Combines all of the rendering setup information about one HMD.
+// This structure only ever exists inside HMDState, but this 
+// declaration is in a separate file to reduce #include dependencies.
+// All actual lifetime and update control is done by the surrounding HMDState.
+struct HMDRenderState
+{
+    // Utility query functions.
+    ovrHmdDesc          GetDesc() const;
+    ovrSizei            GetFOVTextureSize(int eye, ovrFovPort fov, float pixelsPerDisplayPixel) const;
+    ovrEyeRenderDesc    CalcRenderDesc(ovrEyeType eyeType, const ovrFovPort& fov) const;
+
+    HMDInfo                 OurHMDInfo;
+
+    HmdRenderInfo           RenderInfo;
+    DistortionRenderDesc    Distortion[2];
+    ovrEyeRenderDesc        EyeRenderDesc[2]; 
+
+    // Clear color used for distortion
+    float                   ClearColor[4];
+
+    // Pose at which last time the eye was rendered, as submitted by EndEyeRender.
+    ovrPosef                EyeRenderPoses[2];
+
+    // Capabilities passed to Configure.
+    unsigned                EnabledHmdCaps;
+    unsigned                DistortionCaps;
+};
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_HMDState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,794 @@
+/************************************************************************************
+
+Filename    :   CAPI_HMDState.cpp
+Content     :   State associated with a single HMD
+Created     :   January 24, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_HMDState.h"
+#include "../OVR_Profile.h"
+#include "../Service/Service_NetClient.h"
+#ifdef OVR_OS_WIN32
+#include "../Displays/OVR_Win32_ShimFunctions.h"
+#endif
+
+
+namespace OVR { namespace CAPI {
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDState
+
+HMDState::HMDState(const OVR::Service::HMDNetworkInfo& netInfo,
+				   const OVR::HMDInfo& hmdInfo,
+				   Profile* profile,
+				   Service::NetClient* client) :
+    pClient(client),
+    pProfile(profile),
+    pHmdDesc(0),
+    pWindow(0),
+    NetInfo(netInfo),
+    NetId(netInfo.NetId),
+    OurHMDInfo(hmdInfo),
+    EnabledHmdCaps(0),
+    LastFrameTimeSeconds(0.f),
+    LastGetFrameTimeSeconds(0.),
+    LatencyTestActive(false),
+    LatencyTest2Active(false)
+{
+    sharedInit(profile);
+}
+
+HMDState::HMDState(const OVR::HMDInfo& hmdInfo, Profile* profile) :
+    pClient(0),
+    pHmdDesc(0),
+    NetId(InvalidVirtualHmdId),
+    pProfile(profile),
+    OurHMDInfo(hmdInfo),
+    EnabledHmdCaps(0),
+    LastFrameTimeSeconds(0.),
+    LastGetFrameTimeSeconds(0.)
+{
+    sharedInit(profile);
+}
+
+HMDState::~HMDState()
+{
+    if (pClient)
+    {
+		pClient->Hmd_Release(NetId);
+		pClient = 0;
+    }
+
+    ConfigureRendering(0,0,0,0);
+
+    if (pHmdDesc)
+        delete pHmdDesc;
+}
+
+void HMDState::sharedInit(Profile* profile)
+{
+    // TBD: We should probably be looking up the default profile for the given
+    // device type + user if profile == 0.    
+    pLastError = 0;
+
+    RenderState.OurHMDInfo = OurHMDInfo;
+
+    UpdateRenderProfile(profile);
+
+    OVR_ASSERT(!pHmdDesc);
+    pHmdDesc         = new ovrHmdDesc;
+    *pHmdDesc        = RenderState.GetDesc();
+    pHmdDesc->Handle = this;
+
+    RenderState.ClearColor[0] = 0.0f;
+    RenderState.ClearColor[1] = 0.0f;
+    RenderState.ClearColor[2] = 0.0f;
+    RenderState.ClearColor[3] = 0.0f;
+
+    RenderState.EnabledHmdCaps = 0;
+
+    TimeManager.Init(RenderState.RenderInfo);
+
+    /*
+    LatencyTestDrawColor[0] = 0;
+    LatencyTestDrawColor[1] = 0;
+    LatencyTestDrawColor[2] = 0;
+    */
+
+    RenderingConfigured = false;
+    BeginFrameCalled   = false;
+    BeginFrameThreadId = 0;
+    BeginFrameTimingCalled = false;
+
+    // Construct the HSWDisplay. We will later reconstruct it with a specific ovrRenderAPI type if the application starts using SDK-based rendering.
+    if(!pHSWDisplay)
+        pHSWDisplay = *OVR::CAPI::HSWDisplay::Factory(ovrRenderAPI_None, pHmdDesc, RenderState);
+}
+
+static Vector3f GetNeckModelFromProfile(Profile* profile)
+{
+    OVR_ASSERT(profile);
+
+    float neckeye[2] = { OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL, OVR_DEFAULT_NECK_TO_EYE_VERTICAL };
+    profile->GetFloatValues(OVR_KEY_NECK_TO_EYE_DISTANCE, neckeye, 2);
+
+    // Make sure these are vaguely sensible values.
+    //OVR_ASSERT((neckeye[0] > 0.05f) && (neckeye[0] < 0.5f));
+    //OVR_ASSERT((neckeye[1] > 0.05f) && (neckeye[1] < 0.5f));
+
+    // Named for clarity
+    float NeckToEyeHorizontal = neckeye[0];
+    float NeckToEyeVertical = neckeye[1];
+
+    // Store the neck model
+    return Vector3f(0.0, NeckToEyeVertical, -NeckToEyeHorizontal);
+}
+
+static float GetCenterPupilDepthFromRenderInfo(HmdRenderInfo* hmdRenderInfo)
+{
+    OVR_ASSERT(hmdRenderInfo);
+
+    // Find the distance from the center of the screen to the "center eye"
+    // This center eye is used by systems like rendering & audio to represent the player,
+    // and they will handle the offsets needed from there to each actual eye.
+
+    // HACK HACK HACK
+    // We know for DK1 the screen->lens surface distance is roughly 0.049f, and that the faceplate->lens is 0.02357f.
+    // We're going to assume(!!!!) that all HMDs have the same screen->faceplate distance.
+    // Crystal Cove was measured to be roughly 0.025 screen->faceplate which agrees with this assumption.
+    // TODO: do this properly!  Update:  Measured this at 0.02733 with a CC prototype, CES era (PT7), on 2/19/14 -Steve
+    float screenCenterToMidplate = 0.02733f;
+    float centerEyeRelief = hmdRenderInfo->GetEyeCenter().ReliefInMeters;
+    float CenterPupilDepth = screenCenterToMidplate + hmdRenderInfo->LensSurfaceToMidplateInMeters + centerEyeRelief;
+
+    return CenterPupilDepth;
+}
+
+void HMDState::UpdateRenderProfile(Profile* profile)
+{
+    // Apply the given profile to generate a render context
+    RenderState.RenderInfo = GenerateHmdRenderInfoFromHmdInfo(RenderState.OurHMDInfo, profile);
+    RenderState.Distortion[0] = CalculateDistortionRenderDesc(StereoEye_Left, RenderState.RenderInfo, 0);
+    RenderState.Distortion[1] = CalculateDistortionRenderDesc(StereoEye_Right, RenderState.RenderInfo, 0);
+
+    if (pClient)
+    {
+        // Center pupil depth
+        float centerPupilDepth = GetCenterPupilDepthFromRenderInfo(&RenderState.RenderInfo);
+        pClient->SetNumberValue(GetNetId(), "CenterPupilDepth", centerPupilDepth);
+
+        // Neck model
+        Vector3f neckModel = GetNeckModelFromProfile(profile);
+        double neckModelArray[3] = {
+            neckModel.x,
+            neckModel.y,
+            neckModel.z
+        };
+        pClient->SetNumberValues(GetNetId(), "NeckModelVector3f", neckModelArray, 3);
+    }
+}
+
+HMDState* HMDState::CreateHMDState(NetClient* client, const HMDNetworkInfo& netInfo)
+{
+    // HMDState works through a handle to service HMD....
+    HMDInfo hinfo;
+    if (!client->Hmd_GetHmdInfo(netInfo.NetId, &hinfo))
+    {
+        OVR_DEBUG_LOG(("[HMDState] Unable to get HMD info"));
+        return NULL;
+    }
+
+#ifdef OVR_OS_WIN32
+    OVR_DEBUG_LOG(("Setting up display shim"));
+
+    // Initialize the display shim before reporting the display to the user code
+    // so that this will happen before the D3D display object is created.
+    Win32::DisplayShim::GetInstance().Update(&hinfo.ShimInfo);
+#endif
+
+    Ptr<Profile> pDefaultProfile = *ProfileManager::GetInstance()->GetDefaultUserProfile(&hinfo);
+    OVR_DEBUG_LOG(("Using profile %s", pDefaultProfile->GetValue(OVR_KEY_USER)));
+
+    HMDState* hmds = new HMDState(netInfo, hinfo, pDefaultProfile, client);
+
+    if (!hmds->SharedStateReader.Open(netInfo.SharedMemoryName.ToCStr()))
+    {
+        delete hmds;
+        return NULL;
+    }
+
+    hmds->TheSensorStateReader.SetUpdater(hmds->SharedStateReader.Get());
+    hmds->TheLatencyTestStateReader.SetUpdater(hmds->SharedStateReader.Get());
+
+    return hmds;
+}
+
+HMDState* HMDState::CreateHMDState(ovrHmdType hmdType)
+{
+    HmdTypeEnum t = HmdType_None;
+    if (hmdType == ovrHmd_DK1)
+        t = HmdType_DK1;    
+    else if (hmdType == ovrHmd_DK2)
+        t = HmdType_DK2;
+
+    // FIXME: This does not actually grab the right user..
+    Ptr<Profile> pDefaultProfile = *ProfileManager::GetInstance()->GetDefaultProfile(t);
+
+    return new HMDState(CreateDebugHMDInfo(t), pDefaultProfile);
+}
+    
+
+//-------------------------------------------------------------------------------------
+// *** Sensor 
+
+bool HMDState::ConfigureTracking(unsigned supportedCaps, unsigned requiredCaps)
+{
+	return pClient ? pClient->Hmd_ConfigureTracking(NetId, supportedCaps, requiredCaps) : true;
+}
+
+void HMDState::ResetTracking()
+{
+	if (pClient) pClient->Hmd_ResetTracking(NetId);
+}        
+
+// Re-center the orientation.
+void HMDState::RecenterPose()
+{
+    TheSensorStateReader.RecenterPose();
+}
+
+// Returns prediction for time.
+ovrTrackingState HMDState::PredictedTrackingState(double absTime)
+{    
+	Tracking::TrackingState ss;
+    TheSensorStateReader.GetSensorStateAtTime(absTime, ss);
+
+    // Zero out the status flags
+    if (!pClient || !pClient->IsConnected())
+    {
+        ss.StatusFlags = 0;
+    }
+
+    return ss;
+}
+
+void HMDState::SetEnabledHmdCaps(unsigned hmdCaps)
+{
+    if (OurHMDInfo.HmdType < HmdType_DK2)
+    {
+        // disable low persistence
+        hmdCaps &= ~ovrHmdCap_LowPersistence;
+
+        // disable dynamic prediction using the internal latency tester
+        hmdCaps &= ~ovrHmdCap_DynamicPrediction;
+    }
+
+    if (OurHMDInfo.HmdType >= HmdType_DK2)
+    {
+        if ((EnabledHmdCaps ^ hmdCaps) & ovrHmdCap_DynamicPrediction)
+        {
+            // DynamicPrediction change
+            TimeManager.ResetFrameTiming(TimeManager.GetFrameTiming().FrameIndex,
+                                         (hmdCaps & ovrHmdCap_DynamicPrediction) ? true : false,
+                                         RenderingConfigured);
+        }
+    }
+
+    if ((EnabledHmdCaps ^ hmdCaps) & ovrHmdCap_NoVSync)
+    {
+        TimeManager.SetVsync((hmdCaps & ovrHmdCap_NoVSync) ? false : true);
+    }
+
+    if ((EnabledHmdCaps ^ hmdCaps) & ovrHmdCap_NoMirrorToWindow)
+    {
+#ifdef OVR_OS_WIN32
+        Win32::DisplayShim::GetInstance().UseMirroring = (hmdCaps & ovrHmdCap_NoMirrorToWindow)  ?
+                                                         false : true;
+        if (pWindow)
+        {   // Force window repaint so that stale mirrored image doesn't persist.
+            ::InvalidateRect((HWND)pWindow, 0, true);
+        }
+#endif
+    }
+
+    // TBD: Should this include be only the rendering flags? Otherwise, bits that failed
+    //      modification in Hmd_SetEnabledCaps may mis-match...
+    EnabledHmdCaps             = hmdCaps & ovrHmdCap_Writable_Mask;
+    RenderState.EnabledHmdCaps = EnabledHmdCaps;
+
+
+    // If any of the modifiable service caps changed, call on the service.
+    unsigned prevServiceCaps = EnabledServiceHmdCaps & ovrHmdCap_Writable_Mask;
+    unsigned newServiceCaps  = hmdCaps & ovrHmdCap_Writable_Mask & ovrHmdCap_Service_Mask;
+
+    if (prevServiceCaps ^ newServiceCaps)
+	{
+        EnabledServiceHmdCaps = pClient ? pClient->Hmd_SetEnabledCaps(NetId, newServiceCaps)
+                                : newServiceCaps;
+    }
+}
+
+
+unsigned HMDState::SetEnabledHmdCaps()
+{
+	unsigned serviceCaps = pClient ? pClient->Hmd_GetEnabledCaps(NetId) :
+                                      EnabledServiceHmdCaps;
+    
+    return serviceCaps & ((~ovrHmdCap_Service_Mask) | EnabledHmdCaps);    
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Property Access
+
+// FIXME: Remove the EGetBoolValue stuff and do it with a "Server:" prefix, so we do not
+// need to keep a white-list of keys.  This is also way cool because it allows us to add
+// new settings keys from outside CAPI that can modify internal server data.
+
+bool HMDState::getBoolValue(const char* propertyName, bool defaultVal)
+{
+    if (NetSessionCommon::IsServiceProperty(NetSessionCommon::EGetBoolValue, propertyName))
+    {
+       return NetClient::GetInstance()->GetBoolValue(GetNetId(), propertyName, defaultVal);
+    }
+    else if (pProfile)
+    {
+        return pProfile->GetBoolValue(propertyName, defaultVal);
+    }
+    return defaultVal;
+}
+
+bool HMDState::setBoolValue(const char* propertyName, bool value)
+{
+    NetClient::GetInstance()->SetBoolValue(GetNetId(), propertyName, value);
+    return true;
+}
+
+int HMDState::getIntValue(const char* propertyName, int defaultVal)
+{
+    if (NetSessionCommon::IsServiceProperty(NetSessionCommon::EGetIntValue, propertyName))
+    {
+        return NetClient::GetInstance()->GetIntValue(GetNetId(), propertyName, defaultVal);
+    }
+    else if (pProfile)
+    {
+        return pProfile->GetIntValue(propertyName, defaultVal);
+    }
+    return defaultVal;
+}
+
+bool HMDState::setIntValue(const char* propertyName, int value)
+{
+    NetClient::GetInstance()->SetIntValue(GetNetId(), propertyName, value);
+    return true;
+}
+
+float HMDState::getFloatValue(const char* propertyName, float defaultVal)
+{
+    if (OVR_strcmp(propertyName, "LensSeparation") == 0)
+    {
+        return OurHMDInfo.LensSeparationInMeters;
+    }
+    else if (OVR_strcmp(propertyName, "VsyncToNextVsync") == 0) 
+    {
+        return OurHMDInfo.Shutter.VsyncToNextVsync;
+    }
+    else if (OVR_strcmp(propertyName, "PixelPersistence") == 0) 
+    {
+        return OurHMDInfo.Shutter.PixelPersistence;
+    }
+    else if (NetSessionCommon::IsServiceProperty(NetSessionCommon::EGetNumberValue, propertyName))
+    {
+       return (float)NetClient::GetInstance()->GetNumberValue(GetNetId(), propertyName, defaultVal);
+    }
+    else if (pProfile)
+    {
+        return pProfile->GetFloatValue(propertyName, defaultVal);
+    }
+
+    return defaultVal;
+}
+
+bool HMDState::setFloatValue(const char* propertyName, float value)
+{
+    NetClient::GetInstance()->SetNumberValue(GetNetId(), propertyName, value);
+    return true;
+}
+
+static unsigned CopyFloatArrayWithLimit(float dest[], unsigned destSize,
+                                        float source[], unsigned sourceSize)
+{
+    unsigned count = Alg::Min(destSize, sourceSize);
+    for (unsigned i = 0; i < count; i++)
+        dest[i] = source[i];
+    return count;
+}
+
+unsigned HMDState::getFloatArray(const char* propertyName, float values[], unsigned arraySize)
+{
+	if (arraySize)
+	{
+		if (OVR_strcmp(propertyName, "ScreenSize") == 0)
+		{
+			float data[2] = { OurHMDInfo.ScreenSizeInMeters.w, OurHMDInfo.ScreenSizeInMeters.h };
+
+            return CopyFloatArrayWithLimit(values, arraySize, data, 2);
+		}
+        else if (OVR_strcmp(propertyName, "DistortionClearColor") == 0)
+        {
+            return CopyFloatArrayWithLimit(values, arraySize, RenderState.ClearColor, 4);
+        }
+        else if (OVR_strcmp(propertyName, "DK2Latency") == 0)
+        {
+            if (OurHMDInfo.HmdType != HmdType_DK2)
+            {
+                return 0;
+            }
+
+            float data[3];            
+            TimeManager.GetLatencyTimings(data);
+            
+            return CopyFloatArrayWithLimit(values, arraySize, data, 3);
+        }
+        else if (NetSessionCommon::IsServiceProperty(NetSessionCommon::EGetNumberValues, propertyName))
+        {
+            // Convert floats to doubles
+            double* da = new double[arraySize];
+            for (int i = 0; i < (int)arraySize; ++i)
+            {
+                da[i] = values[i];
+            }
+
+            int count = NetClient::GetInstance()->GetNumberValues(GetNetId(), propertyName, da, (int)arraySize);
+
+            for (int i = 0; i < count; ++i)
+            {
+                values[i] = (float)da[i];
+            }
+
+            delete[] da;
+
+            return count;
+        }
+		else if (pProfile)
+		{        
+			// TBD: Not quite right. Should update profile interface, so that
+			//      we can return 0 in all conditions if property doesn't exist.
+		
+            return pProfile->GetFloatValues(propertyName, values, arraySize);
+			}
+		}
+
+	return 0;
+}
+
+bool HMDState::setFloatArray(const char* propertyName, float values[], unsigned arraySize)
+{
+    if (!arraySize)
+    {
+        return false;
+    }
+    
+    if (OVR_strcmp(propertyName, "DistortionClearColor") == 0)
+    {
+        CopyFloatArrayWithLimit(RenderState.ClearColor, 4, values, arraySize);
+        return true;
+    }
+
+    double* da = new double[arraySize];
+    for (int i = 0; i < (int)arraySize; ++i)
+    {
+        da[i] = values[i];
+    }
+
+    NetClient::GetInstance()->SetNumberValues(GetNetId(), propertyName, da, arraySize);
+
+    delete[] da;
+
+    return true;
+}
+
+const char* HMDState::getString(const char* propertyName, const char* defaultVal)
+{
+    if (NetSessionCommon::IsServiceProperty(NetSessionCommon::EGetStringValue, propertyName))
+    {
+        return NetClient::GetInstance()->GetStringValue(GetNetId(), propertyName, defaultVal);
+    }
+
+	if (pProfile)
+	{
+		LastGetStringValue[0] = 0;
+		if (pProfile->GetValue(propertyName, LastGetStringValue, sizeof(LastGetStringValue)))
+		{
+			return LastGetStringValue;
+		}
+	}
+
+	return defaultVal;
+}
+
+bool HMDState::setString(const char* propertyName, const char* value)
+{
+    NetClient::GetInstance()->SetStringValue(GetNetId(), propertyName, value);
+    return true;
+}
+
+
+//-------------------------------------------------------------------------------------
+// *** Latency Test
+
+bool HMDState::ProcessLatencyTest(unsigned char rgbColorOut[3])
+{    
+    bool result = false;
+
+    result = NetClient::GetInstance()->LatencyUtil_ProcessInputs(Timer::GetSeconds(), rgbColorOut);
+
+#if 0 //def ENABLE_LATENCY_TESTER
+    // Check create.
+    if (pLatencyTester)
+    {
+        if (pLatencyTester->IsConnected())
+        {
+            Color colorToDisplay;
+
+            LatencyUtil.ProcessInputs();
+            result = LatencyUtil.DisplayScreenColor(colorToDisplay);
+            rgbColorOut[0] = colorToDisplay.R;
+            rgbColorOut[1] = colorToDisplay.G;
+            rgbColorOut[2] = colorToDisplay.B;
+        }
+        else
+        {
+            // Disconnect.
+            LatencyUtil.SetDevice(NULL);
+            pLatencyTester = 0;
+            LogText("LATENCY SENSOR disconnected.\n");
+        }
+    }
+    else if (AddLatencyTestCount > 0)
+    {
+        // This might have some unlikely race condition issue which could cause us to miss a device...
+        AddLatencyTestCount = 0;
+
+        pLatencyTester = *GlobalState::pInstance->GetManager()->EnumerateDevices<LatencyTestDevice>().CreateDevice();
+        if (pLatencyTester)
+        {
+            LatencyUtil.SetDevice(pLatencyTester);
+            LogText("LATENCY TESTER connected\n");
+        }        
+    }
+#endif
+    
+    return result;
+}
+
+void HMDState::ProcessLatencyTest2(unsigned char rgbColorOut[3], double startTime)
+{
+    OVR_UNUSED2(rgbColorOut, startTime);
+    /*
+    // Check create.
+    if (!(EnabledHmdCaps & ovrHmdCap_LatencyTest))
+        return;
+
+    if (pLatencyTesterDisplay && !LatencyUtil2.HasDisplayDevice())
+    {
+        if (!pLatencyTesterDisplay->IsConnected())
+        {
+            LatencyUtil2.SetDisplayDevice(NULL);
+        }
+    }
+    else if (AddLatencyTestDisplayCount > 0)
+    {
+        // This might have some unlikely race condition issue
+        // which could cause us to miss a device...
+        AddLatencyTestDisplayCount = 0;
+
+        pLatencyTesterDisplay = *GlobalState::pInstance->GetManager()->
+                                 EnumerateDevices<LatencyTestDevice>().CreateDevice();
+        if (pLatencyTesterDisplay)
+        {
+            LatencyUtil2.SetDisplayDevice(pLatencyTesterDisplay);
+        }
+    }
+
+    if (LatencyUtil2.HasDevice() && pSensor && pSensor->IsConnected())
+    {
+        LatencyUtil2.BeginTest(startTime);
+
+        Color colorToDisplay;
+        LatencyTest2Active = LatencyUtil2.DisplayScreenColor(colorToDisplay);
+        rgbColorOut[0] = colorToDisplay.R;
+        rgbColorOut[1] = colorToDisplay.G;
+        rgbColorOut[2] = colorToDisplay.B;
+    }
+    else
+    {
+        LatencyTest2Active = false;
+    }
+    */
+}
+
+//-------------------------------------------------------------------------------------
+// *** Rendering
+
+bool HMDState::ConfigureRendering(ovrEyeRenderDesc eyeRenderDescOut[2],
+                                  const ovrFovPort eyeFovIn[2],
+                                  const ovrRenderAPIConfig* apiConfig,                                  
+                                  unsigned distortionCaps)
+{
+    ThreadChecker::Scope checkScope(&RenderAPIThreadChecker, "ovrHmd_ConfigureRendering");
+
+    // null -> shut down.
+    if (!apiConfig)
+    {
+        if (pHSWDisplay)
+        {
+            pHSWDisplay->Shutdown();
+            pHSWDisplay.Clear();
+        }
+
+        if (pRenderer)
+            pRenderer.Clear();        
+        RenderingConfigured = false; 
+        return true;
+    }
+
+    if (pRenderer &&
+        (apiConfig->Header.API != pRenderer->GetRenderAPI()))
+    {
+        // Shutdown old renderer.
+        if (pHSWDisplay)
+        {
+            pHSWDisplay->Shutdown();
+            pHSWDisplay.Clear();
+        }
+
+        if (pRenderer)
+            pRenderer.Clear();
+    }
+
+	distortionCaps = distortionCaps & pHmdDesc->DistortionCaps;
+
+    // Step 1: do basic setup configuration
+    RenderState.EnabledHmdCaps = EnabledHmdCaps;     // This is a copy... Any cleaner way?
+    RenderState.DistortionCaps = distortionCaps;
+    RenderState.EyeRenderDesc[0] = RenderState.CalcRenderDesc(ovrEye_Left,  eyeFovIn[0]);
+    RenderState.EyeRenderDesc[1] = RenderState.CalcRenderDesc(ovrEye_Right, eyeFovIn[1]);
+    eyeRenderDescOut[0] = RenderState.EyeRenderDesc[0];
+    eyeRenderDescOut[1] = RenderState.EyeRenderDesc[1];
+
+    TimeManager.ResetFrameTiming(0,
+                                 (EnabledHmdCaps & ovrHmdCap_DynamicPrediction) ? true : false,
+                                 true);
+
+    LastFrameTimeSeconds = 0.0f;
+
+    // Set RenderingConfigured early to avoid ASSERTs in renderer initialization.
+    RenderingConfigured = true;
+
+    if (!pRenderer)
+    {
+        pRenderer = *DistortionRenderer::APICreateRegistry
+                        [apiConfig->Header.API](pHmdDesc, TimeManager, RenderState);
+    }
+
+    if (!pRenderer ||
+        !pRenderer->Initialize(apiConfig, distortionCaps))
+    {
+        RenderingConfigured = false;
+        return false;
+    }    
+
+    // Setup the Health and Safety Warning display system.
+    if(pHSWDisplay && (pHSWDisplay->GetRenderAPIType() != apiConfig->Header.API)) // If we need to reconstruct the HSWDisplay for a different graphics API type, delete the existing display.
+    {
+        pHSWDisplay->Shutdown();
+        pHSWDisplay.Clear();
+    }
+
+    if(!pHSWDisplay) // Use * below because that for of operator= causes it to inherit the refcount the factory gave the object.
+        pHSWDisplay = *OVR::CAPI::HSWDisplay::Factory(apiConfig->Header.API, pHmdDesc, RenderState);
+
+    if (pHSWDisplay)
+        pHSWDisplay->Initialize(apiConfig); // This is potentially re-initializing it with a new config.
+
+    return true;
+}
+
+
+void  HMDState::SubmitEyeTextures(const ovrPosef renderPose[2],
+                                  const ovrTexture eyeTexture[2])
+{
+    RenderState.EyeRenderPoses[0] = renderPose[0];
+    RenderState.EyeRenderPoses[1] = renderPose[1];
+
+    if (pRenderer)
+    {
+        pRenderer->SubmitEye(0, &eyeTexture[0]);
+        pRenderer->SubmitEye(1, &eyeTexture[1]);
+    }
+}
+
+
+// I appreciate this is not an idea place for this function, but it didn't seem to be
+// being linked properly when in OVR_CAPI.cpp. 
+// Please relocate if you know of a better place
+ovrBool ovrHmd_CreateDistortionMeshInternal( ovrHmdStruct *  hmd,
+                                             ovrEyeType eyeType, ovrFovPort fov,
+                                             unsigned int distortionCaps,
+                                             ovrDistortionMesh *meshData,
+											 float overrideEyeReliefIfNonZero )
+{
+    if (!meshData)
+        return 0;
+    HMDState* hmds = (HMDState*)hmd;
+
+    // Not used now, but Chromatic flag or others could possibly be checked for in the future.
+    OVR_UNUSED1(distortionCaps); 
+   
+#if defined (OVR_OS_WIN32)
+    OVR_COMPILER_ASSERT(sizeof(DistortionMeshVertexData) == sizeof(ovrDistortionVertex));
+#endif
+	
+    // *** Calculate a part of "StereoParams" needed for mesh generation
+
+    // Note that mesh distortion generation is invariant of RenderTarget UVs, allowing
+    // render target size and location to be changed after the fact dynamically. 
+    // eyeToSourceUV is computed here for convenience, so that users don't need
+    // to call ovrHmd_GetRenderScaleAndOffset unless changing RT dynamically.
+
+    const HmdRenderInfo&  hmdri          = hmds->RenderState.RenderInfo;    
+    StereoEye             stereoEye      = (eyeType == ovrEye_Left) ? StereoEye_Left : StereoEye_Right;
+
+    DistortionRenderDesc& distortion = hmds->RenderState.Distortion[eyeType];
+	if (overrideEyeReliefIfNonZero)
+	{
+		distortion.Lens = GenerateLensConfigFromEyeRelief(overrideEyeReliefIfNonZero,hmdri);
+	}
+
+    // Find the mapping from TanAngle space to target NDC space.
+    ScaleAndOffset2D      eyeToSourceNDC = CreateNDCScaleAndOffsetFromFov(fov);
+
+    int triangleCount = 0;
+    int vertexCount = 0;
+
+    DistortionMeshCreate((DistortionMeshVertexData**)&meshData->pVertexData,
+                         (uint16_t**)&meshData->pIndexData,
+                          &vertexCount, &triangleCount,
+                          (stereoEye == StereoEye_Right),
+                          hmdri, distortion, eyeToSourceNDC);
+
+    if (meshData->pVertexData)
+    {
+        // Convert to index
+        meshData->IndexCount = triangleCount * 3;
+        meshData->VertexCount = vertexCount;
+        return 1;
+    }
+
+    return 0;
+}
+
+
+
+}} // namespace OVR::CAPI
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,301 @@
+/************************************************************************************
+
+Filename    :   CAPI_HMDState.h
+Content     :   State associated with a single HMD
+Created     :   January 24, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HMDState_h
+#define OVR_CAPI_HMDState_h
+
+#include "../Kernel/OVR_Math.h"
+#include "../Kernel/OVR_List.h"
+#include "../Kernel/OVR_Log.h"
+#include "../OVR_CAPI.h"
+
+#include "CAPI_FrameTimeManager.h"
+#include "CAPI_HMDRenderState.h"
+#include "CAPI_DistortionRenderer.h"
+#include "CAPI_HSWDisplay.h"
+
+#include "../Service/Service_NetClient.h"
+#include "../Net/OVR_NetworkTypes.h"
+#include "../Util/Util_LatencyTest2Reader.h"
+
+struct ovrHmdStruct { };
+
+namespace OVR { namespace CAPI {
+
+
+using namespace OVR::Util::Render;
+using namespace OVR::Service;
+using namespace OVR::Net;
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadChecker
+
+// This helper class is used to verify that the API is used according to supported
+// thread safety constraints (is not re-entrant for this and related functions).
+class ThreadChecker
+{
+public:
+
+#ifndef OVR_BUILD_DEBUG
+
+    // In release build, thread checks are disabled.
+    ThreadChecker() { }
+    void Begin(const char* functionName)    { OVR_UNUSED1(functionName); }
+    void End()                              {  }
+
+    // Add thread-re-entrancy check for function scope
+    struct Scope
+    {
+        Scope(ThreadChecker*, const char *) { }
+        ~Scope() { }
+    };
+
+
+#else // OVR_BUILD_DEBUG
+    ThreadChecker() : pFunctionName(0), FirstThread(0)
+    { }
+
+    void Begin(const char* functionName)
+    {        
+        if (!pFunctionName)
+        {
+            pFunctionName = functionName;
+            FirstThread   = GetCurrentThreadId();
+        }
+        else
+        {
+            // pFunctionName may be not null here if function is called internally on the same thread.
+            OVR_ASSERT_LOG((FirstThread == GetCurrentThreadId()),
+                ("%s (threadId=%p) called at the same times as %s (threadId=%p)\n",
+                functionName, GetCurrentThreadId(), pFunctionName, FirstThread) );
+        }        
+    }
+    void End()
+    {
+        pFunctionName = 0;
+        FirstThread   = 0;
+    }
+
+    // Add thread-reentrancy check for function scope.
+    struct Scope
+    {
+        Scope(ThreadChecker* threadChecker, const char *functionName) : pChecker(threadChecker)
+        { pChecker->Begin(functionName); }
+        ~Scope()
+        { pChecker->End(); }
+    private:
+        ThreadChecker* pChecker;
+    };
+
+private:
+    // If not 0, contains the name of the function that first entered the scope.
+    const char * pFunctionName;
+    ThreadId     FirstThread;
+
+#endif // OVR_BUILD_DEBUG
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDState
+
+// Describes a single HMD.
+class HMDState : public ListNode<HMDState>,
+                 public ovrHmdStruct, public NewOverrideBase 
+{
+    void operator=(const HMDState&) { } // Quiet warning.
+
+protected:   
+	HMDState(const OVR::Service::HMDNetworkInfo& netInfo,
+			 const OVR::HMDInfo& hmdInfo,
+			 Profile* profile,
+			 Service::NetClient* client);
+    HMDState(const HMDInfo& src, Profile* profile);
+
+public:   
+    virtual ~HMDState();
+
+    static HMDState* CreateHMDState(Service::NetClient* client, const HMDNetworkInfo& netInfo);
+    static HMDState* CreateHMDState(ovrHmdType hmdType); // Used for debug mode
+
+    // *** Sensor Setup
+
+    bool            ConfigureTracking(unsigned supportedCaps, unsigned requiredCaps);    
+    void            ResetTracking();
+	void			RecenterPose();
+    ovrTrackingState PredictedTrackingState(double absTime);
+
+    // Changes HMD Caps.
+    // Capability bits that are not directly or logically tied to one system (such as sensor)
+    // are grouped here. ovrHmdCap_VSync, for example, affects rendering and timing.
+    void            SetEnabledHmdCaps(unsigned caps);
+    unsigned        SetEnabledHmdCaps();
+
+    bool            ProcessLatencyTest(unsigned char rgbColorOut[3]);
+    void            ProcessLatencyTest2(unsigned char rgbColorOut[3], double startTime);
+    
+    // *** Rendering Setup
+    bool        ConfigureRendering(ovrEyeRenderDesc eyeRenderDescOut[2],
+                                   const ovrFovPort eyeFovIn[2],
+                                   const ovrRenderAPIConfig* apiConfig,                                  
+                                   unsigned distortionCaps);  
+    
+    void        UpdateRenderProfile(Profile* profile);
+
+
+    void        SubmitEyeTextures(const ovrPosef renderPose[2],
+                                  const ovrTexture eyeTexture[2]);
+
+
+    void sharedInit ( Profile *profile );
+
+    void applyProfileToSensorFusion();
+
+    // INlines so that they can be easily compiled out.    
+    // Does debug ASSERT checks for functions that require BeginFrame.
+    // Also verifies that we are on the right thread.
+    void checkBeginFrameScope(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(BeginFrameCalled == true,
+                       ("%s called outside ovrHmd_BeginFrame.", functionName));
+        OVR_ASSERT_LOG(BeginFrameThreadId == OVR::GetCurrentThreadId(),
+                       ("%s called on a different thread then ovrHmd_BeginFrame.", functionName));
+    }
+
+    void checkRenderingConfigured(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(RenderingConfigured == true,
+                       ("%s called without ovrHmd_ConfigureRendering.", functionName));
+    }
+
+    void checkBeginFrameTimingScope(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(BeginFrameTimingCalled == true,
+                       ("%s called outside ovrHmd_BeginFrameTiming.", functionName));
+    }
+
+	// Get properties by name.
+    bool     getBoolValue(const char* propertyName, bool defaultVal);
+    bool     setBoolValue(const char* propertyName, bool value);
+    int      getIntValue(const char* propertyName, int defaultVal);
+    bool     setIntValue(const char* propertyName, int value);
+    float    getFloatValue(const char* propertyName, float defaultVal);
+    bool     setFloatValue(const char* propertyName, float value);
+	unsigned getFloatArray(const char* propertyName, float values[], unsigned arraySize);
+    bool     setFloatArray(const char* propertyName, float values[], unsigned arraySize);
+    const char* getString(const char* propertyName, const char* defaultVal);
+    bool        setString(const char* propertyName, const char* value);
+
+	VirtualHmdId GetNetId() { return NetId; }
+
+public:
+	Ptr<Profile>            pProfile;
+    // Descriptor that gets allocated and returned to the user as ovrHmd.
+    ovrHmdDesc*             pHmdDesc;
+    // Window handle passed in AttachWindow.
+    void*                   pWindow;
+
+	// Network
+	Service::NetClient*     pClient;
+	VirtualHmdId            NetId;
+	HMDNetworkInfo          NetInfo;
+
+    // HMDInfo shouldn't change, as its string pointers are passed out.    
+    HMDInfo                 OurHMDInfo;
+
+    const char*             pLastError;
+
+    // Caps enabled for the HMD.
+    unsigned                EnabledHmdCaps;
+    
+    // Caps actually sent to the Sensor Service
+    unsigned                EnabledServiceHmdCaps;
+    
+    // These are the flags actually applied to the Sensor device,
+    // used to track whether SetDisplayReport calls are necessary.
+    //unsigned                HmdCapsAppliedToSensor;
+    
+    // *** Sensor
+    Tracking::CombinedSharedStateReader SharedStateReader;
+    Tracking::SensorStateReader         TheSensorStateReader;
+    Util::RecordStateReader             TheLatencyTestStateReader;
+
+    bool                    LatencyTestActive;
+    unsigned char           LatencyTestDrawColor[3];
+
+    bool                    LatencyTest2Active;
+    unsigned char           LatencyTest2DrawColor[3];
+
+    // Rendering part
+    FrameTimeManager        TimeManager;
+    HMDRenderState          RenderState;
+    Ptr<DistortionRenderer> pRenderer;
+
+    // Health and Safety Warning display.
+    Ptr<HSWDisplay>         pHSWDisplay;
+
+    // Last timing value reported by BeginFrame.
+    double                  LastFrameTimeSeconds;    
+    // Last timing value reported by GetFrameTime. These are separate since the intended
+    // use is from different threads. TBD: Move to FrameTimeManager? Make atomic?
+    double                  LastGetFrameTimeSeconds;
+
+    // Last cached value returned by ovrHmd_GetString/ovrHmd_GetStringArray.
+    char                    LastGetStringValue[256];
+   
+    // Debug flag set after ovrHmd_ConfigureRendering succeeds.
+    bool                    RenderingConfigured;
+    // Set after BeginFrame succeeds, and its corresponding thread id for debug checks.
+    bool                    BeginFrameCalled;
+    ThreadId                BeginFrameThreadId;    
+    // Graphics functions are not re-entrant from other threads.
+    ThreadChecker           RenderAPIThreadChecker;
+    // 
+    bool                    BeginFrameTimingCalled;
+};
+
+
+
+
+//I appreciate this isn't an idea place for this function prototype, but needed
+//to be seen by OVR_CAPI.cpp and the various SDK renderers of CAPI,
+//and have everything defined.  Please move to a better place if you know of one.
+ovrBool ovrHmd_CreateDistortionMeshInternal( ovrHmdStruct *  hmd,
+                                             ovrEyeType eyeType, ovrFovPort fov,
+                                             unsigned int distortionCaps,
+                                             ovrDistortionMesh *meshData,
+											 float overrideEyeReliefIfNonZero=0 );
+
+
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_HMDState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,473 @@
+/************************************************************************************
+
+Filename    :   CAPI_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 3, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_HSWDisplay.h"
+#include "CAPI_HMDState.h"
+#include "../Kernel/OVR_Log.h"
+#include "../Kernel/OVR_String.h"
+#include "Textures/healthAndSafety.tga.h" // TGA file as a C array declaration.
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_DEBUGGING
+//
+// Defined as 0 or 1. Enables debugging features of this module.
+
+#if !defined(HSWDISPLAY_DEBUGGING)
+    #if defined(AUTHOR_PPEDRIANA)
+        #define HSWDISPLAY_DEBUGGING 1
+    #else
+        #define HSWDISPLAY_DEBUGGING 0
+    #endif
+#endif
+
+#if HSWDISPLAY_DEBUGGING
+    OVR_DISABLE_ALL_MSVC_WARNINGS()
+    #include <winsock2.h>
+    #include <Windows.h>
+    OVR_RESTORE_ALL_MSVC_WARNINGS()
+#endif
+
+OVR_DISABLE_MSVC_WARNING(4996) // "This function or variable may be unsafe..."
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_DEFAULT_ENABLED
+//
+// Defined as 0 or 1. 1 is default. If 0 then by default HSWDisplay is disabled.
+// Developers can set it to 0 to disable HSW display.
+//
+#if !defined(HSWDISPLAY_DEFAULT_ENABLED)
+    #define HSWDISPLAY_DEFAULT_ENABLED 1
+#endif
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** Experimental C API functions
+//
+
+extern "C"
+{
+    OVR_EXPORT void ovrhmd_EnableHSWDisplaySDKRender(ovrHmd hmd, ovrBool enabled)
+    {
+        OVR::CAPI::HMDState* pHMDState = (OVR::CAPI::HMDState*)hmd->Handle;
+
+	    if (pHMDState)
+	    {
+            OVR::CAPI::HSWDisplay* pHSWDisplay = pHMDState->pHSWDisplay;
+
+            if(pHSWDisplay)
+                pHSWDisplay->EnableRender((enabled == 0) ? false : true);
+        }
+    }
+}
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDisplay implementation
+//
+
+namespace OVR { namespace CAPI {
+
+
+static const time_t HSWDisplayTimeNever = (time_t)0; // Constant which denotes the time of "never", as in the display has never been shown yet.
+
+#define HSWDISPLAY_POLL_INTERVAL            0.400 // Seconds between polling for whether the display should be shown.
+#define OVR_KEY_HSWDISPLAYLASTDISPLAYEDTIME "HASWLastDisplayedTime"
+
+
+#if defined(OVR_BUILD_DEBUG)
+    #define HSWDISPLAY_FIRST_DISMISSAL_TIME    4     // Earliest time in seconds until the user can dismiss the display.
+    #define HSWDISPLAY_REGULAR_DISMISSAL_TIME  2
+#else
+    #define HSWDISPLAY_FIRST_DISMISSAL_TIME   15
+    #define HSWDISPLAY_REGULAR_DISMISSAL_TIME  6
+#endif
+
+
+HSWDisplay::HSWDisplay(ovrRenderAPIType renderAPIType, ovrHmd hmd, const HMDRenderState& hmdRenderState)
+  : Enabled(HSWDISPLAY_DEFAULT_ENABLED ? true : false),
+    Displayed(false),
+    SDKRendered(false),
+    DismissRequested(false),
+    RenderEnabled(true),
+    StartTime(0.0),
+    DismissibleTime(0.0),
+    LastPollTime(0.0),
+    HMD(hmd), 
+    HMDMounted(false),
+    HMDNewlyMounted(false),
+    RenderAPIType(renderAPIType), 
+    RenderState(hmdRenderState)
+{
+}
+
+
+HSWDisplay::~HSWDisplay()
+{
+    // To consider: assert that we are already shut down.
+    HSWDisplay::Shutdown();
+}
+
+
+void HSWDisplay::Enable(bool enable)
+{
+    Enabled = enable;
+
+    if(!enable && Displayed) // If it's visible but should not be...
+        Dismiss();
+}
+
+
+void HSWDisplay::EnableRender(bool enable)
+{
+    RenderEnabled = enable;
+}
+
+
+void HSWDisplay::Display()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay] Display()"));
+
+    DisplayInternal();
+
+    HMDNewlyMounted = false;
+    Displayed = true;
+    SDKRendered = RenderEnabled;
+    StartTime = ovr_GetTimeInSeconds();
+
+    const time_t lastDisplayedTime = HSWDisplay::GetCurrentProfileLastHSWTime();
+    DismissibleTime = StartTime + ((lastDisplayedTime == HSWDisplayTimeNever) ? HSWDISPLAY_FIRST_DISMISSAL_TIME : HSWDISPLAY_REGULAR_DISMISSAL_TIME);
+
+    SetCurrentProfileLastHSWTime(time(NULL));
+}
+
+
+bool HSWDisplay::IsDisplayViewable() const
+{
+    // This function is called IsDisplayViewable, but currently it refers only to whether the 
+    // HMD is mounted on the user's head. 
+
+    return HMDMounted;
+}
+
+
+bool HSWDisplay::Dismiss()
+{
+    #if HSWDISPLAY_DEBUGGING
+        if(GetKeyState(VK_SCROLL) & 0x0001) // If the scroll lock key is toggled on...
+            return false;                   // Make it so that the display doesn't dismiss, so we can debug this.
+    #endif
+
+    // If dismissal is not requested yet, mark it as such.
+    bool newlyRequested = false;
+
+    if(!DismissRequested)
+    {
+        DismissRequested = true;
+        newlyRequested = true;
+    }
+
+    // If displayed and time has elapsed, do the dismissal.
+    OVR_ASSERT(DismissibleTime <= (ovr_GetTimeInSeconds() + HSWDISPLAY_FIRST_DISMISSAL_TIME)); // Make sure the dismissal time is sane.
+    if (Displayed && (ovr_GetTimeInSeconds() >= DismissibleTime))
+    {
+        DismissInternal();
+        Displayed = false;
+        DismissRequested = false;
+        SDKRendered = false;
+        return true;
+    }
+
+    if(newlyRequested)
+        { HSWDISPLAY_LOG(("[HSWDisplay] Dismiss(): Not permitted yet. Queued for timeout in %.1f seconds.", DismissibleTime - ovr_GetTimeInSeconds())); }
+
+    return false; // Cannot dismiss yet.
+}
+
+
+bool HSWDisplay::TickState(ovrHSWDisplayState *hswDisplayState)
+{
+    bool newlyDisplayed = false;
+    const double currentTime = ovr_GetTimeInSeconds();
+
+    // See if we need to be currently displayed. By design we automatically display but don't automatically dismiss.
+    if (Displayed)
+    {
+        if (DismissRequested) // If dismiss was previously requested, see if it can be executed.
+            Dismiss();
+
+        if (Displayed) // If not already dismissed above...
+        {
+            // We currently have the debug behavior that we permit dismiss very soon after launch.
+            #if defined(OVR_BUILD_DEBUG)
+                if(currentTime >= (StartTime + 2))
+                {
+                    DismissibleTime = StartTime;
+                    //Dismiss();
+                }
+            #endif
+        }
+
+        if (Displayed) // If not already dismissed above...
+        {
+            const ovrTrackingState ts = ((OVR::CAPI::HMDState*)HMD->Handle)->PredictedTrackingState(currentTime);
+
+            if (ts.StatusFlags & ovrStatus_OrientationTracked) // If the Accelerometer data is valid...
+            {
+				const OVR::Vector3f v(ts.HeadPose.LinearAcceleration.x, ts.HeadPose.LinearAcceleration.y, ts.HeadPose.LinearAcceleration.z);
+
+                const float minTapMagnitude = 350.0f; // Empirically determined by some testing.
+
+                if (v.LengthSq() > minTapMagnitude)
+                    Dismiss(); // This will do nothing if the display is not present.
+            }
+        }
+    }
+    else
+    {
+        if (Enabled && (currentTime >= (LastPollTime + HSWDISPLAY_POLL_INTERVAL)))
+        {
+            LastPollTime = currentTime;
+
+            // We need to display if any of the following are true:
+            //     - The application is just started in Event Mode while the HMD is mounted (warning display would be viewable) and this app was not spawned from a launcher.
+            //     - The current user has never seen the display yet while the HMD is mounted (warning display would be viewable).
+            //     - The HMD is newly mounted (or the warning display is otherwise newly viewable).
+            //     - The warning display hasn't shown in 24 hours (need to verify this as a requirement).
+            // Event Mode refers to when the app is being run in a public demo event such as a trade show.
+
+            OVR::CAPI::HMDState* pHMDState = (OVR::CAPI::HMDState*)HMD->Handle;
+
+            if(pHMDState)
+            {
+                const time_t lastDisplayedTime = HSWDisplay::GetCurrentProfileLastHSWTime();
+
+                // We currently unilaterally set HMDMounted to true because we don't yet have the ability to detect this. To do: Implement this when possible.
+                const bool previouslyMounted = HMDMounted;
+                HMDMounted = true;
+                HMDNewlyMounted = (!previouslyMounted && HMDMounted); // We set this back to false in the Display function or if the HMD is unmounted before then.
+
+                if((lastDisplayedTime == HSWDisplayTimeNever) || HMDNewlyMounted)
+                {
+                    if(IsDisplayViewable()) // If the HMD is mounted and otherwise being viewed by the user...
+                    {
+                        Display();
+                        newlyDisplayed = true;
+                    }
+                }
+            }
+        }
+    }
+
+    if(hswDisplayState)
+        GetState(hswDisplayState);
+
+    return newlyDisplayed;
+}
+
+
+void HSWDisplay::GetState(ovrHSWDisplayState *hswDisplayState) const
+{
+    // Return the state to the caller.
+    OVR_ASSERT(hswDisplayState != NULL);
+    hswDisplayState->Displayed = Displayed;
+    hswDisplayState->StartTime = StartTime;
+    hswDisplayState->DismissibleTime = DismissibleTime;
+}
+
+
+void HSWDisplay::Render(ovrEyeType eye, const ovrTexture* eyeTexture)
+{
+    SDKRendered = true;
+    RenderInternal(eye, eyeTexture);
+}
+
+// Persist the HSW settings on the server, since it needs to be synchronized across all applications.
+// Note that the profile manager singleton cannot be used for this task because it overwrites the global
+// settings for which the rift config tool is supposed to be authoritative.  That also would step on the
+// settings generated by other rift apps.  The server settings, however, are synchronized for all apps
+// and so are appropriate for this task.
+static String getHSWTimeKey(const char* userName)
+{
+    String keyName = "server:";
+    keyName += OVR_KEY_HSWDISPLAYLASTDISPLAYEDTIME;
+    keyName += ":";
+    if (userName)
+    {
+        keyName += userName;
+    }
+    return keyName;
+}
+
+// Returns HSWDisplayTimeNever (0) if there is no profile or this is the first time we are seeing this profile.
+time_t HSWDisplay::GetCurrentProfileLastHSWTime() const
+{
+    // We store the timeout value in HMDState's pProfile.
+    HMDState* pHMDState = (HMDState*)HMD->Handle;
+
+    if (pHMDState)
+    {
+        const char* profileName = pHMDState->pProfile ? pHMDState->pProfile->GetValue(OVR_KEY_USER) : NULL;
+
+        if (profileName)
+        {
+            if (LastProfileName == profileName)
+            {
+                return LastHSWTime;
+            }
+
+            LastProfileName = profileName;
+            String timeKey = getHSWTimeKey(profileName);
+            int lastTime = pHMDState->getIntValue(timeKey.ToCStr(), (int)HSWDisplayTimeNever);
+
+            LastHSWTime = lastTime;
+            return lastTime;
+        }
+    }
+
+    return HSWDisplayTimeNever;
+}
+
+void HSWDisplay::SetCurrentProfileLastHSWTime(time_t t)
+{
+    // The timeout value is stored in HMDState's pProfile.
+    HMDState* pHMDState = (HMDState*)HMD->Handle;
+
+    if (pHMDState)
+    {
+        const char* profileName = pHMDState->pProfile ? pHMDState->pProfile->GetValue(OVR_KEY_USER) : NULL;
+
+        if (profileName)
+        {
+            LastProfileName = profileName;
+            LastHSWTime = (int)t;
+
+            String timeKey = getHSWTimeKey(profileName);
+            pHMDState->setIntValue(timeKey.ToCStr(), (int)t);
+        }
+    }
+}
+
+
+// Generates an appropriate stereo ortho projection matrix.
+void HSWDisplay::GetOrthoProjection(const HMDRenderState& RenderState, Matrix4f OrthoProjection[2])
+{
+    Matrix4f perspectiveProjection[2];
+    perspectiveProjection[0] = ovrMatrix4f_Projection(RenderState.EyeRenderDesc[0].Fov, 0.01f, 10000.f, true);
+    perspectiveProjection[1] = ovrMatrix4f_Projection(RenderState.EyeRenderDesc[1].Fov, 0.01f, 10000.f, true);
+
+    const float    orthoDistance = HSWDISPLAY_DISTANCE; // This is meters from the camera (viewer) that we place the ortho plane.
+    const Vector2f orthoScale0   = Vector2f(1.f) / Vector2f(RenderState.EyeRenderDesc[0].PixelsPerTanAngleAtCenter);
+    const Vector2f orthoScale1   = Vector2f(1.f) / Vector2f(RenderState.EyeRenderDesc[1].PixelsPerTanAngleAtCenter);
+    
+    OrthoProjection[0] = ovrMatrix4f_OrthoSubProjection(perspectiveProjection[0], orthoScale0, orthoDistance, RenderState.EyeRenderDesc[0].ViewAdjust.x);
+    OrthoProjection[1] = ovrMatrix4f_OrthoSubProjection(perspectiveProjection[1], orthoScale1, orthoDistance, RenderState.EyeRenderDesc[1].ViewAdjust.x);
+}
+
+
+const uint8_t* HSWDisplay::GetDefaultTexture(size_t& TextureSize)
+{
+    TextureSize = sizeof(healthAndSafety_tga);
+    return healthAndSafety_tga;
+}
+
+
+
+}} // namespace OVR::CAPI
+
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDisplay factory
+//
+
+#if defined (OVR_OS_WIN32)
+    #define OVR_D3D_VERSION 9
+    #include "D3D1X/CAPI_D3D9_HSWDisplay.h"
+    #undef  OVR_D3D_VERSION
+
+    #define OVR_D3D_VERSION 10
+    #include "D3D1X/CAPI_D3D10_HSWDisplay.h"
+    #undef  OVR_D3D_VERSION
+
+    #define OVR_D3D_VERSION 11
+    #include "D3D1X/CAPI_D3D11_HSWDisplay.h"
+    #undef  OVR_D3D_VERSION
+#endif
+
+#include "GL/CAPI_GL_HSWDisplay.h"
+
+
+OVR::CAPI::HSWDisplay* OVR::CAPI::HSWDisplay::Factory(ovrRenderAPIType apiType, ovrHmd hmd, const OVR::CAPI::HMDRenderState& renderState)
+{
+    OVR::CAPI::HSWDisplay* pHSWDisplay = NULL;
+
+    switch (apiType)
+    {
+        case ovrRenderAPI_None:
+            pHSWDisplay = new OVR::CAPI::HSWDisplay(apiType, hmd, renderState);
+            break;
+
+        case ovrRenderAPI_OpenGL:
+            pHSWDisplay = new OVR::CAPI::GL::HSWDisplay(apiType, hmd, renderState);
+            break;
+
+    #if defined(OVR_OS_WIN32)
+        case ovrRenderAPI_D3D9:
+            pHSWDisplay = new OVR::CAPI::D3D9::HSWDisplay(apiType, hmd, renderState);
+            break;
+
+        case ovrRenderAPI_D3D10:
+            pHSWDisplay = new OVR::CAPI::D3D10::HSWDisplay(apiType, hmd, renderState);
+            break;
+
+        case ovrRenderAPI_D3D11:
+            pHSWDisplay = new OVR::CAPI::D3D11::HSWDisplay(apiType, hmd, renderState);
+            break;
+    #else
+        case ovrRenderAPI_D3D9:
+        case ovrRenderAPI_D3D10:
+        case ovrRenderAPI_D3D11: // Fall through
+    #endif
+
+        // Handle unsupported cases.
+        case ovrRenderAPI_Android_GLES:
+        case ovrRenderAPI_Count: // This is not actually a type.
+        default:
+            break;
+    }
+
+    return pHSWDisplay;
+}
+
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,245 @@
+/************************************************************************************
+
+Filename    :   CAPI_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 3, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HSWDisplay_h
+#define OVR_CAPI_HSWDisplay_h
+
+#include "../OVR_CAPI.h"
+#include "CAPI_HMDRenderState.h"
+#include <time.h>
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_LOG
+//
+// Debug log wrapper.
+
+#if !defined(HSWDISPLAY_LOG_ENABLED)
+    #ifdef OVR_BUILD_DEBUG
+        #define HSWDISPLAY_LOG_ENABLED 1
+    #else
+        #define HSWDISPLAY_LOG_ENABLED 0
+    #endif
+#endif
+
+#if HSWDISPLAY_LOG_ENABLED
+    #define HSWDISPLAY_LOG(...) OVR_DEBUG_LOG(__VA_ARGS__)
+#else
+    #define HSWDISPLAY_LOG(...)
+#endif
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_DISTANCE
+//
+// Floating point value in the range of ~0.75 to ~3.0 which controls the distance 
+// (in meters) of the display from the viewer.
+
+#ifndef HSWDISPLAY_DISTANCE
+    #define HSWDISPLAY_DISTANCE 1.5f
+#endif
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_SCALE
+//
+// Floating point value in the range of ~0.1 to ~2.0 which controls the size scale of the 
+// SDK-rendered HSW display. The value is an arbitrary relative value, though this may 
+// change in future SDK versions.
+
+#ifndef HSWDISPLAY_SCALE
+    #define HSWDISPLAY_SCALE 0.92f
+#endif
+
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** Experimental C API functions
+//
+// These are currently not formally supported and may be promoted to the formal C API
+// or may be removed in the future.
+
+extern "C"
+{
+    // Normally if an application uses SDK-based distortion rendering 
+    // (ovrHmd_BeginFrame / ovrHmd_EndFrame) then the SDK also takes care of 
+    // drawing the health and safety warning. If an application is using 
+    // SDK-based rendering but wants to draw the warning display itself, 
+    // it call this function with enabled set to false.
+    OVR_EXPORT void ovrhmd_EnableHSWDisplaySDKRender(ovrHmd hmd, ovrBool enabled);
+}
+
+
+namespace OVR { namespace CAPI {
+
+
+//-------------------------------------------------------------------------------------
+// ***** CAPI::HSWDisplay
+//
+// Note: This will be renamed to HSWDisplay in the future.
+//
+// Implements the logic for the Health and Safety (HAS) warning display. Primarily this
+// is two things: providing information about whether the warning needs to be currently
+// displayed, and implementing the display itself. 
+//
+// An HSWDisplay is associated 1:1 with an HMD. There can be at most one HSWDisplay 
+// being displayed on an HMD at a time. If a warning needs to be displayed while an  
+// existing one is present, it replaces the existing one. 
+//
+// Notes
+//    Warnings are displayed per HMD (head mounted display).
+//    The app can have multiple HMDs.
+//    There can be multiple users of a given HMD over time, with each identified by a different user profile.
+//    There can be multiple apps using HMDs.
+//
+//    Shows upon first entering a VR application (or VR mode in an application) when in Event Mode (e.g. trade show).
+//    Shows upon each wearing of the HMD.
+//    If the user profile is switched while display is active, the display must restart.
+//    Doesn't show in app when app was started by a launcher app.
+//
+//    First display ever (per profile): 15 seconds until the display can be dismissed.
+//    Subsequent displays: 6 seconds until the display can be dismissed. Per profile.
+//    Dismissing occurs via HMD tap, designated keypress, gaze detection on OK button for N seconds, 
+//        and possibly via an input gesture in the future.
+//
+//    If the warning fades out upon completion, the fade out should begin after the full display time has elapsed, 
+//        but it needs to avoid interfering (e.g. obscuring) with the application. This likely means the application 
+//        would need to put in a couple seconds delay to allow the fade to complete.
+//    Ideally we'd handle the case of a user switching HMDs and not needing to see the warning again.
+
+class HSWDisplay : public RefCountBase<HSWDisplay>
+{
+public:
+    HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+    virtual ~HSWDisplay();
+
+    // Must be called after construction and before use.
+    virtual bool Initialize(const ovrRenderAPIConfig*)
+        { return true; }
+
+    // Must be called before destruction.
+    virtual void Shutdown() {}
+
+    // Enables or disables the HSW display system. It may be disabled only for development uses.
+    // It is enabled by default. 
+    void Enable(bool enable);
+
+    // Enables or disables our internal rendering when Render is called. If set to false then the 
+    // application is expected to implement drawing of the display when Displayed is true.
+    // It is enabled by default. 
+    void EnableRender(bool enable);
+
+    // Triggers a display of the HSW display for the associated HMD. Restarts the display if 
+    // the warning is already being displayed. 
+    void Display();
+
+    // This function should be called per HMD every frame in order to give this class processing time. 
+    // Returns the new state if newHSWDisplayState is non-NULL. Returns true if the new state results
+    // in a required warning display (ovrHSWDisplayState::Displayed became true).
+    bool TickState(ovrHSWDisplayState *newHSWDisplayState = NULL);
+
+    // Gets the current state of the HSW display. 
+    // Corresponds to ovrhmd_GetHSWDisplayState.
+    void GetState(ovrHSWDisplayState *hasWarningState) const;
+
+    // Removes the HSW display display if the minimum dismissal time has occurred. 
+    // Returns true if the warning display could be dissmissed or was not displayed at the time of the call.
+    // Corresponds to ovrhmd_DismissHSWDisplay.
+    bool Dismiss();
+
+    // Returns true if the HMD appears to be currently mounted and in a state that a 
+    // warning display would be viewable.
+    bool IsDisplayViewable() const;
+
+    // Draws the warning to the eye texture(s). This must be done at the end of a 
+    // frame but prior to executing the distortion rendering of the eye textures. 
+    virtual void Render(ovrEyeType, const ovrTexture*);
+
+    // Resets the current profile's HAS settings (e.g. to act as if the user has never seen the HSW display before).
+    void ResetProfileData();
+
+    // Returns the ovrRenderAPIType. This is essentially the same as RTTI, as it's indicating what subclass
+    // is being used for this.
+    ovrRenderAPIType GetRenderAPIType() const // e.g. ovrRenderAPI_D3D11
+        { return RenderAPIType; }
+
+    // Returns the required HSW display text for the current profile's locale. 
+    // Useful for implementing custom warning displays. Returns the required strlen 
+    // of the text, and thus success is indicated by a return value < strCapacity.
+    // size_t GetText(char *str, size_t strCapacity);
+
+    // Creates and constructs an instance of an HSWDisplay subclass based on the API type.
+    static HSWDisplay* Factory(ovrRenderAPIType apiType, ovrHmd hmd, const HMDRenderState& renderState);
+
+private:
+    OVR_NON_COPYABLE(HSWDisplay)
+
+protected:
+    virtual void DisplayInternal() {}
+    virtual void DismissInternal() {}
+    virtual void RenderInternal(ovrEyeType, const ovrTexture*) {}
+
+    // Profile functionality
+    time_t GetCurrentProfileLastHSWTime() const;
+    void   SetCurrentProfileLastHSWTime(time_t t);
+
+    // Generates an appropriate stereo ortho projection matrix.
+    static void GetOrthoProjection(const HMDRenderState& RenderState, Matrix4f OrthoProjection[2]);
+
+    // Returns the default HSW display texture data.
+    static const uint8_t* GetDefaultTexture(size_t& TextureSize);
+
+protected:
+    bool                   Enabled;            // If true then the HSW display system is enabled. True by default. 
+    bool                   Displayed;          // If true then the warning is currently visible and the following variables have meaning. Else there is no warning being displayed for this application on the given HMD.
+    bool                   SDKRendered;        // If true then the display is being rendered by the SDK as opposed to the application. 
+    bool                   DismissRequested;   // If true then the warning has been requested to be hidden.
+    bool                   RenderEnabled;      // If true then we handle rendering when Render is called. Else we skip it and assume the application is otherwise handling it itself.
+    double                 StartTime;          // Absolute time when the warning was first displayed. See ovr_GetTimeInSeconds().
+    double                 DismissibleTime;    // Absolute time when the warning can be dismissed.
+    double                 LastPollTime;       // Used to prevent us from polling the required display state every frame but rather more like every 200 milliseconds.
+    const ovrHmd           HMD;                // The HMDState this HSWDisplay instance corresponds to.
+    mutable bool           HMDMounted;         // True if the HMD was most recently found to be mounted. We need this in order to maintain HMDNewlyMounted.
+    mutable bool           HMDNewlyMounted;    // True if HMDMounted has transitioned from false to true. We need this in order to tell if the HMD was recently mounted so we can display the HSW display.
+    bool                   EventMode;          // True if the application is being run in Event Mode, which means it's running at a trade show or similar public demo.
+    const ovrRenderAPIType RenderAPIType;      // e.g. ovrRenderAPI_D3D11
+    const HMDRenderState&  RenderState;        // Information about the rendering setup.
+
+    // Settings cache
+    mutable String         LastProfileName;
+    mutable int            LastHSWTime;
+
+}; // class HSWDisplay
+
+
+
+}} // namespace OVR::CAPI
+
+
+#endif // OVR_CAPI_HSWDisplay_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,29 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_DistortionRenderer.cpp
+Content     :   Distortion renderer instantiation for D3D10
+Created     :   November 11, 2013
+Authors     :   Volga Aksoy, Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#define OVR_D3D_VERSION 10
+#include "CAPI_D3D1X_Util.cpp"
+#include "CAPI_D3D1X_DistortionRenderer.cpp"
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,34 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_DistortionRenderer.h
+Content     :   Distortion renderer header for D3D10
+Created     :   November 11, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_CAPI_D3D10_DistortionRenderer_h
+#define INC_CAPI_D3D10_DistortionRenderer_h
+
+#define OVR_D3D_VERSION 10
+#include "CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,35 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#define OVR_D3D_VERSION 10
+#include "CAPI_D3D1X_HSWDisplay.cpp"
+#undef  OVR_D3D_VERSION
+
+
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,41 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D10_HSWDisplay_h
+#define OVR_CAPI_D3D10_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+// Due to the similarities between DX10 and DX11, there is a shared implementation of the headers and source
+// which is differentiated only by the OVR_D3D_VERSION define. This define causes D3D_NS (D3D namespace) to 
+// be defined to either D3D10 or D3D11, as well as other similar effects. 
+#include "CAPI_D3D1X_HSWDisplay.h"
+
+
+#endif // OVR_CAPI_D3D10_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,30 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_DistortionRenderer.cpp
+Content     :   Distortion renderer instantiation for D3D11
+Created     :   November 11, 2013
+Authors     :   Volga Aksoy, Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#define OVR_D3D_VERSION 11
+#include "CAPI_D3D1X_Util.cpp"
+#include "CAPI_D3D1X_DistortionRenderer.cpp"
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,34 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_DistortionRenderer.h
+Content     :   Distortion renderer header for D3D11
+Created     :   November 11, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_CAPI_D3D11_DistortionRenderer_h
+#define INC_CAPI_D3D11_DistortionRenderer_h
+
+#define OVR_D3D_VERSION 11
+#include "CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,35 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#define OVR_D3D_VERSION 11
+#include "CAPI_D3D1X_HSWDisplay.cpp"
+#undef  OVR_D3D_VERSION
+
+
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,41 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D11_HSWDisplay_h
+#define OVR_CAPI_D3D11_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+// Due to the similarities between DX10 and DX11, there is a shared implementation of the headers and source
+// which is differentiated only by the OVR_D3D_VERSION define. This define causes D3D_NS (D3D namespace) to 
+// be defined to either D3D10 or D3D11, as well as other similar effects. 
+#include "CAPI_D3D1X_HSWDisplay.h"
+
+
+#endif // OVR_CAPI_D3D11_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1138 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.cpp
+Content     :   Experimental distortion renderer
+Created     :   November 11, 2013
+Authors     :   Volga Aksoy, Michael Antonov, Shariq Hashme
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_D3D1X_DistortionRenderer.h"
+
+#include "../../OVR_CAPI_D3D.h"
+#include "../../Kernel/OVR_Color.h"
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+#include "../Shaders/Distortion_vs.h"
+#include "../Shaders/Distortion_vs_refl.h"
+#include "../Shaders/Distortion_ps.h"
+#include "../Shaders/Distortion_ps_refl.h"
+#include "../Shaders/DistortionChroma_vs.h"
+#include "../Shaders/DistortionChroma_vs_refl.h"
+#include "../Shaders/DistortionChroma_ps.h"
+#include "../Shaders/DistortionChroma_ps_refl.h"
+#include "../Shaders/DistortionTimewarp_vs.h"
+#include "../Shaders/DistortionTimewarp_vs_refl.h"
+#include "../Shaders/DistortionTimewarpChroma_vs.h"
+#include "../Shaders/DistortionTimewarpChroma_vs_refl.h"
+    
+#include "../Shaders/SimpleQuad_vs.h"
+#include "../Shaders/SimpleQuad_vs_refl.h"
+#include "../Shaders/SimpleQuad_ps.h"
+#include "../Shaders/SimpleQuad_ps_refl.h"
+
+// Distortion pixel shader lookup.
+//  Bit 0: Chroma Correction
+//  Bit 1: Timewarp
+
+enum {
+    DistortionVertexShaderBitMask = 3,
+    DistortionVertexShaderCount   = DistortionVertexShaderBitMask + 1,
+    DistortionPixelShaderBitMask  = 1,
+    DistortionPixelShaderCount    = DistortionPixelShaderBitMask + 1
+};
+
+struct PrecompiledShader
+{
+    const unsigned char* ShaderData;
+    size_t ShaderSize;
+    const ShaderBase::Uniform* ReflectionData;
+    size_t ReflectionSize;
+};
+
+// Do add a new distortion shader use these macros (with or w/o reflection)
+#define PCS_NOREFL(shader) { shader, sizeof(shader), NULL, 0 }
+#define PCS_REFL__(shader) { shader, sizeof(shader), shader ## _refl, sizeof( shader ## _refl )/sizeof(*(shader ## _refl)) }
+
+
+static PrecompiledShader DistortionVertexShaderLookup[DistortionVertexShaderCount] =
+{
+    PCS_REFL__(Distortion_vs),
+    PCS_REFL__(DistortionChroma_vs),
+    PCS_REFL__(DistortionTimewarp_vs),
+    PCS_REFL__(DistortionTimewarpChroma_vs),
+};
+
+static PrecompiledShader DistortionPixelShaderLookup[DistortionPixelShaderCount] =
+{
+    PCS_NOREFL(Distortion_ps),
+    PCS_REFL__(DistortionChroma_ps)
+};
+
+void DistortionShaderBitIndexCheck()
+{
+    OVR_COMPILER_ASSERT(ovrDistortionCap_Chromatic == 1);
+    OVR_COMPILER_ASSERT(ovrDistortionCap_TimeWarp  == 2);
+}
+
+
+
+struct DistortionVertex
+{
+    Vector2f ScreenPosNDC;
+    Vector2f TanEyeAnglesR;
+    Vector2f TanEyeAnglesG;
+    Vector2f TanEyeAnglesB;
+    Color    Col;
+};
+
+
+// Vertex type; same format is used for all shapes for simplicity.
+// Shapes are built by adding vertices to Model.
+struct Vertex
+{
+    Vector3f  Pos;
+    Color     C;
+    float     U, V;	
+    Vector3f  Norm;
+
+    Vertex (const Vector3f& p, const Color& c = Color(64,0,0,255), 
+        float u = 0, float v = 0, Vector3f n = Vector3f(1,0,0))
+        : Pos(p), C(c), U(u), V(v), Norm(n)
+    {}
+    Vertex(float x, float y, float z, const Color& c = Color(64,0,0,255),
+        float u = 0, float v = 0) : Pos(x,y,z), C(c), U(u), V(v)
+    { }
+
+    bool operator==(const Vertex& b) const
+    {
+        return Pos == b.Pos && C == b.C && U == b.U && V == b.V;
+    }
+};
+
+
+//----------------------------------------------------------------------------
+// ***** D3D1X::DistortionRenderer
+
+DistortionRenderer::DistortionRenderer(ovrHmd hmd, FrameTimeManager& timeManager,
+                                       const HMDRenderState& renderState)
+    : CAPI::DistortionRenderer(ovrRenderAPI_D3D11, hmd, timeManager, renderState)
+{
+    EyeTextureSize[0]    = Sizei(0);
+    EyeRenderViewport[0] = Recti();
+    EyeTextureSize[1]    = Sizei(0);
+    EyeRenderViewport[1] = Recti();
+}
+
+DistortionRenderer::~DistortionRenderer()
+{
+    destroy();
+}
+
+// static
+CAPI::DistortionRenderer* DistortionRenderer::Create(ovrHmd hmd,
+                                                     FrameTimeManager& timeManager,
+                                                     const HMDRenderState& renderState)
+{
+    return new DistortionRenderer(hmd, timeManager, renderState);
+}
+
+
+bool DistortionRenderer::Initialize(const ovrRenderAPIConfig* apiConfig,
+                                    unsigned distortionCaps)
+{
+    const ovrD3D1X(Config)* config = (const ovrD3D1X(Config)*)apiConfig;
+
+    if (!config)
+    {
+        // Cleanup
+        pEyeTextures[0].Clear();
+        pEyeTextures[1].Clear();
+        memset(&RParams, 0, sizeof(RParams));
+        return true;
+    }
+
+    if (!config->D3D_NS.pDevice || !config->D3D_NS.pBackBufferRT)
+        return false;
+
+    RParams.pDevice		   = config->D3D_NS.pDevice;    
+    RParams.pContext       = D3DSELECT_10_11(config->D3D_NS.pDevice, config->D3D_NS.pDeviceContext);
+    RParams.pBackBufferRT  = config->D3D_NS.pBackBufferRT;
+    RParams.pSwapChain     = config->D3D_NS.pSwapChain;
+    RParams.RTSize         = config->D3D_NS.Header.RTSize;
+    RParams.Multisample    = config->D3D_NS.Header.Multisample;
+
+	GfxState = *new GraphicsState(RParams.pContext);
+
+    DistortionCaps = distortionCaps;
+
+    //DistortionWarper.SetVsync((hmdCaps & ovrHmdCap_NoVSync) ? false : true);
+
+    pEyeTextures[0] = *new Texture(&RParams, Texture_RGBA, Sizei(0),
+                                   getSamplerState(Sample_Linear|Sample_ClampBorder));
+    pEyeTextures[1] = *new Texture(&RParams, Texture_RGBA, Sizei(0),
+                                   getSamplerState(Sample_Linear|Sample_ClampBorder));
+
+    initBuffersAndShaders();
+
+    // Rasterizer state
+    D3D1X_(RASTERIZER_DESC) rs;
+    memset(&rs, 0, sizeof(rs));
+    rs.AntialiasedLineEnable = true;
+    rs.CullMode              = D3D1X_(CULL_BACK);    
+    rs.DepthClipEnable       = true;
+    rs.FillMode              = D3D1X_(FILL_SOLID);
+    Rasterizer = NULL;
+    RParams.pDevice->CreateRasterizerState(&rs, &Rasterizer.GetRawRef());
+
+	initOverdrive();
+
+    // TBD: Blend state.. not used?
+    // We'll want to turn off blending
+
+#if (OVR_D3D_VERSION == 11)
+    GpuProfiler.Init(RParams.pDevice, RParams.pContext);
+#endif
+
+    return true;
+}
+
+void DistortionRenderer::initOverdrive()
+{
+	if(RState.DistortionCaps & ovrDistortionCap_Overdrive)
+	{
+		LastUsedOverdriveTextureIndex = 0;
+
+		for (int i = 0; i < NumOverdriveTextures; i++)
+		{
+			pOverdriveTextures[i] = *new Texture(&RParams, Texture_RGBA, RParams.RTSize,
+				getSamplerState(Sample_Linear|Sample_ClampBorder));
+
+			D3D1X_(TEXTURE2D_DESC) dsDesc;
+			dsDesc.Width     = RParams.RTSize.w;
+			dsDesc.Height    = RParams.RTSize.h;
+			dsDesc.MipLevels = 1;
+			dsDesc.ArraySize = 1;
+			dsDesc.Format    = DXGI_FORMAT_R8G8B8A8_UNORM;
+			dsDesc.SampleDesc.Count = 1;
+			dsDesc.SampleDesc.Quality = 0;
+			dsDesc.Usage     = D3D1X_(USAGE_DEFAULT);
+			dsDesc.BindFlags = D3D1X_(BIND_SHADER_RESOURCE) | D3D1X_(BIND_RENDER_TARGET);
+			dsDesc.CPUAccessFlags = 0;
+			dsDesc.MiscFlags      = 0;
+
+			HRESULT hr = RParams.pDevice->CreateTexture2D(&dsDesc, NULL, &pOverdriveTextures[i]->Tex.GetRawRef());			
+			if (FAILED(hr))
+			{
+				OVR_DEBUG_LOG_TEXT(("Failed to create overdrive texture."));
+				// Remove overdrive flag since we failed to create the texture
+				LastUsedOverdriveTextureIndex = -1;	// disables feature
+				break;
+			}
+
+			RParams.pDevice->CreateShaderResourceView(pOverdriveTextures[i]->Tex, NULL, &pOverdriveTextures[i]->TexSv.GetRawRef());
+			RParams.pDevice->CreateRenderTargetView(pOverdriveTextures[i]->Tex, NULL, &pOverdriveTextures[i]->TexRtv.GetRawRef());
+		}
+	}
+	else
+	{
+		LastUsedOverdriveTextureIndex = -1;
+	}
+}
+
+void DistortionRenderer::SubmitEye(int eyeId, const ovrTexture* eyeTexture)
+{
+    const ovrD3D1X(Texture)* tex = (const ovrD3D1X(Texture)*)eyeTexture;
+
+    if (eyeTexture)
+    {
+        // Use tex->D3D_NS.Header.RenderViewport to update UVs for rendering in case they changed.
+        // TBD: This may be optimized through some caching. 
+        EyeTextureSize[eyeId]    = tex->D3D_NS.Header.TextureSize;
+        EyeRenderViewport[eyeId] = tex->D3D_NS.Header.RenderViewport;
+
+        const ovrEyeRenderDesc& erd = RState.EyeRenderDesc[eyeId];
+
+        ovrHmd_GetRenderScaleAndOffset(erd.Fov,
+                                       EyeTextureSize[eyeId], EyeRenderViewport[eyeId],
+                                       UVScaleOffset[eyeId]);
+
+		if (RState.DistortionCaps & ovrDistortionCap_FlipInput)
+		{
+			UVScaleOffset[eyeId][0].y = -UVScaleOffset[eyeId][0].y;
+			UVScaleOffset[eyeId][1].y = 1.0f - UVScaleOffset[eyeId][1].y;
+		}
+
+        pEyeTextures[eyeId]->UpdatePlaceholderTexture(tex->D3D_NS.pTexture, tex->D3D_NS.pSRView,
+                                                      tex->D3D_NS.Header.TextureSize);
+    }
+}
+
+void DistortionRenderer::renderEndFrame()
+{
+    renderDistortion(pEyeTextures[0], pEyeTextures[1]);
+    
+    if(RegisteredPostDistortionCallback)
+        RegisteredPostDistortionCallback(RParams.pContext);
+
+    if(LatencyTest2Active)
+    {
+        renderLatencyPixel(LatencyTest2DrawColor);
+    }
+}
+
+void DistortionRenderer::EndFrame(bool swapBuffers)
+{
+    // Don't spin if we are explicitly asked not to
+    if (RState.DistortionCaps & ovrDistortionCap_TimeWarp &&
+        !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+    {
+        if (!TimeManager.NeedDistortionTimeMeasurement())
+        {
+            // Wait for timewarp distortion if it is time and Gpu idle
+            FlushGpuAndWaitTillTime(TimeManager.GetFrameTiming().TimewarpPointTime);
+
+            renderEndFrame();
+        }
+        else
+        {
+            // If needed, measure distortion time so that TimeManager can better estimate
+            // latency-reducing time-warp wait timing.
+            WaitUntilGpuIdle();
+            double  distortionStartTime = ovr_GetTimeInSeconds();
+
+            renderEndFrame();
+
+            WaitUntilGpuIdle();
+            TimeManager.AddDistortionTimeMeasurement(ovr_GetTimeInSeconds() - distortionStartTime);
+        }
+    }
+    else
+    {
+        renderEndFrame();
+    }
+
+    if(LatencyTestActive)
+    {
+        renderLatencyQuad(LatencyTestDrawColor);
+    }
+
+    if (swapBuffers)
+    {
+        if (RParams.pSwapChain)
+        {
+            UINT swapInterval = (RState.EnabledHmdCaps & ovrHmdCap_NoVSync) ? 0 : 1;
+            RParams.pSwapChain->Present(swapInterval, 0);
+            
+            // Force GPU to flush the scene, resulting in the lowest possible latency.
+            // It's critical that this flush is *after* present.
+			// With the display driver this flush is obsolete and theoretically should
+			// be a no-op.
+            // Doesn't need to be done if running through the Oculus driver.
+            if (RState.OurHMDInfo.InCompatibilityMode &&
+                !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+                WaitUntilGpuIdle();
+        }
+        else
+        {
+            // TBD: Generate error - swapbuffer option used with null swapchain.
+        }
+    }
+}
+
+
+void DistortionRenderer::WaitUntilGpuIdle()
+{
+    // Flush and Stall CPU while waiting for GPU to complete rendering all of the queued draw calls
+    D3D1x_QUERY_DESC queryDesc = { D3D1X_(QUERY_EVENT), 0 };
+    Ptr<ID3D1xQuery> query;
+    BOOL             done = FALSE;
+
+    if (RParams.pDevice->CreateQuery(&queryDesc, &query.GetRawRef()) == S_OK)
+    {
+        D3DSELECT_10_11(query->End(),
+                        RParams.pContext->End(query));
+
+        // GetData will returns S_OK for both done == TRUE or FALSE.
+        // Exit on failure to avoid infinite loop.
+        do { }
+        while(!done &&
+              !FAILED(D3DSELECT_10_11(query->GetData(&done, sizeof(BOOL), 0),
+                                      RParams.pContext->GetData(query, &done, sizeof(BOOL), 0)))
+             );
+    }
+}
+
+double DistortionRenderer::FlushGpuAndWaitTillTime(double absTime)
+{
+    RParams.pContext->Flush();
+    return WaitTillTime(absTime);
+}
+
+void DistortionRenderer::initBuffersAndShaders()
+{
+    for ( int eyeNum = 0; eyeNum < 2; eyeNum++ )
+    {
+        // Allocate & generate distortion mesh vertices.
+        ovrDistortionMesh meshData;
+
+//        double startT = ovr_GetTimeInSeconds();
+
+        if (!ovrHmd_CreateDistortionMesh( HMD,
+                                          RState.EyeRenderDesc[eyeNum].Eye,
+                                          RState.EyeRenderDesc[eyeNum].Fov,
+                                          RState.DistortionCaps,
+                                          &meshData) )
+        {
+            OVR_ASSERT(false);
+            continue;
+        }
+
+//        double deltaT = ovr_GetTimeInSeconds() - startT;
+//        LogText("GenerateDistortion time = %f\n", deltaT);
+
+        // Now parse the vertex data and create a render ready vertex buffer from it
+        DistortionVertex *   pVBVerts    = (DistortionVertex*)OVR_ALLOC ( sizeof(DistortionVertex) * meshData.VertexCount );
+        DistortionVertex *   pCurVBVert  = pVBVerts;
+        ovrDistortionVertex* pCurOvrVert = meshData.pVertexData;
+
+        for ( unsigned vertNum = 0; vertNum < meshData.VertexCount; vertNum++ )
+        {
+            pCurVBVert->ScreenPosNDC.x = pCurOvrVert->ScreenPosNDC.x;
+            pCurVBVert->ScreenPosNDC.y = pCurOvrVert->ScreenPosNDC.y;
+            pCurVBVert->TanEyeAnglesR  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesR);
+            pCurVBVert->TanEyeAnglesG  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesG);
+            pCurVBVert->TanEyeAnglesB  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesB);
+
+            // Convert [0.0f,1.0f] to [0,255]
+			if (DistortionCaps & ovrDistortionCap_Vignette)
+				pCurVBVert->Col.R = (uint8_t)( pCurOvrVert->VignetteFactor * 255.99f );
+			else
+				pCurVBVert->Col.R = 255;
+
+            pCurVBVert->Col.G = pCurVBVert->Col.R;
+            pCurVBVert->Col.B = pCurVBVert->Col.R;
+            pCurVBVert->Col.A = (uint8_t)( pCurOvrVert->TimeWarpFactor * 255.99f );;
+            pCurOvrVert++;
+            pCurVBVert++;
+        }
+
+        DistortionMeshVBs[eyeNum] = *new Buffer(&RParams);
+		DistortionMeshVBs[eyeNum]->Data(Buffer_Vertex | Buffer_ReadOnly, pVBVerts, sizeof(DistortionVertex)* meshData.VertexCount);
+        DistortionMeshIBs[eyeNum] = *new Buffer(&RParams);
+		DistortionMeshIBs[eyeNum]->Data(Buffer_Index | Buffer_ReadOnly, meshData.pIndexData, (sizeof(INT16)* meshData.IndexCount));
+
+        OVR_FREE ( pVBVerts );
+        ovrHmd_DestroyDistortionMesh( &meshData );
+    }
+
+    // Uniform buffers
+    for(int i = 0; i < Shader_Count; i++)
+    {
+        UniformBuffers[i] = *new Buffer(&RParams);
+        //MaxTextureSet[i] = 0;
+    }
+
+    initShaders();
+}
+
+void DistortionRenderer::renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture)
+{
+
+#if (OVR_D3D_VERSION == 10)
+	RParams.pContext->GSSetShader(NULL);
+#else // d3d 11
+	RParams.pContext->HSSetShader(NULL, NULL, 0);
+	RParams.pContext->DSSetShader(NULL, NULL, 0);
+	RParams.pContext->GSSetShader(NULL, NULL, 0);
+#endif
+
+    RParams.pContext->RSSetState(Rasterizer);
+
+	bool overdriveActive = IsOverdriveActive();
+	int currOverdriveTextureIndex = -1;
+
+	if(overdriveActive)
+	{
+		currOverdriveTextureIndex = (LastUsedOverdriveTextureIndex + 1) % NumOverdriveTextures;
+        ID3D1xRenderTargetView* distortionRtv = pOverdriveTextures[currOverdriveTextureIndex]->TexRtv.GetRawRef();
+        ID3D1xRenderTargetView* mrtRtv[2] = {distortionRtv, RParams.pBackBufferRT};
+        RParams.pContext->OMSetRenderTargets(2, mrtRtv, 0);
+
+        RParams.pContext->ClearRenderTargetView(distortionRtv, RState.ClearColor);
+    }
+    else
+    {
+        RParams.pContext->OMSetRenderTargets(1, &RParams.pBackBufferRT, 0);
+    }
+
+    // Not affected by viewport.
+    RParams.pContext->ClearRenderTargetView(RParams.pBackBufferRT, RState.ClearColor);
+
+    setViewport(Recti(0,0, RParams.RTSize.w, RParams.RTSize.h));
+
+
+    for(int eyeNum = 0; eyeNum < 2; eyeNum++)
+    {        
+		ShaderFill distortionShaderFill(DistortionShader);
+        distortionShaderFill.SetTexture(0, eyeNum == 0 ? leftEyeTexture : rightEyeTexture);
+
+		if(overdriveActive)
+		{
+            distortionShaderFill.SetTexture(1, pOverdriveTextures[LastUsedOverdriveTextureIndex]);
+
+            float invRtWidth  = 1.0f / (float)RParams.RTSize.w;
+            float invRtHeight = 1.0f / (float)RParams.RTSize.h;
+            DistortionShader->SetUniform2f("OverdriveInvRTSize", invRtWidth, invRtHeight);
+
+            static float overdriveScaleRegularRise = 0.1f;
+			static float overdriveScaleRegularFall = 0.05f;	// falling issues are hardly visible
+			DistortionShader->SetUniform2f("OverdriveScales", overdriveScaleRegularRise, overdriveScaleRegularFall);
+		}
+        else
+        {
+            // -1.0f disables PLO            
+            DistortionShader->SetUniform2f("OverdriveInvRTSize", -1.0f, -1.0f);
+        }
+
+        distortionShaderFill.SetInputLayout(DistortionVertexIL);
+
+        DistortionShader->SetUniform2f("EyeToSourceUVScale",  UVScaleOffset[eyeNum][0].x, UVScaleOffset[eyeNum][0].y);
+        DistortionShader->SetUniform2f("EyeToSourceUVOffset", UVScaleOffset[eyeNum][1].x, UVScaleOffset[eyeNum][1].y);
+        
+		if (DistortionCaps & ovrDistortionCap_TimeWarp)
+		{                       
+            ovrMatrix4f timeWarpMatrices[2];
+            ovrHmd_GetEyeTimewarpMatrices(HMD, (ovrEyeType)eyeNum,
+                                          RState.EyeRenderPoses[eyeNum], timeWarpMatrices);
+
+            // Feed identity like matrices in until we get proper timewarp calculation going on
+			DistortionShader->SetUniform4x4f("EyeRotationStart", Matrix4f(timeWarpMatrices[0]));
+			DistortionShader->SetUniform4x4f("EyeRotationEnd",   Matrix4f(timeWarpMatrices[1]));
+
+            renderPrimitives(&distortionShaderFill, DistortionMeshVBs[eyeNum], DistortionMeshIBs[eyeNum],
+                            NULL, 0, (int)DistortionMeshIBs[eyeNum]->GetSize()/2, Prim_Triangles);
+		}
+        else
+        {
+            renderPrimitives(&distortionShaderFill, DistortionMeshVBs[eyeNum], DistortionMeshIBs[eyeNum],
+                            NULL, 0, (int)DistortionMeshIBs[eyeNum]->GetSize()/2, Prim_Triangles);
+        }
+    }
+
+    LastUsedOverdriveTextureIndex = currOverdriveTextureIndex;
+
+    // Re-activate to only draw on back buffer
+    if(overdriveActive)
+    {
+        RParams.pContext->OMSetRenderTargets(1, &RParams.pBackBufferRT, 0);
+    }
+}
+
+void DistortionRenderer::createDrawQuad()
+{
+    const int numQuadVerts = 4;
+    LatencyTesterQuadVB = *new Buffer(&RParams);
+    if(!LatencyTesterQuadVB)
+    {
+        return;
+    }
+
+    LatencyTesterQuadVB->Data(Buffer_Vertex, NULL, numQuadVerts * sizeof(Vertex));
+    Vertex* vertices = (Vertex*)LatencyTesterQuadVB->Map(0, numQuadVerts * sizeof(Vertex), Map_Discard);
+    if(!vertices)
+    {
+        OVR_ASSERT(false); // failed to lock vertex buffer
+        return;
+    }
+
+    const float left   = -1.0f;
+    const float top    = -1.0f;
+    const float right  =  1.0f;
+    const float bottom =  1.0f;
+
+    vertices[0] = Vertex(Vector3f(left,  top,    0.0f), Color(255, 255, 255, 255));
+    vertices[1] = Vertex(Vector3f(left,  bottom, 0.0f), Color(255, 255, 255, 255));
+    vertices[2] = Vertex(Vector3f(right, top,    0.0f), Color(255, 255, 255, 255));
+    vertices[3] = Vertex(Vector3f(right, bottom, 0.0f), Color(255, 255, 255, 255));
+
+    LatencyTesterQuadVB->Unmap(vertices);
+}
+
+void DistortionRenderer::renderLatencyQuad(unsigned char* latencyTesterDrawColor)
+{
+    const int numQuadVerts = 4;
+
+    if(!LatencyTesterQuadVB)
+    {
+        createDrawQuad();
+    }
+       
+    ShaderFill quadFill(SimpleQuadShader);
+    quadFill.SetInputLayout(SimpleQuadVertexIL);
+
+    setViewport(Recti(0,0, RParams.RTSize.w, RParams.RTSize.h));
+
+    SimpleQuadShader->SetUniform2f("Scale", 0.3f, 0.3f);
+    SimpleQuadShader->SetUniform4f("Color", (float)latencyTesterDrawColor[0] / 255.99f,
+                                            (float)latencyTesterDrawColor[0] / 255.99f,
+                                            (float)latencyTesterDrawColor[0] / 255.99f,
+                                            1.0f);
+
+    for(int eyeNum = 0; eyeNum < 2; eyeNum++)
+    {
+        SimpleQuadShader->SetUniform2f("PositionOffset", eyeNum == 0 ? -0.5f : 0.5f, 0.0f);    
+        renderPrimitives(&quadFill, LatencyTesterQuadVB, NULL, NULL, 0, numQuadVerts, Prim_TriangleStrip);
+    }
+}
+
+void DistortionRenderer::renderLatencyPixel(unsigned char* latencyTesterPixelColor)
+{
+    const int numQuadVerts = 4;
+
+    if(!LatencyTesterQuadVB)
+    {
+        createDrawQuad();
+    }
+    
+    ShaderFill quadFill(SimpleQuadShader);
+    quadFill.SetInputLayout(SimpleQuadVertexIL);
+
+    setViewport(Recti(0,0, RParams.RTSize.w, RParams.RTSize.h));
+
+#ifdef OVR_BUILD_DEBUG
+    SimpleQuadShader->SetUniform4f("Color", (float)latencyTesterPixelColor[0] / 255.99f,
+                                            (float)latencyTesterPixelColor[1] / 255.99f,
+                                            (float)latencyTesterPixelColor[2] / 255.99f,
+                                            1.0f);
+
+    Vector2f scale(20.0f / RParams.RTSize.w, 20.0f / RParams.RTSize.h); 
+#else
+    SimpleQuadShader->SetUniform4f("Color", (float)latencyTesterPixelColor[0] / 255.99f,
+                                            (float)latencyTesterPixelColor[0] / 255.99f,
+                                            (float)latencyTesterPixelColor[0] / 255.99f,
+                                            1.0f);
+
+    Vector2f scale(1.0f / RParams.RTSize.w, 1.0f / RParams.RTSize.h); 
+#endif
+    SimpleQuadShader->SetUniform2f("Scale", scale.x, scale.y);
+    SimpleQuadShader->SetUniform2f("PositionOffset", 1.0f-scale.x, 1.0f-scale.y);
+    renderPrimitives(&quadFill, LatencyTesterQuadVB, NULL, NULL, 0, numQuadVerts, Prim_TriangleStrip);
+}
+
+void DistortionRenderer::renderPrimitives(
+                          const ShaderFill* fill,
+                          Buffer* vertices, Buffer* indices,
+                          Matrix4f* viewMatrix, int offset, int count,
+                          PrimitiveType rprim)
+{
+    OVR_ASSERT(fill->GetInputLayout() != 0);    
+    RParams.pContext->IASetInputLayout((ID3D1xInputLayout*)fill->GetInputLayout());    
+
+    if (indices)
+    {
+        RParams.pContext->IASetIndexBuffer(indices->GetBuffer(), DXGI_FORMAT_R16_UINT, 0);
+    }
+
+    ID3D1xBuffer* vertexBuffer = vertices->GetBuffer();
+    UINT          vertexStride = sizeof(Vertex);
+    UINT          vertexOffset = offset;
+    RParams.pContext->IASetVertexBuffers(0, 1, &vertexBuffer, &vertexStride, &vertexOffset);
+
+    ShaderSet* shaders = ((ShaderFill*)fill)->GetShaders();
+
+    ShaderBase*     vshader = ((ShaderBase*)shaders->GetShader(Shader_Vertex));
+    unsigned char*  vertexData = vshader->UniformData;
+    if (vertexData)
+    {
+		// TODO: some VSes don't start with StandardUniformData!
+		if ( viewMatrix )
+		{
+			StandardUniformData* stdUniforms = (StandardUniformData*) vertexData;
+			stdUniforms->View = viewMatrix->Transposed();
+			stdUniforms->Proj = StdUniforms.Proj;
+		}
+		UniformBuffers[Shader_Vertex]->Data(Buffer_Uniform, vertexData, vshader->UniformsSize);
+		vshader->SetUniformBuffer(UniformBuffers[Shader_Vertex]);
+    }
+
+    for(int i = Shader_Vertex + 1; i < Shader_Count; i++)
+    {
+        if (shaders->GetShader(i))
+        {
+            ((ShaderBase*)shaders->GetShader(i))->UpdateBuffer(UniformBuffers[i]);
+            ((ShaderBase*)shaders->GetShader(i))->SetUniformBuffer(UniformBuffers[i]);
+        }
+    }
+
+    D3D1X_(PRIMITIVE_TOPOLOGY) prim;
+    switch(rprim)
+    {
+    case Prim_Triangles:
+        prim = D3D1X_(PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+        break;
+    case Prim_Lines:
+        prim = D3D1X_(PRIMITIVE_TOPOLOGY_LINELIST);
+        break;
+    case Prim_TriangleStrip:
+        prim = D3D1X_(PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+        break;
+    default:
+        OVR_ASSERT(0);
+        return;
+    }
+    RParams.pContext->IASetPrimitiveTopology(prim);
+
+    fill->Set(rprim);
+
+    if (indices)
+    {
+        RParams.pContext->DrawIndexed(count, 0, 0);
+    }
+    else
+    {
+        RParams.pContext->Draw(count, 0);
+    }
+}
+
+void DistortionRenderer::setViewport(const Recti& vp)
+{
+    D3D1x_VIEWPORT d3dvp;
+
+    d3dvp.Width    = D3DSELECT_10_11(vp.w, (float)vp.w);
+    d3dvp.Height   = D3DSELECT_10_11(vp.h, (float)vp.h);
+    d3dvp.TopLeftX = D3DSELECT_10_11(vp.x, (float)vp.x);
+    d3dvp.TopLeftY = D3DSELECT_10_11(vp.y, (float)vp.y);
+    d3dvp.MinDepth = 0;
+    d3dvp.MaxDepth = 1;
+    RParams.pContext->RSSetViewports(1, &d3dvp);
+}
+
+
+
+
+static D3D1X_(INPUT_ELEMENT_DESC) DistortionMeshVertexDesc[] =
+{
+    {"Position", 0, DXGI_FORMAT_R32G32_FLOAT,   0, 0,   D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+    {"TexCoord", 0, DXGI_FORMAT_R32G32_FLOAT,   0, 8,   D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+    {"TexCoord", 1, DXGI_FORMAT_R32G32_FLOAT,   0, 16,	D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+    {"TexCoord", 2, DXGI_FORMAT_R32G32_FLOAT,   0, 24,	D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+    {"Color",    0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 32,  D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+};
+
+static D3D1X_(INPUT_ELEMENT_DESC) SimpleQuadMeshVertexDesc[] =
+{
+    {"Position", 0, DXGI_FORMAT_R32G32_FLOAT,   0, 0,   D3D1X_(INPUT_PER_VERTEX_DATA), 0},
+};
+
+// TODO: this is D3D specific
+void DistortionRenderer::initShaders()
+{  
+    {
+        PrecompiledShader vsShaderByteCode = DistortionVertexShaderLookup[DistortionVertexShaderBitMask & DistortionCaps];
+        Ptr<D3D_NS::VertexShader> vtxShader = *new D3D_NS::VertexShader(
+            &RParams,
+            (void*)vsShaderByteCode.ShaderData, vsShaderByteCode.ShaderSize,
+            vsShaderByteCode.ReflectionData, vsShaderByteCode.ReflectionSize);
+
+        DistortionVertexIL = NULL;
+        ID3D1xInputLayout** objRef = &DistortionVertexIL.GetRawRef();
+
+        HRESULT validate = RParams.pDevice->CreateInputLayout(
+            DistortionMeshVertexDesc, sizeof(DistortionMeshVertexDesc) / sizeof(DistortionMeshVertexDesc[0]),
+            vsShaderByteCode.ShaderData, vsShaderByteCode.ShaderSize, objRef);
+        OVR_UNUSED(validate);
+
+        DistortionShader = *new ShaderSet;
+        DistortionShader->SetShader(vtxShader);
+
+        PrecompiledShader psShaderByteCode = DistortionPixelShaderLookup[DistortionPixelShaderBitMask & DistortionCaps];
+
+        Ptr<D3D_NS::PixelShader> ps  = *new D3D_NS::PixelShader(
+            &RParams,
+            (void*)psShaderByteCode.ShaderData, psShaderByteCode.ShaderSize,
+            psShaderByteCode.ReflectionData, psShaderByteCode.ReflectionSize);
+
+        DistortionShader->SetShader(ps);
+    }
+
+    {
+        Ptr<D3D_NS::VertexShader> vtxShader = *new D3D_NS::VertexShader(
+            &RParams,
+            (void*)SimpleQuad_vs, sizeof(SimpleQuad_vs),
+            SimpleQuad_vs_refl, sizeof(SimpleQuad_vs_refl) / sizeof(SimpleQuad_vs_refl[0]));
+            //NULL, 0);
+
+        SimpleQuadVertexIL = NULL;
+        ID3D1xInputLayout** objRef   = &SimpleQuadVertexIL.GetRawRef();
+
+        HRESULT validate = RParams.pDevice->CreateInputLayout(
+            SimpleQuadMeshVertexDesc, sizeof(SimpleQuadMeshVertexDesc) / sizeof(SimpleQuadMeshVertexDesc[0]),
+            (void*)SimpleQuad_vs, sizeof(SimpleQuad_vs), objRef);
+        OVR_UNUSED(validate);
+
+        SimpleQuadShader = *new ShaderSet;
+        SimpleQuadShader->SetShader(vtxShader);
+
+        Ptr<D3D_NS::PixelShader> ps  = *new D3D_NS::PixelShader(
+            &RParams,
+            (void*)SimpleQuad_ps, sizeof(SimpleQuad_ps),
+            SimpleQuad_ps_refl, sizeof(SimpleQuad_ps_refl) / sizeof(SimpleQuad_ps_refl[0]));
+
+        SimpleQuadShader->SetShader(ps);
+    }
+}
+
+
+
+ID3D1xSamplerState* DistortionRenderer::getSamplerState(int sm)
+{
+    if (SamplerStates[sm])    
+        return SamplerStates[sm];
+
+    D3D1X_(SAMPLER_DESC) ss;
+    memset(&ss, 0, sizeof(ss));
+    if (sm & Sample_Clamp)    
+        ss.AddressU = ss.AddressV = ss.AddressW = D3D1X_(TEXTURE_ADDRESS_CLAMP);    
+    else if (sm & Sample_ClampBorder)    
+        ss.AddressU = ss.AddressV = ss.AddressW = D3D1X_(TEXTURE_ADDRESS_BORDER);    
+    else    
+        ss.AddressU = ss.AddressV = ss.AddressW = D3D1X_(TEXTURE_ADDRESS_WRAP);
+
+    if (sm & Sample_Nearest)
+    {
+        ss.Filter = D3D1X_(FILTER_MIN_MAG_MIP_POINT);
+    }
+    else if (sm & Sample_Anisotropic)
+    {
+        ss.Filter = D3D1X_(FILTER_ANISOTROPIC);
+        ss.MaxAnisotropy = 8;
+    }
+    else
+    {
+        ss.Filter = D3D1X_(FILTER_MIN_MAG_MIP_LINEAR);
+    }
+    ss.MaxLOD = 15;
+    RParams.pDevice->CreateSamplerState(&ss, &SamplerStates[sm].GetRawRef());
+    return SamplerStates[sm];
+}
+
+
+void DistortionRenderer::destroy()
+{
+	for(int eyeNum = 0; eyeNum < 2; eyeNum++)
+	{
+		DistortionMeshVBs[eyeNum].Clear();
+		DistortionMeshIBs[eyeNum].Clear();
+	}
+
+	DistortionVertexIL.Clear();
+
+	if (DistortionShader)
+    {
+        DistortionShader->UnsetShader(Shader_Vertex);
+	    DistortionShader->UnsetShader(Shader_Pixel);
+	    DistortionShader.Clear();
+    }
+
+    LatencyTesterQuadVB.Clear();
+}
+
+
+DistortionRenderer::GraphicsState::GraphicsState(ID3D1xDeviceContext* c)
+: context(c)
+, rasterizerState(NULL)
+, inputLayoutState(NULL)
+, depthStencilViewState(NULL)
+, omBlendState(NULL)
+, omSampleMaskState(0xffffffff)
+, iaIndexBufferPointerState(NULL)
+, memoryCleared(TRUE)
+, currentPixelShader(NULL)
+, currentVertexShader(NULL)
+, currentGeometryShader(NULL)
+#if (OVR_D3D_VERSION == 11)
+, currentHullShader(NULL)
+, currentDomainShader(NULL)
+#endif
+{
+	for (int i = 0; i < D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT; ++i)
+		samplerStates[i] = NULL;
+
+	for (int i = 0; i < D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT; i++)
+	{
+		psShaderResourceState[i] = NULL;
+		vsShaderResourceState[i] = NULL;
+	}
+
+	for (int i = 0; i < D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT; i++)
+	{
+		psConstantBuffersState[i] = NULL;
+		vsConstantBuffersState[i] = NULL;
+	}
+
+	for (int i = 0; i < D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT; i++)
+		renderTargetViewState[i] = NULL;
+
+	for (int i = 0; i < 4; i++)
+		omBlendFactorState[i] = NULL;
+
+	for (int i = 0; i < D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT; i++)
+		iaVertexBufferPointersState[i] = NULL;
+}
+
+void DistortionRenderer::GraphicsState::clearMemory()
+{
+	if (rasterizerState != NULL)
+	{
+		rasterizerState->Release();
+		rasterizerState = NULL;
+	}
+
+	for (int i = 0; i < D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT; ++i)
+	{
+		if (samplerStates[i] == NULL)
+			continue;
+		samplerStates[i]->Release();
+		samplerStates[i] = NULL;
+	}
+
+	if (inputLayoutState != NULL)
+	{
+		inputLayoutState->Release();
+		inputLayoutState = NULL;
+	}
+
+	for (int i = 0; i < D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT; i++)
+	{
+		if (psShaderResourceState[i] != NULL)
+		{
+			psShaderResourceState[i]->Release();
+			psShaderResourceState[i] = NULL;
+		}
+		if (vsShaderResourceState[i] != NULL)
+		{
+			vsShaderResourceState[i]->Release();
+			vsShaderResourceState[i] = NULL;
+		}
+	}
+
+	for (int i = 0; i < D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT; i++)
+	{
+		if (psConstantBuffersState[i] != NULL)
+		{
+			psConstantBuffersState[i]->Release();
+			psConstantBuffersState[i] = NULL;
+		}
+		if (vsConstantBuffersState[i] != NULL)
+		{
+			vsConstantBuffersState[i]->Release();
+			vsConstantBuffersState[i] = NULL;
+		}
+	}
+
+	for (int i = 0; i < D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT; i++)
+	{
+		if (renderTargetViewState[i] != NULL)
+		{
+			renderTargetViewState[i]->Release();
+			renderTargetViewState[i] = NULL;
+		}
+	}
+
+	if (depthStencilViewState != NULL)
+	{
+		depthStencilViewState->Release();
+		depthStencilViewState = NULL;
+	}
+
+	if (omBlendState != NULL)
+	{
+		omBlendState->Release();
+		omBlendState = NULL;
+	}
+
+	if (iaIndexBufferPointerState != NULL)
+	{
+		iaIndexBufferPointerState->Release();
+		iaIndexBufferPointerState = NULL;
+	}
+
+	for (int i = 0; i < D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT; i++)
+	{
+		if (iaVertexBufferPointersState[i] == NULL)
+			continue;
+		iaVertexBufferPointersState[i]->Release();
+		iaVertexBufferPointersState[i] = NULL;
+	}
+
+	if (currentPixelShader != NULL)
+	{
+		currentPixelShader->Release();
+		currentPixelShader = NULL;
+	}
+
+	if (currentVertexShader != NULL)
+	{
+		currentVertexShader->Release();
+		currentVertexShader = NULL;
+	}
+
+	if (currentGeometryShader != NULL)
+	{
+		currentGeometryShader->Release();
+		currentGeometryShader = NULL;
+	}
+
+#if (OVR_D3D_VERSION == 11)
+
+	if (currentHullShader != NULL)
+	{
+		currentHullShader->Release();
+		currentHullShader = NULL;
+	}
+
+	if (currentDomainShader != NULL)
+	{
+		currentDomainShader->Release();
+		currentDomainShader = NULL;
+	}
+
+#endif
+
+	memoryCleared = TRUE;
+}
+
+DistortionRenderer::GraphicsState::~GraphicsState()
+{
+	clearMemory();
+}
+
+
+void DistortionRenderer::GraphicsState::Save()
+{
+	if (!memoryCleared)
+		clearMemory();
+
+	memoryCleared = FALSE;
+
+	context->RSGetState(&rasterizerState);
+	context->PSGetSamplers(0, D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT, samplerStates);
+	context->IAGetInputLayout(&inputLayoutState);
+
+	context->PSGetShaderResources(0, D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, psShaderResourceState);
+	context->VSGetShaderResources(0, D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, vsShaderResourceState);
+
+	context->PSGetConstantBuffers(0, D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, psConstantBuffersState);
+	context->VSGetConstantBuffers(0, D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, vsConstantBuffersState);
+
+	context->OMGetRenderTargets(D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT, renderTargetViewState, &depthStencilViewState);
+
+	context->OMGetBlendState(&omBlendState, omBlendFactorState, &omSampleMaskState);
+
+	context->IAGetPrimitiveTopology(&primitiveTopologyState);
+
+	context->IAGetIndexBuffer(&iaIndexBufferPointerState, &iaIndexBufferFormatState, &iaIndexBufferOffsetState);
+
+	context->IAGetVertexBuffers(0, D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT, iaVertexBufferPointersState, iaVertexBufferStridesState, iaVertexBufferOffsetsState);
+
+#if (OVR_D3D_VERSION == 10)
+	context->PSGetShader(&currentPixelShader);
+	context->VSGetShader(&currentVertexShader);
+	context->GSGetShader(&currentGeometryShader);
+#else // Volga says class instance interfaces are very new and almost no one uses them
+	context->PSGetShader(&currentPixelShader, NULL, NULL);
+	context->VSGetShader(&currentVertexShader, NULL, NULL);
+	context->GSGetShader(&currentGeometryShader, NULL, NULL);
+	context->HSGetShader(&currentHullShader, NULL, NULL);
+	context->DSGetShader(&currentDomainShader, NULL, NULL);
+	/* maybe above doesn't work; then do something with this (must test on dx11)
+	ID3D11ClassInstance* blank_array[0];
+	UINT blank_uint = 0;
+	context->PSGetShader(&currentPixelShader, blank_array, blank_uint);
+	context->VSGetShader(&currentVertexShader, blank_array, blank_uint);
+	context->GSGetShader(&currentGeometryShader, blank_array, blank_uint);
+	context->HSGetShader(&currentHullShader, blank_array, blank_uint);
+	context->DSGetShader(&currentDomainShader, blank_array, blank_uint);
+	*/
+#endif
+}
+
+
+void DistortionRenderer::GraphicsState::Restore()
+{
+	if (rasterizerState != NULL)
+		context->RSSetState(rasterizerState);
+
+	context->PSSetSamplers(0, D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT, samplerStates);
+
+	if (inputLayoutState != NULL)
+		context->IASetInputLayout(inputLayoutState);
+
+	if (psShaderResourceState != NULL)
+		context->PSSetShaderResources(0, D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, psShaderResourceState);
+
+	if (vsShaderResourceState != NULL)
+		context->VSSetShaderResources(0, D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, vsShaderResourceState);
+
+	if (psConstantBuffersState != NULL)
+		context->PSSetConstantBuffers(0, D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, psConstantBuffersState);
+
+	if (vsConstantBuffersState != NULL)
+		context->VSSetConstantBuffers(0, D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, vsConstantBuffersState);
+
+	if (depthStencilViewState != NULL || renderTargetViewState != NULL)
+		context->OMSetRenderTargets(D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT, renderTargetViewState, depthStencilViewState);
+
+	if (omBlendState != NULL)
+		context->OMSetBlendState(omBlendState, omBlendFactorState, omSampleMaskState);
+
+	context->IASetPrimitiveTopology(primitiveTopologyState);
+
+	if (iaIndexBufferPointerState != NULL)
+		context->IASetIndexBuffer(iaIndexBufferPointerState, iaIndexBufferFormatState, iaIndexBufferOffsetState);
+
+	if (iaVertexBufferPointersState != NULL)
+		context->IASetVertexBuffers(0, D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT, iaVertexBufferPointersState, iaVertexBufferStridesState, iaVertexBufferOffsetsState);
+
+#if (OVR_D3D_VERSION == 10)
+	if (currentPixelShader != NULL)
+		context->PSSetShader(currentPixelShader);
+	if (currentVertexShader != NULL)
+		context->VSSetShader(currentVertexShader);
+	if (currentGeometryShader != NULL)
+		context->GSSetShader(currentGeometryShader);
+#else
+	if (currentPixelShader != NULL)
+		context->PSSetShader(currentPixelShader, NULL, 0);
+	if (currentVertexShader != NULL)
+		context->VSSetShader(currentVertexShader, NULL, 0);
+	if (currentGeometryShader != NULL)
+		context->GSSetShader(currentGeometryShader, NULL, 0);
+	if (currentHullShader != NULL)
+		context->HSSetShader(currentHullShader, NULL, 0);
+	if (currentDomainShader != NULL)
+		context->DSSetShader(currentDomainShader, NULL, 0);
+#endif
+	clearMemory();
+}
+
+}}} // OVR::CAPI::D3D1X
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,190 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.h
+Content     :   Experimental distortion renderer
+Created     :   November 11, 2013
+Authors     :   Volga Aksoy
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// No include guard, since this fill will be multiply-included. 
+//#ifndef OVR_CAPI_D3D1X_DistortionRenderer_h
+
+#include "CAPI_D3D1X_Util.h"
+#include "../CAPI_DistortionRenderer.h"
+
+#include "../../Kernel/OVR_Log.h"
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+
+// ***** D3D1X::DistortionRenderer
+
+// Implementation of DistortionRenderer for D3D10/11.
+
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd,
+                       FrameTimeManager& timeManager,
+                       const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+                                            FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+
+
+    // ***** Public DistortionRenderer interface
+
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    // TBD: Make public?
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+
+	class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+	{
+	public:
+		GraphicsState(ID3D1xDeviceContext* context);
+		virtual ~GraphicsState();
+		virtual void clearMemory();
+		virtual void Save();
+		virtual void Restore();
+
+	protected:
+		ID3D1xDeviceContext* context;
+		BOOL memoryCleared;
+
+		ID3D1xRasterizerState* rasterizerState;
+		ID3D1xSamplerState* samplerStates[D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT];
+		ID3D1xInputLayout* inputLayoutState;
+
+		ID3D1xShaderResourceView* psShaderResourceState[D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT];
+		ID3D1xShaderResourceView* vsShaderResourceState[D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT];
+
+		ID3D1xBuffer* psConstantBuffersState[D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT];
+		ID3D1xBuffer* vsConstantBuffersState[D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT];
+
+		ID3D1xRenderTargetView* renderTargetViewState[D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT];
+		ID3D1xDepthStencilView* depthStencilViewState;
+
+		ID3D1xBlendState* omBlendState;
+		FLOAT omBlendFactorState[4];
+		UINT omSampleMaskState;
+
+		D3D1x_PRIMITIVE_TOPOLOGY primitiveTopologyState;
+
+		ID3D1xBuffer* iaIndexBufferPointerState;
+		DXGI_FORMAT iaIndexBufferFormatState;
+		UINT iaIndexBufferOffsetState;
+
+		ID3D1xBuffer* iaVertexBufferPointersState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+		UINT iaVertexBufferStridesState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+		UINT iaVertexBufferOffsetsState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+
+		ID3D1xPixelShader* currentPixelShader;
+		ID3D1xVertexShader* currentVertexShader;
+		ID3D1xGeometryShader* currentGeometryShader;
+#if (OVR_D3D_VERSION == 11)
+		ID3D11HullShader* currentHullShader;
+		ID3D11DomainShader* currentDomainShader;
+#endif
+
+	};
+
+private:
+    // Helpers
+    void initBuffersAndShaders();
+    void initShaders();
+    void initFullscreenQuad();
+	void initOverdrive();
+    void destroy();
+
+    void setViewport(const Recti& vp);
+
+    void renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture);
+
+    void renderPrimitives(const ShaderFill* fill, Buffer* vertices, Buffer* indices,
+                          Matrix4f* viewMatrix, int offset, int count,
+                          PrimitiveType rprim);
+
+    void renderEndFrame();
+
+    void createDrawQuad();
+    void renderLatencyQuad(unsigned char* latencyTesterDrawColor);
+    void renderLatencyPixel(unsigned char* latencyTesterPixelColor);
+
+    // Create or get cached D3D sampler based on flags.
+    ID3D1xSamplerState* getSamplerState(int sm);
+
+    
+    // TBD: Should we be using oe from RState instead?
+    unsigned            DistortionCaps;
+
+    // D3DX device and utility variables.
+    RenderParams        RParams;    
+    Ptr<Texture>        pEyeTextures[2];
+
+    // U,V scale and offset needed for timewarp.
+    ovrVector2f         UVScaleOffset[2][2];
+    ovrSizei            EyeTextureSize[2];
+    ovrRecti            EyeRenderViewport[2];
+
+	Ptr<Texture>        pOverdriveTextures[NumOverdriveTextures];
+
+    //Ptr<Buffer>         mpFullScreenVertexBuffer;
+
+	Ptr<Buffer>         DistortionMeshVBs[2];    // one per-eye
+	Ptr<Buffer>         DistortionMeshIBs[2];    // one per-eye
+
+	Ptr<ShaderSet>      DistortionShader;
+	Ptr<ID3D1xInputLayout> DistortionVertexIL;
+
+    struct StandardUniformData
+    {
+        Matrix4f  Proj;
+        Matrix4f  View;
+    }                   StdUniforms;
+    Ptr<Buffer>         UniformBuffers[Shader_Count];
+    
+    Ptr<ID3D1xSamplerState>     SamplerStates[Sample_Count];
+    Ptr<ID3D1xRasterizerState>  Rasterizer;
+
+    Ptr<Buffer>         LatencyTesterQuadVB;
+    Ptr<ShaderSet>      SimpleQuadShader;
+    Ptr<ID3D1xInputLayout> SimpleQuadVertexIL;
+
+    GpuTimer GpuProfiler;
+};
+
+}}} // OVR::CAPI::D3D1X
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,592 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// This file is intended to be #included by CAPI_D3D10_HSWDisplay.cpp or CAPI_D3D11_HSWDisplay.cpp,
+// which define OVR_D3D_VERSION to 10 or 11 respectively.
+#if defined(OVR_D3D_VERSION) && ((OVR_D3D_VERSION == 10) || (OVR_D3D_VERSION == 11))
+
+#define _WINSOCKAPI_             // Prevents <Windows.h> from #including <Winsock.h>, as we need the app to use <Winsock2.h> instead.
+#include "../../OVR_CAPI_D3D.h"  // OVR_D3D_VERSION will have been defined by who included us.
+#include "CAPI_D3D1X_HSWDisplay.h"
+#include "../../Kernel/OVR_File.h"
+#include "../../Kernel/OVR_SysFile.h"
+#include "../../Kernel/OVR_Math.h"
+#include "../../Kernel/OVR_Allocator.h"
+#include "../../Kernel/OVR_Color.h"
+
+// We currently borrow the SimpleQuad shaders
+#include "../Shaders/SimpleTexturedQuad_vs.h"
+#include "../Shaders/SimpleTexturedQuad_vs_refl.h"
+#include "../Shaders/SimpleTexturedQuad_ps.h"
+#include "../Shaders/SimpleTexturedQuad_ps_refl.h"
+
+
+/*
+#include <d3dcompiler.h>
+
+ID3D10Blob* CompileShader(const char* profile, const char* src, const char* mainName = "main")
+{
+    ID3D10Blob* shader = NULL;
+    ID3D10Blob* errors = NULL;
+    HRESULT     hr = D3DCompile(src, strlen(src), NULL, NULL, NULL, mainName, profile, 0, 0, &shader, &errors);
+
+    OVR_ASSERT(SUCCEEDED(hr));
+    if (FAILED(hr))
+    {
+        shader = NULL;
+        OVR_DEBUG_LOG(("Compiling D3D shader for %s failed\n%s\n\n%s", profile, src, errors->GetBufferPointer()));
+    }
+
+    if (errors)
+        errors->Release();
+
+    return shader;
+}
+*/
+
+
+
+// For a given DXGI format: if the format is a typeless one then this function returns a 
+// suitable typed one. If the format is a typed one then this function returns it as-is.
+static DXGI_FORMAT GetFullyTypedDXGIFormat(DXGI_FORMAT textureFormat)
+{
+    // http://msdn.microsoft.com/en-us/library/windows/desktop/bb173059%28v=vs.85%29.aspx
+
+    DXGI_FORMAT fullyTypedFormat = textureFormat;
+
+    switch(textureFormat)
+    {
+        case DXGI_FORMAT_R32G32B32A32_TYPELESS:
+            return DXGI_FORMAT_R32G32B32A32_FLOAT;   // or DXGI_FORMAT_R32G32B32A32_UINT, DXGI_FORMAT_R32G32B32A32_SINT
+
+        case DXGI_FORMAT_R32G32B32_TYPELESS:
+            return DXGI_FORMAT_R32G32B32_FLOAT;      // or DXGI_FORMAT_R32G32B32_UINT, DXGI_FORMAT_R32G32B32_SINT
+
+        case DXGI_FORMAT_R16G16B16A16_TYPELESS:
+            return DXGI_FORMAT_R16G16B16A16_UNORM;   // or DXGI_FORMAT_R16G16B16A16_FLOAT, DXGI_FORMAT_R16G16B16A16_UINT, DXGI_FORMAT_R16G16B16A16_SNORM, DXGI_FORMAT_R16G16B16A16_SINT
+
+        case DXGI_FORMAT_R8G8B8A8_TYPELESS:
+            return DXGI_FORMAT_R8G8B8A8_UNORM;      // or DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, DXGI_FORMAT_R8G8B8A8_UINT, DXGI_FORMAT_R8G8B8A8_SNORM, DXGI_FORMAT_R8G8B8A8_SINT
+
+        case DXGI_FORMAT_B8G8R8A8_TYPELESS:
+            return DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
+
+        case DXGI_FORMAT_B8G8R8X8_TYPELESS:
+            return DXGI_FORMAT_B8G8R8X8_UNORM_SRGB;
+
+      // Others which we don't currently support:
+      //case DXGI_FORMAT_R32G32_TYPELESS:
+      //case DXGI_FORMAT_R32G8X24_TYPELESS:
+      //case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:
+      //case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:
+      //case DXGI_FORMAT_R10G10B10A2_TYPELESS:
+      //case DXGI_FORMAT_R16G16_TYPELESS:
+      //case DXGI_FORMAT_R32_TYPELESS:
+      //case DXGI_FORMAT_R24G8_TYPELESS:
+      //case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:
+      //case DXGI_FORMAT_X24_TYPELESS_G8_UINT:
+      //case DXGI_FORMAT_R8G8_TYPELESS:
+      //case DXGI_FORMAT_R16_TYPELESS:
+      //case DXGI_FORMAT_R8_TYPELESS:
+      //case DXGI_FORMAT_BC1_TYPELESS:
+      //case DXGI_FORMAT_BC2_TYPELESS:
+      //case DXGI_FORMAT_BC3_TYPELESS:
+      //case DXGI_FORMAT_BC4_TYPELESS:
+      //case DXGI_FORMAT_BC5_TYPELESS:
+      //case DXGI_FORMAT_BC6H_TYPELESS:
+      //case DXGI_FORMAT_BC7_TYPELESS:
+    }
+
+    return fullyTypedFormat;
+}
+
+
+
+namespace OVR { namespace CAPI { 
+
+// To do Need to move LoadTextureTgaData to a shared location.
+uint8_t* LoadTextureTgaData(OVR::File* f, uint8_t alpha, int& width, int& height);
+
+
+namespace D3D_NS {
+
+// This is a temporary function implementation, and it functionality needs to be implemented in a more generic way.
+Texture* LoadTextureTga(RenderParams& rParams, ID3D1xSamplerState* pSamplerState, OVR::File* f, uint8_t alpha)
+{
+    OVR::CAPI::D3D_NS::Texture* pTexture = NULL;
+
+    int width, height;
+    const uint8_t* pRGBA = LoadTextureTgaData(f, alpha, width, height);
+
+    if (pRGBA)
+    {
+        pTexture = new OVR::CAPI::D3D_NS::Texture(&rParams, OVR::CAPI::D3D_NS::Texture_RGBA, OVR::Sizei(0,0), pSamplerState, 1);
+
+        // Create the D3D texture
+        D3D1X_(TEXTURE2D_DESC) dsDesc;
+		dsDesc.Width              = width;
+		dsDesc.Height             = height;
+        dsDesc.MipLevels          = 1;
+        dsDesc.ArraySize          = 1;
+        dsDesc.Format             = DXGI_FORMAT_R8G8B8A8_UNORM;
+		dsDesc.SampleDesc.Count   = 1;
+        dsDesc.SampleDesc.Quality = 0;
+        dsDesc.Usage              = D3D1X_(USAGE_DEFAULT);
+        dsDesc.BindFlags          = D3D1X_(BIND_SHADER_RESOURCE);
+        dsDesc.CPUAccessFlags     = 0;
+        dsDesc.MiscFlags          = 0;
+
+        HRESULT hr = rParams.pDevice->CreateTexture2D(&dsDesc, NULL, &pTexture->Tex.GetRawRef());
+
+        if (SUCCEEDED(hr))
+        {
+            if (dsDesc.BindFlags & D3D1X_(BIND_SHADER_RESOURCE))
+                rParams.pDevice->CreateShaderResourceView(pTexture->Tex, NULL, &pTexture->TexSv.GetRawRef());
+
+            rParams.pContext->UpdateSubresource(pTexture->Tex, 0, NULL, pRGBA, width * 4, width * height * 4);
+        }
+        else
+        {
+            OVR_DEBUG_LOG_TEXT(("[LoadTextureTga] CreateTexture2D failed"));
+            pTexture->Release();
+        }
+
+        OVR_FREE(const_cast<uint8_t*>(pRGBA));
+    }
+
+    return pTexture;
+}
+
+
+// Loads a texture from a memory image of a TGA file.
+Texture* LoadTextureTga(RenderParams& rParams, ID3D1xSamplerState* pSamplerState, const uint8_t* pData, int dataSize, uint8_t alpha)
+{
+    MemoryFile memoryFile("", pData, dataSize);
+
+    return LoadTextureTga(rParams, pSamplerState, &memoryFile, alpha);
+}
+
+
+// Loads a texture from a disk TGA file.
+Texture* LoadTextureTga(RenderParams& rParams, ID3D1xSamplerState* pSamplerState, const char* pFilePath, uint8_t alpha)
+{
+    SysFile sysFile;
+
+    if(sysFile.Open(pFilePath, FileConstants::Open_Read | FileConstants::Open_Buffered))
+        return LoadTextureTga(rParams, pSamplerState, &sysFile, alpha);
+
+    return NULL;
+}
+
+
+
+// To do: This needs to be promoted to a central version, possibly in CAPI_HSWDisplay.h
+struct HASWVertex
+{
+    Vector3f  Pos;
+    Color     C;
+    float     U, V;	
+
+    HASWVertex(const Vector3f& p, const Color& c = Color(64,0,0,255), float u = 0, float v = 0)
+        : Pos(p), C(c), U(u), V(v)
+    {}
+
+    HASWVertex(float x, float y, float z, const Color& c = Color(64,0,0,255), float u = 0, float v = 0) 
+        : Pos(x,y,z), C(c), U(u), V(v)
+    {}
+
+    bool operator==(const HASWVertex& b) const
+    {
+        return (Pos == b.Pos) && (C == b.C) && (U == b.U) && (V == b.V);
+    }
+};
+
+
+
+// The texture below may conceivably be shared between HSWDisplay instances. However,  
+// beware that sharing may not be possible if two HMDs are using different locales  
+// simultaneously. As of this writing it's not clear if that can occur in practice.
+
+HSWDisplay::HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState)
+  : OVR::CAPI::HSWDisplay(api, hmd, renderState),
+    RenderParams()
+{
+}
+
+bool HSWDisplay::Initialize(const ovrRenderAPIConfig* apiConfig)
+{
+    #if (OVR_D3D_VERSION == 10)
+        const ovrD3D10Config* config = reinterpret_cast<const ovrD3D10Config*>(apiConfig);
+    #else
+        const ovrD3D11Config* config = reinterpret_cast<const ovrD3D11Config*>(apiConfig);
+    #endif
+
+    if(config)
+    {
+        RenderParams.pDevice	   = config->D3D_NS.pDevice;
+        #if (OVR_D3D_VERSION == 10)    
+        RenderParams.pContext      = config->D3D10.pDevice;
+        #else
+        RenderParams.pContext      = config->D3D11.pDeviceContext;
+        #endif
+        RenderParams.pBackBufferRT = config->D3D_NS.pBackBufferRT;
+        RenderParams.pSwapChain    = config->D3D_NS.pSwapChain;
+        RenderParams.RTSize        = config->D3D_NS.Header.RTSize;
+        RenderParams.Multisample   = config->D3D_NS.Header.Multisample;
+
+        // We may want to create RasterizerState, or alternatively let the DistortionRenderer handle it.
+    }
+    // else do any necessary cleanup
+
+    return true;
+}
+
+void HSWDisplay::Shutdown()
+{
+    UnloadGraphics();
+}
+
+
+void HSWDisplay::DisplayInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay D3D1x] DisplayInternal()"));
+    // We may want to call LoadGraphics here instead of within Render.
+}
+
+
+void HSWDisplay::DismissInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay D3D1x] DismissInternal()"));
+    UnloadGraphics();
+}
+
+
+void HSWDisplay::UnloadGraphics()
+{
+    //RenderParams: nothing to do.
+    pSamplerState.Clear();
+    pTexture.Clear();
+    pVB.Clear();
+    for(size_t i = 0; i < OVR_ARRAY_COUNT(UniformBufferArray); i++)
+        UniformBufferArray[i].Clear();
+    pShaderSet.Clear();
+    pVertexInputLayout.Clear();
+    pBlendState.Clear();
+    pRasterizerState.Clear();
+    // OrthoProjection: No need to clear.
+}
+
+void HSWDisplay::LoadGraphics()
+{
+    // Load the graphics if not loaded already.
+    if(!pSamplerState)
+    {
+        D3D1X_(SAMPLER_DESC) sDesc;
+
+        memset(&sDesc, 0, sizeof(sDesc));
+        sDesc.Filter   = D3D1X_(FILTER_MIN_MAG_MIP_LINEAR);
+        sDesc.AddressU = D3D1X_(TEXTURE_ADDRESS_CLAMP);
+        sDesc.AddressV = D3D1X_(TEXTURE_ADDRESS_CLAMP);
+        sDesc.AddressW = D3D1X_(TEXTURE_ADDRESS_CLAMP);
+
+        RenderParams.pDevice->CreateSamplerState(&sDesc, &pSamplerState.GetRawRef());
+    }
+
+    #if defined(OVR_BUILD_DEBUG)
+        if(!pTexture)
+            pTexture = *LoadTextureTga(RenderParams, pSamplerState, "C:\\TestPath\\TestFile.tga", 255);
+    #endif
+
+    if(!pTexture) // To do: Add support for .dds files, which would be significantly smaller than the size of the tga.
+    {
+        size_t textureSize;
+        const uint8_t* TextureData = GetDefaultTexture(textureSize);
+        pTexture = *LoadTextureTga(RenderParams, pSamplerState, TextureData, (int)textureSize, 255);
+    }
+
+    if(!UniformBufferArray[0])
+    {
+        for(size_t i = 0; i < OVR_ARRAY_COUNT(UniformBufferArray); i++)
+            UniformBufferArray[i] = *new Buffer(&RenderParams);
+    }
+
+    if(!pShaderSet)
+    {
+        pShaderSet = *new ShaderSet;
+
+        // Setup the vertex shader
+        const D3D1X_(INPUT_ELEMENT_DESC) VertexDescription[] = {
+            { "Position", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, offsetof(HASWVertex, Pos), D3D1X_(INPUT_PER_VERTEX_DATA), 0 },
+            { "Color",    0, DXGI_FORMAT_R8G8B8A8_UNORM,  0, offsetof(HASWVertex, C),   D3D1X_(INPUT_PER_VERTEX_DATA), 0 },
+            { "TexCoord", 0, DXGI_FORMAT_R32G32_FLOAT,    0, offsetof(HASWVertex, U),   D3D1X_(INPUT_PER_VERTEX_DATA), 0 }
+        };
+
+        Ptr<D3D_NS::VertexShader> vs = *new D3D_NS::VertexShader(&RenderParams,  (void*)SimpleTexturedQuad_vs, sizeof(SimpleTexturedQuad_vs), SimpleTexturedQuad_vs_refl, OVR_ARRAY_COUNT(SimpleTexturedQuad_vs_refl));
+        pVertexInputLayout = NULL; // Make sure it's cleared in case it wasn't.
+        ID3D1xInputLayout** ppD3DInputLayout = &pVertexInputLayout.GetRawRef();
+        HRESULT hResult = RenderParams.pDevice->CreateInputLayout(VertexDescription, OVR_ARRAY_COUNT(VertexDescription), SimpleTexturedQuad_vs, sizeof(SimpleTexturedQuad_vs), ppD3DInputLayout);
+        OVR_ASSERT(SUCCEEDED(hResult));
+        if(SUCCEEDED(hResult))
+            pShaderSet->SetShader(vs);
+
+        // Setup the pixel shader
+        Ptr<D3D_NS::PixelShader> ps  = *new D3D_NS::PixelShader(&RenderParams, (void*)SimpleTexturedQuad_ps, sizeof(SimpleTexturedQuad_ps), SimpleTexturedQuad_ps_refl, OVR_ARRAY_COUNT(SimpleTexturedQuad_ps_refl));
+        pShaderSet->SetShader(ps);
+
+        if(!pBlendState)
+        {
+            D3D1X_(BLEND_DESC) bm;
+            memset(&bm, 0, sizeof(bm));
+            #if (OVR_D3D_VERSION == 10)
+                bm.BlendEnable[0] = TRUE;
+                bm.BlendOp   = bm.BlendOpAlpha   = D3D1X_(BLEND_OP_ADD);
+                bm.SrcBlend  = bm.SrcBlendAlpha  = D3D1X_(BLEND_SRC_ALPHA);
+                bm.DestBlend = bm.DestBlendAlpha = D3D1X_(BLEND_INV_SRC_ALPHA);
+                bm.RenderTargetWriteMask[0] = D3D1X_(COLOR_WRITE_ENABLE_ALL);
+            #else
+                bm.RenderTarget[0].BlendEnable = TRUE;
+                bm.RenderTarget[0].BlendOp   = bm.RenderTarget[0].BlendOpAlpha   = D3D1X_(BLEND_OP_ADD);
+                bm.RenderTarget[0].SrcBlend  = bm.RenderTarget[0].SrcBlendAlpha  = D3D1X_(BLEND_SRC_ALPHA);
+                bm.RenderTarget[0].DestBlend = bm.RenderTarget[0].DestBlendAlpha = D3D1X_(BLEND_INV_SRC_ALPHA);
+                bm.RenderTarget[0].RenderTargetWriteMask = D3D1X_(COLOR_WRITE_ENABLE_ALL);
+            #endif
+
+            RenderParams.pDevice->CreateBlendState(&bm, &pBlendState.GetRawRef());
+        }
+
+        if(!pRasterizerState)
+        {
+            D3D1X_(RASTERIZER_DESC) rs;
+            memset(&rs, 0, sizeof(rs));
+            rs.AntialiasedLineEnable = true;
+            rs.CullMode              = D3D1X_(CULL_BACK);    
+            rs.DepthClipEnable       = true;
+            rs.FillMode              = D3D1X_(FILL_SOLID);
+
+            RenderParams.pDevice->CreateRasterizerState(&rs, &pRasterizerState.GetRawRef());
+        }
+    }
+
+    if(!pVB)
+    {
+        pVB = *new Buffer(&RenderParams);
+
+        if(pVB)
+        {
+            const size_t vertexCount = 4;
+
+            pVB->Data(Buffer_Vertex, NULL, vertexCount * sizeof(HASWVertex));
+            HASWVertex* pVertices = (HASWVertex*)pVB->Map(0, vertexCount * sizeof(HASWVertex), Map_Discard);
+            OVR_ASSERT(pVertices);
+
+            if(pVertices)
+            {
+                const bool  flip   = ((RenderState.DistortionCaps & ovrDistortionCap_FlipInput) != 0);
+                const float left   = -1.0f; // We currently draw this in normalized device coordinates with an stereo translation
+                const float top    = -1.1f; // applied as a vertex shader uniform. In the future when we have a more formal graphics
+                const float right  =  1.0f; // API abstraction we may move this draw to an overlay layer or to a more formal 
+                const float bottom =  0.9f; // model/mesh scheme with a perspective projection.
+
+                pVertices[0] = HASWVertex(left,  top,    0.f, Color(255, 255, 255, 255), 0.f, flip ? 1.f : 0.f); 
+                pVertices[1] = HASWVertex(left,  bottom, 0.f, Color(255, 255, 255, 255), 0.f, flip ? 0.f : 1.f);
+                pVertices[2] = HASWVertex(right, top,    0.f, Color(255, 255, 255, 255), 1.f, flip ? 1.f : 0.f); 
+                pVertices[3] = HASWVertex(right, bottom, 0.f, Color(255, 255, 255, 255), 1.f, flip ? 0.f : 1.f);
+
+                pVB->Unmap(pVertices);
+            }
+        }
+    }
+}
+
+
+// Note: If we are drawing this warning onto the eye texture before distortion, the "time warp" functionality
+// will cause the warning to shake on the screen when the user moves their head. One solution is to disable
+// time warping while the warning or any screen-static GUI elements are present.
+
+void HSWDisplay::RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture)
+{
+    if(RenderEnabled && eyeTexture)
+    {
+        // We need to render to the eyeTexture with the texture viewport.
+        // Setup rendering to the texture.
+        ovrD3D1X(Texture)* eyeTextureD3D = const_cast<ovrD3D1X(Texture)*>(reinterpret_cast<const ovrD3D1X(Texture)*>(eyeTexture));
+        OVR_ASSERT(eyeTextureD3D->Texture.Header.API == ((OVR_D3D_VERSION == 10) ? ovrRenderAPI_D3D10 : ovrRenderAPI_D3D11));
+
+        // D3D10 is currently disabled while we track down a bug that results in a black screen.
+        //if(eyeTextureD3D->Texture.Header.API == ovrRenderAPI_D3D10)
+        //    return;
+
+        // Load the graphics if not loaded already.
+        if(!pVB)
+            LoadGraphics();
+
+        // Calculate ortho projection.
+        GetOrthoProjection(RenderState, OrthoProjection);
+
+        // Save settings
+        // To do: Merge this saved state with that done by DistortionRenderer::GraphicsState::Save(), and put them in a shared location.
+        Ptr<ID3D1xBlendState> pBlendStateSaved;
+        FLOAT blendFactorSaved[4];
+        UINT blendSampleMaskSaved;
+        RenderParams.pContext->OMGetBlendState(&pBlendStateSaved.GetRawRef(), blendFactorSaved, &blendSampleMaskSaved);
+
+        Ptr<ID3D1xRasterizerState> pRasterizerStateSaved;
+        RenderParams.pContext->RSGetState(&pRasterizerStateSaved.GetRawRef());
+
+        Ptr<ID3D1xRenderTargetView> pTextureRenderTargetViewSaved;
+        Ptr<ID3D1xDepthStencilView> pDepthStencilViewSaved;
+        RenderParams.pContext->OMGetRenderTargets(1, &pTextureRenderTargetViewSaved.GetRawRef(), &pDepthStencilViewSaved.GetRawRef());
+
+        #ifndef D3D10_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE // D3D10 doesn't define this, so we pretend that it does.
+            #define D3D10_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE 4
+        #endif
+        D3D1x_VIEWPORT d3dViewportSaved[D3D1X_(VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE)];
+        UINT viewportCountSaved = OVR_ARRAY_COUNT(d3dViewportSaved);
+        RenderParams.pContext->RSGetViewports(&viewportCountSaved, d3dViewportSaved);
+
+        UINT stencilRefSaved;
+        Ptr<ID3D1xDepthStencilState> pDepthStencilStateSaved;
+        RenderParams.pContext->OMGetDepthStencilState(&pDepthStencilStateSaved.GetRawRef(), &stencilRefSaved);
+
+        Ptr<ID3D1xInputLayout> pInputLayoutSaved;
+        RenderParams.pContext->IAGetInputLayout(&pInputLayoutSaved.GetRawRef());
+
+        Ptr<ID3D1xBuffer> pVertexBufferSaved;
+        UINT vertexStrideSaved[1];
+        UINT vertexOffsetSaved[1];
+        RenderParams.pContext->IAGetVertexBuffers(0, 1, &pVertexBufferSaved.GetRawRef(), vertexStrideSaved, vertexOffsetSaved);
+
+        D3D1X_(PRIMITIVE_TOPOLOGY) topologySaved;
+        RenderParams.pContext->IAGetPrimitiveTopology(&topologySaved);
+
+
+        // Set our settings
+        RenderParams.pContext->OMSetBlendState(pBlendState, NULL, 0xffffffff);
+        RenderParams.pContext->RSSetState(pRasterizerState);
+
+        // We can't necessarily use a NULL D3D11_RENDER_TARGET_VIEW_DESC argument to CreateRenderTargetView, because we are rendering to
+        // a texture that somebody else created and which may have been created in a typeless format (e.g. DXGI_FORMAT_R8G8B8A8_TYPELESS).
+        // So what we do is check to see if the texture format is a typeless format and if see we pass a suitable D3D11_RENDER_TARGET_VIEW_DESC
+        // to CreateRenderTargetView instead of NULL.
+        D3D1X_(TEXTURE2D_DESC) texture2DDesc;
+        eyeTextureD3D->D3D_NS.pTexture->GetDesc(&texture2DDesc);
+
+        D3D1X_(RENDER_TARGET_VIEW_DESC) renderTargetViewDesc;
+        memset(&renderTargetViewDesc, 0, sizeof(renderTargetViewDesc));
+        renderTargetViewDesc.Format = GetFullyTypedDXGIFormat(texture2DDesc.Format); // DXGI_FORMAT. If this is a typeless format then GetFullyTypedFormat converts it to a fully typed format. 
+        renderTargetViewDesc.ViewDimension = (texture2DDesc.SampleDesc.Count > 1) ? D3D1X_(RTV_DIMENSION_TEXTURE2DMS) : D3D1X_(RTV_DIMENSION_TEXTURE2D);
+        renderTargetViewDesc.Texture2D.MipSlice = 0;
+        Ptr<ID3D1xRenderTargetView> pTextureRenderTargetView;
+        HRESULT hResult = RenderParams.pDevice->CreateRenderTargetView(eyeTextureD3D->D3D_NS.pTexture, (renderTargetViewDesc.Format == texture2DDesc.Format) ? NULL : &renderTargetViewDesc, &pTextureRenderTargetView.GetRawRef());
+
+        if(SUCCEEDED(hResult))
+        {
+            RenderParams.pContext->OMSetRenderTargets(1, &pTextureRenderTargetView.GetRawRef(), NULL); // We currently don't bind a depth buffer.
+
+            D3D1x_VIEWPORT D3DViewport;
+
+            OVR_DISABLE_MSVC_WARNING(4244) // conversion from int to float
+            D3DViewport.TopLeftX = eyeTextureD3D->Texture.Header.RenderViewport.Pos.x;
+            D3DViewport.TopLeftY = eyeTextureD3D->Texture.Header.RenderViewport.Pos.y;    
+            D3DViewport.Width    = eyeTextureD3D->Texture.Header.RenderViewport.Size.w;
+            D3DViewport.Height   = eyeTextureD3D->Texture.Header.RenderViewport.Size.h;
+            D3DViewport.MinDepth = 0;
+            D3DViewport.MaxDepth = 1;
+            RenderParams.pContext->RSSetViewports(1, &D3DViewport);
+            OVR_RESTORE_MSVC_WARNING()
+
+            // We don't set up a world/view/projection matrix because we are using 
+            // normalized device coordinates below.
+
+            // We don't set the depth state because we aren't using it.
+            //     RenderParams.pContext->OMSetDepthStencilState(<depth state>, 0);
+
+            ShaderFill fill(pShaderSet);
+            fill.SetInputLayout(pVertexInputLayout);
+            if(pTexture)
+                fill.SetTexture(0, pTexture);
+
+            const float scale  = HSWDISPLAY_SCALE * ((RenderState.OurHMDInfo.HmdType == HmdType_DK1) ? 0.70f : 1.f);
+            pShaderSet->SetUniform2f("Scale", scale, scale / 2.f); // X and Y scale. Y is a fixed proportion to X in order to give a certain aspect ratio.
+            pShaderSet->SetUniform4f("Color", 1.f, 1.f, 1.f, 1.f);
+            pShaderSet->SetUniform2f("PositionOffset", OrthoProjection[eye].GetTranslation().x, 0.0f);
+
+            RenderParams.pContext->IASetInputLayout((ID3D1xInputLayout*)fill.GetInputLayout());    
+
+            ID3D1xBuffer* vertexBuffer = pVB->GetBuffer();
+            UINT          vertexStride = sizeof(HASWVertex);
+            UINT          vertexOffset = 0;
+            RenderParams.pContext->IASetVertexBuffers(0, 1, &vertexBuffer, &vertexStride, &vertexOffset);
+
+            ShaderBase*    vShaderBase = (ShaderBase*)pShaderSet->GetShader(OVR::CAPI::D3D_NS::Shader_Vertex);
+            unsigned char* vertexData = vShaderBase->UniformData;
+
+            if (vertexData)
+            {
+		        UniformBufferArray[OVR::CAPI::D3D_NS::Shader_Vertex]->Data(OVR::CAPI::D3D_NS::Buffer_Uniform, vertexData, vShaderBase->UniformsSize);
+		        vShaderBase->SetUniformBuffer(UniformBufferArray[OVR::CAPI::D3D_NS::Shader_Vertex]);
+            }
+
+            for (int i = (OVR::CAPI::D3D_NS::Shader_Vertex + 1); i < OVR::CAPI::D3D_NS::Shader_Count; i++)
+            {
+                if (pShaderSet->GetShader(i))
+                {
+                    ((ShaderBase*)pShaderSet->GetShader(i))->UpdateBuffer(UniformBufferArray[i]);
+                    ((ShaderBase*)pShaderSet->GetShader(i))->SetUniformBuffer(UniformBufferArray[i]);
+                }
+            }
+
+            RenderParams.pContext->IASetPrimitiveTopology(D3D1X_(PRIMITIVE_TOPOLOGY_TRIANGLESTRIP));
+            fill.Set(Prim_TriangleStrip);
+
+            RenderParams.pContext->Draw(4, 0);
+        }
+        else
+        {
+            HSWDISPLAY_LOG(("[HSWDisplay D3D1x] CreateRenderTargetView() failed"));
+        }
+
+
+        // Restore settings
+        RenderParams.pContext->IASetPrimitiveTopology(topologySaved);
+        RenderParams.pContext->IASetVertexBuffers(0, 1, &pVertexBufferSaved.GetRawRef(), &vertexStrideSaved[0], &vertexOffsetSaved[0]);
+        RenderParams.pContext->IASetInputLayout(pInputLayoutSaved);
+        RenderParams.pContext->OMSetDepthStencilState(pDepthStencilStateSaved, stencilRefSaved);
+        RenderParams.pContext->RSSetViewports(viewportCountSaved, d3dViewportSaved);
+        RenderParams.pContext->OMSetRenderTargets(1, &pTextureRenderTargetViewSaved.GetRawRef(), pDepthStencilViewSaved);
+        RenderParams.pContext->RSSetState(pRasterizerStateSaved);
+        RenderParams.pContext->OMSetBlendState(pBlendStateSaved, blendFactorSaved, blendSampleMaskSaved);
+    }
+}
+
+}}} // namespace OVR::CAPI::D3D_NS
+
+
+#endif // OVR_D3D_VERSION
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,84 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// Do not use include guards, as this file is #included separately by both 
+// CAPI_D3D10_HSWDisplay.h and CAPI_D3D11_HSWDisplay.h with OVR_D3D_VERSION defined
+// to either 10 or 11. Only those two headers should #include this one.
+//#ifndef OVR_CAPI_D3D1X_HSWDisplay_h
+//#define OVR_CAPI_D3D1X_HSWDisplay_h
+
+//#if !defined(OVR_CAPI_D3D10_HSWDisplay_h) && !defined(OVR_CAPI_D3D11_HSWDisplay_h)
+//    #error This header is expected to be compiled only by these two headers.
+//#endif
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_D3D1X_Util.h"
+
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrD3D11Config* config = (const ovrD3D11Config*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void LoadGraphics();
+        void UnloadGraphics();
+
+        OVR::CAPI::D3D_NS::RenderParams   RenderParams;
+        Ptr<ID3D1xSamplerState>           pSamplerState;
+        Ptr<OVR::CAPI::D3D_NS::Texture>   pTexture;
+        Ptr<Buffer>                       pVB;
+        Ptr<Buffer>                       UniformBufferArray[OVR::CAPI::D3D_NS::Shader_Count];
+        Ptr<ShaderSet>                    pShaderSet;
+        Ptr<ID3D1xInputLayout>            pVertexInputLayout;
+        Ptr<ID3D1xBlendState>             pBlendState;
+        Ptr<ID3D1xRasterizerState>        pRasterizerState;
+        Matrix4f                          OrthoProjection[ovrEye_Count];
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::D3D_NS
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,417 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_Util.cpp
+Content     :   D3DX10 utility classes for rendering
+Created     :   September 10, 2012
+Authors     :   Andrew Reisse
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_D3D1X_Util.h"
+
+#include <d3dcompiler.h>
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+
+//-------------------------------------------------------------------------------------
+// ***** ShaderFill
+
+void ShaderFill::Set(PrimitiveType prim) const
+{
+    Shaders->Set(prim);
+    for(int i = 0; i < 8; i++)
+    {
+        if(Textures[i])
+        {
+            Textures[i]->Set(i);
+        }
+    }
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Buffer
+
+Buffer::~Buffer()
+{
+}
+
+bool Buffer::Data(int use, const void *buffer, size_t size)
+{
+    if (D3DBuffer && Size >= size)
+    {
+        if (Dynamic)
+        {
+            if (!buffer)
+                return true;
+
+            void* v = Map(0, size, Map_Discard);
+            if (v)
+            {
+                memcpy(v, buffer, size);
+                Unmap(v);
+                return true;
+            }
+        }
+        else
+        {
+            pParams->pContext->UpdateSubresource(D3DBuffer, 0, NULL, buffer, 0, 0);
+            return true;
+        }
+    }
+    if (D3DBuffer)
+    {
+        D3DBuffer = NULL;
+        Size = 0;
+        Use = 0;
+        Dynamic = 0;
+    }
+
+    D3D1X_(BUFFER_DESC) desc;
+    memset(&desc, 0, sizeof(desc));
+    if (use & Buffer_ReadOnly)
+    {
+        desc.Usage = D3D1X_(USAGE_IMMUTABLE);
+        desc.CPUAccessFlags = 0;
+    }
+    else
+    {
+        desc.Usage = D3D1X_(USAGE_DYNAMIC);
+        desc.CPUAccessFlags = D3D1X_(CPU_ACCESS_WRITE);
+        Dynamic = 1;
+    }
+
+    switch(use & Buffer_TypeMask)
+    {
+    case Buffer_Vertex:  desc.BindFlags = D3D1X_(BIND_VERTEX_BUFFER); break;
+    case Buffer_Index:   desc.BindFlags = D3D1X_(BIND_INDEX_BUFFER);  break;
+    case Buffer_Uniform:
+        desc.BindFlags = D3D1X_(BIND_CONSTANT_BUFFER);
+        size += ((size + 15) & ~15) - size;
+        break;
+    }
+
+    desc.ByteWidth = (unsigned)size;
+
+    D3D1X_(SUBRESOURCE_DATA) sr;
+    sr.pSysMem = buffer;
+    sr.SysMemPitch = 0;
+    sr.SysMemSlicePitch = 0;
+
+    D3DBuffer = NULL;
+    HRESULT hr = pParams->pDevice->CreateBuffer(&desc, buffer ? &sr : NULL, &D3DBuffer.GetRawRef());
+    if (SUCCEEDED(hr))
+    {
+        Use = use;
+        Size = desc.ByteWidth;
+        return 1;
+    }
+    return 0;
+}
+
+void*  Buffer::Map(size_t start, size_t size, int flags)
+{
+    OVR_UNUSED(size);
+
+    D3D1X_(MAP) mapFlags = D3D1X_(MAP_WRITE);
+    if (flags & Map_Discard)    
+        mapFlags = D3D1X_(MAP_WRITE_DISCARD);    
+    if (flags & Map_Unsynchronized)    
+        mapFlags = D3D1X_(MAP_WRITE_NO_OVERWRITE);
+
+#if (OVR_D3D_VERSION == 10)
+    void* map;
+    if (SUCCEEDED(D3DBuffer->Map(mapFlags, 0, &map)))    
+        return ((char*)map) + start;    
+#else
+    D3D11_MAPPED_SUBRESOURCE map;
+    if (SUCCEEDED(pParams->pContext->Map(D3DBuffer, 0, mapFlags, 0, &map)))
+        return ((char*)map.pData) + start;
+#endif
+
+    return NULL;
+}
+
+bool   Buffer::Unmap(void *m)
+{
+    OVR_UNUSED(m);
+
+    D3DSELECT_10_11( D3DBuffer->Unmap(),
+                     pParams->pContext->Unmap(D3DBuffer, 0) );
+    return true;
+}
+
+
+//-------------------------------------------------------------------------------------
+// Shaders
+
+template<> bool ShaderImpl<Shader_Vertex, ID3D1xVertexShader>::Load(void* shader, size_t size)
+{
+    return SUCCEEDED(pParams->pDevice->CreateVertexShader(shader, size  D3D11_COMMA_0, &D3DShader));
+}
+template<> bool ShaderImpl<Shader_Pixel, ID3D1xPixelShader>::Load(void* shader, size_t size)
+{
+    return SUCCEEDED(pParams->pDevice->CreatePixelShader(shader, size  D3D11_COMMA_0, &D3DShader));
+}
+
+template<> void ShaderImpl<Shader_Vertex, ID3D1xVertexShader>::Set(PrimitiveType) const
+{
+    pParams->pContext->VSSetShader(D3DShader D3D11_COMMA_0 D3D11_COMMA_0 );
+}
+template<> void ShaderImpl<Shader_Pixel, ID3D1xPixelShader>::Set(PrimitiveType) const
+{
+    pParams->pContext->PSSetShader(D3DShader D3D11_COMMA_0 D3D11_COMMA_0 ) ;
+}
+
+template<> void ShaderImpl<Shader_Vertex, ID3D1xVertexShader>::SetUniformBuffer(Buffer* buffer, int i)
+{
+    pParams->pContext->VSSetConstantBuffers(i, 1, &((Buffer*)buffer)->D3DBuffer.GetRawRef());
+}
+template<> void ShaderImpl<Shader_Pixel, ID3D1xPixelShader>::SetUniformBuffer(Buffer* buffer, int i)
+{
+    pParams->pContext->PSSetConstantBuffers(i, 1, &((Buffer*)buffer)->D3DBuffer.GetRawRef());
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Shader Base
+
+ShaderBase::ShaderBase(RenderParams* rp, ShaderStage stage)
+    : Shader(stage), pParams(rp), UniformData(0)
+{
+}
+ShaderBase::~ShaderBase()
+{
+    if (UniformData)    
+        OVR_FREE(UniformData);    
+}
+
+bool ShaderBase::SetUniform(const char* name, int n, const float* v)
+{
+    for(unsigned i = 0; i < UniformReflSize; i++)
+    {
+        if (!strcmp(UniformRefl[i].Name, name))
+        {
+            memcpy(UniformData + UniformRefl[i].Offset, v, n * sizeof(float));
+            return 1;
+        }
+    }
+    return 0;
+}
+
+bool ShaderBase::SetUniformBool(const char* name, int n, const bool* v) 
+{
+    OVR_UNUSED(n);
+    for(unsigned i = 0; i < UniformReflSize; i++)
+    {
+        if (!strcmp(UniformRefl[i].Name, name))
+        {
+            memcpy(UniformData + UniformRefl[i].Offset, v, UniformRefl[i].Size);
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void ShaderBase::InitUniforms(const Uniform* refl, size_t reflSize)
+{
+    if(!refl)
+    {
+        UniformRefl = NULL;
+        UniformReflSize = 0;
+
+        UniformsSize = 0;
+        if (UniformData)
+        {
+            OVR_FREE(UniformData);
+            UniformData = 0;
+        }
+        return; // no reflection data
+    }
+
+    UniformRefl = refl;
+    UniformReflSize = reflSize;
+    
+    UniformsSize = UniformRefl[UniformReflSize-1].Offset + UniformRefl[UniformReflSize-1].Size;
+    UniformData = (unsigned char*)OVR_ALLOC(UniformsSize);
+}
+
+void ShaderBase::UpdateBuffer(Buffer* buf)
+{
+    if (UniformsSize)
+    {
+        buf->Data(Buffer_Uniform, UniformData, UniformsSize);
+    }
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Texture
+// 
+Texture::Texture(RenderParams* rp, int fmt, const Sizei texSize,
+                 ID3D1xSamplerState* sampler, int samples)
+    : pParams(rp), Tex(NULL), TexSv(NULL), TexRtv(NULL), TexDsv(NULL),
+    TextureSize(texSize),
+    Sampler(sampler),
+    Samples(samples)
+{
+    OVR_UNUSED(fmt);    
+}
+
+Texture::~Texture()
+{
+}
+
+void Texture::Set(int slot, ShaderStage stage) const
+{    
+    ID3D1xShaderResourceView* texSv = TexSv.GetPtr();
+
+    switch(stage)
+    {
+    case Shader_Fragment:
+        pParams->pContext->PSSetShaderResources(slot, 1, &texSv);
+        pParams->pContext->PSSetSamplers(slot, 1, &Sampler.GetRawRef());        
+        break;
+
+    case Shader_Vertex:
+        pParams->pContext->VSSetShaderResources(slot, 1, &texSv);
+        break;
+    }
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** GpuTimer
+// 
+#if (OVR_D3D_VERSION == 11)
+#define D3DQUERY_EXEC(_context_, _query_, _command_, ...)  _context_->_command_(_query_, __VA_ARGS__)
+#else
+#define D3DQUERY_EXEC(_context_, _query_, _command_, ...)  _query_->_command_(__VA_ARGS__)
+#endif
+
+
+void GpuTimer::Init(ID3D1xDevice* device, ID3D1xDeviceContext* content)
+{
+    D3dDevice = device;
+    Context = content;    
+}
+
+void GpuTimer::BeginQuery()
+{
+    if(GotoNextFrame(LastQueuedFrame) == LastTimedFrame)
+    {
+        OVR_ASSERT(false); // too many queries queued
+        return;
+    }
+
+    LastQueuedFrame = GotoNextFrame(LastQueuedFrame);
+
+    GpuQuerySets& newQuerySet = QuerySets[LastQueuedFrame];
+    if(newQuerySet.DisjointQuery == NULL)
+    {
+        // Create the queries
+        D3D1x_QUERY_DESC desc;
+        desc.Query = D3D1X_(QUERY_TIMESTAMP_DISJOINT);
+        desc.MiscFlags = 0;
+        VERIFY_HRESULT(D3dDevice->CreateQuery(&desc, &newQuerySet.DisjointQuery));
+
+        desc.Query = D3D1X_(QUERY_TIMESTAMP);
+        VERIFY_HRESULT(D3dDevice->CreateQuery(&desc, &newQuerySet.TimeStartQuery));
+        VERIFY_HRESULT(D3dDevice->CreateQuery(&desc, &newQuerySet.TimeEndQuery));
+    }
+
+    OVR_ASSERT(!newQuerySet.QueryStarted);
+    OVR_ASSERT(!newQuerySet.QueryAwaitingTiming);
+
+    
+    D3DQUERY_EXEC(Context, QuerySets[LastQueuedFrame].DisjointQuery, Begin, );  // First start a disjoint query
+    D3DQUERY_EXEC(Context, QuerySets[LastQueuedFrame].TimeStartQuery, End, );   // Insert start timestamp
+    
+    newQuerySet.QueryStarted = true;
+    newQuerySet.QueryAwaitingTiming = false;
+    //newQuerySet.QueryTimed = false;
+}
+
+void GpuTimer::EndQuery()
+{
+    if(LastQueuedFrame > 0 && !QuerySets[LastQueuedFrame].QueryStarted)
+        return;
+
+    GpuQuerySets& doneQuerySet = QuerySets[LastQueuedFrame];
+    OVR_ASSERT(doneQuerySet.QueryStarted);
+    OVR_ASSERT(!doneQuerySet.QueryAwaitingTiming);
+
+    // Insert the end timestamp
+    D3DQUERY_EXEC(Context, doneQuerySet.TimeEndQuery, End, );
+
+    // End the disjoint query
+    D3DQUERY_EXEC(Context, doneQuerySet.DisjointQuery, End, );
+
+    doneQuerySet.QueryStarted = false;
+    doneQuerySet.QueryAwaitingTiming = true;
+}
+
+float GpuTimer::GetTiming(bool blockUntilValid)
+{
+    float time = -1.0f;
+
+    // loop until we hit a query that is not ready yet, or we have read all queued queries
+    while(LastTimedFrame != LastQueuedFrame)
+    {
+        int timeTestFrame = GotoNextFrame(LastTimedFrame);
+
+        GpuQuerySets& querySet = QuerySets[timeTestFrame];
+
+        OVR_ASSERT(!querySet.QueryStarted && querySet.QueryAwaitingTiming);
+
+        UINT64 startTime = 0;
+        UINT64 endTime = 0;
+        D3D1X_(QUERY_DATA_TIMESTAMP_DISJOINT) disjointData;
+
+        if(blockUntilValid)
+        {
+            while(D3DQUERY_EXEC(Context, querySet.TimeStartQuery, GetData, &startTime, sizeof(startTime), 0) != S_OK);
+            while(D3DQUERY_EXEC(Context, querySet.TimeEndQuery, GetData, &endTime, sizeof(endTime), 0) != S_OK);
+            while(D3DQUERY_EXEC(Context, querySet.DisjointQuery, GetData, &disjointData, sizeof(disjointData), 0) != S_OK);
+        }
+        else
+        {
+// Early return if we fail to get data for any of these
+            if(D3DQUERY_EXEC(Context, querySet.TimeStartQuery, GetData, &startTime, sizeof(startTime), 0) != S_OK)    return time;
+            if(D3DQUERY_EXEC(Context, querySet.TimeEndQuery, GetData, &endTime, sizeof(endTime), 0) != S_OK)          return time;
+            if(D3DQUERY_EXEC(Context, querySet.DisjointQuery, GetData, &disjointData, sizeof(disjointData), 0) != S_OK)    return time;
+        }
+
+        querySet.QueryAwaitingTiming = false;
+        LastTimedFrame = timeTestFrame; // successfully retrieved the timing data
+
+        if(disjointData.Disjoint == false)
+        {
+            UINT64 delta = endTime - startTime;
+            float frequency = (float)(disjointData.Frequency);
+            time = (delta / frequency);
+        }
+    }
+    
+    return time;
+}
+
+}}} // OVR::CAPI::D3DX
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,514 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_Util.h
+Content     :   D3DX 10/11 utility classes for rendering
+Created     :   September 10, 2012
+Authors     :   Andrew Reisse
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// ***** IMPORTANT:
+// This file can be included twice, once with OVR_D3D_VERSION=10 and
+// once with OVR_D3D_VERSION=11.
+
+
+#ifndef OVR_D3D_VERSION
+#error define OVR_D3D_VERSION to 10 or 11
+#endif
+
+// Custom include guard, allowing one of each D3D10/11.
+#if (OVR_D3D_VERSION == 10 && !defined(INC_OVR_CAPI_D3D10_Util_h)) || \
+    (OVR_D3D_VERSION == 11 && !defined(INC_OVR_CAPI_D3D11_Util_h))
+
+#include "../../Kernel/OVR_String.h"
+#include "../../Kernel/OVR_Array.h"
+#include "../../Kernel/OVR_Math.h"
+
+#if defined(OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <comdef.h> // for _COM_SMARTPTR_TYPEDEF()
+
+#undef D3D_NS           // namespace
+#undef D3D1X_       
+#undef ID3D1X           // interface prefix
+#undef ovrD3D1X         // ovrD3D10Config, etc.
+#undef D3D11_COMMA_0    // Injects on ", 0" for D3D11 only
+#undef D3DSELECT_10_11
+#undef IID_ID3D1xShaderReflection
+
+#if (OVR_D3D_VERSION == 10)
+
+    #define INC_OVR_CAPI_D3D10_Util_h 
+    #define D3D_NS                      D3D10
+    #define D3D1X_(x)                   D3D10_##x
+    #define ID3D1X(x)                   ID3D10##x
+    #define ovrD3D1X(x)                 ovrD3D10##x
+    #define D3DSELECT_10_11(a10, a11)   a10
+    #define D3D11_COMMA_0    
+    #define IID_ID3D1xShaderReflection  IID_ID3D10ShaderReflection
+    #include <d3d10_1.h> // avoids warning?
+    #include <d3d10.h>
+
+#else // (OVR_D3D_VERSION == 11)
+
+    #define INC_OVR_CAPI_D3D11_Util_h
+    #define D3D_NS                      D3D11        
+    #define D3D1X_(x)                   D3D11_##x
+    #define ID3D1X(x)                   ID3D11##x
+    #define ovrD3D1X(x)                 ovrD3D11##x
+    #define D3DSELECT_10_11(a10, a11)   a11
+    #define D3D11_COMMA_0               , 0
+    #define IID_ID3D1xShaderReflection  IID_ID3D11ShaderReflection
+    #include <d3d11.h>
+    #include <D3D11Shader.h>
+#endif
+#endif
+
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+// D3D Namespace-local types.
+typedef ID3D1X(Device)                          ID3D1xDevice;
+typedef ID3D1X(RenderTargetView)                ID3D1xRenderTargetView;
+typedef ID3D1X(Texture2D)                       ID3D1xTexture2D;
+typedef ID3D1X(ShaderResourceView)              ID3D1xShaderResourceView;
+typedef ID3D1X(DepthStencilView)                ID3D1xDepthStencilView;
+typedef ID3D1X(DepthStencilState)               ID3D1xDepthStencilState;
+typedef ID3D1X(InputLayout)                     ID3D1xInputLayout;
+typedef ID3D1X(Buffer)                          ID3D1xBuffer;
+typedef ID3D1X(VertexShader)                    ID3D1xVertexShader;
+typedef ID3D1X(PixelShader)                     ID3D1xPixelShader;
+typedef ID3D1X(GeometryShader)                  ID3D1xGeometryShader;
+typedef ID3D1X(BlendState)                      ID3D1xBlendState;
+typedef ID3D1X(RasterizerState)                 ID3D1xRasterizerState;
+typedef ID3D1X(SamplerState)                    ID3D1xSamplerState;
+typedef ID3D1X(Query)                           ID3D1xQuery;
+typedef ID3D1X(ShaderReflection)                ID3D1xShaderReflection;
+typedef ID3D1X(ShaderReflectionVariable)        ID3D1xShaderReflectionVariable;
+typedef ID3D1X(ShaderReflectionConstantBuffer)  ID3D1xShaderReflectionConstantBuffer;
+typedef D3D1X_(VIEWPORT)                        D3D1x_VIEWPORT;
+typedef D3D1X_(QUERY_DESC)                      D3D1x_QUERY_DESC;
+typedef D3D1X_(SHADER_BUFFER_DESC)              D3D1x_SHADER_BUFFER_DESC;
+typedef D3D1X_(SHADER_VARIABLE_DESC)            D3D1x_SHADER_VARIABLE_DESC;
+typedef D3D1X_(PRIMITIVE_TOPOLOGY)            D3D1x_PRIMITIVE_TOPOLOGY;
+static const int D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT = D3D1X_(COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
+static const int D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT = D3D1X_(COMMONSHADER_SAMPLER_SLOT_COUNT);
+static const int D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT = D3D1X_(SIMULTANEOUS_RENDER_TARGET_COUNT);
+static const int D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT = D3D1X_(IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT);
+static const int D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT = D3D1X_(COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
+// Blob is the same
+typedef ID3D10Blob                 ID3D1xBlob;
+
+#if (OVR_D3D_VERSION == 10)
+    typedef ID3D10Device		        ID3D1xDeviceContext;
+#else
+    typedef ID3D11DeviceContext         ID3D1xDeviceContext;
+#endif
+
+
+// Assert on HRESULT failure
+inline void VERIFY_HRESULT(HRESULT hr)
+{
+    if (FAILED(hr))
+        OVR_ASSERT(false);
+}
+
+class Buffer;
+
+// Rendering parameters/pointers describing D3DX rendering setup.
+struct RenderParams
+{
+    ID3D1xDevice*			pDevice;
+    ID3D1xDeviceContext*    pContext;
+    ID3D1xRenderTargetView* pBackBufferRT;
+    IDXGISwapChain*         pSwapChain;
+    Sizei                   RTSize;
+    int                     Multisample;
+};
+
+
+// Rendering primitive type used to render Model.
+enum PrimitiveType
+{
+    Prim_Triangles,
+    Prim_Lines,
+    Prim_TriangleStrip,
+    Prim_Unknown,
+    Prim_Count
+};
+
+// Types of shaders that can be stored together in a ShaderSet.
+enum ShaderStage
+{
+    Shader_Vertex   = 0,
+    Shader_Fragment = 2,
+    Shader_Pixel    = 2,
+    Shader_Count    = 3,
+};
+
+enum MapFlags
+{
+    Map_Discard        = 1,
+    Map_Read           = 2, // do not use
+    Map_Unsynchronized = 4, // like D3D11_MAP_NO_OVERWRITE
+};
+
+
+// Buffer types used for uploading geometry & constants.
+enum BufferUsage
+{
+    Buffer_Unknown  = 0,
+    Buffer_Vertex   = 1,
+    Buffer_Index    = 2,
+    Buffer_Uniform  = 4,
+    Buffer_TypeMask = 0xff,
+    Buffer_ReadOnly = 0x100, // Buffer must be created with Data().
+};
+
+enum TextureFormat
+{
+    Texture_RGBA            = 0x0100,
+    Texture_Depth           = 0x8000,
+    Texture_TypeMask        = 0xff00,
+    Texture_SamplesMask     = 0x00ff,
+    Texture_RenderTarget    = 0x10000,
+    Texture_GenMipmaps      = 0x20000,
+};
+
+// Texture sampling modes.
+enum SampleMode
+{
+    Sample_Linear       = 0,
+    Sample_Nearest      = 1,
+    Sample_Anisotropic  = 2,
+    Sample_FilterMask   = 3,
+
+    Sample_Repeat       = 0,
+    Sample_Clamp        = 4,
+    Sample_ClampBorder  = 8, // If unsupported Clamp is used instead.
+    Sample_AddressMask  =12,
+
+    Sample_Count        =13,
+};
+
+// Base class for vertex and pixel shaders. Stored in ShaderSet.
+class Shader : public RefCountBase<Shader>
+{
+    friend class ShaderSet;
+
+protected:
+    ShaderStage Stage;
+
+public:
+    Shader(ShaderStage s) : Stage(s) {}
+    virtual ~Shader() {}
+
+    ShaderStage GetStage() const { return Stage; }
+
+    virtual void Set(PrimitiveType) const { }
+    virtual void SetUniformBuffer(class Buffer* buffers, int i = 0) { OVR_UNUSED2(buffers, i); }
+
+protected:
+    virtual bool SetUniform(const char* name, int n, const float* v) { OVR_UNUSED3(name, n, v); return false; }
+    virtual bool SetUniformBool(const char* name, int n, const bool* v) { OVR_UNUSED3(name, n, v); return false; }
+};
+
+
+
+// A group of shaders, one per stage.
+// A ShaderSet is applied to a RenderDevice for rendering with a given fill.
+class ShaderSet : public RefCountBase<ShaderSet>
+{
+protected:
+    Ptr<Shader> Shaders[Shader_Count];
+
+public:
+    ShaderSet() { }
+    ~ShaderSet() { }
+
+    virtual void SetShader(Shader *s)
+    {
+        Shaders[s->GetStage()] = s;
+    }
+    virtual void UnsetShader(int stage)
+    {
+        Shaders[stage] = NULL;
+    }
+    Shader* GetShader(int stage) { return Shaders[stage]; }
+
+    virtual void Set(PrimitiveType prim) const
+    {
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                Shaders[i]->Set(prim);
+    }
+
+    // Set a uniform (other than the standard matrices). It is undefined whether the
+    // uniforms from one shader occupy the same space as those in other shaders
+    // (unless a buffer is used, then each buffer is independent).     
+    virtual bool SetUniform(const char* name, int n, const float* v)
+    {
+        bool result = 0;
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                result |= Shaders[i]->SetUniform(name, n, v);
+
+        return result;
+    }
+    bool SetUniform1f(const char* name, float x)
+    {
+        const float v[] = {x};
+        return SetUniform(name, 1, v);
+    }
+    bool SetUniform2f(const char* name, float x, float y)
+    {
+        const float v[] = {x,y};
+        return SetUniform(name, 2, v);
+    }
+    bool SetUniform3f(const char* name, float x, float y, float z)
+    {
+        const float v[] = {x,y,z};
+        return SetUniform(name, 3, v);
+    }
+    bool SetUniform4f(const char* name, float x, float y, float z, float w = 1)
+    {
+        const float v[] = {x,y,z,w};
+        return SetUniform(name, 4, v);
+    }
+
+    bool SetUniformv(const char* name, const Vector3f& v)
+    {
+        const float a[] = {v.x,v.y,v.z,1};
+        return SetUniform(name, 4, a);
+    }
+ 
+    virtual bool SetUniform4x4f(const char* name, const Matrix4f& m)
+    {
+        Matrix4f mt = m.Transposed();
+        return SetUniform(name, 16, &mt.M[0][0]);
+    }
+};
+
+
+// Fill combines a ShaderSet (vertex, pixel) with textures, if any.
+// Every model has a fill.
+class ShaderFill : public RefCountBase<ShaderFill>
+{
+    Ptr<ShaderSet>     Shaders;
+    Ptr<class Texture> Textures[8];
+    void*              InputLayout; // HACK this should be abstracted
+
+public:
+    ShaderFill(ShaderSet* sh) : Shaders(sh) { InputLayout = NULL; }
+    ShaderFill(ShaderSet& sh) : Shaders(sh) { InputLayout = NULL; }    
+
+    ShaderSet*  GetShaders() const      { return Shaders; }
+    void*       GetInputLayout() const  { return InputLayout; }
+
+    virtual void Set(PrimitiveType prim = Prim_Unknown) const;   
+    virtual void SetTexture(int i, class Texture* tex) { if (i < 8) Textures[i] = tex; }
+    void SetInputLayout(void* newIL) { InputLayout = (void*)newIL; }
+};
+
+
+class ShaderBase : public Shader
+{
+public:    
+    RenderParams*   pParams;
+    unsigned char*  UniformData;
+    int             UniformsSize;
+
+	enum VarType
+	{
+		VARTYPE_FLOAT,
+		VARTYPE_INT,
+		VARTYPE_BOOL,
+	};
+
+	struct Uniform
+	{
+		const char* Name;
+		VarType Type;
+		int     Offset, Size;
+	};
+    const Uniform* UniformRefl;
+    size_t UniformReflSize;
+
+	ShaderBase(RenderParams* rp, ShaderStage stage);
+	~ShaderBase();
+
+    ShaderStage GetStage() const { return Stage; }
+
+    void InitUniforms(const Uniform* refl, size_t reflSize);
+	bool SetUniform(const char* name, int n, const float* v);
+	bool SetUniformBool(const char* name, int n, const bool* v);
+ 
+    void UpdateBuffer(Buffer* b);
+};
+
+
+template<ShaderStage SStage, class D3DShaderType>
+class ShaderImpl : public ShaderBase
+{
+public:
+    D3DShaderType*  D3DShader;
+
+    ShaderImpl(RenderParams* rp, void* s, size_t size, const Uniform* refl, size_t reflSize) : ShaderBase(rp, SStage)
+    {
+        Load(s, size);
+        InitUniforms(refl, reflSize);
+    }
+    ~ShaderImpl()
+    {
+        if (D3DShader)        
+            D3DShader->Release();        
+    }
+
+    // These functions have specializations.
+    bool Load(void* shader, size_t size);
+    void Set(PrimitiveType prim) const;
+    void SetUniformBuffer(Buffer* buffers, int i = 0);
+};
+
+typedef ShaderImpl<Shader_Vertex,  ID3D1xVertexShader> VertexShader;
+typedef ShaderImpl<Shader_Fragment, ID3D1xPixelShader> PixelShader;
+
+
+class Buffer : public RefCountBase<Buffer>
+{
+public:
+    RenderParams*     pParams;
+    Ptr<ID3D1xBuffer> D3DBuffer;
+    size_t            Size;
+    int               Use;
+    bool              Dynamic;
+
+public:
+    Buffer(RenderParams* rp) : pParams(rp), Size(0), Use(0) {}
+    ~Buffer();
+
+    ID3D1xBuffer* GetBuffer() const { return D3DBuffer; }
+
+    virtual size_t GetSize()        { return Size; }
+    virtual void*  Map(size_t start, size_t size, int flags = 0);
+    virtual bool   Unmap(void *m);
+    virtual bool   Data(int use, const void* buffer, size_t size);
+};
+
+
+class Texture : public RefCountBase<Texture>
+{
+public:
+    RenderParams*                   pParams;
+    Ptr<ID3D1xTexture2D>            Tex;
+    Ptr<ID3D1xShaderResourceView>   TexSv;
+    Ptr<ID3D1xRenderTargetView>     TexRtv;
+    Ptr<ID3D1xDepthStencilView>     TexDsv;
+    mutable Ptr<ID3D1xSamplerState> Sampler;
+    Sizei                           TextureSize;
+    int                             Samples;
+
+    Texture(RenderParams* rp, int fmt, const Sizei texSize,
+            ID3D1xSamplerState* sampler, int samples = 1);
+    ~Texture();
+
+    virtual Sizei GetSize() const     { return TextureSize; }    
+    virtual int   GetSamples() const  { return Samples; }
+
+  //  virtual void SetSampleMode(int sm);
+
+    // Updates texture to point to specified resources
+    //  - used for slave rendering.
+    void UpdatePlaceholderTexture(ID3D1xTexture2D* texture,
+                                  ID3D1xShaderResourceView* psrv,
+                                  const Sizei& textureSize)
+    {
+        Tex     = texture;
+        TexSv   = psrv;
+        TexRtv.Clear();
+        TexDsv.Clear();
+
+        TextureSize = textureSize;
+
+#ifdef OVR_BUILD_DEBUG
+        D3D1X_(TEXTURE2D_DESC) desc;
+        texture->GetDesc(&desc);
+        OVR_ASSERT(TextureSize == Sizei(desc.Width, desc.Height));
+#endif
+    }
+
+
+    virtual void Set(int slot, ShaderStage stage = Shader_Fragment) const;
+
+};
+
+
+class GpuTimer : public RefCountBase<GpuTimer>
+{
+public:
+    GpuTimer()
+        : QuerySets(MaxNumQueryFrames)
+        , D3dDevice(NULL)
+        , Context(NULL)
+        , LastQueuedFrame(-1)
+        , LastTimedFrame(-1)
+    { }
+
+    void Init(ID3D1xDevice* device, ID3D1xDeviceContext* content);
+
+    void BeginQuery();
+    void EndQuery();
+
+    // Returns -1 if timing is invalid
+    float GetTiming(bool blockUntilValid);
+
+protected:
+    static const unsigned MaxNumQueryFrames = 10;
+    
+    int GotoNextFrame(int frame)
+    {
+        return (frame + 1) % MaxNumQueryFrames;
+    }
+    
+    _COM_SMARTPTR_TYPEDEF(ID3D1xQuery, __uuidof(ID3D1xQuery));
+
+    struct GpuQuerySets
+    {
+        ID3D1xQueryPtr DisjointQuery;
+        ID3D1xQueryPtr TimeStartQuery;
+        ID3D1xQueryPtr TimeEndQuery;
+        bool QueryStarted;
+        bool QueryAwaitingTiming;
+
+        GpuQuerySets() : QueryStarted(false), QueryAwaitingTiming(false) {}
+    };
+    Array<GpuQuerySets> QuerySets;
+    
+    int LastQueuedFrame;
+    int LastTimedFrame;
+
+    Ptr<ID3D1xDevice> D3dDevice;
+    Ptr<ID3D1xDeviceContext> Context;
+};
+
+}}} // OVR::CAPI::D3D1X
+
+#endif // INC_OVR_CAPI_D3D10/11_Util_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,294 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.cpp
+Content     :   Experimental distortion renderer
+Created     :   March 7th, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_D3D9_DistortionRenderer.h"
+#define OVR_D3D_VERSION 9
+#include "../../OVR_CAPI_D3D.h"
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+
+///QUESTION : Why not just a normal constructor?
+CAPI::DistortionRenderer* DistortionRenderer::Create(ovrHmd hmd,
+                                                     FrameTimeManager& timeManager,
+                                                     const HMDRenderState& renderState)
+{
+    return new DistortionRenderer(hmd, timeManager, renderState);
+}
+
+DistortionRenderer::DistortionRenderer(ovrHmd hmd, FrameTimeManager& timeManager,
+                                       const HMDRenderState& renderState)
+    : CAPI::DistortionRenderer(ovrRenderAPI_D3D9, hmd, timeManager, renderState) 
+{
+}
+/**********************************************/
+DistortionRenderer::~DistortionRenderer()
+{
+	//Release any memory 
+	eachEye[0].dxIndices->Release();
+	eachEye[0].dxVerts->Release();
+	eachEye[1].dxIndices->Release();
+	eachEye[1].dxVerts->Release();
+}
+
+
+/******************************************************************************/
+bool DistortionRenderer::Initialize(const ovrRenderAPIConfig* apiConfig,
+                                    unsigned arg_distortionCaps)
+{
+	///QUESTION - what is returned bool for???  Are we happy with this true, if not config.
+    const ovrD3D9Config * config = (const ovrD3D9Config*)apiConfig;
+    if (!config)                return true; 
+    if (!config->D3D9.pDevice)  return false;
+
+	//Glean all the required variables from the input structures
+	device         = config->D3D9.pDevice;
+    swapChain      = config->D3D9.pSwapChain;
+	screenSize     = config->D3D9.Header.RTSize;
+	distortionCaps = arg_distortionCaps;
+
+	GfxState = *new GraphicsState(device, distortionCaps);
+
+	CreateVertexDeclaration();
+	CreateDistortionShaders();
+	Create_Distortion_Models();
+
+    return true;
+}
+
+
+/**************************************************************/
+void DistortionRenderer::SubmitEye(int eyeId, const ovrTexture* eyeTexture)
+{
+	//Doesn't do a lot in here??
+	const ovrD3D9Texture* tex = (const ovrD3D9Texture*)eyeTexture;
+
+	//Write in values
+    eachEye[eyeId].texture = tex->D3D9.pTexture;
+
+	// Its only at this point we discover what the viewport of the texture is.
+	// because presumably we allow users to realtime adjust the resolution.
+    eachEye[eyeId].TextureSize    = tex->D3D9.Header.TextureSize;
+    eachEye[eyeId].RenderViewport = tex->D3D9.Header.RenderViewport;
+
+    const ovrEyeRenderDesc& erd = RState.EyeRenderDesc[eyeId];
+    
+    ovrHmd_GetRenderScaleAndOffset( erd.Fov,
+                                    eachEye[eyeId].TextureSize, eachEye[eyeId].RenderViewport,
+                                    eachEye[eyeId].UVScaleOffset );
+
+	if (RState.DistortionCaps & ovrDistortionCap_FlipInput)
+	{
+		eachEye[eyeId].UVScaleOffset[0].y = -eachEye[eyeId].UVScaleOffset[0].y;
+		eachEye[eyeId].UVScaleOffset[1].y = 1.0f - eachEye[eyeId].UVScaleOffset[1].y;
+	}
+}
+
+void DistortionRenderer::renderEndFrame()
+{
+    RenderBothDistortionMeshes();
+
+    if(RegisteredPostDistortionCallback)
+        RegisteredPostDistortionCallback(device);
+
+    if(LatencyTest2Active)
+    {
+        // TODO:
+        //renderLatencyPixel(LatencyTest2DrawColor);
+    }
+}
+
+/******************************************************************/
+void DistortionRenderer::EndFrame(bool swapBuffers)
+{
+	///QUESTION : Clear the screen? 
+	///QUESTION : Ensure the screen is the render target
+
+    // Don't spin if we are explicitly asked not to
+    if (RState.DistortionCaps & ovrDistortionCap_TimeWarp &&
+        !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+    {
+        if (!TimeManager.NeedDistortionTimeMeasurement())
+        {
+            // Wait for timewarp distortion if it is time and Gpu idle
+            FlushGpuAndWaitTillTime(TimeManager.GetFrameTiming().TimewarpPointTime);
+
+            renderEndFrame();
+        }
+        else
+        {
+            // If needed, measure distortion time so that TimeManager can better estimate
+            // latency-reducing time-warp wait timing.
+            WaitUntilGpuIdle();
+            double  distortionStartTime = ovr_GetTimeInSeconds();
+
+            renderEndFrame();
+
+            WaitUntilGpuIdle();
+            TimeManager.AddDistortionTimeMeasurement(ovr_GetTimeInSeconds() - distortionStartTime);
+        }
+    }
+    else
+    {
+        renderEndFrame();
+    }
+
+    if(RegisteredPostDistortionCallback)
+        RegisteredPostDistortionCallback(device);
+
+    if(LatencyTestDrawColor)
+    {
+		// TODO: Support latency tester quad
+        ///renderLatencyQuad(latencyTesterDrawColor);
+    }
+
+    if (swapBuffers)
+    {
+        if (swapChain)
+        {
+            swapChain->Present(NULL, NULL, NULL, NULL, 0);
+        }
+        else
+        {
+		    device->Present( NULL, NULL, NULL, NULL );
+        }
+
+        // Force GPU to flush the scene, resulting in the lowest possible latency.
+        // It's critical that this flush is *after* present.
+        // Doesn't need to be done if running through the Oculus driver.
+        if (RState.OurHMDInfo.InCompatibilityMode &&
+            !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+            WaitUntilGpuIdle();
+    }
+}
+
+
+void DistortionRenderer::WaitUntilGpuIdle()
+{
+	if(device)
+    {
+         IDirect3DQuery9* pEventQuery=NULL ;
+         device->CreateQuery(D3DQUERYTYPE_EVENT, &pEventQuery) ;
+
+         if(pEventQuery!=NULL)
+         {
+            pEventQuery->Issue(D3DISSUE_END) ;
+            while(S_FALSE == pEventQuery->GetData(NULL, 0, D3DGETDATA_FLUSH)){}
+            pEventQuery->Release();
+         }
+     }
+}
+
+double DistortionRenderer::FlushGpuAndWaitTillTime(double absTime)
+{
+	double initialTime = ovr_GetTimeInSeconds();
+	if (initialTime >= absTime)
+		return 0.0;
+
+	WaitUntilGpuIdle();
+
+    return WaitTillTime(absTime);
+}
+
+
+
+DistortionRenderer::GraphicsState::GraphicsState(IDirect3DDevice9* d, unsigned arg_distortionCaps)
+: device(d)
+, numSavedStates(0)
+, distortionCaps(arg_distortionCaps)
+{
+}
+
+void DistortionRenderer::GraphicsState::RecordAndSetState(int which, int type, DWORD newValue)
+{
+	SavedStateType * sst = &savedState[numSavedStates++];
+	sst->which = which;
+	sst->type = type;
+	if (which == 0)
+	{
+		device->GetSamplerState(0, (D3DSAMPLERSTATETYPE)type, &sst->valueToRevertTo);
+		device->SetSamplerState(0, (D3DSAMPLERSTATETYPE)type, newValue);
+	}
+	else
+	{
+		device->GetRenderState((D3DRENDERSTATETYPE)type, &sst->valueToRevertTo);
+		device->SetRenderState((D3DRENDERSTATETYPE)type, newValue);
+	}
+}
+
+void DistortionRenderer::GraphicsState::Save()
+{
+	//Record and set rasterizer and sampler states.
+
+	numSavedStates=0;
+
+    RecordAndSetState(0, D3DSAMP_MINFILTER,          D3DTEXF_LINEAR );
+    RecordAndSetState(0, D3DSAMP_MAGFILTER,          D3DTEXF_LINEAR );
+    RecordAndSetState(0, D3DSAMP_MIPFILTER,          D3DTEXF_LINEAR );
+    RecordAndSetState(0, D3DSAMP_BORDERCOLOR,        0x000000 );
+    RecordAndSetState(0, D3DSAMP_ADDRESSU,           D3DTADDRESS_BORDER );
+    RecordAndSetState(0, D3DSAMP_ADDRESSV,           D3DTADDRESS_BORDER );
+    RecordAndSetState(0, D3DSAMP_SRGBTEXTURE,        (distortionCaps & ovrDistortionCap_SRGB) ? TRUE : FALSE );
+
+	RecordAndSetState(1, D3DRS_MULTISAMPLEANTIALIAS, FALSE );
+	RecordAndSetState(1, D3DRS_DITHERENABLE,         FALSE );
+	RecordAndSetState(1, D3DRS_ZENABLE,              FALSE );
+    RecordAndSetState(1, D3DRS_ZWRITEENABLE,         TRUE   );
+    RecordAndSetState(1, D3DRS_ZFUNC,                D3DCMP_LESSEQUAL   );
+    RecordAndSetState(1, D3DRS_CULLMODE ,            D3DCULL_CCW  );
+   	RecordAndSetState(1, D3DRS_ALPHABLENDENABLE ,    FALSE );
+   	RecordAndSetState(1, D3DRS_DEPTHBIAS ,           0 );
+    RecordAndSetState(1, D3DRS_SRCBLEND ,            D3DBLEND_SRCALPHA );
+    RecordAndSetState(1, D3DRS_DESTBLEND ,           D3DBLEND_INVSRCALPHA   );
+   	RecordAndSetState(1, D3DRS_FILLMODE,             D3DFILL_SOLID );
+    RecordAndSetState(1, D3DRS_ALPHATESTENABLE,      FALSE);
+ 	RecordAndSetState(1, D3DRS_DEPTHBIAS ,           0 );
+    RecordAndSetState(1, D3DRS_LIGHTING,             FALSE );
+   	RecordAndSetState(1, D3DRS_FOGENABLE,            FALSE );
+    RecordAndSetState(1, D3DRS_SRGBWRITEENABLE,      (distortionCaps & ovrDistortionCap_SRGB) ? TRUE : FALSE );
+}
+
+
+void DistortionRenderer::GraphicsState::Restore()
+{
+	for (int i = 0; i<numSavedStates; i++)
+	{
+		SavedStateType * sst = &savedState[i];
+		if (sst->which == 0)
+		{
+			device->SetSamplerState(0, (D3DSAMPLERSTATETYPE)sst->type, sst->valueToRevertTo);
+		}
+		else
+		{
+			device->SetRenderState((D3DRENDERSTATETYPE)sst->type, sst->valueToRevertTo);
+		}
+	}
+}
+
+
+}}} // OVR::CAPI::D3D1X
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,142 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.h
+Content     :   Experimental distortion renderer
+Created     :   March 7, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "../../Kernel/OVR_Types.h"
+
+#undef new
+
+#if defined (OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#if _MSC_VER < 1700
+#include <d3dx9.h>
+#else
+#include <d3d9.h>
+#endif
+#endif
+
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif 
+
+#include "../CAPI_DistortionRenderer.h"
+
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+
+//Implementation of DistortionRenderer for D3D9.
+/***************************************************/
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd, FrameTimeManager& timeManager, const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+		                                    FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+	
+    // ***** Public DistortionRenderer interface
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    // TBD: Make public?
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+	
+	class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+	{
+	public:
+		GraphicsState(IDirect3DDevice9* d, unsigned arg_distortionCaps);
+		virtual void Save();
+		virtual void Restore();
+
+	protected:
+		void RecordAndSetState(int which, int type, DWORD newValue);
+
+		//Structure to store our state changes
+		static const int MAX_SAVED_STATES=100;
+		struct SavedStateType
+		{
+			int which;  //0 for samplerstate, 1 for renderstate
+			int type;
+			DWORD valueToRevertTo;
+		} savedState[MAX_SAVED_STATES];
+
+		//Keep track of how many we've done, for reverting
+		int numSavedStates;
+		IDirect3DDevice9* device;
+        unsigned distortionCaps;
+	};
+
+private:
+
+	//Functions
+	void         CreateDistortionShaders(void);
+	void         Create_Distortion_Models(void);
+	void         CreateVertexDeclaration(void);
+	void         RenderBothDistortionMeshes();
+	void         RecordAndSetState(int which, int type, DWORD newValue);
+	void         RevertAllStates(void);
+
+    void         renderEndFrame();
+	
+	//Data, structures and pointers
+	IDirect3DDevice9            * device;
+	IDirect3DSwapChain9         * swapChain;
+	IDirect3DVertexDeclaration9 * vertexDecl;
+	IDirect3DPixelShader9       * pixelShader;
+	IDirect3DVertexShader9      * vertexShader;
+	IDirect3DVertexShader9      * vertexShaderTimewarp;
+	ovrSizei                      screenSize; 
+	unsigned                      distortionCaps;
+
+	struct FOR_EACH_EYE
+	{
+        FOR_EACH_EYE() : TextureSize(0), RenderViewport(Sizei(0)) { }
+
+		IDirect3DVertexBuffer9  * dxVerts;
+		IDirect3DIndexBuffer9   * dxIndices;
+		int                       numVerts;
+		int                       numIndices;
+		IDirect3DTexture9       * texture;
+		ovrVector2f			 	  UVScaleOffset[2]; 
+        Sizei                     TextureSize;
+        Recti                     RenderViewport;
+	} eachEye[2];
+};
+
+}}} // OVR::CAPI::D3D9
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,430 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D9_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#define OVR_D3D_VERSION 9
+#include "CAPI_D3D9_HSWDisplay.h"
+#include "../../OVR_CAPI_D3D.h"
+#undef  OVR_D3D_VERSION
+
+#include <d3d9.h>
+#include "../../Kernel/OVR_File.h"
+#include "../../Kernel/OVR_SysFile.h"
+#include "../../Kernel/OVR_Math.h"
+#include "../../Kernel/OVR_Allocator.h"
+#include "../../Kernel/OVR_Color.h"
+
+
+namespace OVR { namespace CAPI { 
+
+
+// To do Need to move LoadTextureTgaData to a shared location.
+uint8_t* LoadTextureTgaData(OVR::File* f, uint8_t alpha, int& width, int& height);
+
+
+namespace D3D9 {
+
+// This is a temporary function implementation, and it functionality needs to be implemented in a more generic way.
+IDirect3DTexture9* LoadTextureTga(HSWRenderParams& rParams, OVR::File* f, uint8_t alpha)
+{
+    IDirect3DTexture9* pTexture = NULL;
+
+    int width, height;
+    const uint8_t* pRGBA = LoadTextureTgaData(f, alpha, width, height);
+
+    if (pRGBA)
+    {
+        // We don't have access to D3DX9 and so we currently have to do this manually instead of calling a D3DX9 utility function.
+        Ptr<IDirect3DTexture9> pTextureSysmem;
+        HRESULT hResult = rParams.Device->CreateTexture((UINT)width, (UINT)height, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &pTextureSysmem.GetRawRef(), NULL);
+
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("CreateTexture(D3DPOOL_SYSTEMMEM) failed. %d (%x)", hResult, hResult)); }
+        else
+        {
+            // Lock the texture so we can write this frame's texel data
+            D3DLOCKED_RECT lock;
+            hResult = pTextureSysmem->LockRect(0, &lock, NULL, D3DLOCK_NOSYSLOCK | D3DLOCK_NO_DIRTY_UPDATE);
+            if(FAILED(hResult))
+                { HSWDISPLAY_LOG(("LockRect failed. %d (%x)", hResult, hResult)); }
+            else
+            {
+                // Four bytes per pixel. Pitch bytes per row (will be >= w * 4).
+                uint8_t*       pRow = (uint8_t*)lock.pBits;
+                const uint8_t* pSource = pRGBA;
+
+                for(int y = 0; y < height; y++, pRow += lock.Pitch, pSource += (width * 4))
+                {
+                    uint8_t* pDest = pRow;
+
+                    for(int x = 0, xEnd = width * 4; x < xEnd; x += 4)
+                    {
+                        pDest[x + 0] = pSource[x + 2];
+                        pDest[x + 1] = pSource[x + 1];
+                        pDest[x + 2] = pSource[x + 0];
+                        pDest[x + 3] = pSource[x + 3];
+                    }
+                }
+
+                pTextureSysmem->UnlockRect(0);
+
+                hResult = rParams.Device->CreateTexture((UINT)width, (UINT)height, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &pTexture, NULL);
+                if(FAILED(hResult))
+                    { HSWDISPLAY_LOG(("CreateTexture(D3DPOOL_DEFAULT) failed. %d (%x)", hResult, hResult)); }
+                else
+                {
+                    hResult = rParams.Device->UpdateTexture(pTextureSysmem, pTexture);
+                    if(FAILED(hResult))
+                    {
+                        HSWDISPLAY_LOG(("UpdateTexture failed. %d (%x)", hResult, hResult));
+                        pTexture->Release();
+                        pTexture = NULL;
+                    }
+                }
+            }
+        }
+
+        OVR_FREE(const_cast<uint8_t*>(pRGBA));
+    }
+
+    return pTexture;
+}
+
+
+// Loads a texture from a memory image of a TGA file.
+IDirect3DTexture9* LoadTextureTga(HSWRenderParams& rParams, const uint8_t* pData, int dataSize, uint8_t alpha)
+{
+    MemoryFile memoryFile("", pData, dataSize);
+
+    return LoadTextureTga(rParams, &memoryFile, alpha);
+}
+
+
+// Loads a texture from a disk TGA file.
+IDirect3DTexture9* LoadTextureTga(HSWRenderParams& rParams, const char* pFilePath, uint8_t alpha)
+{
+    SysFile sysFile;
+
+    if(sysFile.Open(pFilePath, FileConstants::Open_Read | FileConstants::Open_Buffered))
+        return LoadTextureTga(rParams, &sysFile, alpha);
+
+    return NULL;
+}
+
+
+
+// To do: This needs to be promoted to a central version, possibly in CAPI_HSWDisplay.h
+struct HASWVertex
+{
+    Vector3f  Pos;
+    Color     C;
+    float     U, V;	
+
+    HASWVertex(const Vector3f& p, const Color& c = Color(64,0,0,255), float u = 0, float v = 0)
+        : Pos(p), C(c), U(u), V(v)
+    {}
+
+    HASWVertex(float x, float y, float z, const Color& c = Color(64,0,0,255), float u = 0, float v = 0) 
+        : Pos(x,y,z), C(c), U(u), V(v)
+    {}
+
+    bool operator==(const HASWVertex& b) const
+    {
+        return (Pos == b.Pos) && (C == b.C) && (U == b.U) && (V == b.V);
+    }
+};
+
+#define HASWVertexD3D9Format (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1)
+
+
+// The texture below may conceivably be shared between HSWDisplay instances. However,  
+// beware that sharing may not be possible if two HMDs are using different locales  
+// simultaneously. As of this writing it's not clear if that can occur in practice.
+
+HSWDisplay::HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState)
+  : OVR::CAPI::HSWDisplay(api, hmd, renderState)
+  , RenderParams()
+{
+}
+    
+bool HSWDisplay::Initialize(const ovrRenderAPIConfig* apiConfig)
+{
+    const ovrD3D9Config* config = reinterpret_cast<const ovrD3D9Config*>(apiConfig);
+
+    if(config)
+    {
+	    RenderParams.Device     = config->D3D9.pDevice;
+        RenderParams.SwapChain  = config->D3D9.pSwapChain;
+	    RenderParams.ScreenSize = config->D3D9.Header.RTSize;
+    }
+    else
+    {
+        UnloadGraphics();
+    }
+
+    return true;
+}
+
+void HSWDisplay::Shutdown()
+{
+    UnloadGraphics();
+}
+
+void HSWDisplay::DisplayInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay D3D9] DisplayInternal()"));
+    // We may want to call LoadGraphics here instead of within Render.
+}
+
+void HSWDisplay::DismissInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay D3D9] DismissInternal()"));
+    UnloadGraphics();
+}
+
+
+void HSWDisplay::UnloadGraphics()
+{
+    // RenderParams: No need to clear.
+    pTexture.Clear();
+    pVB.Clear();
+    // OrthoProjection: No need to clear.
+}
+
+
+void HSWDisplay::LoadGraphics()
+{
+    // As of this writing, we don't yet have an abstraction for Textures, Buffers, and Shaders like we do for D3D11, D3D11, and OpenGL.
+    #if defined(OVR_BUILD_DEBUG)
+        if(!pTexture)
+            pTexture = *LoadTextureTga(RenderParams, "C:\\TestPath\\TestFile.tga", 255);
+    #endif
+
+    if(!pTexture)
+    {
+        D3DCAPS9 caps;
+        RenderParams.Device->GetDeviceCaps(&caps);
+
+        if(caps.TextureCaps & (D3DPTEXTURECAPS_SQUAREONLY | D3DPTEXTURECAPS_POW2))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] Square textures allowed only.")); }
+
+        size_t textureSize;
+        const uint8_t* TextureData = GetDefaultTexture(textureSize);
+        pTexture = *LoadTextureTga(RenderParams, TextureData, (int)textureSize, 255);
+        OVR_ASSERT(pTexture);
+    }
+
+    if(!pVB)
+    {
+        HRESULT hResult = RenderParams.Device->CreateVertexBuffer(4 * sizeof(HASWVertex), NULL, HASWVertexD3D9Format, D3DPOOL_MANAGED, &pVB.GetRawRef(), NULL);
+
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] CreateVertexBuffer failed. %d (%x)", hResult, hResult)); }
+        else
+        {
+            void* pVerticesVoid;
+            hResult = pVB->Lock(0, 0, (void**)&pVerticesVoid, 0);
+
+            if(FAILED(hResult))
+                { HSWDISPLAY_LOG(("[HSWDisplay D3D9] Lock failed. %d (%x)", hResult, hResult)); }
+            else
+            {
+                HASWVertex* pVertices = reinterpret_cast<HASWVertex*>(pVerticesVoid);
+
+                const bool  flip   = ((RenderState.DistortionCaps & ovrDistortionCap_FlipInput) != 0);
+                const float left   = -1.0f;
+                const float top    = -1.1f;
+                const float right  = +1.0f;
+                const float bottom = +0.9f;
+
+                pVertices[0] = HASWVertex(left,  top,    0.f, Color(255, 255, 255, 255), 0.f, flip ? 1.f : 0.f); // To do: Make this branchless 
+                pVertices[1] = HASWVertex(left,  bottom, 0.f, Color(255, 255, 255, 255), 0.f, flip ? 0.f : 1.f);
+                pVertices[2] = HASWVertex(right, top,    0.f, Color(255, 255, 255, 255), 1.f, flip ? 1.f : 0.f); 
+                pVertices[3] = HASWVertex(right, bottom, 0.f, Color(255, 255, 255, 255), 1.f, flip ? 0.f : 1.f);
+
+                pVB->Unlock();
+            }
+        }
+    }
+}
+
+
+void HSWDisplay::RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture)
+{
+    if(RenderEnabled && eyeTexture)
+    {
+        // Note: The D3D9 implementation below is entirely fixed-function and isn't yet using shaders.
+        // For the time being this is sufficient, but future designs will likely necessitate moving
+        // to a system that uses programmable shaders.
+
+        // We need to render to the eyeTexture with the texture viewport.
+        // Setup rendering to the texture.
+        ovrD3D9Texture* eyeTextureD3D9 = const_cast<ovrD3D9Texture*>(reinterpret_cast<const ovrD3D9Texture*>(eyeTexture));
+        OVR_ASSERT(eyeTextureD3D9->Texture.Header.API == ovrRenderAPI_D3D9);
+
+
+        // Save previous state.
+        // To do: Merge this saved state with that done by DistortionRenderer::GraphicsState::Save(), and put them in a shared location.
+        DWORD fvfSaved;
+        RenderParams.Device->GetFVF(&fvfSaved);
+
+        Ptr<IDirect3DVertexBuffer9> pVBDSaved;
+        UINT vbOffsetSaved;
+        UINT vbStrideSaved;
+        RenderParams.Device->GetStreamSource(0, &pVBDSaved.GetRawRef(), &vbOffsetSaved, &vbStrideSaved);
+
+        Ptr<IDirect3DBaseTexture9> pTexture0Saved;
+        RenderParams.Device->GetTexture(0, &pTexture0Saved.GetRawRef());
+        Ptr<IDirect3DBaseTexture9> pTexture1Saved;
+        RenderParams.Device->GetTexture(1, &pTexture1Saved.GetRawRef());
+
+        D3DMATRIX worldMatrixSaved, viewMatrixSaved, projectionMatrixSaved, texture0MatrixSaved;
+        RenderParams.Device->GetTransform(D3DTS_WORLD, &worldMatrixSaved);
+        RenderParams.Device->GetTransform(D3DTS_VIEW, &viewMatrixSaved);
+        RenderParams.Device->GetTransform(D3DTS_PROJECTION, &projectionMatrixSaved);
+        RenderParams.Device->GetTransform(D3DTS_TEXTURE0, &texture0MatrixSaved);
+
+        Ptr<IDirect3DVertexShader9> pVertexShaderSaved;
+        RenderParams.Device->GetVertexShader(&pVertexShaderSaved.GetRawRef());
+
+        Ptr<IDirect3DPixelShader9> pPixelShaderSaved;
+        RenderParams.Device->GetPixelShader(&pPixelShaderSaved.GetRawRef());
+
+        D3DVIEWPORT9 viewportSaved;
+        RenderParams.Device->GetViewport(&viewportSaved);
+
+        Ptr<IDirect3DSurface9> pRenderTargetSaved;
+        RenderParams.Device->GetRenderTarget(0, &pRenderTargetSaved.GetRawRef());
+
+
+        // Load the graphics if not loaded already.
+        if(!pTexture)
+            LoadGraphics();
+
+        // Calculate ortho projection.
+        GetOrthoProjection(RenderState, OrthoProjection);
+
+        HRESULT hResult = RenderParams.Device->BeginScene();
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] BeginScene failed. %d (%x)", hResult, hResult)); }
+
+        Ptr<IDirect3DSurface9> pDestSurface;
+        hResult = eyeTextureD3D9->D3D9.pTexture->GetSurfaceLevel(0, &pDestSurface.GetRawRef());
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] GetSurfaceLevel failed. %d (%x)", hResult, hResult)); }
+
+        hResult = RenderParams.Device->SetRenderTarget(0, pDestSurface);
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] SetRenderTarget failed. %d (%x)", hResult, hResult)); }
+
+        D3DVIEWPORT9 D3DViewport;
+        D3DViewport.X        = eyeTextureD3D9->Texture.Header.RenderViewport.Pos.x;
+        D3DViewport.Y        = eyeTextureD3D9->Texture.Header.RenderViewport.Pos.y;    
+        D3DViewport.Width    = eyeTextureD3D9->Texture.Header.RenderViewport.Size.w;
+        D3DViewport.Height   = eyeTextureD3D9->Texture.Header.RenderViewport.Size.h;
+        D3DViewport.MinZ     = 0;
+        D3DViewport.MaxZ     = 1;
+        hResult = RenderParams.Device->SetViewport(&D3DViewport);
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] SetViewport failed. %d (%x)", hResult, hResult)); }
+
+        hResult = RenderParams.Device->SetTexture(0, pTexture);
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] SetTexture failed. %d (%x)", hResult, hResult)); }
+
+        RenderParams.Device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
+        RenderParams.Device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+        RenderParams.Device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+
+        RenderParams.Device->SetVertexShader(NULL);
+        RenderParams.Device->SetPixelShader(NULL);
+
+        hResult = RenderParams.Device->SetStreamSource(0, pVB, 0, sizeof(HASWVertex));
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] SetStreamSource failed. %d (%x)", hResult, hResult)); }
+
+        RenderParams.Device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+        RenderParams.Device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+		RenderParams.Device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+        RenderParams.Device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
+		RenderParams.Device->SetRenderState(D3DRS_LIGHTING, FALSE);
+        RenderParams.Device->SetRenderState(D3DRS_ZENABLE, FALSE);
+        RenderParams.Device->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
+        RenderParams.Device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
+        RenderParams.Device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+        RenderParams.Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+
+        const float scale  = HSWDISPLAY_SCALE * ((RenderState.OurHMDInfo.HmdType == HmdType_DK1) ? 0.70f : 1.f);
+        Matrix4f identityMatrix = Matrix4f::Identity();
+        Vector3f translation = OrthoProjection[eye].GetTranslation();
+        Matrix4f orthoStereoMatrix(
+            scale, 0, 0, 0,
+            0, scale / 2, 0, 0,
+            0, 0, HSWDISPLAY_DISTANCE, 0,
+            translation.x, translation.y, translation.z, 1
+            );
+        RenderParams.Device->SetTransform(D3DTS_WORLD,      reinterpret_cast<const D3DMATRIX*>(&identityMatrix));
+        RenderParams.Device->SetTransform(D3DTS_VIEW,       reinterpret_cast<const D3DMATRIX*>(&identityMatrix));
+        RenderParams.Device->SetTransform(D3DTS_PROJECTION, reinterpret_cast<const D3DMATRIX*>(&orthoStereoMatrix));
+        RenderParams.Device->SetTransform(D3DTS_TEXTURE0,   reinterpret_cast<const D3DMATRIX*>(&identityMatrix));
+
+        hResult = RenderParams.Device->SetFVF(HASWVertexD3D9Format);
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] SetFVF failed. %d (%x)", hResult, hResult)); }
+
+        hResult = RenderParams.Device->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] DrawPrimitive failed. %d (%x)", hResult, hResult)); }
+
+        hResult = RenderParams.Device->EndScene();
+        if(FAILED(hResult))
+            { HSWDISPLAY_LOG(("[HSWDisplay D3D9] EndScene failed. %d (%x)", hResult, hResult)); }
+
+
+        // Restore previous state.
+        RenderParams.Device->SetRenderTarget(0, pRenderTargetSaved);
+        RenderParams.Device->SetViewport(&viewportSaved);
+        RenderParams.Device->SetPixelShader(pPixelShaderSaved);
+        RenderParams.Device->SetVertexShader(pVertexShaderSaved);
+        RenderParams.Device->SetTransform(D3DTS_TEXTURE0, &texture0MatrixSaved);
+        RenderParams.Device->SetTransform(D3DTS_PROJECTION, &projectionMatrixSaved);
+        RenderParams.Device->SetTransform(D3DTS_VIEW, &viewMatrixSaved);
+        RenderParams.Device->SetTransform(D3DTS_WORLD, &worldMatrixSaved);
+        RenderParams.Device->SetTexture(0, pTexture0Saved);
+        RenderParams.Device->SetTexture(1, pTexture1Saved);
+        RenderParams.Device->SetStreamSource(0, pVBDSaved, vbOffsetSaved, vbStrideSaved);
+        RenderParams.Device->SetFVF(fvfSaved);
+    }
+}
+
+
+}}} // namespace OVR::CAPI::D3D9
+
+
+
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,82 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D9_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D9_HSWDisplay_h
+#define OVR_CAPI_D3D9_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || (OVR_D3D_VERSION != 9)
+    #error This header expects OVR_D3D_VERSION to be defined, to 9.
+#endif
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_D3D1X_Util.h"
+#include <d3d9.h>
+
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+    // There currently isn't a D3D9::RenderParams, as D3D9 support is currently only very basic.
+    struct HSWRenderParams
+    {
+	    IDirect3DDevice9*    Device;
+	    IDirect3DSwapChain9* SwapChain;
+	    ovrSizei             ScreenSize; 
+    };
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrD3D9Config* config = (const ovrD3D9Config*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void LoadGraphics();
+        void UnloadGraphics();
+
+        D3D9::HSWRenderParams       RenderParams;
+        Ptr<IDirect3DTexture9>      pTexture;
+        Ptr<IDirect3DVertexBuffer9> pVB;
+        Matrix4f                    OrthoProjection[2];     // Projection for 2D.
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::D3D9
+
+
+#endif // OVR_CAPI_D3D9_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_Util.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_Util.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,270 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_Util.cpp
+Content     :   D3D9 utility functions for rendering
+Created     :   March 7 , 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_D3D9_DistortionRenderer.h"
+#define OVR_D3D_VERSION 9
+#include "../../OVR_CAPI_D3D.h"
+
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+
+#define PRECOMPILE_FLAG 0
+#if !PRECOMPILE_FLAG
+//To make these, you need to run it with PRECOMPILE_FLAG, which also uses them, so good for debugging.
+//Then cut and paste these from the output window.
+//Then turn off the flag.
+DWORD precompiledVertexShaderSrc[96] = {4294836736,3080190,1111577667,28,130,4294836736,2,28,33024,123,68,131074,655361,88,0,104,2,131073,88,0,1415936325,1970230127,1432707954,1717981014,7628147,196609,131073,1,0,1415936325,1970230127,1432707954,1633899350,1979737452,1597136755,1766654000,1936683619,544499311,539578920,1280527432,1634226976,544367972,1886220099,1919249513,841890080,892939833,825437746,2868916529,83886161,2685337601,1065353216,0,1056964608,0,33554463,2147483648,2416902144,33554463,2147614720,2416902145,33554463,2147483653,2416902146,33554463,2147549189,2416902147,33554463,2147614725,2416902148,33554433,2147680256,2699296768,67108868,3758292992,2162425856,2430861314,2699296770,67108868,3758292993,2162425856,2430861315,2699296770,67108868,3758292994,2162425856,2430861316,2699296770,67108868,3222208512,2416181248,2689597441,2686779393,33554433,3758161923,2415919105,65535,};
+DWORD precompiledVertexShaderTimewarpSrc[310] = {4294836992,4587518,1111577667,28,222,4294836992,4,28,33024,215,108,1310722,5373956,124,0,140,262146,1179652,124,0,157,131074,655361,180,0,196,2,131073,180,0,1382381893,1952543855,1164865385,2868929646,196611,262148,1,0,1382381893,1952543855,1399746409,1953653108,1702446336,1867738964,1701016181,1716475477,1952805734,2880154368,196609,131073,1,0,1415936325,1970230127,1432707954,1633899350,1979737452,1597202291,1766654000,1936683619,544499311,539578920,1280527432,1634226976,544367972,1886220099,1919249513,841890080,892939833,825437746,2868916529,83886161,2685337601,1065353216,0,1056964608,0,33554463,2147483648,2416902144,33554463,2147549184,2416902145,33554463,2147614720,2416902146,33554463,2147483653,2416902147,33554463,2147549189,2416902148,33554463,2147614725,2416902149,33554463,2147483648,3759079424,33554463,2147483653,3758292993,33554463,2147549189,3758292994,33554463,2147614725,3758292995,33554463,2147680261,3758161924,33554433,2147549184,2695495684,50331650,2147549185,2164260864,2695495700,33554433,2147614720,2695495685,50331650,2147614721,2169831424,2695495701,33554433,2147745792,2695495686,50331650,2147745793,2175401984,2695495702,33554433,2148007936,2695495687,50331650,2148007937,2180972544,2695495703,67108868,2148466688,2415919105,2162425857,2162425856,67108868,2148466689,2416181251,2689597441,2684682241,50331657,2147549186,2162425856,2162425857,33554438,2147549186,2147483650,33554433,2147680259,2699296772,50331650,2147876866,2177892355,2697986068,67108868,2147549187,2415919105,2158624770,2689925124,67108868,2147549188,2415919105,2153054210,2684354564,33554433,2147680261,2699296773,50331650,2147876866,2177105925,2697199637,67108868,2147614723,2415919105,2153054210,2689925125,67108868,2147614724,2415919105,2158624770,2684354565,33554433,2147680261,2699296774,50331650,2147811333,2177171461,2697265174,67108868,2147745795,2415919105,2147483653,2689925126,67108868,2147745796,2415919105,2158624773,2684354566,33554433,2147680261,2699296775,50331650,2148073477,2166685701,2686779415,67108868,2148007939,2415919105,2147483653,2689925127,67108868,2148007940,2415919105,2164195333,2684354567,50331657,2147549189,2162425860,2162425857,50331657,2147614725,2162425859,2162425857,50331653,2147680257,2147483650,2162425861,33554433,2147680258,2699296768,67108868,3758292993,2162425858,2162425857,2699296770,67108868,2148466689,2416181252,2689597441,2684682241,50331657,2147549189,2162425860,2162425857,50331657,2147614725,2162425859,2162425857,50331657,2147549185,2162425856,2162425857,33554438,2147549185,2147483649,50331653,2147680257,2147483649,2162425861,67108868,3758292994,2162425858,2162425857,2699296770,67108868,2148466689,2416181253,2689597441,2684682241,50331657,2147549188,2162425860,2162425857,50331657,2147614724,2162425859,2162425857,50331657,2147549184,2162425856,2162425857,33554438,2147549184,2147483648,50331653,2147680256,2147483648,2162425860,67108868,3758292995,2162425858,2162425856,2699296770,67108868,3759079424,2416181248,2689597441,2686779393,33554433,3758161924,2415919106,65535,};
+DWORD precompiledPixelShaderSrc[84] = {4294902528,2228222,1111577667,28,79,4294902528,1,28,33024,72,48,3,131073,56,0,1954047316,6648437,786436,65537,1,0,861893488,1291858015,1869767529,1952870259,693250080,1397508128,1750278220,1919247457,1836008224,1701603696,775495794,959330610,858665525,3223857,83886161,2685337600,1065353216,0,0,0,33554463,2147483653,2416115712,33554463,2147549189,2416115713,33554463,2147614725,2416115714,33554463,2147680261,2415984643,33554463,2415919104,2685339648,50331714,2148466688,2430861312,2699298816,67108868,2148073472,2147483648,2690908160,2686779392,50331714,2148466689,2430861313,2699298816,33554433,2147614720,2153054209,50331714,2148466689,2430861314,2699298816,33554433,2147745792,2158624769,50331653,2148468736,2162425856,2415919107,65535,};
+
+#else
+#include "d3dcompiler.h"
+#pragma comment(lib, "C:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86\\D3DCompiler.lib")
+/***************************************************************************/
+const char* VertexShaderSrc = 
+	
+	"float2 EyeToSourceUVScale  : register(c0);                                           \n"
+	"float2 EyeToSourceUVOffset : register(c2);                                           \n"
+	
+	"void main(in float2 Position    : POSITION,    in float  TimeWarp    : POSITION1, \n"
+	"          in float  Vignette    : POSITION2,   in float2 TexCoord0   : TEXCOORD0, \n"
+	"          in float2 TexCoord1   : TEXCOORD1,   in float2 TexCoord2   : TEXCOORD2, \n"
+	"          out float4 oPosition  : SV_Position, out float2 oTexCoord0 : TEXCOORD0, \n"
+	"          out float2 oTexCoord1 : TEXCOORD1,   out float2 oTexCoord2 : TEXCOORD2, \n"
+	"          out float oVignette   : TEXCOORD3)                                      \n"
+	"{                                                                                 \n"
+	"    oTexCoord0 = EyeToSourceUVScale * TexCoord0 + EyeToSourceUVOffset;                  \n"
+	"    oTexCoord1 = EyeToSourceUVScale * TexCoord1 + EyeToSourceUVOffset;                  \n"
+	"    oTexCoord2 = EyeToSourceUVScale * TexCoord2 + EyeToSourceUVOffset;                  \n"
+	"    oVignette  = Vignette;                                                        \n"
+	"    oPosition  = float4(Position.xy, 0.5, 1.0);                                   \n"
+	"}";
+
+/***************************************************************************/
+const char* VertexShaderTimewarpSrc = 
+	
+	"float2 EyeToSourceUVScale    : register(c0);                                         \n"
+	"float2 EyeToSourceUVOffset   : register(c2);                                         \n"
+	"float4x4 EyeRotationStart : register(c4);                                         \n"
+	"float4x4 EyeRotationEnd   : register(c20);                                        \n"
+	
+	"float2 TimewarpTexCoord(float2 TexCoord, float4x4 rotMat)                         \n"
+	"{                                                                                 \n"
+	"    float3 transformed = float3( mul ( rotMat, float4(TexCoord.xy, 1, 1) ).xyz);  \n"
+	"    float2 flattened = (transformed.xy / transformed.z);                          \n"
+	"    return(EyeToSourceUVScale * flattened + EyeToSourceUVOffset);                       \n"
+	"}                                                                                 \n"
+	"void main(in float2 Position    : POSITION,    in float  TimeWarp    : POSITION1, \n"
+	"          in float  Vignette    : POSITION2,   in float2 TexCoord0   : TEXCOORD0, \n"
+	"          in float2 TexCoord1   : TEXCOORD1,   in float2 TexCoord2   : TEXCOORD2, \n"
+	"          out float4 oPosition  : SV_Position, out float2 oTexCoord0 : TEXCOORD0, \n"
+	"          out float2 oTexCoord1 : TEXCOORD1,   out float2 oTexCoord2 : TEXCOORD2, \n"
+	"          out float oVignette   : TEXCOORD3)                                      \n"
+	"{                                                                                 \n"
+	"    float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, TimeWarp);     \n"
+	"    oTexCoord0  = TimewarpTexCoord(TexCoord0,lerpedEyeRot);                       \n"
+	"    oTexCoord1  = TimewarpTexCoord(TexCoord1,lerpedEyeRot);                       \n"
+	"    oTexCoord2  = TimewarpTexCoord(TexCoord2,lerpedEyeRot);                       \n"
+	"    oVignette  = Vignette;                                                        \n"
+	"    oPosition  = float4(Position.xy, 0.5, 1.0);                                   \n"
+	"}";
+
+/***************************************************************************/
+const char* PixelShaderSrc =
+	
+	" sampler2D Texture : register(s0);		                                           \n"
+
+	"float4 main(in float4 oPosition  : SV_Position, in float2 oTexCoord0 : TEXCOORD0, \n"
+	"            in float2 oTexCoord1 : TEXCOORD1,   in float2 oTexCoord2 : TEXCOORD2, \n"
+	"            in float  oVignette  : TEXCOORD3) \n"
+	"          : SV_Target                                                             \n" 
+	"{                                                                                 \n"
+    "	 float R = tex2D(Texture,oTexCoord0).r;		                                   \n"
+    "	 float G = tex2D(Texture,oTexCoord1).g;		                                   \n"
+    "	 float B = tex2D(Texture,oTexCoord2).b;		                                   \n"
+	"    return (oVignette*float4(R,G,B,1));                                           \n"
+	"}";
+
+/*************************************************************/
+ID3DBlob* ShaderCompile(char * shaderName, const char * shaderSrcString, const char * profile)
+{
+    ID3DBlob* pShaderCode = NULL;
+    ID3DBlob* pErrorMsg = NULL;
+
+	if (FAILED(D3DCompile(shaderSrcString, strlen(shaderSrcString),NULL,NULL,NULL,
+						  "main",profile,D3DCOMPILE_OPTIMIZATION_LEVEL3,0,
+						  &pShaderCode,&pErrorMsg)))					
+ 		MessageBoxA(NULL,(char *) pErrorMsg->GetBufferPointer(),"", MB_OK); 
+	if (pErrorMsg) pErrorMsg->Release();
+
+	//Now write out blob
+	char tempString[1000];
+	int numDWORDs = ((int)pShaderCode->GetBufferSize())/4;
+	DWORD * ptr = (DWORD *)pShaderCode->GetBufferPointer();
+	sprintf_s(tempString,"DWORD %s[%d] = {",shaderName,numDWORDs);
+	OutputDebugStringA(tempString);
+	for (int i = 0;i < numDWORDs; i++)
+	{
+		sprintf_s(tempString,"%lu,",ptr[i]);
+		OutputDebugStringA(tempString);
+	}
+	OutputDebugStringA("};\n");
+
+	return(pShaderCode);
+}
+#endif
+
+/***********************************************************/
+void DistortionRenderer::CreateDistortionShaders(void)
+{
+#if PRECOMPILE_FLAG
+	ID3DBlob * pShaderCode;
+	pShaderCode = ShaderCompile("precompiledVertexShaderSrc",VertexShaderSrc,"vs_2_0");
+	device->CreateVertexShader( ( DWORD* )pShaderCode->GetBufferPointer(), &vertexShader );
+    pShaderCode->Release();
+
+	pShaderCode = ShaderCompile("precompiledVertexShaderTimewarpSrc",VertexShaderTimewarpSrc,"vs_3_0");
+	device->CreateVertexShader( ( DWORD* )pShaderCode->GetBufferPointer(), &vertexShaderTimewarp );
+    pShaderCode->Release();
+
+	pShaderCode = ShaderCompile("precompiledPixelShaderSrc",PixelShaderSrc,"ps_3_0");
+	device->CreatePixelShader( ( DWORD* )pShaderCode->GetBufferPointer(), &pixelShader );
+    pShaderCode->Release();
+#else
+	device->CreateVertexShader( precompiledVertexShaderSrc, &vertexShader );
+	device->CreateVertexShader( precompiledVertexShaderTimewarpSrc, &vertexShaderTimewarp );
+	device->CreatePixelShader(  precompiledPixelShaderSrc, &pixelShader );
+#endif
+}
+
+
+/***************************************************/
+void DistortionRenderer::CreateVertexDeclaration(void)
+{
+	static const D3DVERTEXELEMENT9 VertexElements[7] =	{
+        { 0,  0, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
+        { 0,  8, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 1 },
+        { 0, 12, D3DDECLTYPE_FLOAT1, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 2 },
+        { 0, 16, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
+        { 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1 },
+        { 0, 32, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 2 },
+		D3DDECL_END()	};
+    device->CreateVertexDeclaration( VertexElements, &vertexDecl );
+}
+
+
+/******************************************************/
+void DistortionRenderer::Create_Distortion_Models(void)
+{
+	//Make the distortion models
+	for (int eye=0;eye<2;eye++)
+	{		
+		FOR_EACH_EYE * e = &eachEye[eye];
+		ovrDistortionMesh meshData;
+		ovrHmd_CreateDistortionMesh(HMD,
+            RState.EyeRenderDesc[eye].Eye,
+            RState.EyeRenderDesc[eye].Fov,
+                                    distortionCaps,
+                                    &meshData);
+
+		e->numVerts = meshData.VertexCount;
+		e->numIndices = meshData.IndexCount;
+
+		device->CreateVertexBuffer( (e->numVerts)*sizeof(ovrDistortionVertex),0, 0,
+                                    D3DPOOL_MANAGED, &e->dxVerts, NULL );
+		ovrDistortionVertex * dxv; 	e->dxVerts->Lock( 0, 0, (void**)&dxv, 0 );
+		for (int v=0;v<e->numVerts;v++) dxv[v] = meshData.pVertexData[v];
+		e->dxVerts->Unlock();
+
+		device->CreateIndexBuffer( (e->numIndices)*sizeof(u_short),0, D3DFMT_INDEX16,
+                                   D3DPOOL_MANAGED, &e->dxIndices, NULL );
+		unsigned short* dxi; e->dxIndices->Lock( 0, 0, (void**)&dxi, 0 );
+		for (int i=0;i<e->numIndices;i++) dxi[i] = meshData.pIndexData[i];
+		e->dxIndices->Unlock();
+
+		ovrHmd_DestroyDistortionMesh( &meshData );
+	}
+}
+
+/**********************************************************/
+void DistortionRenderer::RenderBothDistortionMeshes(void)
+{
+	device->BeginScene();
+
+	D3DCOLOR clearColor = D3DCOLOR_RGBA(
+		(int)(RState.ClearColor[0] * 255.0f),
+		(int)(RState.ClearColor[1] * 255.0f),
+		(int)(RState.ClearColor[2] * 255.0f),
+		(int)(RState.ClearColor[3] * 255.0f));
+
+	device->Clear(1, NULL, D3DCLEAR_TARGET, clearColor, 0, 0);
+
+	for (int eye=0; eye<2; eye++)
+	{
+		FOR_EACH_EYE * e = &eachEye[eye];
+		D3DVIEWPORT9 vp; vp.X=0; vp.Y=0; vp.Width=screenSize.w;	vp.Height=screenSize.h; vp.MinZ=0; vp.MaxZ = 1;
+
+		device->SetViewport(&vp);
+		device->SetStreamSource( 0, e->dxVerts,0, sizeof(ovrDistortionVertex) );
+		device->SetVertexDeclaration( vertexDecl ); 
+		device->SetIndices( e->dxIndices );
+		device->SetPixelShader( pixelShader );
+		device->SetTexture( 0, e->texture);
+
+		//Choose which vertex shader, with associated additional inputs
+		if (distortionCaps & ovrDistortionCap_TimeWarp)
+		{          
+			device->SetVertexShader( vertexShaderTimewarp );  
+
+            ovrMatrix4f timeWarpMatrices[2];            
+            ovrHmd_GetEyeTimewarpMatrices(HMD, (ovrEyeType)eye,
+                                          RState.EyeRenderPoses[eye], timeWarpMatrices);
+
+			//Need to transpose the matrices
+			timeWarpMatrices[0] = Matrix4f(timeWarpMatrices[0]).Transposed();
+			timeWarpMatrices[1] = Matrix4f(timeWarpMatrices[1]).Transposed();
+
+            // Feed identity like matrices in until we get proper timewarp calculation going on
+			device->SetVertexShaderConstantF(4, (float *) &timeWarpMatrices[0],4);
+			device->SetVertexShaderConstantF(20,(float *) &timeWarpMatrices[1],4);
+        }
+		else
+		{
+			device->SetVertexShader( vertexShader );  
+		}
+
+		//Set up vertex shader constants
+		device->SetVertexShaderConstantF( 0, ( FLOAT* )&(e->UVScaleOffset[0]), 1 );
+		device->SetVertexShaderConstantF( 2, ( FLOAT* )&(e->UVScaleOffset[1]), 1 );
+
+		device->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,e->numVerts,0,e->numIndices/3);
+	}
+
+	device->EndScene();
+}
+
+}}}
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1013 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_DistortionRenderer.h
+Content     :   Distortion renderer header for GL
+Created     :   November 11, 2013
+Authors     :   David Borel, Lee Cooper
+
+Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+
+#include "CAPI_GL_DistortionRenderer.h"
+
+#include "CAPI_GL_DistortionShaders.h"
+
+#include "../../OVR_CAPI_GL.h"
+#include "../../Kernel/OVR_Color.h"
+
+namespace OVR { namespace CAPI { namespace GL {
+
+
+// Distortion pixel shader lookup.
+//  Bit 0: Chroma Correction
+//  Bit 1: Timewarp
+
+enum {
+    DistortionVertexShaderBitMask = 3,
+    DistortionVertexShaderCount   = DistortionVertexShaderBitMask + 1,
+    DistortionPixelShaderBitMask  = 1,
+    DistortionPixelShaderCount    = DistortionPixelShaderBitMask + 1
+};
+
+struct ShaderInfo
+{
+    const char* ShaderData;
+    size_t ShaderSize;
+    const ShaderBase::Uniform* ReflectionData;
+    size_t ReflectionSize;
+};
+
+// Do add a new distortion shader use these macros (with or w/o reflection)
+#define SI_NOREFL(shader) { shader, sizeof(shader), NULL, 0 }
+#define SI_REFL__(shader) { shader, sizeof(shader), shader ## _refl, sizeof( shader ## _refl )/sizeof(*(shader ## _refl)) }
+
+
+static ShaderInfo DistortionVertexShaderLookup[DistortionVertexShaderCount] =
+{
+    SI_REFL__(Distortion_vs),
+    SI_REFL__(DistortionChroma_vs),
+    SI_REFL__(DistortionTimewarp_vs),
+    SI_REFL__(DistortionTimewarpChroma_vs)
+};
+
+static ShaderInfo DistortionPixelShaderLookup[DistortionPixelShaderCount] =
+{
+    SI_NOREFL(Distortion_fs),
+    SI_NOREFL(DistortionChroma_fs)
+};
+
+void DistortionShaderBitIndexCheck()
+{
+    OVR_COMPILER_ASSERT(ovrDistortionCap_Chromatic == 1);
+    OVR_COMPILER_ASSERT(ovrDistortionCap_TimeWarp  == 2);
+}
+
+
+
+struct DistortionVertex
+{
+    Vector2f ScreenPosNDC;
+    Vector2f TanEyeAnglesR;
+    Vector2f TanEyeAnglesG;
+    Vector2f TanEyeAnglesB;
+    Color    Col;
+};
+
+
+// Vertex type; same format is used for all shapes for simplicity.
+// Shapes are built by adding vertices to Model.
+struct LatencyVertex
+{
+    Vector3f  Pos;
+    LatencyVertex (const Vector3f& p) : Pos(p) {}
+};
+
+
+//----------------------------------------------------------------------------
+// ***** GL::DistortionRenderer
+
+DistortionRenderer::DistortionRenderer(ovrHmd hmd, FrameTimeManager& timeManager,
+                                       const HMDRenderState& renderState)
+    : CAPI::DistortionRenderer(ovrRenderAPI_OpenGL, hmd, timeManager, renderState)
+	, LatencyVAO(0)
+{
+	DistortionMeshVAOs[0] = 0;
+	DistortionMeshVAOs[1] = 0;
+}
+
+DistortionRenderer::~DistortionRenderer()
+{
+    destroy();
+}
+
+// static
+CAPI::DistortionRenderer* DistortionRenderer::Create(ovrHmd hmd,
+                                                     FrameTimeManager& timeManager,
+                                                     const HMDRenderState& renderState)
+{
+#if !defined(OVR_OS_MAC)
+    InitGLExtensions();
+#endif
+    return new DistortionRenderer(hmd, timeManager, renderState);
+}
+
+
+bool DistortionRenderer::Initialize(const ovrRenderAPIConfig* apiConfig,
+									unsigned distortionCaps)
+{
+	GfxState = *new GraphicsState();
+
+	SaveGraphicsState();
+
+    const ovrGLConfig* config = (const ovrGLConfig*)apiConfig;
+
+    if (!config)
+    {
+        // Cleanup
+        pEyeTextures[0].Clear();
+        pEyeTextures[1].Clear();
+        memset(&RParams, 0, sizeof(RParams));
+        return true;
+    }
+
+	RParams.Multisample = config->OGL.Header.Multisample;
+	RParams.RTSize      = config->OGL.Header.RTSize;
+#if defined(OVR_OS_WIN32)
+	RParams.Window      = (config->OGL.Window) ? config->OGL.Window : GetActiveWindow();
+    RParams.DC          = config->OGL.DC;
+#elif defined(OVR_OS_LINUX)
+    if (config->OGL.Disp)
+        RParams.Disp = config->OGL.Disp;
+    if (!RParams.Disp)
+        RParams.Disp = XOpenDisplay(NULL);
+    if (!RParams.Disp)
+    {
+        OVR_DEBUG_LOG(("XOpenDisplay failed."));
+        return false;
+    }
+
+    if (config->OGL.Win)
+        RParams.Win         = config->OGL.Win;
+    if (!RParams.Win)
+    {
+        int unused;
+        RParams.Win = glXGetCurrentDrawable();
+    }
+    if (!RParams.Win)
+    {
+        OVR_DEBUG_LOG(("XGetInputFocus failed."));
+        return false;
+    }
+#endif
+	
+    DistortionCaps = distortionCaps;
+	
+    DistortionMeshVAOs[0] = 0;
+    DistortionMeshVAOs[1] = 0;
+
+    LatencyVAO = 0;
+
+    //DistortionWarper.SetVsync((hmdCaps & ovrHmdCap_NoVSync) ? false : true);
+
+    pEyeTextures[0] = *new Texture(&RParams, 0, 0);
+    pEyeTextures[1] = *new Texture(&RParams, 0, 0);
+
+    initBuffersAndShaders();
+
+	RestoreGraphicsState();
+
+    return true;
+}
+
+
+void DistortionRenderer::SubmitEye(int eyeId, const ovrTexture* eyeTexture)
+{
+    // Doesn't do a lot in here??
+	const ovrGLTexture* tex = (const ovrGLTexture*)eyeTexture;
+
+	// Write in values
+    eachEye[eyeId].texture = tex->OGL.TexId;
+
+	if (tex)
+	{
+        // Its only at this point we discover what the viewport of the texture is.
+	    // because presumably we allow users to realtime adjust the resolution.
+        eachEye[eyeId].TextureSize    = tex->OGL.Header.TextureSize;
+        eachEye[eyeId].RenderViewport = tex->OGL.Header.RenderViewport;
+
+        const ovrEyeRenderDesc& erd = RState.EyeRenderDesc[eyeId];
+    
+        ovrHmd_GetRenderScaleAndOffset( erd.Fov,
+                                        eachEye[eyeId].TextureSize, eachEye[eyeId].RenderViewport,
+                                        eachEye[eyeId].UVScaleOffset );
+
+		if (!(RState.DistortionCaps & ovrDistortionCap_FlipInput))
+		{
+			eachEye[eyeId].UVScaleOffset[0].y = -eachEye[eyeId].UVScaleOffset[0].y;
+			eachEye[eyeId].UVScaleOffset[1].y = 1.0f - eachEye[eyeId].UVScaleOffset[1].y;
+		}
+
+        pEyeTextures[eyeId]->UpdatePlaceholderTexture(tex->OGL.TexId,
+                                                      tex->OGL.Header.TextureSize);
+	}
+}
+
+void DistortionRenderer::renderEndFrame()
+{
+    renderDistortion(pEyeTextures[0], pEyeTextures[1]);
+
+    // TODO: Add rendering context to callback.
+    if(RegisteredPostDistortionCallback)
+       RegisteredPostDistortionCallback(NULL);
+
+    if(LatencyTest2Active)
+    {
+        renderLatencyPixel(LatencyTest2DrawColor);
+    }
+}
+
+void DistortionRenderer::EndFrame(bool swapBuffers)
+{
+    // Don't spin if we are explicitly asked not to
+    if (RState.DistortionCaps & ovrDistortionCap_TimeWarp &&
+        !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+    {
+        if (!TimeManager.NeedDistortionTimeMeasurement())
+        {
+            // Wait for timewarp distortion if it is time and Gpu idle
+            FlushGpuAndWaitTillTime(TimeManager.GetFrameTiming().TimewarpPointTime);
+
+            renderEndFrame();
+        }
+        else
+        {
+            // If needed, measure distortion time so that TimeManager can better estimate
+            // latency-reducing time-warp wait timing.
+            WaitUntilGpuIdle();
+            double  distortionStartTime = ovr_GetTimeInSeconds();
+
+            renderEndFrame();
+
+            WaitUntilGpuIdle();
+            TimeManager.AddDistortionTimeMeasurement(ovr_GetTimeInSeconds() - distortionStartTime);
+        }
+    }
+    else
+    {
+        renderEndFrame();
+    }
+
+    if(LatencyTestActive)
+    {
+        renderLatencyQuad(LatencyTestDrawColor);
+    }
+
+    if (swapBuffers)
+    {
+		bool useVsync = ((RState.EnabledHmdCaps & ovrHmdCap_NoVSync) == 0);
+		int swapInterval = (useVsync) ? 1 : 0;
+#if defined(OVR_OS_WIN32)
+		if (wglGetSwapIntervalEXT() != swapInterval)
+            wglSwapIntervalEXT(swapInterval);
+
+        HDC dc = (RParams.DC != NULL) ? RParams.DC : GetDC(RParams.Window);
+		BOOL success = SwapBuffers(dc);
+        OVR_ASSERT(success);
+        OVR_UNUSED(success);
+
+        if (RParams.DC == NULL)
+            ReleaseDC(RParams.Window, dc);
+#elif defined(OVR_OS_MAC)
+        CGLContextObj context = CGLGetCurrentContext();
+        GLint currentSwapInterval = 0;
+        CGLGetParameter(context, kCGLCPSwapInterval, &currentSwapInterval);
+        if (currentSwapInterval != swapInterval)
+            CGLSetParameter(context, kCGLCPSwapInterval, &swapInterval);
+        
+        CGLFlushDrawable(context);
+#elif defined(OVR_OS_LINUX)
+        static const char* extensions = glXQueryExtensionsString(RParams.Disp, 0);
+        static bool supportsVSync = (extensions != NULL && strstr(extensions, "GLX_EXT_swap_control"));
+        if (supportsVSync)
+        {
+            GLuint currentSwapInterval = 0;
+            glXQueryDrawable(RParams.Disp, RParams.Win, GLX_SWAP_INTERVAL_EXT, &currentSwapInterval);
+            if (currentSwapInterval != swapInterval)
+                glXSwapIntervalEXT(RParams.Disp, RParams.Win, swapInterval);
+        }
+
+        glXSwapBuffers(RParams.Disp, RParams.Win);
+#endif
+        // Force GPU to flush the scene, resulting in the lowest possible latency.
+        // It's critical that this flush is *after* present.
+        // With the display driver this flush is obsolete and theoretically should
+        // be a no-op.
+        // Doesn't need to be done if running through the Oculus driver.
+        if (RState.OurHMDInfo.InCompatibilityMode &&
+            !(RState.DistortionCaps & ovrDistortionCap_ProfileNoTimewarpSpinWaits))
+            WaitUntilGpuIdle();
+    }
+}
+
+void DistortionRenderer::WaitUntilGpuIdle()
+{
+	glFinish();
+}
+
+double DistortionRenderer::FlushGpuAndWaitTillTime(double absTime)
+{
+    // because glFlush() is not strict enough certain GL drivers
+    // we do a glFinish(), but before doing so, we make sure we're not
+    // running late
+    double initialTime = ovr_GetTimeInSeconds();
+    if (initialTime >= absTime)
+        return 0.0;
+
+    glFinish();
+
+    return WaitTillTime(absTime);
+}
+    
+    
+DistortionRenderer::GraphicsState::GraphicsState()
+{
+    bool foundVersion = false;
+    const char* glVersionString = (const char*)glGetString(GL_VERSION);
+    if (glVersionString)
+    {
+        OVR_DEBUG_LOG(("GL_VERSION STRING: %s", (const char*)glVersionString));
+        char prefix[64];
+
+        for (int i = 10; i < 30; ++i)
+        {
+            int major = i / 10;
+            int minor = i % 10;
+            OVR_sprintf(prefix, 64, "%d.%d", major, minor);
+            if (strstr(glVersionString, prefix) == glVersionString)
+            {
+                GlMajorVersion = major;
+                GlMinorVersion = minor;
+                foundVersion = true;
+                break;
+            }
+        }
+    }
+    
+    if (!foundVersion)
+    {
+        glGetIntegerv(GL_MAJOR_VERSION, &GlMajorVersion);
+        glGetIntegerv(GL_MAJOR_VERSION, &GlMinorVersion);
+	}
+
+	OVR_ASSERT(GlMajorVersion >= 2);
+    
+    if (GlMajorVersion >= 3)
+    {
+        SupportsVao = true;
+        SupportsDrawBuffers = true;
+    }
+    else
+    {
+        const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
+        SupportsVao = (strstr(extensions, "GL_ARB_vertex_array_object") != NULL
+                       || strstr(extensions, "GL_APPLE_vertex_array_object") != NULL);
+        SupportsDrawBuffers = (strstr(extensions, "GL_EXT_draw_buffers2") != NULL);
+    }
+}
+    
+    
+void DistortionRenderer::GraphicsState::ApplyBool(GLenum Name, GLint Value, GLint index)
+{
+	if (SupportsDrawBuffers && index != -1)
+	{
+		if (Value != 0)
+			glEnablei(Name, index);
+		else
+			glDisablei(Name, index);
+	}
+	else
+	{
+		if (Value != 0)
+			glEnable(Name);
+		else
+			glDisable(Name);
+	}
+}
+    
+    
+void DistortionRenderer::GraphicsState::Save()
+{
+    glGetIntegerv(GL_VIEWPORT, Viewport);
+    glGetFloatv(GL_COLOR_CLEAR_VALUE, ClearColor);
+    glGetIntegerv(GL_DEPTH_TEST, &DepthTest);
+    glGetIntegerv(GL_CULL_FACE, &CullFace);
+	glGetIntegerv(GL_FRAMEBUFFER_SRGB, &SRGB);
+    glGetIntegerv(GL_CURRENT_PROGRAM, &Program);
+    glGetIntegerv(GL_ACTIVE_TEXTURE, &ActiveTexture);
+    glGetIntegerv(GL_TEXTURE_BINDING_2D, &TextureBinding);
+    if (SupportsVao)
+    {
+        glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &VertexArrayBinding);
+    }
+    else
+    {
+        glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &ElementArrayBufferBinding);
+        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &ArrayBufferBinding);
+    }
+    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &FrameBufferBinding);
+    if (SupportsDrawBuffers)
+    {
+        glGetIntegeri_v(GL_BLEND, 0, &Blend);
+        glGetIntegeri_v(GL_COLOR_WRITEMASK, 0, ColorWritemask);
+    }
+    else
+    {
+        glGetIntegerv(GL_BLEND, &Blend);
+        glGetIntegerv(GL_COLOR_WRITEMASK, ColorWritemask);
+    }
+    glGetIntegerv(GL_DITHER, &Dither);
+    glGetIntegerv(GL_RASTERIZER_DISCARD, &RasterizerDiscard);
+    if ((GlMajorVersion == 3 && GlMinorVersion >= 2) || GlMajorVersion >= 4)
+        glGetIntegerv(GL_SAMPLE_MASK, &SampleMask);
+
+	IsValid = true;
+}
+
+#ifdef OVR_OS_MAC
+bool DistortionRenderer::GraphicsState::isAtLeastOpenGL3()
+{
+    return !(GlMajorVersion < 3|| (GlMajorVersion == 3 && GlMinorVersion < 2));
+}
+#endif
+
+void DistortionRenderer::GraphicsState::Restore()
+{
+	// Don't allow restore-before-save.
+	if (!IsValid)
+		return;
+
+    glViewport(Viewport[0], Viewport[1], Viewport[2], Viewport[3]);
+    glClearColor(ClearColor[0], ClearColor[1], ClearColor[2], ClearColor[3]);
+    
+    ApplyBool(GL_DEPTH_TEST, DepthTest);
+    ApplyBool(GL_CULL_FACE, CullFace);
+    ApplyBool(GL_FRAMEBUFFER_SRGB, SRGB);	
+    
+    glUseProgram(Program);
+    glActiveTexture(ActiveTexture);
+    glBindTexture(GL_TEXTURE_2D, TextureBinding);
+    if (SupportsVao)
+    {
+#ifdef OVR_OS_MAC
+        if (isAtLeastOpenGL3())
+        {
+            glBindVertexArray(VertexArrayBinding);
+        }
+        else
+        {
+            glBindVertexArrayAPPLE(VertexArrayBinding);
+        }
+#else
+		glBindVertexArray(VertexArrayBinding);
+#endif
+    }
+    else
+    {
+        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementArrayBufferBinding);
+        glBindBuffer(GL_ARRAY_BUFFER, ArrayBufferBinding);
+    }
+    glBindFramebuffer(GL_FRAMEBUFFER, FrameBufferBinding);
+    
+	ApplyBool(GL_BLEND, Blend, 0);
+    
+    if (SupportsDrawBuffers)
+        glColorMaski(0, (GLboolean)ColorWritemask[0], (GLboolean)ColorWritemask[1], (GLboolean)ColorWritemask[2], (GLboolean)ColorWritemask[3]);
+    else
+        glColorMask((GLboolean)ColorWritemask[0], (GLboolean)ColorWritemask[1], (GLboolean)ColorWritemask[2], (GLboolean)ColorWritemask[3]);
+    
+    ApplyBool(GL_DITHER, Dither);
+    ApplyBool(GL_RASTERIZER_DISCARD, RasterizerDiscard);
+	if ((GlMajorVersion == 3 && GlMinorVersion >= 2) || GlMajorVersion >= 4)
+        ApplyBool(GL_SAMPLE_MASK, SampleMask);
+}
+
+
+void DistortionRenderer::initBuffersAndShaders()
+{
+    for ( int eyeNum = 0; eyeNum < 2; eyeNum++ )
+    {
+        // Allocate & generate distortion mesh vertices.
+        ovrDistortionMesh meshData;
+
+//        double startT = ovr_GetTimeInSeconds();
+
+        if (!ovrHmd_CreateDistortionMesh( HMD,
+                                          RState.EyeRenderDesc[eyeNum].Eye,
+                                          RState.EyeRenderDesc[eyeNum].Fov,
+                                          RState.DistortionCaps,
+                                          &meshData) )
+        {
+            OVR_ASSERT(false);
+            continue;
+        }
+
+        // Now parse the vertex data and create a render ready vertex buffer from it
+        DistortionVertex *   pVBVerts    = (DistortionVertex*)OVR_ALLOC ( sizeof(DistortionVertex) * meshData.VertexCount );
+        DistortionVertex *   pCurVBVert  = pVBVerts;
+        ovrDistortionVertex* pCurOvrVert = meshData.pVertexData;
+
+        for ( unsigned vertNum = 0; vertNum < meshData.VertexCount; vertNum++ )
+        {
+            pCurVBVert->ScreenPosNDC.x = pCurOvrVert->ScreenPosNDC.x;
+            pCurVBVert->ScreenPosNDC.y = pCurOvrVert->ScreenPosNDC.y;
+            pCurVBVert->TanEyeAnglesR  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesR);
+            pCurVBVert->TanEyeAnglesG  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesG);
+            pCurVBVert->TanEyeAnglesB  = (*(Vector2f*)&pCurOvrVert->TanEyeAnglesB);
+
+            // Convert [0.0f,1.0f] to [0,255]
+			if (DistortionCaps & ovrDistortionCap_Vignette)
+				pCurVBVert->Col.R = (uint8_t)( pCurOvrVert->VignetteFactor * 255.99f );
+			else
+				pCurVBVert->Col.R = 255;
+
+            pCurVBVert->Col.G = pCurVBVert->Col.R;
+            pCurVBVert->Col.B = pCurVBVert->Col.R;
+            pCurVBVert->Col.A = (uint8_t)( pCurOvrVert->TimeWarpFactor * 255.99f );;
+            pCurOvrVert++;
+            pCurVBVert++;
+        }
+
+        DistortionMeshVBs[eyeNum] = *new Buffer(&RParams);
+        DistortionMeshVBs[eyeNum]->Data ( Buffer_Vertex | Buffer_ReadOnly, pVBVerts, sizeof(DistortionVertex) * meshData.VertexCount );
+        DistortionMeshIBs[eyeNum] = *new Buffer(&RParams);
+        DistortionMeshIBs[eyeNum]->Data ( Buffer_Index | Buffer_ReadOnly, meshData.pIndexData, ( sizeof(int16_t) * meshData.IndexCount ) );
+
+        OVR_FREE ( pVBVerts );
+        ovrHmd_DestroyDistortionMesh( &meshData );
+    }
+
+    initShaders();
+}
+
+void DistortionRenderer::renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture)
+{
+    GraphicsState* glState = (GraphicsState*)GfxState.GetPtr();
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    setViewport( Recti(0,0, RParams.RTSize.w, RParams.RTSize.h) );
+
+	if (DistortionCaps & ovrDistortionCap_SRGB)
+		glEnable(GL_FRAMEBUFFER_SRGB);
+    else
+        glDisable(GL_FRAMEBUFFER_SRGB);
+
+	glDisable(GL_CULL_FACE);
+	glDisable(GL_DEPTH_TEST);
+    
+    if (glState->SupportsDrawBuffers)
+    {
+        glDisablei(GL_BLEND, 0);
+        glColorMaski(0, GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE);
+    }
+    else
+    {
+        glDisable(GL_BLEND);
+        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE);
+    }
+    
+    glDisable(GL_DITHER);
+    glDisable(GL_RASTERIZER_DISCARD);
+    if ((glState->GlMajorVersion >= 3 && glState->GlMinorVersion >= 2) || glState->GlMajorVersion >= 4)
+        glDisable(GL_SAMPLE_MASK);
+        
+	glClearColor(
+		RState.ClearColor[0],
+		RState.ClearColor[1],
+		RState.ClearColor[2],
+		RState.ClearColor[3] );
+
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    for (int eyeNum = 0; eyeNum < 2; eyeNum++)
+    {        
+		ShaderFill distortionShaderFill(DistortionShader);
+        distortionShaderFill.SetTexture(0, eyeNum == 0 ? leftEyeTexture : rightEyeTexture);
+
+		DistortionShader->SetUniform2f("EyeToSourceUVScale",  eachEye[eyeNum].UVScaleOffset[0].x, eachEye[eyeNum].UVScaleOffset[0].y);
+		DistortionShader->SetUniform2f("EyeToSourceUVOffset", eachEye[eyeNum].UVScaleOffset[1].x, eachEye[eyeNum].UVScaleOffset[1].y);
+        
+		if (DistortionCaps & ovrDistortionCap_TimeWarp)
+		{                       
+            ovrMatrix4f timeWarpMatrices[2];            
+            ovrHmd_GetEyeTimewarpMatrices(HMD, (ovrEyeType)eyeNum,
+                                          RState.EyeRenderPoses[eyeNum], timeWarpMatrices);
+
+            // Feed identity like matrices in until we get proper timewarp calculation going on
+			DistortionShader->SetUniform4x4f("EyeRotationStart", Matrix4f(timeWarpMatrices[0]).Transposed());
+			DistortionShader->SetUniform4x4f("EyeRotationEnd",   Matrix4f(timeWarpMatrices[1]).Transposed());
+
+            renderPrimitives(&distortionShaderFill, DistortionMeshVBs[eyeNum], DistortionMeshIBs[eyeNum],
+                            0, (int)DistortionMeshIBs[eyeNum]->GetSize()/2, Prim_Triangles, &DistortionMeshVAOs[eyeNum], true);
+		}
+        else
+        {
+            renderPrimitives(&distortionShaderFill, DistortionMeshVBs[eyeNum], DistortionMeshIBs[eyeNum],
+                            0, (int)DistortionMeshIBs[eyeNum]->GetSize()/2, Prim_Triangles, &DistortionMeshVAOs[eyeNum], true);
+        }
+    }
+}
+
+void DistortionRenderer::createDrawQuad()
+{
+    const int numQuadVerts = 4;
+    LatencyTesterQuadVB = *new Buffer(&RParams);
+    if(!LatencyTesterQuadVB)
+    {
+        return;
+    }
+
+    LatencyTesterQuadVB->Data(Buffer_Vertex, NULL, numQuadVerts * sizeof(LatencyVertex));
+    LatencyVertex* vertices = (LatencyVertex*)LatencyTesterQuadVB->Map(0, numQuadVerts * sizeof(LatencyVertex), Map_Discard);
+    if(!vertices)
+    {
+        OVR_ASSERT(false); // failed to lock vertex buffer
+        return;
+    }
+
+    const float left   = -1.0f;
+    const float top    = -1.0f;
+    const float right  =  1.0f;
+    const float bottom =  1.0f;
+
+    vertices[0] = LatencyVertex(Vector3f(left,  top,    0.0f));
+    vertices[1] = LatencyVertex(Vector3f(left,  bottom, 0.0f));
+    vertices[2] = LatencyVertex(Vector3f(right, top,    0.0f));
+    vertices[3] = LatencyVertex(Vector3f(right, bottom, 0.0f));
+
+    LatencyTesterQuadVB->Unmap(vertices);
+}
+
+void DistortionRenderer::renderLatencyQuad(unsigned char* latencyTesterDrawColor)
+{
+    const int numQuadVerts = 4;
+
+    if(!LatencyTesterQuadVB)
+    {
+        createDrawQuad();
+    }
+       
+    Ptr<ShaderSet> quadShader = (DistortionCaps & ovrDistortionCap_SRGB) ? SimpleQuadGammaShader : SimpleQuadShader;
+    ShaderFill quadFill(quadShader);
+    //quadFill.SetInputLayout(SimpleQuadVertexIL);
+
+    setViewport(Recti(0,0, RParams.RTSize.w, RParams.RTSize.h));
+
+    quadShader->SetUniform2f("Scale", 0.3f, 0.3f);
+    quadShader->SetUniform4f("Color", (float)latencyTesterDrawColor[0] / 255.99f,
+                                      (float)latencyTesterDrawColor[0] / 255.99f,
+                                      (float)latencyTesterDrawColor[0] / 255.99f,
+                                      1.0f);
+
+    for(int eyeNum = 0; eyeNum < 2; eyeNum++)
+    {
+        quadShader->SetUniform2f("PositionOffset", eyeNum == 0 ? -0.5f : 0.5f, 0.0f);    
+        renderPrimitives(&quadFill, LatencyTesterQuadVB, NULL, 0, numQuadVerts, Prim_TriangleStrip, &LatencyVAO, false);
+    }
+}
+
+void DistortionRenderer::renderLatencyPixel(unsigned char* latencyTesterPixelColor)
+{
+    const int numQuadVerts = 4;
+
+    if(!LatencyTesterQuadVB)
+    {
+        createDrawQuad();
+    }
+
+    Ptr<ShaderSet> quadShader = (DistortionCaps & ovrDistortionCap_SRGB) ? SimpleQuadGammaShader : SimpleQuadShader;
+    ShaderFill quadFill(quadShader);
+
+    setViewport(Recti(0,0, RParams.RTSize.w, RParams.RTSize.h));
+
+#ifdef OVR_BUILD_DEBUG
+    quadShader->SetUniform4f("Color", (float)latencyTesterPixelColor[0] / 255.99f,
+                                      (float)latencyTesterPixelColor[1] / 255.99f,
+                                      (float)latencyTesterPixelColor[2] / 255.99f,
+                                      1.0f);
+
+    Vector2f scale(20.0f / RParams.RTSize.w, 20.0f / RParams.RTSize.h); 
+#else
+    quadShader->SetUniform4f("Color", (float)latencyTesterPixelColor[0] / 255.99f,
+                                      (float)latencyTesterPixelColor[0] / 255.99f,
+                                      (float)latencyTesterPixelColor[0] / 255.99f,
+                                      1.0f);
+
+    Vector2f scale(1.0f / RParams.RTSize.w, 1.0f / RParams.RTSize.h); 
+#endif
+    quadShader->SetUniform2f("Scale", scale.x, scale.y);
+    quadShader->SetUniform2f("PositionOffset", 1.0f-scale.x, 1.0f-scale.y);
+	renderPrimitives(&quadFill, LatencyTesterQuadVB, NULL, 0, numQuadVerts, Prim_TriangleStrip, &LatencyVAO, false);
+}
+
+void DistortionRenderer::renderPrimitives(
+                          const ShaderFill* fill,
+                          Buffer* vertices, Buffer* indices,
+                          int offset, int count,
+                          PrimitiveType rprim, GLuint* vao, bool isDistortionMesh)
+{
+    GraphicsState* glState = (GraphicsState*)GfxState.GetPtr();
+
+    GLenum prim;
+    switch (rprim)
+    {
+    case Prim_Triangles:
+        prim = GL_TRIANGLES;
+        break;
+    case Prim_Lines:
+        prim = GL_LINES;
+        break;
+    case Prim_TriangleStrip:
+        prim = GL_TRIANGLE_STRIP;
+        break;
+    default:
+        OVR_ASSERT(false);
+        return;
+    }
+
+    fill->Set();
+    
+    GLuint prog = fill->GetShaders()->Prog;
+
+	if (vao != NULL)
+	{
+		if (*vao != 0)
+		{
+#ifdef OVR_OS_MAC
+            if (glState->isAtLeastOpenGL3())
+            {
+                glBindVertexArray(*vao);
+            }
+            else
+            {
+                glBindVertexArrayAPPLE(*vao);
+            }
+#else
+			glBindVertexArray(*vao);
+#endif
+
+			if (isDistortionMesh)
+				glDrawElements(prim, count, GL_UNSIGNED_SHORT, NULL);
+			else
+				glDrawArrays(prim, 0, count);
+
+#ifdef OVR_OS_MAC
+            if (glState->isAtLeastOpenGL3())
+            {
+                glBindVertexArray(*vao);
+            }
+            else
+            {
+                glBindVertexArrayAPPLE(0);
+            }
+#else
+            glBindVertexArray(0);
+#endif
+		}
+		else
+		{
+            if (glState->SupportsVao)
+            {
+#ifdef OVR_OS_MAC
+                if (glState->isAtLeastOpenGL3())
+                {
+                    glGenVertexArrays(1, vao);
+                    glBindVertexArray(*vao);
+                }
+                else
+                {
+                    glGenVertexArraysAPPLE(1, vao);
+                    glBindVertexArrayAPPLE(*vao);
+                }
+#else
+                glGenVertexArrays(1, vao);
+                glBindVertexArray(*vao);
+#endif
+			}
+
+			int attributeCount = (isDistortionMesh) ? 5 : 1;
+			int* locs = new int[attributeCount];
+
+			glBindBuffer(GL_ARRAY_BUFFER, ((Buffer*)vertices)->GLBuffer);
+
+			if (isDistortionMesh)
+			{
+				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ((Buffer*)indices)->GLBuffer);
+
+				locs[0] = glGetAttribLocation(prog, "Position");
+				locs[1] = glGetAttribLocation(prog, "Color");
+				locs[2] = glGetAttribLocation(prog, "TexCoord0");
+				locs[3] = glGetAttribLocation(prog, "TexCoord1");
+				locs[4] = glGetAttribLocation(prog, "TexCoord2");
+
+				glVertexAttribPointer(locs[0], 2, GL_FLOAT, false, sizeof(DistortionVertex), reinterpret_cast<char*>(offset)+offsetof(DistortionVertex, ScreenPosNDC));
+				glVertexAttribPointer(locs[1], 4, GL_UNSIGNED_BYTE, true, sizeof(DistortionVertex), reinterpret_cast<char*>(offset)+offsetof(DistortionVertex, Col));
+				glVertexAttribPointer(locs[2], 2, GL_FLOAT, false, sizeof(DistortionVertex), reinterpret_cast<char*>(offset)+offsetof(DistortionVertex, TanEyeAnglesR));
+				glVertexAttribPointer(locs[3], 2, GL_FLOAT, false, sizeof(DistortionVertex), reinterpret_cast<char*>(offset)+offsetof(DistortionVertex, TanEyeAnglesG));
+				glVertexAttribPointer(locs[4], 2, GL_FLOAT, false, sizeof(DistortionVertex), reinterpret_cast<char*>(offset)+offsetof(DistortionVertex, TanEyeAnglesB));
+			}
+			else
+			{
+				locs[0] = glGetAttribLocation(prog, "Position");
+
+				glVertexAttribPointer(locs[0], 3, GL_FLOAT, false, sizeof(LatencyVertex), reinterpret_cast<char*>(offset)+offsetof(LatencyVertex, Pos));
+			}
+
+            for (int i = 0; i < attributeCount; ++i)
+                glEnableVertexAttribArray(locs[i]);
+            
+			if (isDistortionMesh)
+				glDrawElements(prim, count, GL_UNSIGNED_SHORT, NULL);
+			else
+				glDrawArrays(prim, 0, count);
+
+
+            if (!glState->SupportsVao)
+            {
+				for (int i = 0; i < attributeCount; ++i)
+                    glDisableVertexAttribArray(locs[i]);
+            }
+
+			delete[] locs;
+
+            if (glState->SupportsVao)
+            {
+#ifdef OVR_OS_MAC
+                if (glState->isAtLeastOpenGL3())
+                {
+                    glBindVertexArray(0);
+                }
+                else
+                {
+                    glBindVertexArrayAPPLE(0);
+                }
+#else
+                glBindVertexArray(0);
+#endif
+            }
+		}
+	}
+}
+
+void DistortionRenderer::setViewport(const Recti& vp)
+{
+    glViewport(vp.x, vp.y, vp.w, vp.h);
+}
+
+
+void DistortionRenderer::initShaders()
+{
+    GraphicsState* glState = (GraphicsState*)GfxState.GetPtr();
+
+    const char* shaderPrefix =
+        (glState->GlMajorVersion < 3 || (glState->GlMajorVersion == 3 && glState->GlMinorVersion < 2)) ?
+            glsl2Prefix : glsl3Prefix;
+
+    {
+		ShaderInfo vsInfo = DistortionVertexShaderLookup[DistortionVertexShaderBitMask & DistortionCaps];
+
+		size_t vsSize = strlen(shaderPrefix)+vsInfo.ShaderSize;
+		char* vsSource = new char[vsSize];
+		OVR_strcpy(vsSource, vsSize, shaderPrefix);
+		OVR_strcat(vsSource, vsSize, vsInfo.ShaderData);
+
+        Ptr<GL::VertexShader> vs = *new GL::VertexShader(
+            &RParams,
+			(void*)vsSource, vsSize,
+			vsInfo.ReflectionData, vsInfo.ReflectionSize);
+
+        DistortionShader = *new ShaderSet;
+        DistortionShader->SetShader(vs);
+
+		delete[](vsSource);
+
+		ShaderInfo psInfo = DistortionPixelShaderLookup[DistortionPixelShaderBitMask & DistortionCaps];
+
+		size_t psSize = strlen(shaderPrefix)+psInfo.ShaderSize;
+		char* psSource = new char[psSize];
+		OVR_strcpy(psSource, psSize, shaderPrefix);
+		OVR_strcat(psSource, psSize, psInfo.ShaderData);
+
+        Ptr<GL::FragmentShader> ps  = *new GL::FragmentShader(
+            &RParams,
+			(void*)psSource, psSize,
+			psInfo.ReflectionData, psInfo.ReflectionSize);
+
+        DistortionShader->SetShader(ps);
+
+		delete[](psSource);
+    }
+	{
+		size_t vsSize = strlen(shaderPrefix)+sizeof(SimpleQuad_vs);
+		char* vsSource = new char[vsSize];
+		OVR_strcpy(vsSource, vsSize, shaderPrefix);
+		OVR_strcat(vsSource, vsSize, SimpleQuad_vs);
+
+        Ptr<GL::VertexShader> vs = *new GL::VertexShader(
+            &RParams,
+            (void*)vsSource, vsSize,
+			SimpleQuad_vs_refl, sizeof(SimpleQuad_vs_refl) / sizeof(SimpleQuad_vs_refl[0]));
+
+        SimpleQuadShader = *new ShaderSet;
+		SimpleQuadShader->SetShader(vs);
+
+		delete[](vsSource);
+
+		size_t psSize = strlen(shaderPrefix)+sizeof(SimpleQuad_fs);
+		char* psSource = new char[psSize];
+		OVR_strcpy(psSource, psSize, shaderPrefix);
+		OVR_strcat(psSource, psSize, SimpleQuad_fs);
+
+        Ptr<GL::FragmentShader> ps  = *new GL::FragmentShader(
+            &RParams,
+            (void*)psSource, psSize,
+            SimpleQuad_fs_refl, sizeof(SimpleQuad_fs_refl) / sizeof(SimpleQuad_fs_refl[0]));
+
+		SimpleQuadShader->SetShader(ps);
+
+		delete[](psSource);
+    }
+    {
+        size_t vsSize = strlen(shaderPrefix)+sizeof(SimpleQuad_vs);
+        char* vsSource = new char[vsSize];
+        OVR_strcpy(vsSource, vsSize, shaderPrefix);
+        OVR_strcat(vsSource, vsSize, SimpleQuad_vs);
+
+        Ptr<GL::VertexShader> vs = *new GL::VertexShader(
+            &RParams,
+            (void*)vsSource, vsSize,
+            SimpleQuad_vs_refl, sizeof(SimpleQuad_vs_refl) / sizeof(SimpleQuad_vs_refl[0]));
+
+        SimpleQuadGammaShader = *new ShaderSet;
+        SimpleQuadGammaShader->SetShader(vs);
+
+        delete[](vsSource);
+
+        size_t psSize = strlen(shaderPrefix)+sizeof(SimpleQuadGamma_fs);
+        char* psSource = new char[psSize];
+        OVR_strcpy(psSource, psSize, shaderPrefix);
+        OVR_strcat(psSource, psSize, SimpleQuadGamma_fs);
+
+        Ptr<GL::FragmentShader> ps  = *new GL::FragmentShader(
+            &RParams,
+            (void*)psSource, psSize,
+            SimpleQuadGamma_fs_refl, sizeof(SimpleQuadGamma_fs_refl) / sizeof(SimpleQuadGamma_fs_refl[0]));
+
+        SimpleQuadGammaShader->SetShader(ps);
+
+        delete[](psSource);
+    }
+}
+
+
+void DistortionRenderer::destroy()
+{
+	SaveGraphicsState();
+
+    GraphicsState* glState = (GraphicsState*)GfxState.GetPtr();
+
+	for(int eyeNum = 0; eyeNum < 2; eyeNum++)
+	{
+        if (glState->SupportsVao)
+            glDeleteVertexArrays(1, &DistortionMeshVAOs[eyeNum]);
+
+		DistortionMeshVAOs[eyeNum] = 0;
+
+		DistortionMeshVBs[eyeNum].Clear();
+		DistortionMeshIBs[eyeNum].Clear();
+	}
+
+	if (DistortionShader)
+    {
+        DistortionShader->UnsetShader(Shader_Vertex);
+	    DistortionShader->UnsetShader(Shader_Pixel);
+	    DistortionShader.Clear();
+    }
+
+    LatencyTesterQuadVB.Clear();
+
+    if(LatencyVAO != 0)
+    {
+        glDeleteVertexArrays(1, &LatencyVAO);
+	    LatencyVAO = 0;
+    }
+
+	RestoreGraphicsState();
+}
+
+
+}}} // OVR::CAPI::GL
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,191 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_DistortionRenderer.h
+Content     :   Distortion renderer header for GL
+Created     :   November 11, 2013
+Authors     :   David Borel, Lee Cooper
+
+Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_GL_DistortionRenderer_h
+#define OVR_CAPI_GL_DistortionRenderer_h
+
+#include "../CAPI_DistortionRenderer.h"
+
+#include "../../Kernel/OVR_Log.h"
+#include "CAPI_GL_Util.h"
+
+namespace OVR { namespace CAPI { namespace GL {
+
+// ***** GL::DistortionRenderer
+
+// Implementation of DistortionRenderer for GL.
+
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd,
+                       FrameTimeManager& timeManager,
+                       const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+                                            FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+
+
+    // ***** Public DistortionRenderer interface
+	
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+    
+    
+    class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+    {
+    public:
+        GraphicsState();
+        virtual void Save();
+        virtual void Restore();
+        
+#ifdef OVR_OS_MAC
+        // Asking for Core Profile is equivalent to asking whether we have a
+        // 3.2+ context on mac.
+        bool isAtLeastOpenGL3();
+#endif
+
+    protected:
+        void ApplyBool(GLenum Name, GLint Value, GLint index = -1);
+        
+    public:
+        GLint GlMajorVersion;
+        GLint GlMinorVersion;
+        bool SupportsVao;
+        bool SupportsDrawBuffers;
+        
+        GLint Viewport[4];
+        GLfloat ClearColor[4];
+        GLint DepthTest;
+        GLint CullFace;
+        GLint SRGB;
+        GLint Program;
+        GLint ActiveTexture;
+        GLint TextureBinding;
+        GLint VertexArrayBinding;
+        GLint ElementArrayBufferBinding;
+        GLint ArrayBufferBinding;
+        GLint FrameBufferBinding;
+        
+        GLint Blend;
+        GLint ColorWritemask[4];
+        GLint Dither;
+        GLint Fog;
+        GLint Lighting;
+        GLint RasterizerDiscard;
+        GLint RenderMode;
+        GLint SampleMask;
+        GLint ScissorTest;
+        GLfloat ZoomX;
+        GLfloat ZoomY;
+    };
+
+    // TBD: Should we be using oe from RState instead?
+    unsigned            DistortionCaps;
+
+	struct FOR_EACH_EYE
+	{
+        FOR_EACH_EYE() : TextureSize(0), RenderViewport(Sizei(0)) { }
+
+#if 0
+		IDirect3DVertexBuffer9  * dxVerts;
+		IDirect3DIndexBuffer9   * dxIndices;
+#endif
+		int                       numVerts;
+		int                       numIndices;
+
+		GLuint                    texture;
+
+		ovrVector2f			 	  UVScaleOffset[2];
+        Sizei                     TextureSize;
+        Recti                     RenderViewport;
+	} eachEye[2];
+
+    // GL context and utility variables.
+    RenderParams        RParams;    
+
+	// Helpers
+    void initBuffersAndShaders();
+    void initShaders();
+    void initFullscreenQuad();
+    void destroy();
+	
+    void setViewport(const Recti& vp);
+
+    void renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture);
+
+    void renderPrimitives(const ShaderFill* fill, Buffer* vertices, Buffer* indices,
+                          int offset, int count,
+						  PrimitiveType rprim, GLuint* vao, bool isDistortionMesh);
+
+	void createDrawQuad();
+    void renderLatencyQuad(unsigned char* latencyTesterDrawColor);
+    void renderLatencyPixel(unsigned char* latencyTesterPixelColor);
+	
+    void renderEndFrame();
+
+    Ptr<Texture>        pEyeTextures[2];
+
+	Ptr<Buffer>         DistortionMeshVBs[2];    // one per-eye
+	Ptr<Buffer>         DistortionMeshIBs[2];    // one per-eye
+	GLuint              DistortionMeshVAOs[2];   // one per-eye
+
+	Ptr<ShaderSet>      DistortionShader;
+
+    struct StandardUniformData
+    {
+        Matrix4f  Proj;
+        Matrix4f  View;
+    }                   StdUniforms;
+	
+	GLuint              LatencyVAO;
+    Ptr<Buffer>         LatencyTesterQuadVB;
+    Ptr<ShaderSet>      SimpleQuadShader;
+    Ptr<ShaderSet>      SimpleQuadGammaShader;
+
+    Ptr<Texture>             CurRenderTarget;
+    Array<Ptr<Texture> >     DepthBuffers;
+    GLuint                   CurrentFbo;
+
+	GLint SavedViewport[4];
+	GLfloat SavedClearColor[4];
+	GLint SavedDepthTest;
+	GLint SavedCullFace;
+	GLint SavedProgram;
+	GLint SavedActiveTexture;
+	GLint SavedBoundTexture;
+	GLint SavedVertexArray;
+    GLint SavedBoundFrameBuffer;
+};
+
+}}} // OVR::CAPI::GL
+
+#endif // OVR_CAPI_GL_DistortionRenderer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionShaders.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionShaders.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,381 @@
+/************************************************************************************
+ 
+ Filename    :   CAPI_GL_Shaders.h
+ Content     :   Distortion shader header for GL
+ Created     :   November 11, 2013
+ Authors     :   David Borel, Volga Aksoy
+ 
+ Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+ 
+ Use of this software is subject to the terms of the Oculus Inc license
+ agreement provided at the time of installation or download, or which
+ otherwise accompanies this software in either electronic or hard copy form.
+ 
+ ************************************************************************************/
+
+
+#ifndef OVR_CAPI_GL_Shaders_h
+#define OVR_CAPI_GL_Shaders_h
+
+
+#include "CAPI_GL_Util.h"
+
+namespace OVR { namespace CAPI { namespace GL {
+    
+    static const char glsl2Prefix[] =
+    "#version 110\n"
+    "#extension GL_ARB_shader_texture_lod : enable\n"
+    "#define _FRAGCOLOR_DECLARATION\n"
+    "#define _VS_IN attribute\n"
+    "#define _VS_OUT varying\n"
+    "#define _FS_IN varying\n"
+    "#define _TEXTURELOD texture2DLod\n"
+    "#define _FRAGCOLOR gl_FragColor\n";
+    
+    static const char glsl3Prefix[] =
+    "#version 150\n"
+    "#define _FRAGCOLOR_DECLARATION out vec4 FragColor;\n"
+    "#define _VS_IN in\n"
+    "#define _VS_OUT out\n"
+    "#define _FS_IN in\n"
+    "#define _TEXTURELOD textureLod\n"
+    "#define _FRAGCOLOR FragColor\n";
+    
+    static const char SimpleQuad_vs[] =
+    "uniform vec2 PositionOffset;\n"
+    "uniform vec2 Scale;\n"
+    
+    "_VS_IN vec3 Position;\n"
+    
+	"void main()\n"
+	"{\n"
+	"	gl_Position = vec4(Position.xy * Scale + PositionOffset, 0.5, 1.0);\n"
+	"}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuad_vs_refl[] =
+    {
+        { "PositionOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "Scale",          OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char SimpleQuad_fs[] =
+    "uniform vec4 Color;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+	"void main()\n"
+	"{\n"
+	"    _FRAGCOLOR = Color;\n"
+	"}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuad_fs_refl[] =
+    {
+        { "Color", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    static const char SimpleQuadGamma_fs[] =
+        "uniform vec4 Color;\n"
+
+        "_FRAGCOLOR_DECLARATION\n"
+
+        "void main()\n"
+        "{\n"
+        "    _FRAGCOLOR.rgb = pow(Color.rgb, vec3(2.2));\n"
+        "    _FRAGCOLOR.a = Color.a;\n"
+        "}\n";
+
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuadGamma_fs_refl[] =
+    {
+        { "Color", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    // This must be prefixed with glsl2Prefix or glsl3Prefix before being compiled.
+    static const char SimpleTexturedQuad_vs[] =
+        "uniform vec2 PositionOffset;\n"
+        "uniform vec2 Scale;\n"
+
+        "_VS_IN vec3 Position;\n"
+        "_VS_IN vec4 Color;\n"
+        "_VS_IN vec2 TexCoord;\n"
+  
+        "_VS_OUT vec4 oColor;\n"
+        "_VS_OUT vec2 oTexCoord;\n"
+
+        "void main()\n"
+        "{\n"
+	    "	gl_Position = vec4(Position.xy * Scale + PositionOffset, 0.5, 1.0);\n"
+        "   oColor = Color;\n"
+        "   oTexCoord = TexCoord;\n"
+        "}\n";
+
+    // The following declaration is copied from the generated D3D SimpleTexturedQuad_vs_refl.h file, with D3D_NS renamed to GL.
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleTexturedQuad_vs_refl[] =
+    {
+	    { "PositionOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	    { "Scale",          OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+
+
+    // This must be prefixed with glsl2Prefix or glsl3Prefix before being compiled.
+    static const char SimpleTexturedQuad_ps[] =
+        "uniform sampler2D Texture0;\n"
+    
+        "_FS_IN vec4 oColor;\n"
+        "_FS_IN vec2 oTexCoord;\n"
+    
+        "_FRAGCOLOR_DECLARATION\n"
+
+        "void main()\n"
+        "{\n"
+        "   _FRAGCOLOR = oColor * texture2D(Texture0, oTexCoord);\n"
+        "}\n";
+
+    // The following is copied from the generated D3D SimpleTexturedQuad_ps_refl.h file, with D3D_NS renamed to GL.
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleTexturedQuad_ps_refl[] =
+    {
+	    { "Color", 	OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    
+    static const char Distortion_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.5;\n"
+    "   gl_Position.w = 1.0;\n"
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   oTexCoord0 = TexCoord0 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oColor = Color;\n"              // Used for vignette fade.
+    "}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform Distortion_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char Distortion_fs[] =
+    "uniform sampler2D Texture0;\n"
+    
+    "_FS_IN vec4 oColor;\n"
+    "_FS_IN vec2 oTexCoord0;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+    "void main()\n"
+    "{\n"
+    "   _FRAGCOLOR = _TEXTURELOD(Texture0, oTexCoord0, 0.0);\n"
+    "   _FRAGCOLOR.a = 1.0;\n"
+    "}\n";
+    
+    
+    static const char DistortionTimewarp_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    "uniform mat4 EyeRotationStart;\n"
+    "uniform mat4 EyeRotationEnd;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.0;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.
+    "   vec3 TanEyeAngle = vec3 ( TexCoord0.x, TexCoord0.y, 1.0 );\n"
+    
+    // Accurate time warp lerp vs. faster
+#if 1
+    // Apply the two 3x3 timewarp rotations to these vectors.
+	"   vec3 TransformedStart = (EyeRotationStart * vec4(TanEyeAngle, 0)).xyz;\n"
+	"   vec3 TransformedEnd   = (EyeRotationEnd * vec4(TanEyeAngle, 0)).xyz;\n"
+    // And blend between them.
+    "   vec3 Transformed = mix ( TransformedStart, TransformedEnd, Color.a );\n"
+#else
+    "   mat4 EyeRotation = mix ( EyeRotationStart, EyeRotationEnd, Color.a );\n"
+    "   vec3 Transformed   = EyeRotation * TanEyeAngle;\n"
+#endif
+    
+    // Project them back onto the Z=1 plane of the rendered images.
+    "   float RecipZ = 1.0 / Transformed.z;\n"
+    "   vec2 Flattened = vec2 ( Transformed.x * RecipZ, Transformed.y * RecipZ );\n"
+    
+    // These are now still in TanEyeAngle space.
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   vec2 SrcCoord = Flattened * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord0 = SrcCoord;\n"
+    "   oColor = vec4(Color.r, Color.r, Color.r, Color.r);\n"              // Used for vignette fade.
+    "}\n";
+
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionTimewarp_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char DistortionChroma_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    "_VS_IN vec2 TexCoord1;\n"
+    "_VS_IN vec2 TexCoord2;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    "_VS_OUT vec2 oTexCoord1;\n"
+    "_VS_OUT vec2 oTexCoord2;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.5;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   oTexCoord0 = TexCoord0 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord1 = TexCoord1 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord2 = TexCoord2 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    
+    "   oColor = Color;\n" // Used for vignette fade.
+    "}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionChroma_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char DistortionChroma_fs[] =
+    "uniform sampler2D Texture0;\n"
+    
+    "_FS_IN vec4 oColor;\n"
+    "_FS_IN vec2 oTexCoord0;\n"
+    "_FS_IN vec2 oTexCoord1;\n"
+    "_FS_IN vec2 oTexCoord2;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+    "void main()\n"
+    "{\n"
+    "   float ResultR = _TEXTURELOD(Texture0, oTexCoord0, 0.0).r;\n"
+    "   float ResultG = _TEXTURELOD(Texture0, oTexCoord1, 0.0).g;\n"
+    "   float ResultB = _TEXTURELOD(Texture0, oTexCoord2, 0.0).b;\n"
+    
+    "   _FRAGCOLOR = vec4(ResultR * oColor.r, ResultG * oColor.g, ResultB * oColor.b, 1.0);\n"
+    "}\n";
+
+    
+    static const char DistortionTimewarpChroma_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    "uniform mat4 EyeRotationStart;\n"
+    "uniform mat4 EyeRotationEnd;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    "_VS_IN vec2 TexCoord1;\n"
+    "_VS_IN vec2 TexCoord2;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    "_VS_OUT vec2 oTexCoord1;\n"
+    "_VS_OUT vec2 oTexCoord2;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.0;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.
+    "   vec3 TanEyeAngleR = vec3 ( TexCoord0.x, TexCoord0.y, 1.0 );\n"
+    "   vec3 TanEyeAngleG = vec3 ( TexCoord1.x, TexCoord1.y, 1.0 );\n"
+    "   vec3 TanEyeAngleB = vec3 ( TexCoord2.x, TexCoord2.y, 1.0 );\n"
+    
+    // Accurate time warp lerp vs. faster
+#if 1
+    // Apply the two 3x3 timewarp rotations to these vectors.
+	"   vec3 TransformedRStart = (EyeRotationStart * vec4(TanEyeAngleR, 0)).xyz;\n"
+	"   vec3 TransformedGStart = (EyeRotationStart * vec4(TanEyeAngleG, 0)).xyz;\n"
+	"   vec3 TransformedBStart = (EyeRotationStart * vec4(TanEyeAngleB, 0)).xyz;\n"
+	"   vec3 TransformedREnd   = (EyeRotationEnd * vec4(TanEyeAngleR, 0)).xyz;\n"
+	"   vec3 TransformedGEnd   = (EyeRotationEnd * vec4(TanEyeAngleG, 0)).xyz;\n"
+	"   vec3 TransformedBEnd   = (EyeRotationEnd * vec4(TanEyeAngleB, 0)).xyz;\n"
+    
+    // And blend between them.
+    "   vec3 TransformedR = mix ( TransformedRStart, TransformedREnd, Color.a );\n"
+    "   vec3 TransformedG = mix ( TransformedGStart, TransformedGEnd, Color.a );\n"
+    "   vec3 TransformedB = mix ( TransformedBStart, TransformedBEnd, Color.a );\n"
+#else
+    "   mat3 EyeRotation;\n"
+    "   EyeRotation[0] = mix ( EyeRotationStart[0], EyeRotationEnd[0], Color.a ).xyz;\n"
+    "   EyeRotation[1] = mix ( EyeRotationStart[1], EyeRotationEnd[1], Color.a ).xyz;\n"
+    "   EyeRotation[2] = mix ( EyeRotationStart[2], EyeRotationEnd[2], Color.a ).xyz;\n"
+    "   vec3 TransformedR   = EyeRotation * TanEyeAngleR;\n"
+    "   vec3 TransformedG   = EyeRotation * TanEyeAngleG;\n"
+    "   vec3 TransformedB   = EyeRotation * TanEyeAngleB;\n"
+#endif
+    
+    // Project them back onto the Z=1 plane of the rendered images.
+    "   float RecipZR = 1.0 / TransformedR.z;\n"
+    "   float RecipZG = 1.0 / TransformedG.z;\n"
+    "   float RecipZB = 1.0 / TransformedB.z;\n"
+    "   vec2 FlattenedR = vec2 ( TransformedR.x * RecipZR, TransformedR.y * RecipZR );\n"
+    "   vec2 FlattenedG = vec2 ( TransformedG.x * RecipZG, TransformedG.y * RecipZG );\n"
+    "   vec2 FlattenedB = vec2 ( TransformedB.x * RecipZB, TransformedB.y * RecipZB );\n"
+    
+    // These are now still in TanEyeAngle space.
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   vec2 SrcCoordR = FlattenedR * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   vec2 SrcCoordG = FlattenedG * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   vec2 SrcCoordB = FlattenedB * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    
+    "   oTexCoord0 = SrcCoordR;\n"
+    "   oTexCoord1 = SrcCoordG;\n"
+    "   oTexCoord2 = SrcCoordB;\n"
+    
+    "   oColor = vec4(Color.r, Color.r, Color.r, Color.r);\n"              // Used for vignette fade.
+    "}\n";
+    
+
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionTimewarpChroma_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+        { "EyeRotationStart",    OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+        { "EyeRotationEnd",      OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+    };
+    
+}}} // OVR::CAPI::GL
+
+#endif // OVR_CAPI_GL_Shaders_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,859 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_HSWDisplay.cpp
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+
+#include "CAPI_GL_HSWDisplay.h"
+#include "CAPI_GL_DistortionShaders.h"
+#include "../../OVR_CAPI_GL.h"
+#include "../../Kernel/OVR_File.h"
+#include "../../Kernel/OVR_Math.h"
+#include "../../Kernel/OVR_Allocator.h"
+#include "../../Kernel/OVR_Color.h"
+
+
+OVR_DISABLE_MSVC_WARNING(4996) // "This function or variable may be unsafe..."
+
+
+namespace OVR { namespace CAPI { 
+
+
+// Loads the TGA data from the File as an array of width * height 32 bit Texture_RGBA values.
+// Returned pointer must be freed with OVR_FREE.
+uint8_t* LoadTextureTgaData(OVR::File* f, uint8_t alpha, int& width, int& height)
+{
+    // See http://www.fileformat.info/format/tga/egff.htm for format details.
+    // TGA files are stored with little-endian data.
+    uint8_t* pRGBA  = NULL;
+
+    f->SeekToBegin();
+    
+    const int desclen = f->ReadUByte();
+    const int palette = f->ReadUByte();
+    OVR_UNUSED(palette);
+    const int imgtype = f->ReadUByte();
+    f->ReadUInt16(); // Skip bytes
+    int palCount = f->ReadUInt16();
+    int palSize = f->ReadUByte();
+    f->ReadUInt16();
+    f->ReadUInt16();
+    width = f->ReadUInt16();
+    height = f->ReadUInt16();
+    int bpp = f->ReadUByte();
+    f->ReadUByte();
+
+    const int ImgTypeBGRAUncompressed = 2;
+    const int ImgTypeBGRARLECompressed = 10;
+
+    OVR_ASSERT(((imgtype == ImgTypeBGRAUncompressed) || (imgtype == ImgTypeBGRARLECompressed)) && ((bpp == 24) || (bpp == 32)));
+
+    // imgType 2 is uncompressed true-color image.
+    // imgType 10 is run-length encoded true-color image.
+    if(((imgtype == ImgTypeBGRAUncompressed) || (imgtype == ImgTypeBGRARLECompressed)) && ((bpp == 24) || (bpp == 32)))
+    {
+        int imgsize = width * height * 4;
+        pRGBA = (uint8_t*) OVR_ALLOC(imgsize);
+        f->Skip(desclen);
+        f->Skip(palCount * (palSize + 7) >> 3);
+        int strideBytes = width * 4; // This is the number of bytes between successive rows.
+
+        unsigned char buf[4] = { 0, 0, 0, alpha }; // If bpp is 24 then this alpha will be unmodified below.
+
+        switch (imgtype)
+        {
+        case ImgTypeBGRAUncompressed:
+            switch (bpp)
+            {
+            case 24:
+            case 32:
+                for (int y = 0; y < height; y++)
+                {
+                    for (int x = 0; x < width; x++)
+                    {
+                        f->Read(buf, bpp / 8); // Data is stored as B, G, R
+                        pRGBA[y*strideBytes + x*4 + 0] = buf[2];
+                        pRGBA[y*strideBytes + x*4 + 1] = buf[1];
+                        pRGBA[y*strideBytes + x*4 + 2] = buf[0];
+                        pRGBA[y*strideBytes + x*4 + 3] = buf[3];
+                    }
+                }
+                break;
+            }
+            break;
+
+        case ImgTypeBGRARLECompressed:
+            switch (bpp)
+            {
+            case 24:
+            case 32:
+                for (int y = 0; y < height; y++) // RLE spans don't cross successive rows.
+                {
+                    int x = 0;
+
+                    while(x < width)
+                    {
+                        uint8_t rleByte;
+                        f->Read(&rleByte, 1);
+
+                        if(rleByte & 0x80) // If the high byte is set then what follows are RLE bytes.
+                        {
+                            size_t rleCount = ((rleByte & 0x7f) + 1);
+                            f->Read(buf, bpp / 8); // Data is stored as B, G, R, A
+
+                            for (; rleCount; --rleCount, ++x)
+                            {
+                                pRGBA[y*strideBytes + x*4 + 0] = buf[2];
+                                pRGBA[y*strideBytes + x*4 + 1] = buf[1];
+                                pRGBA[y*strideBytes + x*4 + 2] = buf[0];
+                                pRGBA[y*strideBytes + x*4 + 3] = buf[3];
+                            }   
+                        }
+                        else // Else what follows are regular bytes of a count indicated by rleByte
+                        {
+                            for (size_t rleCount = (rleByte + 1); rleCount; --rleCount, ++x)
+                            {
+                                f->Read(buf, bpp / 8); // Data is stored as B, G, R, A
+                                pRGBA[y*strideBytes + x*4 + 0] = buf[2];
+                                pRGBA[y*strideBytes + x*4 + 1] = buf[1];
+                                pRGBA[y*strideBytes + x*4 + 2] = buf[0];
+                                pRGBA[y*strideBytes + x*4 + 3] = buf[3];
+                            }
+                        }
+                    }
+                }
+                break;
+            }
+            break;
+        }
+    }
+
+    return pRGBA;
+} // LoadTextureTgaData
+
+
+
+namespace GL {
+
+
+// To do: This needs to be promoted to a central version, possibly in CAPI_HSWDisplay.h
+struct HASWVertex
+{
+    Vector3f  Pos;
+    Color     C;
+    float     U, V;    
+
+    HASWVertex(const Vector3f& p, const Color& c = Color(64,0,0,255), float u = 0, float v = 0)
+        : Pos(p), C(c), U(u), V(v)
+    {}
+
+    HASWVertex(float x, float y, float z, const Color& c = Color(64,0,0,255), float u = 0, float v = 0) 
+        : Pos(x,y,z), C(c), U(u), V(v)
+    {}
+
+    bool operator==(const HASWVertex& b) const
+    {
+        return (Pos == b.Pos) && (C == b.C) && (U == b.U) && (V == b.V);
+    }
+};
+
+
+
+// This is a temporary function implementation, and it functionality needs to be implemented in a more generic way.
+Texture* LoadTextureTga(RenderParams& rParams, int samplerMode, OVR::File* f, uint8_t alpha)
+{
+    OVR::CAPI::GL::Texture* pTexture = NULL;
+
+    int width, height;
+    const uint8_t* pRGBA = LoadTextureTgaData(f, alpha, width, height);
+
+    if (pRGBA)
+    {
+        pTexture = new OVR::CAPI::GL::Texture(&rParams, width, height);
+
+        // SetSampleMode forces the use of mipmaps through GL_LINEAR_MIPMAP_LINEAR.
+        pTexture->SetSampleMode(samplerMode); // Calls glBindTexture internally.
+
+        // We are intentionally not using mipmaps. We need to use this because Texture::SetSampleMode unilaterally uses GL_LINEAR_MIPMAP_LINEAR.
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+        OVR_ASSERT(glGetError() == 0);
+
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pRGBA);
+        OVR_ASSERT(glGetError() == 0);
+
+        // With OpenGL 4.2+ we can use this instead of glTexImage2D:
+        // glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, width, height);
+        // glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pRGBA);
+
+        OVR_FREE(const_cast<uint8_t*>(pRGBA));
+    }
+
+    return pTexture;
+}
+
+
+// Loads a texture from a memory image of a TGA file.
+Texture* LoadTextureTga(RenderParams& rParams, int samplerMode, const uint8_t* pData, int dataSize, uint8_t alpha)
+{
+    MemoryFile memoryFile("", pData, dataSize);
+
+    return LoadTextureTga(rParams, samplerMode, &memoryFile, alpha);
+}
+
+
+
+
+// The texture below may conceivably be shared between HSWDisplay instances. However,  
+// beware that sharing may not be possible if two HMDs are using different locales  
+// simultaneously. As of this writing it's not clear if that can occur in practice.
+
+HSWDisplay::HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState)
+  : OVR::CAPI::HSWDisplay(api, hmd, renderState)
+  , RenderParams()
+  , GLMajorVersion(0)
+  , GLMinorVersion(0)
+  , SupportsVao(false)
+  , FrameBuffer(0)
+  , pTexture()
+  , pShaderSet()
+  , pVertexShader()
+  , pFragmentShader()
+  , pVB()
+  , VAO(0)
+  , VAOInitialized(false)
+  , OrthoProjection()
+{
+}
+
+
+bool HSWDisplay::Initialize(const ovrRenderAPIConfig* apiConfig)
+{
+    const ovrGLConfig* config = (const ovrGLConfig*)apiConfig;
+
+    if(config)
+    {
+        // The following is essentially copied from CAPI_GL_DistortionRender.cpp's 
+        // Initialize function. To do: Merge this to a central location.
+        RenderParams.Multisample = config->OGL.Header.Multisample;
+        RenderParams.RTSize      = config->OGL.Header.RTSize;
+
+        #if defined(OVR_OS_WIN32)
+            RenderParams.Window = (config->OGL.Window) ? config->OGL.Window : GetActiveWindow();
+            RenderParams.DC     = config->OGL.DC;
+        #elif defined(OVR_OS_LINUX)
+            if (config->OGL.Disp)
+                RenderParams.Disp = config->OGL.Disp;
+            if (!RenderParams.Disp)
+                RenderParams.Disp = XOpenDisplay(NULL);
+            if (!RenderParams.Disp)
+            {
+                OVR_DEBUG_LOG(("XOpenDisplay failed."));
+                return false;
+            }
+
+            if (config->OGL.Win)
+                RenderParams.Win= config->OGL.Win;
+            if (!RenderParams.Win)
+            {
+                int unused;
+                RenderParams.Win = glXGetCurrentDrawable();
+            }
+            if (!RenderParams.Win)
+            {
+                OVR_DEBUG_LOG(("XGetInputFocus failed."));
+                return false;
+            }
+        #endif
+    }
+    else
+    {
+        UnloadGraphics();
+    }
+
+    return true;
+}
+
+
+void HSWDisplay::Shutdown()
+{
+    UnloadGraphics();
+}
+
+
+void HSWDisplay::DisplayInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay GL] DisplayInternal()"));
+    // We may want to call LoadGraphics here instead of within Render.
+}
+
+
+void HSWDisplay::DismissInternal()
+{
+    HSWDISPLAY_LOG(("[HSWDisplay GL] DismissInternal()"));
+    UnloadGraphics();
+}
+
+
+void HSWDisplay::UnloadGraphics()
+{
+    // RenderParams: No need to clear.
+    if(FrameBuffer != 0)
+    {
+        glDeleteFramebuffers(1, &FrameBuffer);
+        FrameBuffer = 0;
+    }
+    pTexture.Clear();
+    pShaderSet.Clear();
+    pVertexShader.Clear();
+    pFragmentShader.Clear();
+    pVB.Clear();
+    if(VAO)
+    {
+        #ifdef OVR_OS_MAC
+    		if(GLMajorVersion >= 3)
+			{
+				glDeleteVertexArrays(1, &VAO);
+        	}
+			else
+			{
+        	    glDeleteVertexArraysAPPLE(1, &VAO);
+			}
+		#else
+            glDeleteVertexArrays(1, &VAO);
+        #endif
+        VAO = 0;
+        VAOInitialized = false;
+    }
+    // OrthoProjection: No need to clear.
+}
+
+
+void HSWDisplay::LoadGraphics()
+{
+    const char* glVersionString = (const char*)glGetString(GL_VERSION);
+
+    OVR_ASSERT(glVersionString);
+    if (glVersionString)
+    {
+        int fieldCount = sscanf(glVersionString, isdigit(*glVersionString) ? "%d.%d" : "%*[^0-9]%d.%d", &GLMajorVersion, &GLMinorVersion); // Skip all leading non-digits before reading %d. Example glVersionStrings: "1.5 ATI-1.4.18", "OpenGL ES-CM 3.2"
+        
+        if(fieldCount != 2)
+        {
+            static_assert(sizeof(GLMajorVersion) == sizeof(GLint), "type mis-match");
+            glGetIntegerv(GL_MAJOR_VERSION, &GLMajorVersion);
+        }
+    }
+
+    // SupportsVao
+    if(GLMajorVersion >= 3)
+        SupportsVao = true;
+    else
+    {
+        const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
+        SupportsVao = (strstr(extensions, "GL_ARB_vertex_array_object") || strstr(extensions, "GL_APPLE_vertex_array_object"));
+    }
+
+    if (FrameBuffer == 0)
+        glGenFramebuffers(1, &FrameBuffer);
+
+    if (!pTexture) // To do: Add support for .dds files, which would be significantly smaller than the size of the tga.
+    {
+        size_t textureSize;
+        const uint8_t* TextureData = GetDefaultTexture(textureSize);
+        pTexture = *LoadTextureTga(RenderParams, Sample_Linear | Sample_Clamp, TextureData, (int)textureSize, 255);
+    }
+
+    if(!pShaderSet)
+        pShaderSet = *new ShaderSet();
+
+    if(!pVertexShader)
+    {
+        OVR::String strShader((GLMajorVersion >= 3) ? glsl3Prefix : glsl2Prefix);
+        strShader += SimpleTexturedQuad_vs;
+
+        pVertexShader = *new VertexShader(&RenderParams, const_cast<char*>(strShader.ToCStr()), strShader.GetLength(), SimpleTexturedQuad_vs_refl, OVR_ARRAY_COUNT(SimpleTexturedQuad_vs_refl));
+        pShaderSet->SetShader(pVertexShader);
+    }
+
+    if(!pFragmentShader)
+    {
+        OVR::String strShader((GLMajorVersion >= 3) ? glsl3Prefix : glsl2Prefix);
+        strShader += SimpleTexturedQuad_ps;
+
+        pFragmentShader = *new FragmentShader(&RenderParams, const_cast<char*>(strShader.ToCStr()), strShader.GetLength(), SimpleTexturedQuad_ps_refl, OVR_ARRAY_COUNT(SimpleTexturedQuad_ps_refl));
+        pShaderSet->SetShader(pFragmentShader);
+    }
+
+    if(!pVB)
+    {
+        pVB = *new Buffer(&RenderParams);
+
+        pVB->Data(Buffer_Vertex, NULL, 4 * sizeof(HASWVertex));
+        HASWVertex* pVertices = (HASWVertex*)pVB->Map(0, 4 * sizeof(HASWVertex), Map_Discard);
+        OVR_ASSERT(pVertices);
+
+        if(pVertices)
+        {
+            const bool  flip   = ((RenderState.DistortionCaps & ovrDistortionCap_FlipInput) != 0);
+            const float left   = -1.0f; // We currently draw this in normalized device coordinates with an stereo translation
+            const float top    = -1.1f; // applied as a vertex shader uniform. In the future when we have a more formal graphics
+            const float right  =  1.0f; // API abstraction we may move this draw to an overlay layer or to a more formal 
+            const float bottom =  0.9f; // model/mesh scheme with a perspective projection.
+
+            pVertices[0] = HASWVertex(left,  top,    0.f, Color(255, 255, 255, 255), 0.f, flip ? 1.f : 0.f);
+            pVertices[1] = HASWVertex(left,  bottom, 0.f, Color(255, 255, 255, 255), 0.f, flip ? 0.f : 1.f);
+            pVertices[2] = HASWVertex(right, top,    0.f, Color(255, 255, 255, 255), 1.f, flip ? 1.f : 0.f); 
+            pVertices[3] = HASWVertex(right, bottom, 0.f, Color(255, 255, 255, 255), 1.f, flip ? 0.f : 1.f);
+
+            pVB->Unmap(pVertices);
+        }
+    }
+
+    // We don't generate the vertex arrays here
+    if(!VAO && SupportsVao)
+    {
+        OVR_ASSERT(!VAOInitialized);
+        #ifdef OVR_OS_MAC
+    		if(GLMajorVersion >= 3)
+			{
+				glGenVertexArrays(1, &VAO);
+        	}
+			else
+			{
+	            glGenVertexArraysAPPLE(1, &VAO);
+			}
+        #else
+            glGenVertexArrays(1, &VAO);
+        #endif
+    }
+}
+
+
+void HSWDisplay::RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture)
+{
+    if(RenderEnabled && eyeTexture)
+    {
+        // Hack - Clear previous errors.
+        glGetError();
+        
+        // We need to render to the eyeTexture with the texture viewport.
+        // Setup rendering to the texture.
+        ovrGLTexture* eyeTextureGL = const_cast<ovrGLTexture*>(reinterpret_cast<const ovrGLTexture*>(eyeTexture));
+        OVR_ASSERT(eyeTextureGL->Texture.Header.API == ovrRenderAPI_OpenGL);
+
+        const GLuint kVertexAttribCount = 3;
+        const GLuint kSavedVertexAttribCount = 8;
+
+        // Save state
+        // To do: Converge this with the state setting/restoring functionality present in the distortion renderer.
+        // Note that the glGet functions below will block until command buffer has completed.
+        // glPushAttrib is deprecated, so we use glGet* to save/restore fixed-function settings.
+        // https://www.opengl.org/sdk/docs/man/docbook4/xhtml/glGet.xml
+        //
+        GLint RenderModeSaved;
+        glGetIntegerv(GL_RENDER_MODE, &RenderModeSaved);
+        OVR_ASSERT(glGetError() == 0);
+        OVR_ASSERT(RenderModeSaved == GL_RENDER); // Make sure it's not GL_SELECT or GL_FEEDBACK.
+
+        GLint FrameBufferBindingSaved; // OpenGL renamed GL_FRAMEBUFFER_BINDING to GL_DRAW_FRAMEBUFFER_BINDING and adds GL_READ_FRAMEBUFFER_BINDING.
+        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &FrameBufferBindingSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint TextureBinding2DSaved;
+        glGetIntegerv(GL_TEXTURE_BINDING_2D, &TextureBinding2DSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint ViewportSaved[4];
+        glGetIntegerv(GL_VIEWPORT, ViewportSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint PolygonModeSaved[2]; // Will be two (e.g. GL_FILL) values, one for the front mode and one for the mode.
+        glGetIntegerv(GL_POLYGON_MODE, PolygonModeSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLdouble DepthRangeSaved[2];
+        #if defined(OVR_OS_MAC)
+            // Using glDepthRange as a conditional will always evaluate to true on Mac.
+            glGetDoublev(GL_DEPTH_RANGE, DepthRangeSaved);
+        #else
+            GLfloat DepthRangefSaved[2];
+            if(glDepthRange) // If we can use the double version (glDepthRangef may not be available)...
+                glGetDoublev(GL_DEPTH_RANGE, DepthRangeSaved);
+            else
+                glGetFloatv(GL_DEPTH_RANGE, DepthRangefSaved);
+        #endif
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint DepthWriteMaskSaved;
+        glGetIntegerv(GL_DEPTH_WRITEMASK, &DepthWriteMaskSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint DepthTestSaved;
+        glGetIntegerv(GL_DEPTH_TEST, &DepthTestSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        // No need to save/restore depth offset because we are neither testing nor writing depth.
+
+        GLint CullFaceSaved;
+        glGetIntegerv(GL_CULL_FACE, &CullFaceSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint FrontFaceSaved;
+        glGetIntegerv(GL_FRONT_FACE, &FrontFaceSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint BlendSaved;
+        glGetIntegerv(GL_BLEND, &BlendSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint BlendSrcRGBSaved, BlendSrcAlphaSaved, BlendDstRGBSaved, BlendDstAlphaSaved;
+        glGetIntegerv(GL_BLEND_SRC_RGB,   &BlendSrcRGBSaved);
+        glGetIntegerv(GL_BLEND_SRC_ALPHA, &BlendSrcAlphaSaved);
+        glGetIntegerv(GL_BLEND_DST_RGB,   &BlendDstRGBSaved);
+        glGetIntegerv(GL_BLEND_DST_ALPHA, &BlendDstAlphaSaved);
+
+        GLint DitherSaved;
+        glGetIntegerv(GL_DITHER, &DitherSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint RasterizerDiscardSaved;
+        glGetIntegerv(GL_RASTERIZER_DISCARD, &RasterizerDiscardSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint ScissorTestSaved;
+        glGetIntegerv(GL_SCISSOR_TEST, &ScissorTestSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint SampleMaskSaved = 0;
+        if(((GLMajorVersion * 100) + GLMinorVersion) >= 302) // OpenGL 3.2 or later
+        {
+            glGetIntegerv(GL_SAMPLE_MASK, &SampleMaskSaved);
+            OVR_ASSERT(glGetError() == 0);
+        }
+
+        GLint ColorWriteMaskSaved[4];
+        glGetIntegerv(GL_COLOR_WRITEMASK, ColorWriteMaskSaved);
+
+        GLint ArrayBufferBindingSaved;
+        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &ArrayBufferBindingSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint ProgramSaved;
+        glGetIntegerv(GL_CURRENT_PROGRAM, &ProgramSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint ActiveTextureSaved;
+        glGetIntegerv(GL_ACTIVE_TEXTURE, &ActiveTextureSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        GLint TextureBindingSaved;
+        glGetIntegerv(GL_TEXTURE_BINDING_2D, &TextureBindingSaved);
+        OVR_ASSERT(glGetError() == 0);
+
+        // https://www.opengl.org/sdk/docs/man/docbook4/xhtml/glVertexAttribPointer.xml
+        GLint   VertexAttribEnabledSaved[kSavedVertexAttribCount];
+        GLint   VertexAttribSizeSaved[kSavedVertexAttribCount];
+        GLint   VertexAttribTypeSaved[kSavedVertexAttribCount];
+        GLint   VertexAttribNormalizedSaved[kSavedVertexAttribCount];
+        GLint   VertexAttribStrideSaved[kSavedVertexAttribCount];
+        GLvoid* VertexAttribPointerSaved[kSavedVertexAttribCount];
+        for(GLuint i = 0; i < kSavedVertexAttribCount; i++)
+        {
+            glGetVertexAttribiv(i, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &VertexAttribEnabledSaved[i]);
+
+            glGetVertexAttribiv(i,       GL_VERTEX_ATTRIB_ARRAY_SIZE,       &VertexAttribSizeSaved[i]);
+            glGetVertexAttribiv(i,       GL_VERTEX_ATTRIB_ARRAY_TYPE,       &VertexAttribTypeSaved[i]);
+            glGetVertexAttribiv(i,       GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, &VertexAttribNormalizedSaved[i]);
+            glGetVertexAttribiv(i,       GL_VERTEX_ATTRIB_ARRAY_STRIDE,     &VertexAttribStrideSaved[i]);
+            glGetVertexAttribPointerv(i, GL_VERTEX_ATTRIB_ARRAY_POINTER,    &VertexAttribPointerSaved[i]); 
+
+            OVR_ASSERT(glGetError() == 0);
+        }
+
+        GLint VertexArrayBindingSaved = 0;
+        if (SupportsVao)
+            glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &VertexArrayBindingSaved);
+
+        //
+        // End of save state
+
+
+        // Load the graphics if not loaded already.
+        if (!pTexture)
+            LoadGraphics();
+
+        // Calculate ortho projection.
+        GetOrthoProjection(RenderState, OrthoProjection);
+
+        // Set the rendering to be to the eye texture.
+        glBindFramebuffer(GL_FRAMEBUFFER, FrameBuffer);
+        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, eyeTextureGL->OGL.TexId, 0);
+        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, 0); // We aren't using depth, as we currently want this to overwrite everything.
+        // GLenum DrawBuffers[1] = { GL_COLOR_ATTACHMENT0 };
+        // glDrawBuffers(OVR_ARRAY_COUNT(DrawBuffers), DrawBuffers);
+        GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+        OVR_ASSERT(status == GL_FRAMEBUFFER_COMPLETE); OVR_UNUSED(status);
+        OVR_ASSERT(glGetError() == 0);
+
+        // Set up the viewport
+        const GLint   x = (GLint)eyeTextureGL->Texture.Header.RenderViewport.Pos.x;
+        const GLint   y = (GLint)eyeTextureGL->Texture.Header.RenderViewport.Pos.y; // Note that GL uses bottom-up coordinates.
+        const GLsizei w = (GLsizei)eyeTextureGL->Texture.Header.RenderViewport.Size.w;
+        const GLsizei h = (GLsizei)eyeTextureGL->Texture.Header.RenderViewport.Size.h;
+        glViewport(x, y, w, h);
+        OVR_ASSERT(glGetError() == 0);
+
+        // Set fixed-function render states
+        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+        OVR_ASSERT(glGetError() == 0);
+        #if defined(OVR_OS_MAC) // On Mac we are directly using OpenGL functions instead of function pointers.
+            glDepthRange(0.0,  1.0);
+        #else
+            if(glDepthRange) // If we can use the double version (glDepthRangef may not be available)...
+                glDepthRange(0.0,  1.0);
+            else
+                glDepthRangef(0.f,  1.f);
+        #endif
+        glDepthMask(GL_FALSE);
+        glDisable(GL_DEPTH_TEST); // Disabling depth test should also have the effect of glDepthMask(GL_FALSE).
+        glDisable(GL_CULL_FACE);
+        glFrontFace(GL_CW);
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        glDisable(GL_DITHER);
+        glDisable(GL_RASTERIZER_DISCARD);
+        glDisable(GL_SCISSOR_TEST);
+        if(((GLMajorVersion * 100) + GLMinorVersion) >= 302) // OpenGL 3.2 or later
+            glDisable(GL_SAMPLE_MASK);
+        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE);
+        OVR_ASSERT(glGetError() == 0);
+
+        // Enable the buffer and shaders we use.
+        ShaderFill fill(pShaderSet);
+        if(pTexture)
+        {
+            fill.SetTexture(0, pTexture);
+            OVR_ASSERT(glGetError() == 0);
+        }
+
+        // Set shader uniforms.
+        const float scale  = HSWDISPLAY_SCALE * ((RenderState.OurHMDInfo.HmdType == HmdType_DK1) ? 0.70f : 1.f);
+        pShaderSet->SetUniform2f("Scale", scale, scale / 2.f); // X and Y scale. Y is a fixed proportion to X in order to give a certain aspect ratio.
+        pShaderSet->SetUniform2f("PositionOffset", OrthoProjection[eye].GetTranslation().x, 0.0f);
+        OVR_ASSERT(glGetError() == 0);
+
+        // Set vertex attributes
+        // To do: We must add support for vertext array objects (VAOs) here. When using an OpenGL 3.2+ core profile, 
+        // the application is required to use vertex array objects and glVertexAttribPointer will fail otherwise.
+
+        if(SupportsVao)
+        {
+            OVR_ASSERT(VAO != 0);
+            #ifdef OVR_OS_MAC
+    			if(GLMajorVersion >= 3)
+				{
+					glBindVertexArray(VAO);
+        		}
+				else
+				{
+					glBindVertexArrayAPPLE(VAO);
+				}
+            #else
+		    	glBindVertexArray(VAO);
+            #endif
+        }
+
+        if(!VAOInitialized) // This executes for the case that VAO isn't supported.
+        {
+            glBindBuffer(GL_ARRAY_BUFFER, pVB->GLBuffer); // This must be called before glVertexAttribPointer is called below.
+            OVR_ASSERT(glGetError() == 0);
+
+            const GLuint shaderProgram = pShaderSet->Prog;
+            GLint attributeLocationArray[kVertexAttribCount];
+
+            attributeLocationArray[0] = glGetAttribLocation(shaderProgram, "Position");
+            glVertexAttribPointer(attributeLocationArray[0], sizeof(Vector3f)/sizeof(float), GL_FLOAT,         false, sizeof(HASWVertex), reinterpret_cast<char*>(offsetof(HASWVertex, Pos)));
+
+            attributeLocationArray[1] = glGetAttribLocation(shaderProgram, "Color");
+            glVertexAttribPointer(attributeLocationArray[1], sizeof(Color)/sizeof(uint8_t),  GL_UNSIGNED_BYTE,  true, sizeof(HASWVertex), reinterpret_cast<char*>(offsetof(HASWVertex, C)));  // True because we want it to convert [0,255] to [0,1] for us.
+
+            attributeLocationArray[2] = glGetAttribLocation(shaderProgram, "TexCoord");
+            glVertexAttribPointer(attributeLocationArray[2], sizeof(float[2])/sizeof(float), GL_FLOAT,         false, sizeof(HASWVertex), reinterpret_cast<char*>(offsetof(HASWVertex, U)));
+            OVR_ASSERT(glGetError() == 0);
+
+            for (size_t i = 0; i < kVertexAttribCount; i++)
+                glEnableVertexAttribArray((GLuint)i);
+            OVR_ASSERT(glGetError() == 0);
+
+            for (size_t i = kVertexAttribCount; i < kSavedVertexAttribCount; i++)
+                glDisableVertexAttribArray((GLuint)i);
+            OVR_ASSERT(glGetError() == 0);
+        }
+
+        fill.Set(Prim_TriangleStrip);
+        OVR_ASSERT(glGetError() == 0);
+
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+        OVR_ASSERT(glGetError() == 0);
+
+        if(SupportsVao)
+        {
+            VAOInitialized = true;
+
+            #ifdef OVR_OS_MAC
+            	if(GLMajorVersion >= 3)
+            	{
+            	    glBindVertexArray(0);
+            	}
+            	else
+            	{
+            	    glBindVertexArrayAPPLE(0);
+            	}
+            #else
+		    	glBindVertexArray(0);
+            #endif
+        }
+
+        // Restore state
+        // We restore the state in the reverse order that we saved it.
+        // To do: Make the code below avoid changes that are effectively no-ops.
+        //
+        if (SupportsVao)
+        {
+#ifdef OVR_OS_MAC
+            if(GLMajorVersion >= 3)
+            {
+                glBindVertexArray(VertexArrayBindingSaved);
+            }
+            else
+            {
+                glBindVertexArrayAPPLE(VertexArrayBindingSaved);
+            }
+#else
+            glBindVertexArray(VertexArrayBindingSaved);
+#endif
+        }
+
+        for (GLuint i = 0; i < kSavedVertexAttribCount; i++)
+        {
+            // We have a problem here: if the GL context was initialized with a core profile version 3.x or later, calls to glVertexAttribPointer can fail when there is no Vertex Array Object
+            // in place. That case is possible here, and we don't have an easy means to detect that a core profile was specified and thus that the glVertexAttribPointer call below could fail.
+            // Our current solution is to call glVertexAttribPointer only if vertex array objects are not supported. We cannot simply decide based on whether the given vertex attrib was enabled
+            // or if there was a vertex array object installed. With our solution below a problem can occur when using OpenGL 3.x+ which supports VAOs, the user has vertex attrib pointers installed,
+            // the currently installed VAO is 0, and the user is somehow dependent on us returning to the user with those vertex attrib pointers reinstalled.
+
+            if (!SupportsVao || (VertexArrayBindingSaved != 0)) // If the OpenGL version is older or in core profile compatibility mode, or if there's a VAO currently installed...
+            {
+                glVertexAttribPointer(i, VertexAttribSizeSaved[i], VertexAttribTypeSaved[i], (GLboolean)VertexAttribNormalizedSaved[i], VertexAttribStrideSaved[i], VertexAttribPointerSaved[i]);
+
+                if(VertexAttribEnabledSaved[i])
+                    glEnableVertexAttribArray(i);
+                else
+                    glDisableVertexAttribArray(i);
+
+                OVR_ASSERT(glGetError() == 0);
+            }
+        }
+
+        glBindTexture(GL_TEXTURE_2D, TextureBindingSaved);
+        glActiveTexture(ActiveTextureSaved);
+        glUseProgram(ProgramSaved);
+        glBindBuffer(GL_ARRAY_BUFFER, ArrayBufferBindingSaved);
+        glColorMask((GLboolean)ColorWriteMaskSaved[0], (GLboolean)ColorWriteMaskSaved[1], (GLboolean)ColorWriteMaskSaved[2], (GLboolean)ColorWriteMaskSaved[3]);
+
+        if(((GLMajorVersion * 100) + GLMinorVersion) >= 302) // OpenGL 3.2 or later
+        {
+            if(SampleMaskSaved)
+                glEnable(GL_SAMPLE_MASK);
+            else
+                glDisable(GL_SAMPLE_MASK);
+        }
+
+        if(ScissorTestSaved)
+            glEnable(GL_SCISSOR_TEST);
+        else
+            glDisable(GL_SCISSOR_TEST);
+
+        if(RasterizerDiscardSaved)
+            glEnable(GL_RASTERIZER_DISCARD);
+        else
+            glDisable(GL_RASTERIZER_DISCARD);
+
+        if(DitherSaved)
+            glEnable(GL_DITHER);
+        else
+            glDisable(GL_DITHER);
+
+        glBlendFunc(BlendSrcRGBSaved, BlendDstRGBSaved); // What about BlendSrcAlphaSaved / BlendDstAlphaSaved?
+
+        if(BlendSaved)
+            glEnable(GL_BLEND);
+        else
+            glDisable(GL_BLEND);
+
+        glFrontFace(FrontFaceSaved);
+
+        if(CullFaceSaved)
+            glEnable(GL_CULL_FACE);
+        else
+            glDisable(GL_CULL_FACE);
+
+        if(DepthTestSaved)
+            glEnable(GL_DEPTH_TEST);
+        else
+            glDisable(GL_DEPTH_TEST);
+
+        glDepthMask(DepthWriteMaskSaved ? GL_TRUE : GL_FALSE);  
+        #if defined(OVR_OS_MAC) // On Mac we are directly using OpenGL functions instead of function pointers.
+            glDepthRange(DepthRangeSaved[0], DepthRangeSaved[1]);
+        #else
+            if(glDepthRange) // If we can use the double version (glDepthRangef may not be available)...
+                glDepthRange(DepthRangeSaved[0], DepthRangeSaved[1]);
+            else
+                glDepthRangef(DepthRangefSaved[0], DepthRangefSaved[1]);
+        #endif
+        // For OpenGL 3.x+ core profile mode, glPolygonMode allows only GL_FRONT_AND_BACK and not separate GL_FRONT and GL_BACK.
+        glPolygonMode(GL_FRONT_AND_BACK, PolygonModeSaved[0]);
+        glViewport(ViewportSaved[0], ViewportSaved[1], ViewportSaved[2], ViewportSaved[3]);
+        glBindTexture(GL_TEXTURE_2D, TextureBinding2DSaved);
+        glBindFramebuffer(GL_FRAMEBUFFER, FrameBufferBindingSaved);
+        //glRenderMode(RenderModeSaved);
+
+        OVR_ASSERT(glGetError() == 0);
+        //
+        // End of restore state
+    }
+}
+
+ 
+
+}}} // namespace OVR::CAPI::GL
+
+
+
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,79 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_GL_HSWDisplay_h
+#define OVR_CAPI_GL_HSWDisplay_h
+
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_GL_Util.h"
+
+
+namespace OVR { namespace CAPI { namespace GL {
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrGLConfig* config = (const ovrGLConfig*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void UnloadGraphics();
+        void LoadGraphics();
+
+        OVR::CAPI::GL::RenderParams        RenderParams;
+        int                                GLMajorVersion;      // Derived from glGetString(GL_VERSION). To consider: Move this into GL::RenderParams.
+        int                                GLMinorVersion;      // 
+        bool                               SupportsVao;         // True if Vertex Array Objects are supported by the OpenGL version.
+        GLuint                             FrameBuffer;         // This is a container for a texture, depth buffer, stencil buffer to be rendered to. To consider: Make a wrapper class, like the OculusWorldDemo RBuffer class. 
+        Ptr<OVR::CAPI::GL::Texture>        pTexture;
+        Ptr<OVR::CAPI::GL::ShaderSet>      pShaderSet;
+        Ptr<OVR::CAPI::GL::VertexShader>   pVertexShader;
+        Ptr<OVR::CAPI::GL::FragmentShader> pFragmentShader;
+        Ptr<OVR::CAPI::GL::Buffer>         pVB;
+        GLuint                             VAO;                 // Vertex Array Object.
+        bool                               VAOInitialized;      // True if the VAO was initialized with vertex buffer data.
+        Matrix4f                           OrthoProjection[2];  // Projection for 2D.
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::GL
+
+
+#endif // OVR_CAPI_GL_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,578 @@
+/************************************************************************************
+
+Filename    :   Render_GL_Device.cpp
+Content     :   RenderDevice implementation for OpenGL
+Created     :   September 10, 2012
+Authors     :   David Borel, Andrew Reisse
+
+Copyright   :   Copyright 2012 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "CAPI_GL_Util.h"
+#include "../../Kernel/OVR_Log.h"
+#include <string.h>
+
+namespace OVR { namespace CAPI { namespace GL {
+
+
+
+// GL Hooks for non-Mac.
+#if !defined(OVR_OS_MAC)
+
+#if defined(OVR_OS_WIN32)
+
+PFNWGLGETPROCADDRESS                     wglGetProcAddress;
+
+PFNGLGETERRORPROC                        glGetError;
+PFNGLENABLEPROC                          glEnable;
+PFNGLDISABLEPROC                         glDisable;
+PFNGLGETFLOATVPROC                       glGetFloatv;
+PFNGLGETINTEGERVPROC                     glGetIntegerv;
+PFNGLGETDOUBLEVPROC                      glGetDoublev;
+PFNGLGETSTRINGPROC                       glGetString;
+PFNGLCOLORMASKPROC                       glColorMask;
+PFNGLCLEARPROC                           glClear;
+PFNGLCLEARCOLORPROC                      glClearColor;
+PFNGLCLEARDEPTHPROC                      glClearDepth;
+PFNGLDEPTHMASKPROC                       glDepthMask;
+PFNGLDEPTHRANGEPROC                      glDepthRange;
+PFNGLDEPTHRANGEFPROC                     glDepthRangef;
+PFNGLVIEWPORTPROC                        glViewport;
+PFNGLDRAWELEMENTSPROC                    glDrawElements;
+PFNGLTEXPARAMETERIPROC                   glTexParameteri;
+PFNGLFLUSHPROC                           glFlush;
+PFNGLFINISHPROC                          glFinish;
+PFNGLDRAWARRAYSPROC                      glDrawArrays;
+PFNGLGENTEXTURESPROC                     glGenTextures;
+PFNGLDELETETEXTURESPROC                  glDeleteTextures;
+PFNGLBINDTEXTUREPROC                     glBindTexture;
+PFNGLTEXIMAGE2DPROC                      glTexImage2D;
+PFNGLBLENDFUNCPROC                       glBlendFunc;
+PFNGLFRONTFACEPROC                       glFrontFace;
+PFNGLRENDERMODEPROC                      glRenderMode;
+PFNGLPOLYGONMODEPROC                     glPolygonMode;
+
+PFNWGLGETSWAPINTERVALEXTPROC             wglGetSwapIntervalEXT;
+PFNWGLSWAPINTERVALEXTPROC                wglSwapIntervalEXT;
+
+#elif defined(OVR_OS_LINUX)
+
+PFNGLXSWAPINTERVALEXTPROC                glXSwapIntervalEXT;
+
+#endif
+
+PFNGLENABLEIPROC                         glEnablei;
+PFNGLDISABLEIPROC                        glDisablei;
+PFNGLCOLORMASKIPROC                      glColorMaski;
+PFNGLGETINTEGERI_VPROC                   glGetIntegeri_v;
+PFNGLGENFRAMEBUFFERSPROC                 glGenFramebuffers;
+PFNGLDELETEFRAMEBUFFERSPROC              glDeleteFramebuffers;
+PFNGLDELETESHADERPROC                    glDeleteShader;
+PFNGLCHECKFRAMEBUFFERSTATUSPROC          glCheckFramebufferStatus;
+PFNGLFRAMEBUFFERRENDERBUFFERPROC         glFramebufferRenderbuffer;
+PFNGLFRAMEBUFFERTEXTURE2DPROC            glFramebufferTexture2D;
+PFNGLBINDFRAMEBUFFERPROC                 glBindFramebuffer;
+PFNGLACTIVETEXTUREPROC                   glActiveTexture;
+PFNGLGETVERTEXATTRIBIVPROC               glGetVertexAttribiv;
+PFNGLGETVERTEXATTRIBPOINTERVPROC         glGetVertexAttribPointerv;
+PFNGLDISABLEVERTEXATTRIBARRAYPROC        glDisableVertexAttribArray;
+PFNGLVERTEXATTRIBPOINTERPROC             glVertexAttribPointer;
+PFNGLENABLEVERTEXATTRIBARRAYPROC         glEnableVertexAttribArray;
+PFNGLBINDBUFFERPROC                      glBindBuffer;
+PFNGLUNIFORMMATRIX3FVPROC                glUniformMatrix3fv;
+PFNGLUNIFORMMATRIX4FVPROC                glUniformMatrix4fv;
+PFNGLDELETEBUFFERSPROC                   glDeleteBuffers;
+PFNGLBUFFERDATAPROC                      glBufferData;
+PFNGLGENBUFFERSPROC                      glGenBuffers;
+PFNGLMAPBUFFERPROC                       glMapBuffer;
+PFNGLUNMAPBUFFERPROC                     glUnmapBuffer;
+PFNGLGETSHADERINFOLOGPROC                glGetShaderInfoLog;
+PFNGLGETSHADERIVPROC                     glGetShaderiv;
+PFNGLCOMPILESHADERPROC                   glCompileShader;
+PFNGLSHADERSOURCEPROC                    glShaderSource;
+PFNGLCREATESHADERPROC                    glCreateShader;
+PFNGLCREATEPROGRAMPROC                   glCreateProgram;
+PFNGLATTACHSHADERPROC                    glAttachShader;
+PFNGLDETACHSHADERPROC                    glDetachShader;
+PFNGLDELETEPROGRAMPROC                   glDeleteProgram;
+PFNGLUNIFORM1IPROC                       glUniform1i;
+PFNGLGETUNIFORMLOCATIONPROC              glGetUniformLocation;
+PFNGLGETACTIVEUNIFORMPROC                glGetActiveUniform;
+PFNGLUSEPROGRAMPROC                      glUseProgram;
+PFNGLGETPROGRAMINFOLOGPROC               glGetProgramInfoLog;
+PFNGLGETPROGRAMIVPROC                    glGetProgramiv;
+PFNGLLINKPROGRAMPROC                     glLinkProgram;
+PFNGLBINDATTRIBLOCATIONPROC              glBindAttribLocation;
+PFNGLGETATTRIBLOCATIONPROC               glGetAttribLocation;
+PFNGLUNIFORM4FVPROC                      glUniform4fv;
+PFNGLUNIFORM3FVPROC                      glUniform3fv;
+PFNGLUNIFORM2FVPROC                      glUniform2fv;
+PFNGLUNIFORM1FVPROC                      glUniform1fv;
+PFNGLGENVERTEXARRAYSPROC                 glGenVertexArrays;
+PFNGLDELETEVERTEXARRAYSPROC              glDeleteVertexArrays;
+PFNGLBINDVERTEXARRAYPROC                 glBindVertexArray;
+PFNGLFEEDBACKBUFFERPROC                  glFeedbackBuffer;
+
+
+#if defined(OVR_OS_WIN32)
+
+void* GetFunction(const char* functionName)
+{
+    return wglGetProcAddress(functionName);
+}
+
+#else
+
+void (*GetFunction(const char *functionName))( void )
+{
+    return glXGetProcAddress((GLubyte*)functionName);
+}
+
+#endif
+
+void InitGLExtensions()
+{
+    if (glGenVertexArrays)
+        return;
+
+#if defined(OVR_OS_WIN32)
+	HINSTANCE hInst = LoadLibrary(L"Opengl32.dll");
+	if (!hInst)
+		return;
+
+	glGetError =                        (PFNGLGETERRORPROC)                        GetProcAddress(hInst, "glGetError");
+	glGetFloatv =                       (PFNGLGETFLOATVPROC)                       GetProcAddress(hInst, "glGetFloatv");
+	glGetIntegerv =                     (PFNGLGETINTEGERVPROC)                     GetProcAddress(hInst, "glGetIntegerv");
+	glGetDoublev =                      (PFNGLGETDOUBLEVPROC)                      GetProcAddress(hInst, "glGetDoublev");
+	glGetString =                       (PFNGLGETSTRINGPROC)                       GetProcAddress(hInst, "glGetString");
+	glEnable =                          (PFNGLENABLEPROC)                          GetProcAddress(hInst, "glEnable");
+	glDisable =                         (PFNGLDISABLEPROC)                         GetProcAddress(hInst, "glDisable");
+	glColorMask =                       (PFNGLCOLORMASKPROC)                       GetProcAddress(hInst, "glColorMask");
+	glClear =                           (PFNGLCLEARPROC)                           GetProcAddress(hInst, "glClear" );
+	glClearColor =                      (PFNGLCLEARCOLORPROC)                      GetProcAddress(hInst, "glClearColor");
+	glClearDepth =                      (PFNGLCLEARDEPTHPROC)                      GetProcAddress(hInst, "glClearDepth");
+	glDepthMask =                       (PFNGLDEPTHMASKPROC)                       GetProcAddress(hInst, "glDepthMask");
+	glDepthRange =                      (PFNGLDEPTHRANGEPROC)                      GetProcAddress(hInst, "glDepthRange");
+	glDepthRangef =                     (PFNGLDEPTHRANGEFPROC)                     GetProcAddress(hInst, "glDepthRangef");
+	glViewport =                        (PFNGLVIEWPORTPROC)                        GetProcAddress(hInst, "glViewport");
+	glFlush =                           (PFNGLFLUSHPROC)                           GetProcAddress(hInst, "glFlush");
+	glFinish =                          (PFNGLFINISHPROC)                          GetProcAddress(hInst, "glFinish");
+    glDrawArrays =                      (PFNGLDRAWARRAYSPROC)                      GetProcAddress(hInst, "glDrawArrays");
+	glDrawElements =                    (PFNGLDRAWELEMENTSPROC)                    GetProcAddress(hInst, "glDrawElements");
+    glGenTextures =                     (PFNGLGENTEXTURESPROC)                     GetProcAddress(hInst, "glGenTextures");
+    glDeleteTextures =                  (PFNGLDELETETEXTURESPROC)                  GetProcAddress(hInst, "glDeleteTextures");
+    glBindTexture =                     (PFNGLBINDTEXTUREPROC)                     GetProcAddress(hInst, "glBindTexture");
+    glTexImage2D =                      (PFNGLTEXIMAGE2DPROC)                      GetProcAddress(hInst, "glTexImage2D");
+	glTexParameteri =                   (PFNGLTEXPARAMETERIPROC)                   GetProcAddress(hInst, "glTexParameteri");
+	glBlendFunc =                       (PFNGLBLENDFUNCPROC)                       GetProcAddress(hInst, "glBlendFunc");
+	glFrontFace =                       (PFNGLFRONTFACEPROC)                       GetProcAddress(hInst, "glFrontFace");
+	glRenderMode =                      (PFNGLRENDERMODEPROC)                      GetProcAddress(hInst, "glRenderMode");
+	glPolygonMode =                     (PFNGLPOLYGONMODEPROC)                     GetProcAddress(hInst, "glPolygonMode");
+
+    wglGetProcAddress =                 (PFNWGLGETPROCADDRESS)                     GetProcAddress(hInst, "wglGetProcAddress");
+
+    wglGetSwapIntervalEXT =             (PFNWGLGETSWAPINTERVALEXTPROC)             GetFunction("wglGetSwapIntervalEXT");
+    wglSwapIntervalEXT =                (PFNWGLSWAPINTERVALEXTPROC)                GetFunction("wglSwapIntervalEXT");
+#elif defined(OVR_OS_LINUX)
+
+    glXSwapIntervalEXT =                (PFNGLXSWAPINTERVALEXTPROC)                GetFunction("glXSwapIntervalEXT");
+#endif
+    
+    glGenFramebuffers =                 (PFNGLGENFRAMEBUFFERSPROC)                 GetFunction("glGenFramebuffersEXT");
+    glDeleteFramebuffers =              (PFNGLDELETEFRAMEBUFFERSPROC)              GetFunction("glDeleteFramebuffersEXT");
+	glEnablei =                         (PFNGLENABLEIPROC)                         GetFunction("glEnableIndexedEXT");
+	glDisablei =                        (PFNGLDISABLEIPROC)                        GetFunction("glDisableIndexedEXT");
+	glColorMaski =                      (PFNGLCOLORMASKIPROC)                      GetFunction("glColorMaskIndexedEXT");
+	glGetIntegeri_v =                   (PFNGLGETINTEGERI_VPROC)                   GetFunction("glGetIntegerIndexedvEXT");
+    glCheckFramebufferStatus =          (PFNGLCHECKFRAMEBUFFERSTATUSPROC)          GetFunction("glCheckFramebufferStatusEXT");
+    glFramebufferRenderbuffer =         (PFNGLFRAMEBUFFERRENDERBUFFERPROC)         GetFunction("glFramebufferRenderbufferEXT");
+    glFramebufferTexture2D =            (PFNGLFRAMEBUFFERTEXTURE2DPROC)            GetFunction("glFramebufferTexture2DEXT");
+    glBindFramebuffer =                 (PFNGLBINDFRAMEBUFFERPROC)                 GetFunction("glBindFramebufferEXT");
+    glGenVertexArrays =                 (PFNGLGENVERTEXARRAYSPROC)                 GetFunction("glGenVertexArrays");
+    glDeleteVertexArrays =              (PFNGLDELETEVERTEXARRAYSPROC)              GetFunction("glDeleteVertexArrays");
+    glBindVertexArray =                 (PFNGLBINDVERTEXARRAYPROC)                 GetFunction("glBindVertexArray");
+    glGenBuffers =                      (PFNGLGENBUFFERSPROC)                      GetFunction("glGenBuffers");
+    glDeleteBuffers =                   (PFNGLDELETEBUFFERSPROC)                   GetFunction("glDeleteBuffers");
+    glBindBuffer =                      (PFNGLBINDBUFFERPROC)                      GetFunction("glBindBuffer");	
+    glBufferData =                      (PFNGLBUFFERDATAPROC)                      GetFunction("glBufferData");
+    glMapBuffer =                       (PFNGLMAPBUFFERPROC)                       GetFunction("glMapBuffer");
+    glUnmapBuffer =                     (PFNGLUNMAPBUFFERPROC)                     GetFunction("glUnmapBuffer");
+    glGetVertexAttribiv =               (PFNGLGETVERTEXATTRIBIVPROC)               GetFunction("glGetVertexAttribiv");
+    glGetVertexAttribPointerv =         (PFNGLGETVERTEXATTRIBPOINTERVPROC)         GetFunction("glGetVertexAttribPointerv");
+    glDisableVertexAttribArray =        (PFNGLDISABLEVERTEXATTRIBARRAYPROC)        GetFunction("glDisableVertexAttribArray");
+    glVertexAttribPointer =             (PFNGLVERTEXATTRIBPOINTERPROC)             GetFunction("glVertexAttribPointer");
+    glEnableVertexAttribArray =         (PFNGLENABLEVERTEXATTRIBARRAYPROC)         GetFunction("glEnableVertexAttribArray");
+    glActiveTexture =                   (PFNGLACTIVETEXTUREPROC)                   GetFunction("glActiveTexture");
+    glUniformMatrix3fv =                (PFNGLUNIFORMMATRIX3FVPROC)                GetFunction("glUniformMatrix3fv");
+    glUniformMatrix4fv =                (PFNGLUNIFORMMATRIX4FVPROC)                GetFunction("glUniformMatrix4fv");
+    glUniform1i =                       (PFNGLUNIFORM1IPROC)                       GetFunction("glUniform1i");
+    glUniform1fv =                      (PFNGLUNIFORM1FVPROC)                      GetFunction("glUniform1fv");
+    glUniform2fv =                      (PFNGLUNIFORM2FVPROC)                      GetFunction("glUniform2fv");
+    glUniform3fv =                      (PFNGLUNIFORM3FVPROC)                      GetFunction("glUniform3fv");
+    glUniform2fv =                      (PFNGLUNIFORM2FVPROC)                      GetFunction("glUniform2fv");
+    glUniform4fv =                      (PFNGLUNIFORM4FVPROC)                      GetFunction("glUniform4fv");
+    glGetUniformLocation =              (PFNGLGETUNIFORMLOCATIONPROC)              GetFunction("glGetUniformLocation");
+    glGetActiveUniform =                (PFNGLGETACTIVEUNIFORMPROC)                GetFunction("glGetActiveUniform");
+    glGetShaderInfoLog =                (PFNGLGETSHADERINFOLOGPROC)                GetFunction("glGetShaderInfoLog");
+    glGetShaderiv =                     (PFNGLGETSHADERIVPROC)                     GetFunction("glGetShaderiv");
+    glCompileShader =                   (PFNGLCOMPILESHADERPROC)                   GetFunction("glCompileShader");
+    glShaderSource =                    (PFNGLSHADERSOURCEPROC)                    GetFunction("glShaderSource");
+    glCreateShader =                    (PFNGLCREATESHADERPROC)                    GetFunction("glCreateShader");
+    glDeleteShader =                    (PFNGLDELETESHADERPROC)                    GetFunction("glDeleteShader");
+    glCreateProgram =                   (PFNGLCREATEPROGRAMPROC)                   GetFunction("glCreateProgram");
+    glDeleteProgram =                   (PFNGLDELETEPROGRAMPROC)                   GetFunction("glDeleteProgram");
+    glUseProgram =                      (PFNGLUSEPROGRAMPROC)                      GetFunction("glUseProgram");
+    glGetProgramInfoLog =               (PFNGLGETPROGRAMINFOLOGPROC)               GetFunction("glGetProgramInfoLog");
+    glGetProgramiv =                    (PFNGLGETPROGRAMIVPROC)                    GetFunction("glGetProgramiv");
+    glLinkProgram =                     (PFNGLLINKPROGRAMPROC)                     GetFunction("glLinkProgram");
+    glAttachShader =                    (PFNGLATTACHSHADERPROC)                    GetFunction("glAttachShader");
+    glDetachShader =                    (PFNGLDETACHSHADERPROC)                    GetFunction("glDetachShader");
+    glBindAttribLocation =              (PFNGLBINDATTRIBLOCATIONPROC)              GetFunction("glBindAttribLocation");
+    glGetAttribLocation =               (PFNGLGETATTRIBLOCATIONPROC)               GetFunction("glGetAttribLocation");
+    glFeedbackBuffer =                  (PFNGLFEEDBACKBUFFERPROC)                  GetFunction("glFeedbackBuffer");
+}
+    
+#endif
+    
+Buffer::Buffer(RenderParams* rp) : pParams(rp), Size(0), Use(0), GLBuffer(0)
+{
+}
+
+Buffer::~Buffer()
+{
+    if (GLBuffer)
+        glDeleteBuffers(1, &GLBuffer);
+}
+
+bool Buffer::Data(int use, const void* buffer, size_t size)
+{
+	Size = size;
+
+    switch (use & Buffer_TypeMask)
+    {
+    case Buffer_Index:     Use = GL_ELEMENT_ARRAY_BUFFER; break;
+    default:               Use = GL_ARRAY_BUFFER; break;
+    }
+
+    if (!GLBuffer)
+        glGenBuffers(1, &GLBuffer);
+
+    int mode = GL_DYNAMIC_DRAW;
+    if (use & Buffer_ReadOnly)
+        mode = GL_STATIC_DRAW;
+
+    glBindBuffer(Use, GLBuffer);
+    glBufferData(Use, size, buffer, mode);
+    return 1;
+}
+
+void* Buffer::Map(size_t, size_t, int)
+{
+    int mode = GL_WRITE_ONLY;
+    //if (flags & Map_Unsynchronized)
+    //    mode |= GL_MAP_UNSYNCHRONIZED;
+    
+    glBindBuffer(Use, GLBuffer);
+    void* v = glMapBuffer(Use, mode);
+    return v;
+}
+
+bool Buffer::Unmap(void*)
+{
+    glBindBuffer(Use, GLBuffer);
+    int r = glUnmapBuffer(Use);
+    return r != 0;
+}
+
+ShaderSet::ShaderSet()
+{
+    Prog = glCreateProgram();
+}
+ShaderSet::~ShaderSet()
+{
+    glDeleteProgram(Prog);
+}
+
+GLint ShaderSet::GetGLShader(Shader* s)
+{
+	switch (s->Stage)
+	{
+	case Shader_Vertex: {
+		ShaderImpl<Shader_Vertex, GL_VERTEX_SHADER>* gls = (ShaderImpl<Shader_Vertex, GL_VERTEX_SHADER>*)s;
+		return gls->GLShader;
+	} break;
+	case Shader_Fragment: {
+		ShaderImpl<Shader_Fragment, GL_FRAGMENT_SHADER>* gls = (ShaderImpl<Shader_Fragment, GL_FRAGMENT_SHADER>*)s;
+		return gls->GLShader;
+	} break;
+    default: break;
+	}
+
+	return -1;
+}
+
+void ShaderSet::SetShader(Shader *s)
+{
+    Shaders[s->Stage] = s;
+	GLint GLShader = GetGLShader(s);
+    glAttachShader(Prog, GLShader);
+    if (Shaders[Shader_Vertex] && Shaders[Shader_Fragment])
+        Link();
+}
+
+void ShaderSet::UnsetShader(int stage)
+{
+    if (Shaders[stage] == NULL)
+		return;
+
+	GLint GLShader = GetGLShader(Shaders[stage]);
+    glDetachShader(Prog, GLShader);
+
+    Shaders[stage] = NULL;
+}
+
+bool ShaderSet::SetUniform(const char* name, int n, const float* v)
+{
+    for (unsigned int i = 0; i < UniformInfo.GetSize(); i++)
+        if (!strcmp(UniformInfo[i].Name.ToCStr(), name))
+        {
+            OVR_ASSERT(UniformInfo[i].Location >= 0);
+            glUseProgram(Prog);
+            switch (UniformInfo[i].Type)
+            {
+            case 1:   glUniform1fv(UniformInfo[i].Location, n, v); break;
+            case 2:   glUniform2fv(UniformInfo[i].Location, n/2, v); break;
+            case 3:   glUniform3fv(UniformInfo[i].Location, n/3, v); break;
+            case 4:   glUniform4fv(UniformInfo[i].Location, n/4, v); break;
+            case 12:  glUniformMatrix3fv(UniformInfo[i].Location, 1, 1, v); break;
+            case 16:  glUniformMatrix4fv(UniformInfo[i].Location, 1, 1, v); break;
+            default: OVR_ASSERT(0);
+            }
+            return 1;
+        }
+
+    OVR_DEBUG_LOG(("Warning: uniform %s not present in selected shader", name));
+    return 0;
+}
+
+bool ShaderSet::Link()
+{
+    glLinkProgram(Prog);
+    GLint r;
+    glGetProgramiv(Prog, GL_LINK_STATUS, &r);
+    if (!r)
+    {
+        GLchar msg[1024];
+        glGetProgramInfoLog(Prog, sizeof(msg), 0, msg);
+        OVR_DEBUG_LOG(("Linking shaders failed: %s\n", msg));
+        if (!r)
+            return 0;
+    }
+    glUseProgram(Prog);
+
+    UniformInfo.Clear();
+    LightingVer = 0;
+    UsesLighting = 0;
+
+	GLint uniformCount = 0;
+	glGetProgramiv(Prog, GL_ACTIVE_UNIFORMS, &uniformCount);
+	OVR_ASSERT(uniformCount >= 0);
+
+    for(GLuint i = 0; i < (GLuint)uniformCount; i++)
+    {
+        GLsizei namelen;
+        GLint size = 0;
+        GLenum type;
+        GLchar name[32];
+        glGetActiveUniform(Prog, i, sizeof(name), &namelen, &size, &type, name);
+
+        if (size)
+        {
+            int l = glGetUniformLocation(Prog, name);
+            char *np = name;
+            while (*np)
+            {
+                if (*np == '[')
+                    *np = 0;
+                np++;
+            }
+            Uniform u;
+            u.Name = name;
+            u.Location = l;
+            u.Size = size;
+            switch (type)
+            {
+            case GL_FLOAT:      u.Type = 1; break;
+            case GL_FLOAT_VEC2: u.Type = 2; break;
+            case GL_FLOAT_VEC3: u.Type = 3; break;
+            case GL_FLOAT_VEC4: u.Type = 4; break;
+            case GL_FLOAT_MAT3: u.Type = 12; break;
+            case GL_FLOAT_MAT4: u.Type = 16; break;
+            default:
+                continue;
+            }
+            UniformInfo.PushBack(u);
+            if (!strcmp(name, "LightCount"))
+                UsesLighting = 1;
+        }
+        else
+            break;
+    }
+
+    ProjLoc = glGetUniformLocation(Prog, "Proj");
+    ViewLoc = glGetUniformLocation(Prog, "View");
+    for (int i = 0; i < 8; i++)
+    {
+        char texv[32];
+        OVR_sprintf(texv, 10, "Texture%d", i);
+        TexLoc[i] = glGetUniformLocation(Prog, texv);
+        if (TexLoc[i] < 0)
+            break;
+
+        glUniform1i(TexLoc[i], i);
+    }
+    if (UsesLighting)
+        OVR_ASSERT(ProjLoc >= 0 && ViewLoc >= 0);
+    return 1;
+}
+
+bool ShaderBase::SetUniform(const char* name, int n, const float* v)
+{
+    for(unsigned i = 0; i < UniformReflSize; i++)
+    {
+        if (!strcmp(UniformRefl[i].Name, name))
+        {
+            memcpy(UniformData + UniformRefl[i].Offset, v, n * sizeof(float));
+            return 1;
+        }
+    }
+    return 0;
+}
+
+bool ShaderBase::SetUniformBool(const char* name, int n, const bool* v) 
+{
+    OVR_UNUSED(n);
+    for(unsigned i = 0; i < UniformReflSize; i++)
+    {
+        if (!strcmp(UniformRefl[i].Name, name))
+        {
+            memcpy(UniformData + UniformRefl[i].Offset, v, UniformRefl[i].Size);
+            return 1;
+        }
+    }
+    return 0;
+}
+
+void ShaderBase::InitUniforms(const Uniform* refl, size_t reflSize)
+{
+    if(!refl)
+    {
+        UniformRefl = NULL;
+        UniformReflSize = 0;
+
+        UniformsSize = 0;
+        if (UniformData)
+        {
+            OVR_FREE(UniformData);
+            UniformData = 0;
+        }
+        return; // no reflection data
+    }
+
+    UniformRefl = refl;
+    UniformReflSize = reflSize;
+    
+    UniformsSize = UniformRefl[UniformReflSize-1].Offset + UniformRefl[UniformReflSize-1].Size;
+    UniformData = (unsigned char*)OVR_ALLOC(UniformsSize);
+}
+
+Texture::Texture(RenderParams* rp, int w, int h) : IsUserAllocated(true), pParams(rp), TexId(0), Width(w), Height(h)
+{
+	if (w && h)
+		glGenTextures(1, &TexId);
+}
+
+Texture::~Texture()
+{
+    if (TexId && !IsUserAllocated)
+        glDeleteTextures(1, &TexId);
+}
+
+void Texture::Set(int slot, ShaderStage) const
+{
+	glActiveTexture(GL_TEXTURE0 + slot);
+	glBindTexture(GL_TEXTURE_2D, TexId);
+}
+
+void Texture::SetSampleMode(int sm)
+{
+    glBindTexture(GL_TEXTURE_2D, TexId);
+    switch (sm & Sample_FilterMask)
+    {
+    case Sample_Linear:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1);
+        break;
+
+    case Sample_Anisotropic:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 8);
+        break;
+
+    case Sample_Nearest:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1);
+        break;
+    }
+
+    switch (sm & Sample_AddressMask)
+    {
+    case Sample_Repeat:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+        break;
+
+    case Sample_Clamp:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        break;
+
+    case Sample_ClampBorder:
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
+        break;
+    }
+}
+
+void Texture::UpdatePlaceholderTexture(GLuint texId, const Sizei& textureSize)
+{
+	if (!IsUserAllocated && TexId && texId != TexId)
+		glDeleteTextures(1, &TexId);
+
+    TexId = texId;
+	Width = textureSize.w;
+	Height = textureSize.h;
+
+	IsUserAllocated = true;
+}
+
+
+}}}
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,577 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_Util.h
+Content     :   Utility header for OpenGL
+Created     :   March 27, 2014
+Authors     :   Andrew Reisse, David Borel
+
+Copyright   :   Copyright 2012 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_OVR_CAPI_GL_Util_h
+#define INC_OVR_CAPI_GL_Util_h
+
+#include "../../OVR_CAPI.h"  
+#include "../../Kernel/OVR_Array.h"
+#include "../../Kernel/OVR_Math.h"
+#include "../../Kernel/OVR_RefCount.h"
+#include "../../Kernel/OVR_String.h"
+#include "../../Kernel/OVR_Types.h"
+#include "../../Kernel/OVR_Log.h"
+
+#if defined(OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#endif
+
+#if defined(OVR_OS_MAC)
+#define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
+#include <OpenGL/gl.h>
+#include <OpenGL/glext.h>
+#include <OpenGL/gl3.h>
+#include <OpenGL/gl3ext.h>
+#else
+#ifndef GL_GLEXT_PROTOTYPES
+#define GL_GLEXT_PROTOTYPES
+#endif
+#include <GL/gl.h>
+#include <GL/glext.h>
+#if defined(OVR_OS_WIN32)
+#include <GL/wglext.h>
+#elif defined(OVR_OS_LINUX)
+#include <GL/glx.h>
+#endif
+#endif
+
+namespace OVR { namespace CAPI { namespace GL {
+
+// GL extension Hooks for Non-Mac.
+#if !defined(OVR_OS_MAC)
+
+// Let Windows apps build without linking GL.
+#if defined(OVR_OS_WIN32)
+
+typedef GLenum (__stdcall *PFNGLGETERRORPROC) ();
+typedef void (__stdcall *PFNGLENABLEPROC) (GLenum);
+typedef void (__stdcall *PFNGLDISABLEPROC) (GLenum);
+typedef void (__stdcall *PFNGLGETFLOATVPROC) (GLenum, GLfloat*);
+typedef const GLubyte * (__stdcall *PFNGLGETSTRINGPROC) (GLenum);
+typedef void (__stdcall *PFNGLGETINTEGERVPROC) (GLenum, GLint*);
+typedef void (__stdcall *PFNGLGETDOUBLEVPROC) (GLenum, GLdouble*);
+typedef PROC (__stdcall *PFNWGLGETPROCADDRESS) (LPCSTR);
+typedef void (__stdcall *PFNGLFLUSHPROC) ();
+typedef void (__stdcall *PFNGLFINISHPROC) ();
+typedef void (__stdcall *PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
+typedef void (__stdcall *PFNGLCLEARPROC) (GLbitfield);
+typedef void (__stdcall *PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+typedef void (__stdcall *PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+typedef void (__stdcall *PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
+typedef void (__stdcall *PFNGLDELETETEXTURESPROC) (GLsizei n, GLuint *textures);
+typedef void (__stdcall *PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
+typedef void (__stdcall *PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLint format, GLenum type, const GLvoid *pixels);
+typedef void (__stdcall *PFNGLCLEARCOLORPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a);
+typedef void (__stdcall *PFNGLCLEARDEPTHPROC) (GLclampd depth);
+typedef void (__stdcall *PFNGLDEPTHMASKPROC) (GLboolean flag);
+typedef void (__stdcall *PFNGLDEPTHRANGEPROC) (GLclampd nearVal,  GLclampd farVal);
+typedef void (__stdcall *PFNGLDEPTHRANGEFPROC) (GLclampf nearVal,  GLclampf farVal);
+typedef void (__stdcall *PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
+typedef void (__stdcall *PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
+typedef void (__stdcall *PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
+typedef void (__stdcall *PFNGLFRONTFACEPROC) (GLenum mode);
+typedef void (__stdcall *PFNGLFEEDBACKBUFFERPROC) (GLsizei size, GLenum type, GLfloat *buffer);
+typedef GLint (__stdcall *PFNGLRENDERMODEPROC) (GLenum mode);
+typedef void (__stdcall *PFNGLPOLYGONMODEPROC) (GLenum face, GLenum mode);
+
+extern PFNWGLGETPROCADDRESS                     wglGetProcAddress;
+extern PFNWGLGETSWAPINTERVALEXTPROC             wglGetSwapIntervalEXT;
+extern PFNWGLSWAPINTERVALEXTPROC                wglSwapIntervalEXT;
+
+extern PFNGLGETERRORPROC                        glGetError;
+extern PFNGLENABLEPROC                          glEnable;
+extern PFNGLENABLEIPROC                         glEnablei;
+extern PFNGLDISABLEPROC                         glDisable;
+extern PFNGLDISABLEIPROC                        glDisablei;
+extern PFNGLCOLORMASKPROC                       glColorMask;
+extern PFNGLCOLORMASKIPROC                      glColorMaski;
+extern PFNGLGETFLOATVPROC                       glGetFloatv;
+extern PFNGLGETSTRINGPROC                       glGetString;
+extern PFNGLGETINTEGERVPROC                     glGetIntegerv;
+extern PFNGLGETINTEGERI_VPROC                   glGetIntegeri_v;
+extern PFNGLGETDOUBLEVPROC                      glGetDoublev;
+extern PFNGLCLEARPROC                           glClear;
+extern PFNGLCLEARCOLORPROC                      glClearColor;
+extern PFNGLCLEARDEPTHPROC                      glClearDepth;
+extern PFNGLDEPTHMASKPROC                       glDepthMask;
+extern PFNGLDEPTHRANGEPROC                      glDepthRange;
+extern PFNGLDEPTHRANGEFPROC                     glDepthRangef;
+extern PFNGLVIEWPORTPROC                        glViewport;
+extern PFNGLDRAWARRAYSPROC                      glDrawArrays;
+extern PFNGLDRAWELEMENTSPROC                    glDrawElements;
+extern PFNGLGENTEXTURESPROC                     glGenTextures;
+extern PFNGLDELETETEXTURESPROC                  glDeleteTextures;
+extern PFNGLBINDTEXTUREPROC                     glBindTexture;
+extern PFNGLTEXIMAGE2DPROC                      glTexImage2D;
+extern PFNGLTEXPARAMETERIPROC                   glTexParameteri;
+extern PFNGLFLUSHPROC                           glFlush;
+extern PFNGLFINISHPROC                          glFinish;
+extern PFNGLBLENDFUNCPROC                       glBlendFunc;
+extern PFNGLFRONTFACEPROC                       glFrontFace;
+extern PFNGLRENDERMODEPROC                      glRenderMode;
+extern PFNGLPOLYGONMODEPROC                     glPolygonMode;
+
+#elif defined(OVR_OS_LINUX)
+
+extern PFNGLXSWAPINTERVALEXTPROC                glXSwapIntervalEXT;
+
+#endif // defined(OVR_OS_WIN32)
+
+extern PFNGLGENFRAMEBUFFERSPROC                 glGenFramebuffers;
+extern PFNGLDELETEFRAMEBUFFERSPROC              glDeleteFramebuffers;
+extern PFNGLDELETESHADERPROC                    glDeleteShader;
+extern PFNGLCHECKFRAMEBUFFERSTATUSPROC          glCheckFramebufferStatus;
+extern PFNGLFRAMEBUFFERRENDERBUFFERPROC         glFramebufferRenderbuffer;
+extern PFNGLFRAMEBUFFERTEXTURE2DPROC            glFramebufferTexture2D;
+extern PFNGLBINDFRAMEBUFFERPROC                 glBindFramebuffer;
+extern PFNGLACTIVETEXTUREPROC                   glActiveTexture;
+extern PFNGLGETVERTEXATTRIBIVPROC               glGetVertexAttribiv;
+extern PFNGLGETVERTEXATTRIBPOINTERVPROC         glGetVertexAttribPointerv;
+extern PFNGLDISABLEVERTEXATTRIBARRAYPROC        glDisableVertexAttribArray;
+extern PFNGLVERTEXATTRIBPOINTERPROC             glVertexAttribPointer;
+extern PFNGLENABLEVERTEXATTRIBARRAYPROC         glEnableVertexAttribArray;
+extern PFNGLBINDBUFFERPROC                      glBindBuffer;
+extern PFNGLUNIFORMMATRIX4FVPROC                glUniformMatrix4fv;
+extern PFNGLDELETEBUFFERSPROC                   glDeleteBuffers;
+extern PFNGLBUFFERDATAPROC                      glBufferData;
+extern PFNGLGENBUFFERSPROC                      glGenBuffers;
+extern PFNGLMAPBUFFERPROC                       glMapBuffer;
+extern PFNGLUNMAPBUFFERPROC                     glUnmapBuffer;
+extern PFNGLGETSHADERINFOLOGPROC                glGetShaderInfoLog;
+extern PFNGLGETSHADERIVPROC                     glGetShaderiv;
+extern PFNGLCOMPILESHADERPROC                   glCompileShader;
+extern PFNGLSHADERSOURCEPROC                    glShaderSource;
+extern PFNGLCREATESHADERPROC                    glCreateShader;
+extern PFNGLCREATEPROGRAMPROC                   glCreateProgram;
+extern PFNGLATTACHSHADERPROC                    glAttachShader;
+extern PFNGLDETACHSHADERPROC                    glDetachShader;
+extern PFNGLDELETEPROGRAMPROC                   glDeleteProgram;
+extern PFNGLUNIFORM1IPROC                       glUniform1i;
+extern PFNGLGETUNIFORMLOCATIONPROC              glGetUniformLocation;
+extern PFNGLGETACTIVEUNIFORMPROC                glGetActiveUniform;
+extern PFNGLUSEPROGRAMPROC                      glUseProgram;
+extern PFNGLGETPROGRAMINFOLOGPROC               glGetProgramInfoLog;
+extern PFNGLGETPROGRAMIVPROC                    glGetProgramiv;
+extern PFNGLLINKPROGRAMPROC                     glLinkProgram;
+extern PFNGLBINDATTRIBLOCATIONPROC              glBindAttribLocation;
+extern PFNGLGETATTRIBLOCATIONPROC               glGetAttribLocation;
+extern PFNGLUNIFORM4FVPROC                      glUniform4fv;
+extern PFNGLUNIFORM3FVPROC                      glUniform3fv;
+extern PFNGLUNIFORM2FVPROC                      glUniform2fv;
+extern PFNGLUNIFORM1FVPROC                      glUniform1fv;
+extern PFNGLGENVERTEXARRAYSPROC                 glGenVertexArrays;
+extern PFNGLDELETEVERTEXARRAYSPROC              glDeleteVertexArrays;
+extern PFNGLBINDVERTEXARRAYPROC                 glBindVertexArray;
+extern PFNGLFEEDBACKBUFFERPROC                  glFeedbackBuffer;
+
+extern void InitGLExtensions();
+
+#endif // !defined(OVR_OS_MAC)
+
+
+// Rendering primitive type used to render Model.
+enum PrimitiveType
+{
+    Prim_Triangles,
+    Prim_Lines,
+    Prim_TriangleStrip,
+    Prim_Unknown,
+    Prim_Count
+};
+
+// Types of shaders that can be stored together in a ShaderSet.
+enum ShaderStage
+{
+    Shader_Vertex   = 0,
+    Shader_Fragment = 2,
+    Shader_Pixel    = 2,
+    Shader_Count    = 3,
+};
+
+enum MapFlags
+{
+    Map_Discard        = 1,
+    Map_Read           = 2, // do not use
+    Map_Unsynchronized = 4, // like D3D11_MAP_NO_OVERWRITE
+};
+
+
+// Buffer types used for uploading geometry & constants.
+enum BufferUsage
+{
+    Buffer_Unknown  = 0,
+    Buffer_Vertex   = 1,
+    Buffer_Index    = 2,
+    Buffer_Uniform  = 4,
+    Buffer_TypeMask = 0xff,
+    Buffer_ReadOnly = 0x100, // Buffer must be created with Data().
+};
+
+enum TextureFormat
+{
+    Texture_RGBA            = 0x0100,
+    Texture_Depth           = 0x8000,
+    Texture_TypeMask        = 0xff00,
+    Texture_SamplesMask     = 0x00ff,
+    Texture_RenderTarget    = 0x10000,
+    Texture_GenMipmaps      = 0x20000,
+};
+
+// Texture sampling modes.
+enum SampleMode
+{
+    Sample_Linear       = 0,
+    Sample_Nearest      = 1,
+    Sample_Anisotropic  = 2,
+    Sample_FilterMask   = 3,
+
+    Sample_Repeat       = 0,
+    Sample_Clamp        = 4,
+    Sample_ClampBorder  = 8, // If unsupported Clamp is used instead.
+    Sample_AddressMask  =12,
+
+    Sample_Count        =13,
+};
+
+
+// Rendering parameters/pointers describing GL rendering setup.
+struct RenderParams
+{
+#if defined(OVR_OS_WIN32)
+    HWND   Window;
+    HDC    DC;
+#elif defined(OVR_OS_LINUX)
+    _XDisplay*  Disp;
+    Window      Win;
+#endif
+
+    ovrSizei  RTSize;
+    int    Multisample;
+};
+
+
+class Buffer : public RefCountBase<Buffer>
+{
+public:
+    RenderParams* pParams;
+    size_t        Size;
+    GLenum        Use;
+    GLuint        GLBuffer;
+
+public:
+    Buffer(RenderParams* r);
+    ~Buffer();
+
+    GLuint         GetBuffer() { return GLBuffer; }
+
+    virtual size_t GetSize() { return Size; }
+    virtual void*  Map(size_t start, size_t size, int flags = 0);
+    virtual bool   Unmap(void *m);
+    virtual bool   Data(int use, const void* buffer, size_t size);
+};
+
+class Texture : public RefCountBase<Texture>
+{
+	bool IsUserAllocated;
+
+public:
+    RenderParams* pParams;
+    GLuint        TexId;
+    int           Width, Height;
+
+    Texture(RenderParams* rp, int w, int h);
+    ~Texture();
+
+    virtual int GetWidth() const { return Width; }
+    virtual int GetHeight() const { return Height; }
+
+    virtual void SetSampleMode(int sm);
+
+    // Updates texture to point to specified resources
+    //  - used for slave rendering.
+    void UpdatePlaceholderTexture(GLuint texId,
+                                  const Sizei& textureSize);
+
+    virtual void Set(int slot, ShaderStage stage = Shader_Fragment) const;
+};
+
+// Base class for vertex and pixel shaders. Stored in ShaderSet.
+class Shader : public RefCountBase<Shader>
+{
+    friend class ShaderSet;
+
+protected:
+    ShaderStage Stage;
+
+public:
+    Shader(ShaderStage s) : Stage(s) {}
+    virtual ~Shader() {}
+
+    ShaderStage GetStage() const { return Stage; }
+
+    virtual void Set(PrimitiveType) const { }
+    virtual void SetUniformBuffer(class Buffer* buffers, int i = 0) { OVR_UNUSED2(buffers, i); }
+
+protected:
+    virtual bool SetUniform(const char* name, int n, const float* v) { OVR_UNUSED3(name, n, v); return false; }
+    virtual bool SetUniformBool(const char* name, int n, const bool* v) { OVR_UNUSED3(name, n, v); return false; }
+};
+
+
+
+// A group of shaders, one per stage.
+// A ShaderSet is applied for rendering with a given fill.
+class ShaderSet : public RefCountBase<ShaderSet>
+{
+protected:
+    Ptr<Shader> Shaders[Shader_Count];
+
+    struct Uniform
+    {
+        String Name;
+        int    Location, Size;
+        int    Type; // currently number of floats in vector
+    };
+    Array<Uniform> UniformInfo;
+	
+public:
+	GLuint    Prog;
+    GLint     ProjLoc, ViewLoc;
+    GLint     TexLoc[8];
+    bool      UsesLighting;
+    int       LightingVer;
+
+    ShaderSet();
+    ~ShaderSet();
+
+    virtual void SetShader(Shader *s);
+    virtual void UnsetShader(int stage);
+    Shader* GetShader(int stage) { return Shaders[stage]; }
+
+    virtual void Set(PrimitiveType prim) const
+    {
+		glUseProgram(Prog);
+
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                Shaders[i]->Set(prim);
+    }
+
+    // Set a uniform (other than the standard matrices). It is undefined whether the
+    // uniforms from one shader occupy the same space as those in other shaders
+    // (unless a buffer is used, then each buffer is independent).     
+    virtual bool SetUniform(const char* name, int n, const float* v);
+    bool SetUniform1f(const char* name, float x)
+    {
+        const float v[] = {x};
+        return SetUniform(name, 1, v);
+    }
+    bool SetUniform2f(const char* name, float x, float y)
+    {
+        const float v[] = {x,y};
+        return SetUniform(name, 2, v);
+    }
+    bool SetUniform3f(const char* name, float x, float y, float z)
+    {
+        const float v[] = {x,y,z};
+        return SetUniform(name, 3, v);
+    }
+    bool SetUniform4f(const char* name, float x, float y, float z, float w = 1)
+    {
+        const float v[] = {x,y,z,w};
+        return SetUniform(name, 4, v);
+    }
+
+    bool SetUniformv(const char* name, const Vector3f& v)
+    {
+        const float a[] = {v.x,v.y,v.z,1};
+        return SetUniform(name, 4, a);
+    }
+ 
+    virtual bool SetUniform4x4f(const char* name, const Matrix4f& m)
+    {
+        Matrix4f mt = m.Transposed();
+        return SetUniform(name, 16, &mt.M[0][0]);
+    }
+
+protected:
+	GLint GetGLShader(Shader* s);
+    bool Link();
+};
+
+
+// Fill combines a ShaderSet (vertex, pixel) with textures, if any.
+// Every model has a fill.
+class ShaderFill : public RefCountBase<ShaderFill>
+{
+    Ptr<ShaderSet>     Shaders;
+    Ptr<class Texture> Textures[8];
+    void*              InputLayout; // HACK this should be abstracted
+
+public:
+    ShaderFill(ShaderSet* sh) : Shaders(sh) { InputLayout = NULL; }
+    ShaderFill(ShaderSet& sh) : Shaders(sh) { InputLayout = NULL; }    
+
+    ShaderSet*  GetShaders() const      { return Shaders; }
+    void*       GetInputLayout() const  { return InputLayout; }
+
+    virtual void Set(PrimitiveType prim = Prim_Unknown) const {
+		Shaders->Set(prim);
+		for(int i = 0; i < 8; i++)
+		{
+			if(Textures[i])
+			{
+				Textures[i]->Set(i);
+			}
+		}
+	}
+
+    virtual void SetTexture(int i, class Texture* tex) { if (i < 8) Textures[i] = tex; }
+};
+
+    
+struct DisplayId
+{
+    // Windows
+    String MonitorName; // Monitor name for fullscreen mode
+    
+    // MacOS
+    long   CgDisplayId; // CGDirectDisplayID
+    
+    DisplayId() : CgDisplayId(0) {}
+    DisplayId(long id) : CgDisplayId(id) {}
+    DisplayId(String m, long id=0) : MonitorName(m), CgDisplayId(id) {}
+    
+    operator bool () const
+    {
+        return MonitorName.GetLength() || CgDisplayId;
+    }
+    
+    bool operator== (const DisplayId& b) const
+    {
+        return CgDisplayId == b.CgDisplayId &&
+            (strstr(MonitorName.ToCStr(), b.MonitorName.ToCStr()) ||
+             strstr(b.MonitorName.ToCStr(), MonitorName.ToCStr()));
+    }
+};
+
+
+class ShaderBase : public Shader
+{
+public:    
+    RenderParams*   pParams;
+    unsigned char*  UniformData;
+    int             UniformsSize;
+
+	enum VarType
+	{
+		VARTYPE_FLOAT,
+		VARTYPE_INT,
+		VARTYPE_BOOL,
+	};
+
+	struct Uniform
+	{
+		const char* Name;
+		VarType Type;
+		int     Offset, Size;
+	};
+    const Uniform* UniformRefl;
+    size_t UniformReflSize;
+
+	ShaderBase(RenderParams* rp, ShaderStage stage) : Shader(stage), pParams(rp), UniformData(0), UniformsSize(0) {}
+	~ShaderBase()
+	{
+		if (UniformData)    
+			OVR_FREE(UniformData);
+	}
+
+    void InitUniforms(const Uniform* refl, size_t reflSize);
+	bool SetUniform(const char* name, int n, const float* v);
+	bool SetUniformBool(const char* name, int n, const bool* v);
+};
+
+
+template<ShaderStage SStage, GLenum SType>
+class ShaderImpl : public ShaderBase
+{
+    friend class ShaderSet;
+
+public:
+    ShaderImpl(RenderParams* rp, void* s, size_t size, const Uniform* refl, size_t reflSize)
+		: ShaderBase(rp, SStage)
+		, GLShader(0)
+    {
+		bool success;
+        OVR_UNUSED(size);
+        success = Compile((const char*) s);
+        OVR_ASSERT(success);
+		InitUniforms(refl, reflSize);
+    }
+    ~ShaderImpl()
+    {      
+		if (GLShader)
+		{
+			glDeleteShader(GLShader);
+			GLShader = 0;
+		}
+    }
+    bool Compile(const char* src)
+	{
+		if (!GLShader)
+			GLShader = glCreateShader(GLStage());
+
+		glShaderSource(GLShader, 1, &src, 0);
+		glCompileShader(GLShader);
+		GLint r;
+		glGetShaderiv(GLShader, GL_COMPILE_STATUS, &r);
+		if (!r)
+		{
+			GLchar msg[1024];
+			glGetShaderInfoLog(GLShader, sizeof(msg), 0, msg);
+			if (msg[0])
+				OVR_DEBUG_LOG(("Compiling shader\n%s\nfailed: %s\n", src, msg));
+
+			return 0;
+		}
+		return 1;
+	}
+	
+    GLenum GLStage() const
+    {
+		return SType;
+	}
+
+private:
+	GLuint GLShader;
+};
+
+typedef ShaderImpl<Shader_Vertex,  GL_VERTEX_SHADER> VertexShader;
+typedef ShaderImpl<Shader_Fragment, GL_FRAGMENT_SHADER> FragmentShader;
+
+
+}}}
+
+
+#endif // INC_OVR_CAPI_GL_Util_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,65 @@
+#ifndef DISTORTION_PS_H
+#define DISTORTION_PS_H
+
+static const unsigned char Distortion_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x7c, 0x85, 0xba, 0x67, 0x3a, 0xd7, 0x3f, 0x92, 
+    0xa7, 0x4b, 0x33, 0x10, 0x5b, 0x1b, 0x09, 0x5d, 0x01, 0x00, 0x00, 0x00, 
+    0xb4, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0xd8, 0x00, 0x00, 0x00, 0x4c, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 
+    0x38, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x9c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x6b, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x63, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x4c, 0x69, 0x6e, 0x65, 
+    0x61, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 
+    0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 
+    0x49, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x01, 0x01, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x06, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 
+    0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 
+    0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 0x4f, 0x53, 0x47, 0x4e, 
+    0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0xab, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0xb0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x2c, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x03, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04, 0x00, 0x70, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0x62, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x96, 0x15, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x07, 0x72, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x82, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.psh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.psh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,10 @@
+Texture2D    Texture : register(t0);
+SamplerState Linear  : register(s0);
+
+float4 main(in float4 oPosition  : SV_Position,
+            in float1 oColor     : COLOR,
+            in float2 oTexCoord0 : TEXCOORD0) : SV_Target
+{
+	float3 Result = Texture.SampleLevel(Linear, oTexCoord0, 0.0).rgb;
+	return float4(Result * oColor, 1.0 );
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1 @@
+// No data available for shader reflection Distortion_ps_refl
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,82 @@
+#ifndef DISTORTION_VS_H
+#define DISTORTION_VS_H
+
+static const unsigned char Distortion_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0xfd, 0x23, 0xd7, 0xc6, 0x1a, 0x85, 0x42, 0xd8, 
+    0xf1, 0xf2, 0x06, 0x88, 0x86, 0xf0, 0xd9, 0xc7, 0x01, 0x00, 0x00, 0x00, 
+    0x7c, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 
+    0x00, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xb4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 
+    0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x01, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0xdc, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x37, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x11, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,18 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;   
+    oTexCoord0  = EyeToSourceUVScale * TexCoord0 + EyeToSourceUVOffset;
+    oColor      = Color.r;      // Used for vignette fade.
+}
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef Distortion_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform Distortion_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,137 @@
+#ifndef DISTORTIONCHROMA_PS_H
+#define DISTORTIONCHROMA_PS_H
+
+static const unsigned char DistortionChroma_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x2b, 0x0d, 0x42, 0xef, 0x6d, 0xea, 0x8e, 0x3c, 
+    0xe8, 0x90, 0x79, 0x04, 0xfe, 0x42, 0xcf, 0xba, 0x01, 0x00, 0x00, 0x00, 
+    0x10, 0x06, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0xac, 0x01, 0x00, 0x00, 0x50, 0x02, 0x00, 0x00, 0x9c, 0x02, 0x00, 0x00, 
+    0x94, 0x05, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x70, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x3c, 0x01, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0xa3, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0d, 0x00, 0x00, 0x00, 0xb7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 
+    0x72, 0x65, 0x00, 0x4c, 0x61, 0x73, 0x74, 0x54, 0x65, 0x78, 0x74, 0x75, 
+    0x72, 0x65, 0x00, 0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 
+    0xb7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2c, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x69, 0x76, 0x65, 0x49, 0x6e, 0x76, 
+    0x52, 0x54, 0x53, 0x69, 0x7a, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x69, 0x76, 0x65, 0x53, 0x63, 0x61, 
+    0x6c, 0x65, 0x73, 0x00, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 
+    0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 
+    0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 
+    0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 
+    0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 
+    0x9c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x03, 0x00, 0x00, 
+    0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 
+    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 
+    0x52, 0x44, 0x00, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x44, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 
+    0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 
+    0xf0, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 
+    0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x03, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04, 0x00, 0x70, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04, 
+    0x00, 0x70, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 
+    0x64, 0x20, 0x00, 0x04, 0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0x12, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0x62, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0xc2, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x96, 0x15, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xe6, 0x1a, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x22, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 
+    0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x31, 0x00, 0x00, 0x08, 0x82, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x04, 0x03, 
+    0x3a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x08, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x31, 0x00, 0x00, 0x07, 0x72, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x02, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x0b, 0x72, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0xa6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf6, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x08, 0x72, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x20, 0x00, 0x09, 
+    0x72, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x82, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x80, 0x3f, 0x12, 0x00, 0x00, 0x01, 0x36, 0x00, 0x00, 0x05, 
+    0x72, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x82, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
+    0x15, 0x00, 0x00, 0x01, 0x36, 0x00, 0x00, 0x05, 0x72, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x82, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.psh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.psh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,37 @@
+Texture2D Texture : register(t0);
+Texture2D LastTexture : register(t1);
+SamplerState Linear : register(s0);
+
+float2 OverdriveInvRTSize;
+float2 OverdriveScales;
+
+void   main(in float4 oPosition  : SV_Position,
+            in float1 oColor     : COLOR,
+            in float2 oTexCoord0 : TEXCOORD0,
+            in float2 oTexCoord1 : TEXCOORD1,
+            in float2 oTexCoord2 : TEXCOORD2,
+			out float4 outColor0 : SV_Target0,
+			out float4 outColor1 : SV_Target1)
+{
+	float ResultR = Texture.SampleLevel(Linear, oTexCoord0, 0.0).r;
+	float ResultG = Texture.SampleLevel(Linear, oTexCoord1, 0.0).g;
+	float ResultB = Texture.SampleLevel(Linear, oTexCoord2, 0.0).b;
+	float3 newColor = float3(ResultR * oColor, ResultG * oColor, ResultB * oColor);
+
+	outColor0 = float4(newColor, 1.0);
+	outColor1 = outColor0;
+
+	// pixel luminance overdrive
+	if(OverdriveInvRTSize.x > 0)
+	{
+		float3 oldColor = LastTexture.SampleLevel(Linear, oPosition.xy * OverdriveInvRTSize.xy, 0.0).rgb;
+		
+		float3 adjustedScales;
+		adjustedScales.x = newColor.x > oldColor.x ? OverdriveScales.x : OverdriveScales.y;
+		adjustedScales.y = newColor.y > oldColor.y ? OverdriveScales.x : OverdriveScales.y;
+		adjustedScales.z = newColor.z > oldColor.z ? OverdriveScales.x : OverdriveScales.y;
+		
+		float3 overdriveColor = saturate(newColor + (newColor - oldColor) * adjustedScales);
+		outColor1 = float4(overdriveColor, 1.0);
+	}
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef DistortionChroma_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionChroma_ps_refl[] =
+{
+	{ "OverdriveInvRTSize", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "OverdriveScales", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,101 @@
+#ifndef DISTORTIONCHROMA_VS_H
+#define DISTORTIONCHROMA_VS_H
+
+static const unsigned char DistortionChroma_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x8e, 0x20, 0x97, 0xab, 0xce, 0xc8, 0x74, 0x3e, 
+    0xfe, 0xeb, 0x97, 0xa0, 0xe6, 0xca, 0x72, 0xa1, 0x01, 0x00, 0x00, 0x00, 
+    0x64, 0x04, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xd8, 0x01, 0x00, 0x00, 0x7c, 0x02, 0x00, 0x00, 
+    0xe8, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xb4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 
+    0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x98, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x01, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x9c, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x64, 0x01, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x59, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xc2, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x11, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 0xc2, 0x20, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x06, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x14, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xa6, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,30 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          in float2 TexCoord1   : TEXCOORD1,
+          in float2 TexCoord2   : TEXCOORD2,
+          out float4 oPosition  : SV_Position,          
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0,
+          out float2 oTexCoord1 : TEXCOORD1,
+          out float2 oTexCoord2 : TEXCOORD2)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+
+    // Scale them into  UV lookup space
+    float2 tc0scaled = EyeToSourceUVScale * TexCoord0 + EyeToSourceUVOffset;
+    float2 tc1scaled = EyeToSourceUVScale * TexCoord1 + EyeToSourceUVOffset;
+    float2 tc2scaled = EyeToSourceUVScale * TexCoord2 + EyeToSourceUVOffset;
+
+    oTexCoord0  = tc0scaled;        // R sample.
+    oTexCoord1  = tc1scaled;        // G sample.
+    oTexCoord2  = tc2scaled;        // B sample.
+    oColor      = Color.r;          // Used for vignette fade.
+}
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef DistortionChroma_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionChroma_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,167 @@
+#ifndef DISTORTIONTIMEWARP_VS_H
+#define DISTORTIONTIMEWARP_VS_H
+
+static const unsigned char DistortionTimewarp_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x96, 0x74, 0x01, 0x0e, 0x69, 0xc5, 0xe0, 0xbd, 
+    0x73, 0x27, 0xa6, 0x54, 0x7e, 0xee, 0xb9, 0xb6, 0x01, 0x00, 0x00, 0x00, 
+    0x7c, 0x07, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x98, 0x01, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x7c, 0x02, 0x00, 0x00, 
+    0x00, 0x07, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x5c, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x2b, 0x01, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1c, 0x01, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 
+    0x00, 0xab, 0xab, 0xab, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 
+    0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 
+    0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x09, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x7c, 0x04, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x1f, 0x01, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x92, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x68, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x22, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x82, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x82, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 
+    0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0x1f, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x62, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x81, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x81, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x12, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x62, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x22, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x52, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x42, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x92, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x82, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x82, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 
+    0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x96, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xa6, 0x8b, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,40 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+float4x4 EyeRotationStart;
+float4x4 EyeRotationEnd;
+
+float2 TimewarpTexCoordToWarpedPos(float2 inTexCoord, float4x4 rotMat)
+{
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.    
+    // Apply the 3x3 timewarp rotation to these vectors.
+	float3 transformed = float3( mul ( rotMat, float4(inTexCoord,1,1) ).xyz);
+    // Project them back onto the Z=1 plane of the rendered images.
+	float2 flattened = transformed.xy / transformed.z;
+    // Scale them into ([0,0.5],[0,1]) or ([0.5,0],[0,1]) UV lookup space (depending on eye)
+	return flattened * EyeToSourceUVScale + EyeToSourceUVOffset;
+	
+}
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,    
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0)
+{
+
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+
+    float timewarpLerpFactor = Color.a;
+    float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, timewarpLerpFactor);	
+
+    // Warped positions are a bit more involved, hence a separate function
+	oTexCoord0 = TimewarpTexCoordToWarpedPos(TexCoord0, lerpedEyeRot);
+    oColor = Color.r;              // Used for vignette fade.
+}
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,11 @@
+#ifndef DistortionTimewarp_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionTimewarp_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+	{ "EyeRotationStart", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+	{ "EyeRotationEnd", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,214 @@
+#ifndef DISTORTIONTIMEWARPCHROMA_VS_H
+#define DISTORTIONTIMEWARPCHROMA_VS_H
+
+static const unsigned char DistortionTimewarpChroma_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x46, 0xb0, 0x5a, 0x1b, 0xfd, 0x8c, 0xdb, 0xa9, 
+    0x8d, 0x82, 0x83, 0x1f, 0xd6, 0x4f, 0x4a, 0x8f, 0x01, 0x00, 0x00, 0x00, 
+    0xac, 0x09, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x98, 0x01, 0x00, 0x00, 0x38, 0x02, 0x00, 0x00, 0xdc, 0x02, 0x00, 0x00, 
+    0x30, 0x09, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x5c, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x2b, 0x01, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1c, 0x01, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 
+    0x00, 0xab, 0xab, 0xab, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 
+    0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 
+    0x49, 0x53, 0x47, 0x4e, 0x98, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x09, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x9c, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x4c, 0x06, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x93, 0x01, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x92, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xc2, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x68, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x22, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0x82, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
+    0x82, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 
+    0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0x1f, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x32, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x12, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x32, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x16, 0x85, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x85, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x22, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x52, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x42, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x92, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x82, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x82, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 0x22, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 
+    0x42, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x96, 0x05, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0xa6, 0x0a, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xa6, 0x8b, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 
+    0x22, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x06, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x32, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x11, 0x00, 0x00, 0x07, 
+    0x42, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x82, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 
+    0x32, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x0a, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0xc2, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x06, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x84, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
+    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,43 @@
+float2 EyeToSourceUVScale;
+float2 EyeToSourceUVOffset;
+float4x4 EyeRotationStart;
+float4x4 EyeRotationEnd;
+
+float2 TimewarpTexCoordToWarpedPos(float2 inTexCoord, float4x4 rotMat)
+{
+	// Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+	// These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.	
+	// Apply the 3x3 timewarp rotation to these vectors.
+	float3 transformed = float3( mul ( rotMat, float4(inTexCoord.xy, 1, 1) ).xyz);
+	// Project them back onto the Z=1 plane of the rendered images.
+	float2 flattened = transformed.xy / transformed.z;
+	// Scale them into ([0,0.5],[0,1]) or ([0.5,0],[0,1]) UV lookup space (depending on eye)
+	return flattened * EyeToSourceUVScale + EyeToSourceUVOffset;
+}
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          in float2 TexCoord1   : TEXCOORD1,
+          in float2 TexCoord2   : TEXCOORD2,
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0,
+          out float2 oTexCoord1 : TEXCOORD1,
+          out float2 oTexCoord2 : TEXCOORD2)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+     	    
+    float timewarpLerpFactor = Color.a;
+    float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, timewarpLerpFactor);
+
+    // warped positions are a bit more involved, hence a separate function
+	oTexCoord0 = TimewarpTexCoordToWarpedPos(TexCoord0, lerpedEyeRot);
+	oTexCoord1 = TimewarpTexCoordToWarpedPos(TexCoord1, lerpedEyeRot);
+	oTexCoord2 = TimewarpTexCoordToWarpedPos(TexCoord2, lerpedEyeRot);
+
+    oColor = Color.r;              // Used for vignette fade.
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,11 @@
+#ifndef DistortionTimewarpChroma_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionTimewarpChroma_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+	{ "EyeRotationStart", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+	{ "EyeRotationEnd", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/genPixelShaderHeader.bat	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/genPixelShaderHeader.bat	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,15 @@
+@echo off
+pushd %~dp0
+echo Compiling shader and packing into header: %~2
+setlocal
+
+set PATH=%PATH%;"%DXSDK_DIR%Utilities\bin\x86\"
+fxc.exe  /nologo /E main /T ps_4_0 /Fo "%1" %2
+bin2header.exe "%1"
+
+echo Generating shader reflection data for %1
+ShaderReflector "%1" "%1_refl.h"
+
+del "%1"
+endlocal
+popd
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/genVertexShaderHeader.bat	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/genVertexShaderHeader.bat	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,15 @@
+@echo off
+pushd %~dp0
+echo Compiling shader and packing into header: %~2
+setlocal
+
+set PATH=%PATH%;"%DXSDK_DIR%Utilities\bin\x86\"
+fxc.exe  /nologo /E main /T vs_4_0 /Fo "%1" %2
+bin2header.exe "%1"
+
+echo Generating shader reflection data for %1
+ShaderReflector "%1" "%1_refl.h"
+
+del "%1"
+endlocal
+popd
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,51 @@
+#ifndef SIMPLEQUAD_PS_H
+#define SIMPLEQUAD_PS_H
+
+static const unsigned char SimpleQuad_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x8c, 0x53, 0x2f, 0x7c, 0x3d, 0xea, 0xa5, 0xb6, 
+    0x05, 0xb7, 0xe0, 0x83, 0x67, 0x16, 0x9c, 0x93, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x00, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 
+    0x8c, 0x01, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xc4, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xab, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 
+    0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 
+    0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 
+    0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 
+    0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x08, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4f, 0x53, 0x47, 0x4e, 
+    0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0xab, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.psh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.psh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,6 @@
+float4 Color;
+
+float4 main() : SV_Target
+{
+   return Color;
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,8 @@
+#ifndef SimpleQuad_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleQuad_ps_refl[] =
+{
+	{ "Color", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,64 @@
+#ifndef SIMPLEQUAD_VS_H
+#define SIMPLEQUAD_VS_H
+
+static const unsigned char SimpleQuad_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0xd5, 0x40, 0x5f, 0xa6, 0x2d, 0x0a, 0xd9, 0x2a, 
+    0x84, 0x41, 0x9e, 0x1f, 0xab, 0xa5, 0xa9, 0x2c, 0x01, 0x00, 0x00, 0x00, 
+    0xa8, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0x6c, 0x01, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00, 
+    0x2c, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 
+    0xb8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
+    0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x66, 0x73, 
+    0x65, 0x74, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0xab, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 
+    0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x07, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x53, 0x48, 0x44, 0x52, 
+    0x84, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 
+    0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,8 @@
+float2 PositionOffset = float2(0, 0);
+float2 Scale = float2(1, 1);
+
+void main(	in  float3 Position		: POSITION,
+out float4 oPosition	: SV_Position)
+{
+	oPosition = float4(Position.xy * Scale + PositionOffset, 0.5, 1.0);
+}
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef SimpleQuad_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleQuad_vs_refl[] =
+{
+	{ "PositionOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "Scale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,77 @@
+#ifndef SIMPLETEXTUREDQUAD_PS_H
+#define SIMPLETEXTUREDQUAD_PS_H
+
+static const unsigned char SimpleTexturedQuad_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0xbe, 0x17, 0xf1, 0xab, 0xc8, 0x62, 0x4c, 0x11, 
+    0xe8, 0x29, 0xb0, 0x5b, 0x0b, 0xf8, 0x73, 0x38, 0x01, 0x00, 0x00, 0x00, 
+    0x44, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x54, 0x01, 0x00, 0x00, 0xc8, 0x01, 0x00, 0x00, 0xfc, 0x01, 0x00, 0x00, 
+    0xc8, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x18, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x8a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x53, 0x61, 
+    0x6d, 0x70, 0x6c, 0x65, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 
+    0x65, 0x00, 0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 
+    0x92, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xab, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 
+    0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 
+    0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 
+    0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 
+    0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 
+    0x74, 0x00, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0xc4, 0x00, 0x00, 0x00, 
+    0x40, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 
+    0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x5a, 0x00, 0x00, 0x03, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x58, 0x18, 0x00, 0x04, 0x00, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x55, 0x55, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0xf2, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x08, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x1e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x09, 
+    0xf2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.psh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.psh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,16 @@
+float4 Color;
+
+SamplerState LinearSampler : register(s0);
+Texture2D Texture : register(t0);
+
+struct Values
+{
+   float4 Position : SV_Position;
+   float4 Color    : COLOR0;
+   float2 TexCoord : TEXCOORD0;
+};
+
+float4 main(in Values inputValues) : SV_Target
+{
+    return Color * inputValues.Color * Texture.Sample(LinearSampler, inputValues.TexCoord);
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,8 @@
+#ifndef SimpleTexturedQuad_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleTexturedQuad_ps_refl[] =
+{
+	{ "Color", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,82 @@
+#ifndef SIMPLETEXTUREDQUAD_VS_H
+#define SIMPLETEXTUREDQUAD_VS_H
+
+static const unsigned char SimpleTexturedQuad_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0xe3, 0x2d, 0x41, 0xb3, 0xee, 0x4c, 0x7d, 0xb3, 
+    0x80, 0x0d, 0x3a, 0x0c, 0xb6, 0x80, 0x5e, 0xb1, 0x01, 0x00, 0x00, 0x00, 
+    0x7c, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 
+    0x00, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 
+    0xb8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
+    0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x66, 0x73, 
+    0x65, 0x74, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0xab, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 
+    0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x00, 0xab, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x07, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x0f, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0xdc, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x37, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0xf2, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0xf2, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.vsh	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.vsh	2014-08-11 16:08:44.000000000 -0700
@@ -0,0 +1,16 @@
+struct Values
+{
+   float4 Position : SV_Position;
+   float4 Color    : COLOR0;
+   float2 TexCoord : TEXCOORD0;
+};
+
+float2 PositionOffset = float2(0, 0);
+float2 Scale = float2(1, 1);
+
+void main(in float3 Position : POSITION, in float4 Color : COLOR0, in float2 TexCoord : TEXCOORD0, out Values outputValues)
+{
+   outputValues.Position = float4(Position.xy * Scale + PositionOffset, 0.5, 1.0);
+   outputValues.Color    = Color;
+   outputValues.TexCoord = TexCoord;
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs_refl.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs_refl.h	2014-08-11 16:10:18.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef SimpleTexturedQuad_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleTexturedQuad_vs_refl[] =
+{
+	{ "PositionOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "Scale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,32 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Display.cpp
+Content     :   Common implementation for display device
+Created     :   May 6, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Display.h"
+
+namespace OVR {
+
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,198 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Display.h
+Content     :   Contains platform independent display management
+Created     :   May 6, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Display_h
+#define OVR_Display_h
+
+#include "../Sensors/OVR_DeviceConstants.h" // Required for HmdTypeEnum
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_RefCount.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_String.h"
+#include "../Kernel/OVR_Math.h"
+
+namespace OVR {
+
+
+class DisplaySearchHandle : virtual public RefCountBaseV<DisplaySearchHandle>
+{
+public:
+	DisplaySearchHandle() {}
+
+	virtual ~DisplaySearchHandle() {}
+
+	void operator= (const DisplaySearchHandle&) {}
+};
+
+//-------------------------------------------------------------------------------------
+// ***** Display
+
+// Display object describes an Oculus HMD screen in LibOVR, providing information such
+// as EDID serial number and resolution in platform-independent manner.
+//
+// Display is an abstract base class to support OS and driver specific implementations.
+// It support HMD screen enumeration through GetDisplayCount/GetDisplay static functions.
+//
+// Examples of implementations of Display are the following:
+// Display_Win32_Generic - Compatibly mode implementation that maintains operation on
+//						   systems without drivers.
+// Display_Win32_Driver  - Driver-Based display
+// Display_OSX_Generic   - Additional compatibility mode implementation for OS X
+
+class Display : public RefCountBase<Display>
+{
+protected:
+	enum MirrorMode
+	{
+		MirrorEnabled = 0,
+		MirrorDisabled = 1
+	};
+
+	MirrorMode mirrorMode;
+
+	Display(
+            HmdTypeEnum deviceTypeGuess,
+#ifdef OVR_OS_MAC
+            uint32_t displayID,
+#else
+			const String& displayID,
+#endif
+			const String& modelName,
+			const String& editSerial,
+            const Sizei& logicalRes,
+			const Sizei& nativeRes,
+			const Vector2i& displayOffset, 
+			const uint64_t devNumber,
+			const uint32_t rotation,
+			const bool appExclusive):
+		DeviceTypeGuess(deviceTypeGuess),
+        DisplayID(displayID),
+		ModelName(modelName),
+		EdidSerialNumber(editSerial),
+		LogicalResolutionInPixels(logicalRes),
+		NativeResolutionInPixels(nativeRes),
+		DesktopDisplayOffset(displayOffset),
+		DeviceNumber(devNumber),
+		Rotation(rotation),
+		ApplicationExclusive(appExclusive)
+    {
+	}
+
+    void operator = (const Display&) { } // Quiet warning.
+
+public:
+	virtual ~Display() { }
+
+	// ----- Platform specific static Display functionality -----
+
+	// Mandatory function that sets up the display environment with
+	// any necessary shimming and function hooks. This should be one
+	// of the very first things your application does when it
+	// initializes LibOVR
+	static bool         Initialize();
+
+	// Returns a count of the detected displays. These are Rift displays
+	// attached directly to an active display port
+	static int          GetDisplayCount( DisplaySearchHandle* handle = NULL, bool extended = true, bool applicationOnly = true, bool extendedEDIDSerials = false );
+	// Returns a specific index of a display. Displays are sorted in no particular order.
+	static Ptr<Display> GetDisplay( int index = 0, DisplaySearchHandle* handle = NULL ); 
+
+
+    // Returns true if we are referencing the same display; useful for matching display
+    // objects with the ones already detected.
+    bool MatchDisplay(const Display* other)
+    {
+		// Note this is not checking the DeviceName, which corresponds to which monitor the device is.
+		// This allows matching to match a display that has changed how it is plugged in.
+		return (DisplayID == other->DisplayID) &&
+               (EdidSerialNumber == other->EdidSerialNumber) &&
+               (NativeResolutionInPixels == other->NativeResolutionInPixels) &&
+               (DesktopDisplayOffset == other->DesktopDisplayOffset) &&
+               (ApplicationExclusive == other->ApplicationExclusive);
+    }
+
+
+	// ----- Device independent instance based Display functionality -----
+
+    // Device type guess based on display info.
+    const HmdTypeEnum   DeviceTypeGuess;
+#if defined(OVR_OS_MAC)
+    // CGDirectDisplayID for the rift.
+    const uint32_t      DisplayID; 
+#else
+	// A string denoting the display device name so that apps can recognize the monitor
+	const String        DisplayID;
+#endif
+    // A literal string containing the name of the model, i.e. Rift DK2
+    const String        ModelName;
+    // Part of the serial number encoded in Edid, used for monitor <-> sensor matching.
+    const String        EdidSerialNumber;
+    // Logical resolution is the display resolution in presentation terms.
+    // That is to say, the resolution that represents the orientation the
+    // display is projected to the user. For DK2, while being a portrait display
+    // the display is held in landscape and therefore the logical resolution
+    // is 1920x1080
+    const Sizei         LogicalResolutionInPixels;
+    // Native resolution is the resolution reported by the EDID and represents the
+    // exact hardware resolution of the Rift. For example, on DK2
+    // this is 1080x1920
+    // In theory, an OS rotated Rift's native and logical resolutions should match
+    const Sizei         NativeResolutionInPixels;
+    // For displays that are attached to the desktop, this return value has meaning.
+    // Otherwise it should always return origin
+    const Vector2i      DesktopDisplayOffset;
+	// For Windows machines this value stores the ChildUid used to identify this display
+	const uint64_t	    DeviceNumber;
+	// Stores the device specific default rotation of the screen
+	// E.g. DK2 is rotated 90 degrees as it is a portrait display
+	const uint32_t	    Rotation;
+	// Is set if the Display is capable in Application-Only mode
+	const bool			ApplicationExclusive;
+
+	// Functionality for rendering within the window
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode ) = 0;
+
+	// Functionality for enabling/disabling display
+    virtual bool SetDisplaySleep(bool off)
+    {
+        // Override to implement if supported
+        OVR_UNUSED(off);
+        return false;
+    }
+
+    // Check if right now the current rendering application should be in compatibility mode
+    static bool InCompatibilityMode( bool displaySearch = true );
+
+    static DisplaySearchHandle* GetDisplaySearchHandle();
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1035 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_Display.cpp
+Content     :   Win32 Display implementation
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include <Windows.h>
+
+#include "OVR_Win32_Display.h"
+#include "OVR_Win32_Dxgi_Display.h"
+
+#include <stdio.h>
+#include <tchar.h>
+#include <string.h>
+#include <stdlib.h>
+#include <winioctl.h>
+#include <SetupAPI.h>
+#include <Mmsystem.h>
+#include <conio.h>
+# pragma comment(lib, "wbemuuid.lib")
+#include <wbemidl.h>
+#include <AtlBase.h>
+#include <AtlConv.h>
+
+// WIN32_LEAN_AND_MEAN included in OVR_Atomic.h may break 'byte' declaration.
+#ifdef WIN32_LEAN_AND_MEAN
+ typedef unsigned char byte;
+#endif
+
+#include "../Kernel/OVR_String.h"
+#include "../Kernel/OVR_Log.h"
+
+typedef struct
+{
+	HANDLE	hDevice;
+	UINT	ExpectedWidth;
+	UINT	ExpectedHeight;
+	HWND	hWindow;
+	bool	InCompatibilityMode;
+} ContextStruct;
+
+static ContextStruct GlobalDisplayContext = {0};
+
+ 
+//-------------------------------------------------------------------------------------
+// ***** Display enumeration Helpers
+
+// THere are two ways to enumerate display: through our driver (DeviceIoControl)
+// and through Win32 EnumDisplayMonitors (compatibility mode).
+
+
+namespace OVR { 
+
+ULONG getRiftCount( HANDLE hDevice )
+{
+	ULONG riftCount = 0;
+	DWORD bytesReturned = 0;
+
+	BOOL result = DeviceIoControl( hDevice, IOCTL_RIFTMGR_GET_RIFT_COUNT, NULL, 0,
+                                   &riftCount, sizeof( ULONG ), &bytesReturned, NULL );
+
+	if( result )
+		return riftCount;
+	else
+		return 0;
+}
+
+ULONG getRift( HANDLE hDevice, int index )
+{
+	ULONG riftCount = getRiftCount( hDevice );
+	DWORD bytesReturned = 0;
+	BOOL result; 
+
+	if( riftCount >= (ULONG)index )
+	{
+		RIFT_STATUS riftStatus[16] = {0};
+
+		result = DeviceIoControl( hDevice, IOCTL_RIFTMGR_GET_RIFT_ARRAY, riftStatus,
+                                  riftCount * sizeof( RIFT_STATUS ), &riftCount,
+                                  sizeof( ULONG ), &bytesReturned, NULL );
+		if( result )
+		{
+			PRIFT_STATUS tmpRift;
+			unsigned int i;
+			for( i = 0, tmpRift = riftStatus; i < riftCount; ++i, ++tmpRift )
+			{
+				if( i == (unsigned int)index )
+					return tmpRift->childUid;
+			}
+		}
+		else
+		{
+			printf("Failed to get array of rift devices\n");
+		}
+	}
+
+	return 0;
+}
+
+#define EDID_LENGTH                             0x80
+
+#define EDID_HEADER                             0x00
+#define EDID_HEADER_END                         0x07
+
+#define ID_MANUFACTURER_NAME                    0x08
+#define ID_MANUFACTURER_NAME_END                0x09
+
+#define EDID_STRUCT_VERSION                     0x12
+#define EDID_STRUCT_REVISION                    0x13
+
+#define ESTABLISHED_TIMING_1                    0x23
+#define ESTABLISHED_TIMING_2                    0x24
+#define MANUFACTURERS_TIMINGS                   0x25
+
+#define DETAILED_TIMING_DESCRIPTIONS_START      0x36
+#define DETAILED_TIMING_DESCRIPTION_SIZE        18
+#define NO_DETAILED_TIMING_DESCRIPTIONS         4
+
+#define DETAILED_TIMING_DESCRIPTION_1           0x36
+#define DETAILED_TIMING_DESCRIPTION_2           0x48
+#define DETAILED_TIMING_DESCRIPTION_3           0x5a
+#define DETAILED_TIMING_DESCRIPTION_4           0x6c
+
+#define MONITOR_NAME            0xfc
+#define MONITOR_LIMITS          0xfd
+#define MONITOR_SERIAL			0xff
+
+#define UNKNOWN_DESCRIPTOR      -1
+#define DETAILED_TIMING_BLOCK   -2
+
+#define DESCRIPTOR_DATA         5
+
+const byte edid_v1_header[] = { 0x00, 0xff, 0xff, 0xff,
+	                            0xff, 0xff, 0xff, 0x00 };
+
+const byte edid_v1_descriptor_flag[] = { 0x00, 0x00 };
+
+
+static int blockType( byte* block )
+{
+	if ( !strncmp( (const char*)edid_v1_descriptor_flag, (const char*)block, 2 ) )
+	{
+		// descriptor
+		if ( block[ 2 ] != 0 )
+			return UNKNOWN_DESCRIPTOR;
+		return block[ 3 ];
+	}
+    else
+    {		
+		return DETAILED_TIMING_BLOCK;
+	}
+}
+
+static char* getMonitorName( byte const* block )
+{
+	static char name[ 13 ];
+	unsigned    i;
+	byte const* ptr = block + DESCRIPTOR_DATA;
+
+	for( i = 0; i < 13; i++, ptr++ )
+	{
+		if ( *ptr == 0xa )
+		{
+			name[ i ] = 0;
+			return name;
+		}
+
+		name[ i ] = *ptr;
+	}
+
+	return name;
+}
+
+
+static bool parseEdid( byte* edid, OVR::Win32::DisplayEDID& edidResult )
+{
+	unsigned i;
+	byte* block;
+	char* monitor_name = "Unknown";
+	byte checksum = 0;
+
+	for( i = 0; i < EDID_LENGTH; i++ )
+		checksum += edid[ i ];
+
+	// Bad checksum, fail EDID
+	if (  checksum != 0  )
+		return false;
+
+	if ( strncmp( (const char*)edid+EDID_HEADER, (const char*)edid_v1_header, EDID_HEADER_END+1 ) )
+	{
+		// First bytes don't match EDID version 1 header
+		return false;
+	}
+
+	//printf( "\n# EDID version %d revision %d\n", (int)edid[EDID_STRUCT_VERSION],(int)edid[EDID_STRUCT_REVISION] );
+
+	// Monitor name and timings 
+
+	char serialNumber[14];
+	memset( serialNumber, 0, 14 );
+
+	block = edid + DETAILED_TIMING_DESCRIPTIONS_START;
+
+	for( i = 0; i < NO_DETAILED_TIMING_DESCRIPTIONS; i++,
+		block += DETAILED_TIMING_DESCRIPTION_SIZE )
+	{
+
+		if ( blockType( block ) == MONITOR_NAME )
+		{
+			monitor_name = getMonitorName( block );
+		}
+
+		if( blockType( block ) == MONITOR_SERIAL )
+		{
+			memcpy( serialNumber, block + 5, 13 );
+			break;
+		}
+	}
+
+	BYTE vendorString[4] = {0};
+
+	vendorString[0] = (edid[8] >> 2 & 31) + 64;
+	vendorString[1] = ((edid[8] & 3) << 3) | (edid[9] >> 5) + 64;
+	vendorString[2] = (edid[9] & 31) + 64;
+
+	edidResult.ModelNumber  = *(UINT16*)&edid[10];
+	edidResult.MonitorName  = OVR::String(monitor_name);
+	edidResult.VendorName   = OVR::String((const char*)vendorString);
+	edidResult.SerialNumber = OVR::String(serialNumber);
+	
+#if 0
+	printf( "\tIdentifier \"%s\"\n", monitor_name );
+	printf( "\tVendorName \"%s\"\n", vendorString );
+	printf( "\tModelName \"%s\"\n", monitor_name );
+	printf( "\tModelNumber %d\n", modelNumber );
+	printf( "\tSerialNumber \"%x\"\n", *serialPointer );
+#endif
+
+	// FIXME: Get timings as well, though they aren't very useful here
+	// except for the vertical refresh rate, presumably
+
+	return true;
+}
+
+static bool getEdid(HANDLE hDevice, ULONG uid, OVR::Win32::DisplayEDID& edidResult)
+{
+	ULONG       riftCount = 0;
+	DWORD       bytesReturned = 0;
+	RIFT_STATUS riftStatus[16] = {0};
+
+	BOOL result = DeviceIoControl( hDevice, IOCTL_RIFTMGR_GET_RIFT_COUNT, NULL, 0,
+                                   &riftCount, sizeof( ULONG ), &bytesReturned, NULL );
+
+    if (!result)
+    {
+        return false;
+    }
+
+	result = DeviceIoControl( hDevice, IOCTL_RIFTMGR_GET_RIFT_ARRAY, &riftStatus,
+                              riftCount * sizeof( RIFT_STATUS ), &riftCount, sizeof(ULONG),
+                              &bytesReturned, NULL );
+    if (!result)
+    {
+        return false;
+    }
+
+    for (ULONG i = 0; i < riftCount; ++i)
+    {
+		ULONG riftUid = riftStatus[i].childUid;
+        if (riftUid == uid)
+        {
+            char edidBuffer[512];
+
+            result = DeviceIoControl(hDevice, IOCTL_RIFTMGR_GETEDID, &riftUid, sizeof(ULONG),
+                                     edidBuffer, 512, &bytesReturned, NULL);
+
+            if (result)
+            {
+                if (parseEdid((byte*)edidBuffer, edidResult))
+                {
+                    return true;
+                }
+                else
+                {
+                    OVR_DEBUG_LOG(("[Win32Display] WARNING: The driver was not able to return EDID for a display"));
+                }
+            }
+
+            break;
+        }
+	}
+
+    return false;
+}
+
+
+// Used to capture all the active monitor handles
+struct MonitorSet
+{
+    enum { MaxMonitors = 8 };
+    HMONITOR Monitors[MaxMonitors];
+    int      MonitorCount;
+    int      PrimaryCount;
+};
+
+static BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC, LPRECT, LPARAM dwData)
+{
+	MonitorSet* monitorSet = (MonitorSet*)dwData;
+	if (monitorSet->MonitorCount >= MonitorSet::MaxMonitors)
+		return FALSE;
+
+	monitorSet->Monitors[monitorSet->MonitorCount] = hMonitor;
+	monitorSet->MonitorCount++;
+	return TRUE;
+};
+
+
+static bool getCompatDisplayEDID( WCHAR* displayName, String& serialNumberStr, String& userFriendlyNameStr )
+{
+	USES_CONVERSION;
+
+	IWbemLocator *pLoc = NULL;
+	IWbemServices *pSvc = NULL;
+	HRESULT hres;
+
+	static bool initialized = false;
+	static bool selfInitialized = true;
+	if (!initialized)
+	{
+		hres = CoInitializeEx(0, COINIT_MULTITHREADED);
+		if (FAILED(hres))
+		{
+			OVR_DEBUG_LOG_TEXT(("Failed to initialize COM library. Error code = 0x%x\n", hres));
+			return false;
+		}
+
+		hres = CoInitializeSecurity(
+			NULL,
+			-1,                          // COM authentication
+			NULL,                        // Authentication services
+			NULL,                        // Reserved
+			RPC_C_AUTHN_LEVEL_DEFAULT,   // Default authentication 
+			RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation  
+			NULL,                        // Authentication info
+			EOAC_NONE,                   // Additional capabilities 
+			NULL                         // Reserved
+			);
+
+		if (FAILED(hres))
+		{
+			OVR_DEBUG_LOG_TEXT(("Failed to initialize security. Error code = 0x%x\n", hres));
+			//CoUninitialize();
+			//return false;
+			selfInitialized = false;
+		}
+
+		initialized = true;
+	}
+
+	hres = CoCreateInstance(
+		CLSID_WbemLocator,
+		0,
+		CLSCTX_INPROC_SERVER,
+		IID_IWbemLocator, (LPVOID *)&pLoc);
+
+	if (FAILED(hres))
+	{
+		OVR_DEBUG_LOG_TEXT(("Failed to create IWbemLocator object. Err code = 0x%x\n", hres));
+		return false;
+	}
+
+	BSTR AbackB = SysAllocString(L"root\\WMI");
+	// Connect to the root\cimv2 namespace with
+	// the current user and obtain pointer pSvc
+	// to make IWbemServices calls.
+	hres = pLoc->ConnectServer(
+		AbackB, // Object path of WMI namespace
+		NULL,                    // User name. NULL = current user
+		NULL,                    // User password. NULL = current
+		0,                       // Locale. NULL indicates current
+		NULL,                    // Security flags.
+		0,                       // Authority (e.g. Kerberos)
+		0,                       // Context object 
+		&pSvc                    // pointer to IWbemServices proxy
+		);
+	SysFreeString(AbackB);
+
+	if (FAILED(hres))
+	{
+		OVR_DEBUG_LOG_TEXT(("Could not connect. Error code = 0x%x\n", hres));
+		pLoc->Release();
+		return false;
+	}
+
+	hres = CoSetProxyBlanket(
+		pSvc,                        // Indicates the proxy to set
+		RPC_C_AUTHN_WINNT,           // RPC_C_AUTHN_xxx
+		RPC_C_AUTHZ_NONE,            // RPC_C_AUTHZ_xxx
+		NULL,                        // Server principal name 
+		RPC_C_AUTHN_LEVEL_CALL,      // RPC_C_AUTHN_LEVEL_xxx 
+		RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx
+		NULL,                        // client identity
+		EOAC_NONE                    // proxy capabilities 
+		);
+
+	if (FAILED(hres))
+	{
+		OVR_DEBUG_LOG_TEXT(("Could not set proxy blanket. Error code = 0x%x\n", hres));
+		pSvc->Release();
+		pLoc->Release();
+		return false;
+	}
+
+
+	BSTR wql = SysAllocString(L"WQL");
+	BSTR select = SysAllocString(L"SELECT * FROM WmiMonitorID");
+	IEnumWbemClassObject* pEnumerator = NULL;
+	hres = pSvc->ExecQuery(
+		wql,
+		select,
+		WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
+		NULL,
+		&pEnumerator);
+	SysFreeString(wql);
+	SysFreeString(select);
+
+	if (FAILED(hres))
+	{
+		OVR_DEBUG_LOG_TEXT(( "Query for operating system name failed. Error code = 0x%x\n", hres )); 
+		pSvc->Release();
+		pLoc->Release();
+		return false;
+	}
+
+	IWbemClassObject *pclsObj = 0;
+	while (pEnumerator)
+	{
+        ULONG uReturn = 0;
+        HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
+
+        if (FAILED(hr) || !uReturn)
+        {
+            break;
+        }
+
+        VARIANT vtProp;
+        hr = pclsObj->Get(L"InstanceName", 0, &vtProp, 0, 0);
+
+        WCHAR* instanceName = vtProp.bstrVal;
+        WCHAR* nextToken = NULL;
+        if (SUCCEEDED(hr) &&
+            wcstok_s(instanceName, L"\\", &nextToken) != NULL)
+        {
+            WCHAR* aToken = wcstok_s(NULL, L"\\", &nextToken);
+
+            if (aToken != NULL)
+            {
+                VariantClear(&vtProp);
+
+                if (wcscmp(aToken, displayName) != 0)
+                {
+                    pclsObj->Release();
+                    continue;
+                }
+
+                // Read serial
+
+                hr = pclsObj->Get(L"SerialNumberID", 0, &vtProp, 0, 0);
+
+                if (SUCCEEDED(hr))
+                {
+                    if (vtProp.vt != VT_NULL && vtProp.parray != NULL)
+                    {
+                        static const int MaxSerialBytes = 14;
+                        char serialNumber[MaxSerialBytes] = { 0 };
+
+                        UINT32* serialArray = (UINT32*)vtProp.parray->pvData;
+                        for (int i = 0; i < MaxSerialBytes; ++i)
+                        {
+                            serialNumber[i] = (BYTE)(serialArray[i] & 0xff);
+                        }
+
+                        serialNumber[sizeof(serialNumber)-1] = '\0';
+                        serialNumberStr = serialNumber;
+                    }
+                    else
+                    {
+                        OVR_DEBUG_LOG(("[Win32Display] WARNING: Wrong data format for SerialNumberID"));
+                    }
+
+                    VariantClear(&vtProp);
+                }
+                else
+                {
+                    OVR_DEBUG_LOG(("[Win32Display] WARNING: Failure getting display SerialNumberID: %d", (int)hr));
+                }
+
+                // Read length of name
+
+                int userFriendlyNameLen = 0;
+
+                hr = pclsObj->Get(L"UserFriendlyNameLength", 0, &vtProp, 0, 0);
+
+                if (SUCCEEDED(hr))
+                {
+                    if (vtProp.vt != VT_NULL)
+                    {
+                        userFriendlyNameLen = vtProp.iVal;
+
+                        if (userFriendlyNameLen <= 0)
+                        {
+                            userFriendlyNameLen = 0;
+
+                            OVR_DEBUG_LOG(("[Win32Display] WARNING: UserFriendlyNameLength = 0"));
+                        }
+                    }
+                    else
+                    {
+                        OVR_DEBUG_LOG(("[Win32Display] WARNING: Wrong data format for UserFriendlyNameLength"));
+                    }
+
+                    VariantClear(&vtProp);
+                }
+                else
+                {
+                    OVR_DEBUG_LOG(("[Win32Display] WARNING: Failure getting display UserFriendlyNameLength: %d", (int)hr));
+                }
+
+                // Read name
+
+                hr = pclsObj->Get(L"UserFriendlyName", 0, &vtProp, 0, 0);
+
+                if (SUCCEEDED(hr) && userFriendlyNameLen > 0)
+                {
+                    if (vtProp.vt != VT_NULL && vtProp.parray != NULL)
+                    {
+                        static const int MaxNameBytes = 64;
+                        char userFriendlyName[MaxNameBytes] = { 0 };
+
+                        UINT32* nameArray = (UINT32*)vtProp.parray->pvData;
+                        for (int i = 0; i < MaxNameBytes && i < userFriendlyNameLen; ++i)
+                        {
+                            userFriendlyName[i] = (BYTE)(nameArray[i] & 0xff);
+                        }
+
+                        userFriendlyName[sizeof(userFriendlyName)-1] = '\0';
+                        userFriendlyNameStr = userFriendlyName;
+                    }
+                    else
+                    {
+                        // See: https://developer.oculusvr.com/forums/viewtopic.php?f=34&t=10961
+                        // This can happen if someone has an EDID override in the registry.
+                        OVR_DEBUG_LOG(("[Win32Display] WARNING: Wrong data format for UserFriendlyName"));
+                    }
+
+                    VariantClear(&vtProp);
+                }
+                else
+                {
+                    OVR_DEBUG_LOG(("[Win32Display] WARNING: Failure getting display UserFriendlyName: %d", (int)hr));
+                }
+            }
+        }
+
+        pclsObj->Release();
+        break;
+	}
+
+	HMODULE hModule = GetModuleHandleA("wbemuuid");
+	if (hModule)
+	{
+		DisableThreadLibraryCalls(hModule);
+	}
+
+	pSvc->Release();
+	pLoc->Release();
+	pEnumerator->Release();
+
+	return true;
+}
+
+// This is function that's used 
+bool anyRiftsInExtendedMode()
+{
+	bool result = false;
+
+	MonitorSet monitors;
+	monitors.MonitorCount = 0;
+	// Get all the monitor handles 
+	EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&monitors);
+
+	DISPLAY_DEVICE dd, ddm;
+	UINT           i, j;
+
+	for( i = 0;
+		(ZeroMemory(&dd, sizeof(dd)), dd.cb = sizeof(dd),
+		EnumDisplayDevices(0, i, &dd, 0)) != 0;  i++ )
+	{
+		for( j = 0;
+			(ZeroMemory(&ddm, sizeof(ddm)), ddm.cb = sizeof(ddm),
+			EnumDisplayDevices(dd.DeviceName, j, &ddm, 0)) != 0;  j++ )
+		{
+			// Our monitor hardware has string "RTD2205" in it
+			// Nate's device "CVT0003"
+			if( wcsstr(ddm.DeviceID, L"RTD2205") ||
+				wcsstr(ddm.DeviceID, L"CVT0003") ||
+				wcsstr(ddm.DeviceID, L"MST0030") ||
+				wcsstr(ddm.DeviceID, L"OVR00") ) // Part of Oculus EDID.
+			{
+				result = true;
+			}
+		}
+	}
+
+	return result;
+}
+
+static int discoverExtendedRifts(OVR::Win32::DisplayDesc* descriptorArray, int inputArraySize, bool includeEDID)
+{
+	static bool reportDiscovery = true;
+
+	int result = 0;
+
+	MonitorSet monitors;
+	monitors.MonitorCount = 0;
+	// Get all the monitor handles 
+	EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&monitors);
+
+	DISPLAY_DEVICE dd, ddm;
+	UINT           i, j;    
+
+	for (i = 0; 
+		(ZeroMemory(&dd, sizeof(dd)), dd.cb = sizeof(dd),
+		EnumDisplayDevices(0, i, &dd, 0)) != 0;  i++)
+	{
+		for (j = 0; 
+			(ZeroMemory(&ddm, sizeof(ddm)), ddm.cb = sizeof(ddm),
+			EnumDisplayDevices(dd.DeviceName, j, &ddm, 0)) != 0;  j++)
+		{
+			if( result >= inputArraySize )
+				return result;
+
+			// Our monitor hardware has string "RTD2205" in it
+			// Nate's device "CVT0003"
+			if (wcsstr(ddm.DeviceID, L"RTD2205") || 
+				wcsstr(ddm.DeviceID, L"CVT0003") || 
+				wcsstr(ddm.DeviceID, L"MST0030") ||
+				wcsstr(ddm.DeviceID, L"OVR00") ) // Part of Oculus EDID.
+			{
+				String   deviceId(ddm.DeviceID);
+				String   displayDeviceName(ddm.DeviceName);				
+                Vector2i desktopOffset(0, 0);
+                Sizei    monitorResolution(1280, 800);   
+
+                // Make a device type guess
+                HmdTypeEnum deviceTypeGuess = HmdType_Unknown;
+                if (wcsstr(ddm.DeviceID, L"OVR0003"))
+                {
+                    // DK2 prototypes and variants
+                    deviceTypeGuess = HmdType_DK2;
+                    // Could also be:
+                    // HmdType_CrystalCoveProto
+                }
+                else if (wcsstr(ddm.DeviceID, L"OVR0002"))
+                {   // HD Prototypes
+                    deviceTypeGuess = HmdType_DKHDProto;
+                    // Could also be:
+                    // HmdType_DKHD2Proto
+                    // HmdType_DKHDProto566Mi
+                }
+                else if (wcsstr(ddm.DeviceID, L"OVR0001"))
+                {   // DK1
+                    deviceTypeGuess = HmdType_DK1;
+                }
+                else if (wcsstr(ddm.DeviceID, L"OVR00"))
+                {   // Future Oculus HMD devices
+                    deviceTypeGuess = HmdType_Unknown;
+                }
+                else
+                {
+                    deviceTypeGuess = HmdType_DKProto;
+                }
+
+				// Find the matching MONITORINFOEX for this device so we can get the 
+				// screen coordinates
+				MONITORINFOEX info;
+				for (int m=0; m < monitors.MonitorCount; m++)
+				{
+					info.cbSize = sizeof(MONITORINFOEX);
+					GetMonitorInfo(monitors.Monitors[m], &info);
+					if (_tcsstr(ddm.DeviceName, info.szDevice) == ddm.DeviceName)
+					{   // If the device name starts with the monitor name
+						// then we found the matching DISPLAY_DEVICE and MONITORINFO
+						// so we can gather the monitor coordinates
+                        desktopOffset = Vector2i(info.rcMonitor.left, info.rcMonitor.top);
+						break;
+					}
+				}
+
+				WCHAR* instanceBuffer = (WCHAR*)calloc(wcslen(ddm.DeviceID) + 1, sizeof(WCHAR));
+				wcscpy_s(instanceBuffer, wcslen(ddm.DeviceID) + 1, ddm.DeviceID);
+				WCHAR* instanceName = instanceBuffer;
+				WCHAR* nextToken = NULL;
+				if (wcstok_s(instanceName, L"\\", &nextToken))
+				{
+					WCHAR* aToken = wcstok_s(NULL, L"\\", &nextToken);
+
+					if (aToken)
+					{
+						String serialNumberStr, userFriendlyNameStr;
+                        if (!includeEDID || getCompatDisplayEDID(aToken, serialNumberStr, userFriendlyNameStr))
+						{
+							// Set descriptor
+							OVR::Win32::DisplayDesc& desc = descriptorArray[result++];
+
+                            // If not including EDID,
+                            if (!includeEDID)
+                            {
+                                // If DK2 id,
+                                if (wcsstr(ddm.DeviceID, L"OVR0003"))
+                                {
+                                    userFriendlyNameStr = "Rift DK2";
+                                }
+                                else // Assume DK1 for now:
+                                {
+                                    userFriendlyNameStr = "Rift DK1";
+                                }
+                            }
+
+                            desc.DeviceTypeGuess = deviceTypeGuess;
+                            desc.DisplayID = displayDeviceName;
+							desc.ModelName = userFriendlyNameStr;
+							desc.EdidSerialNumber = serialNumberStr;
+							desc.LogicalResolutionInPixels = monitorResolution;
+							desc.DesktopDisplayOffset = desktopOffset;
+
+							// Hard-coded defaults in case the device doesn't have the data itself.
+							// DK2 prototypes (0003) or DK HD Prototypes (0002)                
+							if (wcsstr(ddm.DeviceID, L"OVR0003") || wcsstr(ddm.DeviceID, L"OVR0002"))
+							{
+								desc.LogicalResolutionInPixels = Sizei(1920, 1080);
+								desc.NativeResolutionInPixels = Sizei(1080, 1920);
+							}
+							else
+							{
+								desc.LogicalResolutionInPixels = monitorResolution;
+								desc.NativeResolutionInPixels = monitorResolution;
+							}
+						}
+					}
+				}
+
+				if (reportDiscovery)
+				{
+					// Only report once per run
+					OVR_DEBUG_LOG_TEXT(("Display Found %s - %s\n",
+						deviceId.ToCStr(), displayDeviceName.ToCStr()));
+					reportDiscovery = false;
+				}
+
+				free(instanceBuffer);
+
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Display 
+
+bool Display::InCompatibilityMode( bool displaySearch )
+{
+	bool result = false;
+	if( displaySearch )
+	{
+    OVR::Win32::DisplayDesc displayArray[8];
+
+	int extendedRiftCount = discoverExtendedRifts(displayArray, 8, false);
+	if( extendedRiftCount )
+	{
+		result = true;
+	}
+	else
+	{
+			result = GlobalDisplayContext.InCompatibilityMode;
+		}
+	}
+	else
+	{
+		result = GlobalDisplayContext.InCompatibilityMode;
+	}
+
+	return result;
+}
+
+#define OVR_FLAG_COMPATIBILITY_MODE 1
+
+bool Display::Initialize()
+{
+	HANDLE hDevice = INVALID_HANDLE_VALUE;
+
+	hDevice = CreateFile( L"\\\\.\\ovr_video" ,
+		                  GENERIC_READ | GENERIC_WRITE, NULL,
+		                  NULL, OPEN_EXISTING, NULL, NULL);
+
+	if (hDevice != NULL && hDevice != INVALID_HANDLE_VALUE)
+	{
+		GlobalDisplayContext.hDevice             = hDevice;
+		GlobalDisplayContext.InCompatibilityMode = FALSE;
+
+		DWORD bytesReturned = 0;
+		LONG compatiblityResult = OVR_STATUS_SUCCESS;
+
+		BOOL result = DeviceIoControl( hDevice, IOCTL_RIFTMGR_GETCOMPATIBILITYMODE, NULL, 0,
+                                       &compatiblityResult, sizeof( LONG ), &bytesReturned, NULL );
+		if (result)
+		{
+			if( compatiblityResult & OVR_FLAG_COMPATIBILITY_MODE )
+				GlobalDisplayContext.InCompatibilityMode = TRUE;
+		}
+		else
+		{
+			// If calling our driver fails in any way, assume compatibility mode as well
+			GlobalDisplayContext.InCompatibilityMode = TRUE;
+		}
+
+		if (!GlobalDisplayContext.InCompatibilityMode)
+		{
+			Ptr<DisplaySearchHandle> searchHandle = *Display::GetDisplaySearchHandle();
+
+			// If a display is actually connected, bring up the shim layers so we can actually use it
+			if (GetDisplayCount(searchHandle) > 0)
+			{
+				// FIXME: Initializing DX9 with landscape numbers rather than portrait
+				GlobalDisplayContext.ExpectedWidth = 1080;
+				GlobalDisplayContext.ExpectedHeight = 1920;
+			}
+			else
+			{
+				GlobalDisplayContext.InCompatibilityMode = TRUE;
+			}
+
+		}
+	}
+	else
+	{
+		GlobalDisplayContext.InCompatibilityMode = TRUE;
+	}
+
+	return true;
+}
+
+DisplaySearchHandle* Display::GetDisplaySearchHandle()
+{
+	return new Win32::Win32DisplaySearchHandle();
+}
+
+// FIXME: The handle parameter will be used to unify GetDisplayCount and GetDisplay calls
+// The handle will be written to the 64-bit value pointed and will store the enumerated
+// display list. This will allow the indexes to be meaningful between obtaining
+// the count. With a single handle the count should be stable
+int Display::GetDisplayCount(DisplaySearchHandle* handle, bool extended, bool applicationOnly, bool extendedEDIDSerials)
+{
+	static int extendedCount = -1;
+	static int applicationCount = -1;
+
+	Win32::Win32DisplaySearchHandle* localHandle = (Win32::Win32DisplaySearchHandle*)handle;
+	
+	if( localHandle == NULL )
+		return 0;
+
+	if( extendedCount == -1 || extended )
+	{
+        extendedCount = discoverExtendedRifts(localHandle->cachedDescriptorArray, 16, extendedEDIDSerials);
+	}
+
+	localHandle->extended = true;
+	localHandle->extendedDisplayCount = extendedCount;
+	int totalCount = extendedCount;
+
+	if( applicationCount == -1 || applicationOnly )
+	{
+		applicationCount = getRiftCount(GlobalDisplayContext.hDevice);
+		localHandle->application = true;
+	}
+
+	totalCount += applicationCount;
+	localHandle->applicationDisplayCount = applicationCount;
+	localHandle->displayCount = totalCount;
+
+	return totalCount;
+}
+
+Ptr<Display> Display::GetDisplay(int index, DisplaySearchHandle* handle)
+{
+	Ptr<Display> result;
+
+	if( index < 0 )
+		return result;
+
+	Win32::Win32DisplaySearchHandle* localHandle = (Win32::Win32DisplaySearchHandle*)handle;
+
+	if( localHandle == NULL )
+		return NULL;
+
+	if (localHandle->extended)
+	{
+		if (index >= 0 && index < (int)localHandle->extendedDisplayCount)
+		{
+			return *new Win32::Win32DisplayGeneric(localHandle->cachedDescriptorArray[index]);
+		}
+
+		index -= localHandle->extendedDisplayCount;
+	}
+
+	if(localHandle->application)
+	{
+		if (index >= 0 && index < (int)getRiftCount(GlobalDisplayContext.hDevice))
+		{
+            ULONG riftChildId = getRift(GlobalDisplayContext.hDevice, index);
+            Win32::DisplayEDID dEdid;
+
+            if (!getEdid(GlobalDisplayContext.hDevice, riftChildId, dEdid))
+            {
+                return NULL;
+            }
+
+            // FIXME: We have the EDID. Let's just use that instead.
+			uint32_t nativeWidth = 1080;
+			uint32_t nativeHeight = 1920;
+			uint32_t logicalWidth = 1920;
+			uint32_t logicalHeight = 1080;
+			uint32_t rotation = 0;
+
+            switch (dEdid.ModelNumber)
+            {
+			case 0:
+			case 1:
+				nativeWidth = 1280;
+				nativeHeight = 800;
+				logicalWidth = nativeWidth;
+				logicalHeight = nativeHeight;
+				break;
+			case 2:
+			case 3:
+			default:
+				rotation = 90;
+				break;
+			}
+
+            HmdTypeEnum deviceTypeGuess = HmdType_Unknown;
+            switch (dEdid.ModelNumber)
+            {
+            case 3: deviceTypeGuess = HmdType_DK2;       break;
+            case 2: deviceTypeGuess = HmdType_DKHDProto; break;
+            case 1: deviceTypeGuess = HmdType_DK1;       break;
+            default: break;
+            }
+
+			result = *new Win32::Win32DisplayDriver( 
+						deviceTypeGuess,
+                        "",
+						dEdid.MonitorName,
+						dEdid.SerialNumber,
+                        Sizei(logicalWidth, logicalHeight),
+						Sizei(nativeWidth, nativeHeight),
+						Vector2i(0),
+                        dEdid,
+						GlobalDisplayContext.hDevice,
+						riftChildId,
+						rotation);
+		}
+	}
+	return result;
+}
+
+Display::MirrorMode Win32::Win32DisplayDriver::SetMirrorMode( Display::MirrorMode newMode )
+{
+	return newMode;
+}
+
+static bool SetDisplayPower(HANDLE hDevice, ULONG childId, int mode)
+{
+    ULONG_PTR longArray[2];
+
+    longArray[0] = childId;
+    longArray[1] = mode;
+
+    ULONG localResult = 0;
+    DWORD bytesReturned = 0;
+
+    BOOL result = DeviceIoControl(hDevice,
+                                  IOCTL_RIFTMGR_DISPLAYPOWER,
+                                  longArray,
+                                  2 * sizeof(ULONG_PTR),
+                                  &localResult,
+                                  sizeof(ULONG),
+                                  &bytesReturned,
+                                  NULL);
+
+    // Note: bytesReturned does not seem to be set
+    return result != FALSE /* && bytesReturned == sizeof(ULONG) */ && mode == (int)localResult;
+}
+
+bool Win32::Win32DisplayDriver::SetDisplaySleep(bool sleep)
+{
+    return SetDisplayPower(hDevice, ChildId, sleep ? 2 : 1);
+}
+
+
+} // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,169 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_Display.h
+Content     :   Win32-specific Display declarations
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_Display_h
+#define OVR_Win32_Display_h
+
+#include "OVR_Display.h"
+
+namespace OVR { namespace Win32 {
+
+
+//-------------------------------------------------------------------------------------
+// DisplayDesc
+
+// Display information enumerable through Win32.
+// TBD: Should we just move this to public header, so it's a const member of Display?
+struct DisplayDesc
+{
+    HmdTypeEnum DeviceTypeGuess; // This is a guess about what type of HMD it is connected to
+	String      DisplayID;       // This is the device identifier string from MONITORINFO (for app usage)
+    String      ModelName;       // This is a "DK2" type string
+    String      EdidSerialNumber;
+    Sizei       LogicalResolutionInPixels;
+    Sizei       NativeResolutionInPixels;
+    Vector2i    DesktopDisplayOffset;
+};
+
+
+//-------------------------------------------------------------------------------------
+// DisplayEDID
+
+// Describes EDID information as reported from our display driver.
+struct DisplayEDID
+{
+	String MonitorName;
+	UINT16 ModelNumber;
+	String VendorName;
+	String SerialNumber;
+};
+
+class Win32DisplaySearchHandle : public DisplaySearchHandle
+{
+public:
+    static const int ArraySize = 16;
+
+    Win32::DisplayDesc cachedDescriptorArray[ArraySize];
+    bool			   extended;
+    bool			   application;
+    int				   extendedDisplayCount;
+    int				   applicationDisplayCount;
+    int				   displayCount;
+
+    Win32DisplaySearchHandle()
+    {
+    }
+	virtual ~Win32DisplaySearchHandle()
+    {
+    }
+};
+
+//-------------------------------------------------------------------------------------
+// Win32DisplayGeneric
+
+// Describes Win32 display in Compatibility mode, containing basic data
+class Win32DisplayGeneric : public Display
+{
+public:
+	Win32DisplayGeneric( const DisplayDesc& dd ) :
+		Display(dd.DeviceTypeGuess,
+				dd.DisplayID,
+				dd.ModelName,
+				dd.EdidSerialNumber,
+				dd.LogicalResolutionInPixels,
+				dd.NativeResolutionInPixels,
+				dd.DesktopDisplayOffset,
+				0,
+				0,
+				false)
+    {
+	}
+
+	virtual ~Win32DisplayGeneric()
+	{
+	}
+
+	// Generic displays are not capable of mirroring
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode ) 
+	{ 
+		OVR_UNUSED( newMode ); 
+		return MirrorDisabled; 
+	} 
+};
+
+
+//-------------------------------------------------------------------------------------
+// Win32DisplayDriver
+
+// Oculus driver based display object.
+class Win32DisplayDriver : public Display
+{
+	HANDLE		hDevice;
+	ULONG		ChildId;
+	DisplayEDID Edid;
+
+public:
+    Win32DisplayDriver(const HmdTypeEnum  deviceTypeGuess,
+                       const String&      displayID,
+					   const String&      modelName,
+					   const String&      edidSerial,
+                       const Sizei&       logicalRes,
+					   const Sizei&       nativeRes,
+					   const Vector2i&    displayOffset,
+                       const DisplayEDID& edid,
+					   HANDLE hdevice,
+					   ULONG child,
+					   uint32_t rotation) :
+		Display(deviceTypeGuess,
+				displayID,
+				modelName,
+				edidSerial,
+				logicalRes,
+				nativeRes,
+				displayOffset,
+				child,
+				rotation,
+				true),
+		hDevice(hdevice),
+		ChildId(child),
+		Edid(edid)
+    {
+	}
+
+	virtual ~Win32DisplayDriver()
+	{
+	}
+
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode );
+
+    // Support sleep/wake
+	virtual bool SetDisplaySleep(bool off);
+};
+
+
+}} // namespace OVR::Win32
+
+#endif // OVR_Win32_Display_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Dxgi_Display.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Dxgi_Display.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,413 @@
+/************************************************************************************
+ 
+PublicHeader:   None
+Filename    :   dxgi_ovr_filter.h
+Content     :   Shared usermode/kernel mode definitions for IOCTL functionality.
+                Also used from LibOVR to access the driver.
+Created     :   January 27, 2014
+Authors     :   Dean Beeler
+ 
+Copyright   :   Copyright 2013 Oculus, LLC. All Rights reserved.
+ 
+Use of this software is subject to the terms of the Oculus LLC license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+ 
+/************************************************************************************/
+
+#ifndef OVR_dxgi_ovr_filter_h
+#define OVR_dxgi_ovr_filter_h
+
+#include <InitGuid.h>
+
+#define USERMODE_TEST_ROTATION 1
+
+#if USERMODE_TEST_ROTATION // Used only by the um test application
+#define USERMODE_SURFACE_WIDTH 1920
+#define USERMODE_SURFACE_HEIGHT 1080
+#else
+#define USERMODE_SURFACE_WIDTH 1080
+#define USERMODE_SURFACE_HEIGHT 1920
+#endif
+
+#define TEST_ROTATION 0 // Kernel-mode parameters
+
+#if TEST_ROTATION
+#define SURFACE_WIDTH 1920
+#define SURFACE_HEIGHT 1080
+#else
+#define SURFACE_WIDTH 1080
+#define SURFACE_HEIGHT 1920
+#endif
+
+// {46231713-49FD-4922-84E3-9FF907C06803}
+DEFINE_GUID(GUID_DEVINTERFACE_OVRRIFTMGR, 
+	0x46231713, 0x49fd, 0x4922, 0x84, 0xe3, 0x9f, 0xf9, 0x7, 0xc0, 0x68, 0x3);
+
+#define QUERYADAPTER_MAGICSIZE		17836
+#define QUERYADAPTER_MAGICHEADER	0x4f565246 // OVRF
+#define QUERYADAPTER_MAXPATH		2048
+
+#define FUNCTION_INDEX 0xb800
+
+#pragma pack(push,1)
+
+#define OVR_RIFT_MODE_OFF			0	// Disabled
+#define OVR_RIFT_MODE_ENABLED		1   // Enabled
+#define OVR_RIFT_MODE_EXTEND		2   // Extending 2D displays. Without this flag
+										//	2D displays are disabled when the Rift
+										//	is active
+#define OVR_RIFT_MODE_FRONTBUFFER	4	// Enable front buffer only for Rift
+#define OVR_RIFT_MODE_LOCKMOUSE		8	// Prevent mouse from entering bounds
+
+#define OVR_ESCAPE_TYPE_HANDLE		1   // Escape to notify driver of our collected handles
+
+#define OVR_FlipImmediate			0x2
+#define OVR_FlipOnNextVSync			0x4
+
+//-----------------------------------------------------------------------------------
+// Structures for application to UM driver
+
+// Kernel32.dll functionality
+typedef HMODULE  (WINAPI *WinLoadLibraryA) ( LPCSTR  );
+typedef HMODULE  (WINAPI *WinLoadLibraryW) ( LPCWSTR  );
+typedef HMODULE  (WINAPI *WinLoadLibraryExA) ( LPCSTR, HANDLE, DWORD  );
+typedef HMODULE  (WINAPI *WinLoadLibraryExW) ( LPCWSTR, HANDLE, DWORD  );
+typedef BOOL     (WINAPI *WinGetModuleHandleExA)( DWORD, LPCSTR, HMODULE* );
+typedef BOOL     (WINAPI *WinGetModuleHandleExW)( DWORD, LPCWSTR, HMODULE* );
+
+// Overridden DirectX 9 entry points
+typedef void*	 (WINAPI *WinDirect3DCreate9)(UINT SDKVersion);
+typedef HRESULT  (WINAPI *WinDirect3DCreate9Ex)(UINT SDKVersion, void** aDevice);
+
+// Overridden DXGI entry points
+typedef HRESULT (WINAPI *WinCreateDXGIFactory)(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	);
+
+typedef HRESULT (WINAPI *WinCreateDXGIFactory1)(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	);
+
+typedef HRESULT (WINAPI *WinCreateDXGIFactory2)(
+	__in   UINT flags,
+	__in   const IID &riid,
+	__out  void **ppFactory
+	);
+
+// Application usermode callbacks from usermode driver. These 
+// functions are all provided by the calling application that uses
+// the filter mode driver
+
+// IsInitializingDisplay is used at runtime to validate that
+// the created resource (RT or bind_present) matches the resolution
+// of our expected backbuffer. If the application returns true,
+// our usermode driver will convert this to a primary
+typedef BOOL  (WINAPI *IsInitializingDisplay) ( PVOID, UINT, UINT );
+// RiftForContext is a function that will return the Rift device of
+// the concerned context. This is for targeting a particular
+// device instance with a particular Rift for rendering
+typedef ULONG (WINAPI *RiftForContext)( PVOID, HANDLE );
+// CloseRiftForContext is a function that informs the application
+// the created device is shutting down and the context
+// can freedly disassociate with the particular
+typedef BOOL (WINAPI *CloseRiftForContext)( PVOID, HANDLE, ULONG );
+typedef BOOL (WINAPI *WindowDisplayResolution)( PVOID, UINT*, UINT*, UINT*, UINT*, BOOL* );
+// IsCreatingBackBuffer is a function directed at the runtime shim
+// to confirm that the runtime is actively creating the additional
+// swapchain for rotation and display out to the rift.
+// When creating the original swapchain this function should return false
+// so the orignal swapchain isn't inadvertantly coopted.
+typedef BOOL (WINAPI *IsCreatingBackBuffer)( PVOID );
+// Callback from the usermode driver to obtain the desire to see debug statements from
+// the usermode drivers on the output console. Only called one per usermode driver shim
+// and usermode runtime.
+typedef BOOL (WINAPI *ShouldEnableDebug)( VOID );
+// Callback from the usermode driver to the runtime obtain the vsync status
+typedef BOOL (WINAPI *ShouldVSync)( VOID );
+// Callback from usermode mode and runtime driver to obtain expected native width, 
+// height and degrees rotation of the rift
+typedef BOOL (WINAPI *ExpectedResolution)( PVOID, UINT*, UINT*, UINT* );
+// Usermode callback that reports whether or not mirroring is enabled
+typedef BOOL (WINAPI *MirroringEnabled)( PVOID );
+// Callback from the shim for Unity and other plugins used to
+// report the swapchain that was created by the application
+typedef void* (WINAPI *GetDX11SwapChain)( PVOID );
+// Callback to report the HWND associated with this context
+typedef HWND (WINAPI* GetWindowForContext)( PVOID );
+// Should present Rift on context
+typedef BOOL (WINAPI* PresentRiftOnContext)( PVOID );
+// Used by a pre-loaded shim (d3d9, dxgi, opengl32) to
+// identify which api version we loaded
+// 1 = OpenGL
+// 9 = DirectX 9
+// 10 = DirectX 1X
+typedef int (WINAPI* ActiveAPIVersion)( PVOID );
+
+#pragma warning(push)
+#pragma warning(disable: 4201)
+
+typedef struct _LINK_APPLICATION_DRIVER
+{
+	UINT32                      version;
+	PVOID						context;
+
+	union 
+	{
+		struct  
+		{
+			IsInitializingDisplay		pfnInitializingDisplay;
+			RiftForContext				pfnRiftForContext;
+			CloseRiftForContext			pfnCloseRiftForContext;
+			WindowDisplayResolution		pfnWindowDisplayResolution;
+			IsCreatingBackBuffer		pfnIsCreatingBackBuffer;
+			ShouldEnableDebug			pfnShouldEnableDebug;
+			ShouldVSync					pfnShouldVSync;
+			ExpectedResolution			pfnExpectedResolution;
+			MirroringEnabled			pfnMirroringEnabled;
+			GetDX11SwapChain			pfnGetDX11SwapChain;
+			GetWindowForContext			pfnGetWindowForContext;
+			PresentRiftOnContext		pfnPresentRiftOnContext;
+			ActiveAPIVersion			pfnActiveAPIVersion;
+		};
+
+		PROC	placeholders[128];
+	};
+
+
+	// Used by Runtime filter for linking with original libraries
+	WinDirect3DCreate9			pfnDirect3DCreate9;
+	WinDirect3DCreate9Ex		pfnDirect3DCreate9Ex;
+	WinCreateDXGIFactory		pfnCreateDXGIFactory;
+	WinCreateDXGIFactory1		pfnCreateDXGIFactory1;
+	WinCreateDXGIFactory2		pfnCreateDXGIFactory2;
+} LINK_APPLICATION_DRIVER, *PLINK_APPLICATION_DRIVER;
+
+#pragma warning(pop)
+
+
+// OVRDisplay.dll functionality
+typedef HRESULT (WINAPI *PreloadLibraryFn) ( WinLoadLibraryA , LPCSTR, PLINK_APPLICATION_DRIVER appDriver );
+typedef HRESULT (WINAPI *PreloadLibraryRTFn) ( PLINK_APPLICATION_DRIVER appDriver );
+
+//-----------------------------------------------------------------------------------
+// Structures for UM driver to KM driver
+
+typedef struct _QUERY_KM_DRIVER
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+												// See: QUERYADAPTER_MAGICHEADER
+	UINT32 maxVidPnSources;						// Returns the maximum number of video present network sources
+} QUERY_KM_DRIVER, *PQUERY_KM_DRIVER;
+
+#ifndef _D3DUKMDT_H_
+typedef UINT D3DKMT_HANDLE;
+#endif
+
+typedef struct _HandleNotepad
+{
+	// These are assigned around CreateResource
+	HANDLE			hUsermodeInResource;
+	HANDLE			hUsermodeOutResource;
+
+	// These are assigned within the kernel with
+	// DxgkDdiCreateAllocation and
+	// DxgkDdiOpenAllocation
+	D3DKMT_HANDLE	hAllocation;
+	PVOID			hDeviceSpecificHandle;
+	PVOID			hKernelDriverHandle;
+
+	// These are assigned around pfnAllocateCb
+	HANDLE			hUsermodeSharedResource;
+	D3DKMT_HANDLE	hKernelModeSharedResource;
+
+	ULONG			childUid;
+
+	UINT			pitch;
+
+} HandleNotepad, *PHandleNotepad;
+
+
+typedef struct _ALLOC_PRIVATE_STRUCTURE
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+
+	PVOID originalPrivataDataPtr;				// Location in usermode of the original private data structure
+	UINT  originalPrivateSize;					// Size of private data structure at the end of this header
+
+	PVOID hAllocationHandle;					// User-mode-assigned allocation handle for CreateAllocation
+	PVOID hDeviceSpecificHandle;				// Assigned in kernal OpenAllocation
+	PVOID hInternalHandle;						// Assigned in kernal CreateAllocation
+	UINT  pitch;								// Hinted surface pitch
+
+	BYTE originalPrivateData[1];				// Variable length
+
+
+} ALLOC_PRIVATE_STRUCTURE, *PALLOC_PRIVATE_STRUCTURE;
+
+typedef struct _ESCAPE_STRUCTURE
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+
+	UINT32 escapeType;							// Specifier for individual type of escape message
+												// Type 1 for notepad
+	union {
+		HandleNotepad notepad;
+	};
+} ESCAPE_STRUCTURE, *PESCAPE_STRUCTURE;
+
+// Structures for internal operation of KM driver
+
+typedef struct _RIFT_SYNC
+{
+	ULONG	childUid;				// ChildUid as reported by RIFT_STATUS
+	ULONG   vsync;					// 1 for vsync, 0 for immediate
+} RIFT_SYNC, *PRIFT_SYNC;
+
+typedef struct _RIFT_MODE
+{
+	ULONG	childUid;				// ChildUid as reported by RIFT_STATUS
+	ULONG	mode;					// Bitmap of mode values, defined by OVR_RIFT_HOME_*
+	HANDLE	userModeHandle;			// Handle of render target created in user mode
+									// that's usable as a primary 
+} RIFT_MODE, *PRIFT_MODE;
+
+typedef struct _RIFT_STATUS
+{
+	ULONG childUid;				// Display driver assigned Uid for this display
+	ULONG mode;					// Active rift mode, see OVR_RIFT_MODE_*
+	ULONG serialNumber;			// Serial number as reported in the Rift's EDID
+	ULONG textureHandle;		// Handle of shared render resource -- NULL if not shared 
+} RIFT_STATUS, *PRIFT_STATUS;
+
+typedef struct _RIFT_STATUS_ARRAY
+{
+	ULONG arraySize;			// Size of pre-allocated RIFT_STATUS structures. 
+	RIFT_STATUS status[1];		// Array of status blocks containing connection information on each Rift
+} RIFT_STATUS_ARRAY, *PRIFT_STATUS_ARRAY;
+
+#pragma pack(pop)
+
+// IOCTL for UM application to KM driver
+
+#define OVR_STATUS_SUCCESS					 0
+#define OVR_STATUS_FAIL						-1
+#define OVR_STATUS_DRIVER_IN_USE			-2
+#define OVR_STATUS_MODE_ALREADY_ACTIVE		-3
+#define OVR_STATUS_RIFT_NOT_PRESENT			-4
+
+//
+// Returns the number of Rift displays attached to the video adapter
+// If 0, no Rift displays have been connected.
+// If greater than 0, use this size to pre-allocate space for an array
+// of rift statuses
+//
+// Input Buffer: Nothing
+// Output Buffer: LONG - count of Rift displays attached to video adapter
+//
+#define IOCTL_RIFTMGR_GET_RIFT_COUNT CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+//
+// Fills out a pre-allocated array with information on the individually attached
+// screens.
+// 
+// On Input, specify the arraySize as the size of the allocation.
+//
+// On Output, the arraySize will be updated with the actual number of Rifts
+// reported. Use IOCTL_RIFTMGR_GET_RIFT_COUNT to query the number of Rifts.
+// If the count changes (added or removed) between calls, the function will either fail
+// due to the buffer being too small, or the arraySize count will be updated
+// with a new count of devices along with their respective parameters.
+//
+// Input Buffer: PRIFT_STATUS - Pointer to allocated status array
+// Output Buffer: LONG - Count of Rift displays reported in the structure. -1 if out of
+//						 memory						
+//
+#define IOCTL_RIFTMGR_GET_RIFT_ARRAY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 1, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Changes the mode of an attached Rift (DEPRECATED)
+// Input Buffer: PRIFT_MODE - Pointer to a mode structure specifying the childUid and
+//							  mode for a particular Rift
+// Output Buffer: LONG		- Non-zero on error, 0 on successful mode change
+//
+#define IOCTL_RIFTMGR_SET_RIFT_MODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 2, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Lock the primary of the rift and obtain an address
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: ULONG_PTR		- Pointer to a usermode mapped address of the primary
+#define IOCTL_RIFTMGR_GET_RIFT_PRIMARY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 3, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Release Rift primary
+// Input Buffer: PULONG_PTR		- ChildUid of a Rift as previously discovered and virtual pointer
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_RELEASE_RIFT_PRIMARY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 4, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+
+// Point the rift to another render target
+// Input Buffer: PHANDLE		- Array of handles, rift and the render target resource
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_SETRIFTBUFFER CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 5, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Enable or disable vsync on Rift present
+// Input Buffer: PRIFT_SYNC		- Pointer to a mode structure specifying the childUid and
+//								  and sync
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_SETVSYNCMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 6, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Get scan line
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: ULONG			- 31st bit is set if in vertical blank, high 15 bits has per second 
+//								  frame number (0-74), low 16 bits has scanline (0-1919)
+#define IOCTL_RIFTMGR_GETSCANLINE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 7, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Enable or disable compatibility mode. Entering compatibility mode will fail if
+// the Rift is already actively scanning out a surface
+// Input Buffer: BOOL			- Nonzero if compatibility mode is desired, zero if it's not
+// Output Buffer: LONG			- Result value (see OVR statuses)
+//								   0 = success
+//								  -1 = general failure
+//								  -2 = failure, rift scanning out
+#define IOCTL_RIFTMGR_SETCOMPATIBILITYMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 8, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Call to obtain the current status of compatibility mode
+// Input Buffer: NOTHING
+// Output Buffer: LONG			- Result value 
+//								  0 = Not in compatibility mode
+//								  Non-zero = In compatibility mode
+#define IOCTL_RIFTMGR_GETCOMPATIBILITYMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 9, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Call to set the power mode of a particular Rift
+// Input Buffer: PULONG_PTR		- ChildUid of a Rift as previously discovered and ULONG value
+//							      second ULONG has value of 
+//								  0 to simply obtain the power status of the display
+//								  1 to set the display into a full power state (needs a primary to fully scan out)
+//								  2 to set the display into sleep mode
+//								  3 to set the display into full power off mode (WARNING: Will potentially trash primary)
+// Output Buffer: LONG			- Result value 
+//								  0 = Failure to obtain power status
+//								  1 = Full power
+//								  2 = Sleep
+//								  3 = Power off
+#define IOCTL_RIFTMGR_DISPLAYPOWER CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 10, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Return the EDID of the display in the output buffer. The driver
+// will copy as many bytes as possible to fill the buffer.
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: PCHAR			- Preallocated buffer of a variable size to store the EDID from the display
+#define IOCTL_RIFTMGR_GETEDID CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 11, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,80 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_FocusReader.cpp
+Content     :   Reader for current app with focus on Windows
+Created     :   July 2, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "OVR_Win32_FocusReader.h"
+#include "../Kernel/OVR_Log.h"
+#include "../Service/Service_NetClient.h"
+
+OVR_DEFINE_SINGLETON(OVR::Win32::RenderFocusReader);
+
+namespace OVR { namespace Win32 {
+
+
+HWND RenderFocusReader::ReadActiveWindow()
+{
+    FocusState = Reader.Get();
+    if (!FocusState || NoSharedMemory)
+    {
+        if (!Reader.Open(OVR_FOCUS_OBSERVER_SHARE_NAME))
+        {
+            OVR_DEBUG_LOG(("[Win32ShimFunctions] Unable to open the shared memory space"));
+            // Note: This should only warn and not assert because it is normal behavior when the server is not running.
+            NoSharedMemory = true;
+            return 0;
+        }
+
+        FocusState = Reader.Get();
+        if (!FocusState)
+        {
+            OVR_DEBUG_LOG(("[Win32ShimFunctions] Unable to get the shared memory space"));
+            NoSharedMemory = true;
+            return 0;
+        }
+    }
+
+    return (HWND)Ptr64ToPtr(FocusState->ActiveWindowHandle);
+}
+
+RenderFocusReader::RenderFocusReader()
+{
+	NoSharedMemory = false;
+
+    PushDestroyCallbacks();
+}
+
+RenderFocusReader::~RenderFocusReader()
+{
+}
+
+void RenderFocusReader::OnSystemDestroy()
+{
+    delete this;
+}
+
+
+
+
+}} // namespace OVR::Win32
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,82 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_FocusReader.h
+Content     :   Reader for current app with focus on Windows
+Created     :   July 2, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_FocusReader_h
+#define OVR_Win32_FocusReader_h
+
+#include "../Kernel/OVR_System.h"
+#include "../Kernel/OVR_Lockless.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_SharedMemory.h"
+
+namespace OVR { namespace Win32 {
+
+
+#define OVR_FOCUS_OBSERVER_SHARE_NAME "OVRAppFocus"
+
+//-----------------------------------------------------------------------------
+// LocklessFocusState
+
+#pragma pack(push, 8)
+
+// Focus state data
+struct LocklessFocusState
+{
+    LocklessFocusState(DWORD pid = 0) :
+        ActiveProcessId(pid),
+        ActiveWindowHandle(NULL)
+    {
+    }
+
+    DWORD ActiveProcessId;
+    void * POINTER_64 ActiveWindowHandle;
+};
+
+#pragma pack(pop)
+
+typedef SharedObjectWriter< LocklessFocusState > SharedFocusWriter;
+typedef SharedObjectReader< LocklessFocusState > SharedFocusReader;
+
+
+//-----------------------------------------------------------------------------
+// RenderFocusReader
+
+class RenderFocusReader : public OVR::SystemSingletonBase<RenderFocusReader>
+{
+    OVR_DECLARE_SINGLETON(RenderFocusReader);
+
+    SharedFocusReader         Reader;         // Shared memory reader
+    const LocklessFocusState* FocusState;     // Pointer to the current focus state
+    bool                      NoSharedMemory; // Flag reporting that no shared memory has been detected;
+
+public:
+    HWND ReadActiveWindow();
+};
+
+
+}} // namespace OVR::Win32
+
+#endif // OVR_Win32_FocusReader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_RenderShim.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_RenderShim.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,788 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_DisplayShim.cpp
+Content     :   Shared static functions for inclusion that allow for an application
+		        to inject the usermode driver into an application
+Created     :   March 21, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+
+#include <windows.h>
+#include <DbgHelp.h>
+#include <AtlBase.h>
+#include <AtlConv.h>
+
+#include "OVR_Win32_Dxgi_Display.h"
+
+#if AVOID_LIB_OVR
+#define IN_COMPATIBILITY_MODE() (0)
+#else
+#include "OVR_Win32_Display.h"
+#define IN_COMPATIBILITY_MODE() OVR::Display::InCompatibilityMode()
+#endif
+
+#pragma comment(lib, "DbgHelp.lib")
+
+// Forward declarations
+// These functions are implemented in OVR_Win32_DisplayDevice.cpp.
+
+BOOL WINAPI OVRIsInitializingDisplay( PVOID context, UINT width, UINT height );
+BOOL WINAPI OVRIsCreatingBackBuffer( PVOID context );
+BOOL WINAPI OVRShouldVSync( );
+ULONG WINAPI OVRRiftForContext( PVOID context, HANDLE driverHandle );
+BOOL WINAPI OVRCloseRiftForContext( PVOID context, HANDLE driverHandle, ULONG rift );
+BOOL WINAPI OVRWindowDisplayResolution( PVOID context, UINT* width, UINT* height,
+									   UINT* titleHeight, UINT* borderWidth,
+									   BOOL* vsyncEnabled );
+BOOL WINAPI OVRExpectedResolution( PVOID context, UINT* width, UINT* height, UINT* rotationInDegrees );
+BOOL WINAPI OVRShouldEnableDebug();
+BOOL WINAPI OVRMirroringEnabled( PVOID context );
+HWND WINAPI OVRGetWindowForContext(PVOID context);
+BOOL WINAPI OVRShouldPresentOnContext(PVOID context);
+
+static const char* GFX_DRIVER_KEY_FMT = "SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\%04d";
+#ifdef _WIN64
+static const char* RTFilter = "OVRDisplayRT64.dll";
+static const char* UMFilter = "OVRDisplay64.dll";
+#else
+static const char* RTFilter = "OVRDisplayRT32.dll";
+static const char* UMFilter = "OVRDisplay32.dll";
+#endif
+static const char* OptimusDrivers = "nvumdshimx.dll nvumdshim.dll";
+
+typedef enum OVRTargetAPI
+{
+	DirectX,
+	OpenGL
+};
+
+static PVOID lastContext = NULL;
+LINK_APPLICATION_DRIVER appDriver = {0};
+static INT apiVersion = 10;
+
+static CHAR* ReadRegStr(HKEY keySub, const char* keyName, const char* valName)
+{
+	CHAR *val = NULL;
+	REGSAM access = KEY_READ;
+	HKEY hKey;
+
+TryAgainWOW64:
+	NTSTATUS res = RegOpenKeyExA( keySub, keyName, 0, access, &hKey );
+	if ( res == ERROR_SUCCESS ) 
+	{ 
+		DWORD valLen;
+		res = RegQueryValueExA( hKey, valName, NULL, NULL, NULL, &valLen );
+		if( res == ERROR_SUCCESS ) {
+			val = (CHAR*)calloc( valLen + 1, sizeof(CHAR) );
+			res = RegQueryValueExA( hKey, valName, NULL, NULL, (LPBYTE)val, &valLen );
+
+			if( res == ERROR_SUCCESS )
+			{
+				CHAR* byte = val;
+				for( DWORD j = 0; j < valLen; ++j )
+				{
+					if( byte[j] == 0 )
+						byte[j] = ' ';
+				}
+			}
+			else
+			{
+				free( val );
+				val = NULL;
+			}
+		}
+		RegCloseKey( hKey ); 
+	}
+
+	if( res == ERROR_FILE_NOT_FOUND && keySub == HKEY_LOCAL_MACHINE && access == KEY_READ  ) {
+#ifdef _WIN64
+		access = KEY_READ | KEY_WOW64_32KEY;
+#else
+		access = KEY_READ | KEY_WOW64_64KEY;
+#endif
+		goto TryAgainWOW64;
+	}
+	return val;
+}
+
+#define OLD_DATA_BACKUP_SIZE 16
+
+WinLoadLibraryA			oldProcA = NULL;
+WinLoadLibraryExA		oldProcExA = NULL;
+WinLoadLibraryW			oldProcW = NULL;
+WinLoadLibraryExW		oldProcExW = NULL;
+WinGetModuleHandleExA	oldProcModExA = NULL;
+WinGetModuleHandleExW	oldProcModExW = NULL;
+WinDirect3DCreate9		oldDirectX9Create = NULL;
+BYTE					oldDirectX9CreateData[OLD_DATA_BACKUP_SIZE];
+WinDirect3DCreate9Ex	oldDirectX9ExCreate = NULL;
+BYTE					oldDirectX9ExCreateData[OLD_DATA_BACKUP_SIZE];
+WinCreateDXGIFactory	oldCreateDXGIFactory = NULL;
+BYTE					oldCreateDXGIFactoryData[OLD_DATA_BACKUP_SIZE];
+WinCreateDXGIFactory1	oldCreateDXGIFactory1 = NULL;
+BYTE					oldCreateDXGIFactory1Data[OLD_DATA_BACKUP_SIZE];
+WinCreateDXGIFactory2   oldCreateDXGIFactory2 = NULL;
+BYTE					oldCreateDXGIFactory2Data[OLD_DATA_BACKUP_SIZE];
+
+static bool checkForOverride( LPCSTR libFileName, OVRTargetAPI& targetApi )
+{
+	for (int i=0; ; i++)
+	{
+		CHAR keyString[256] = {0};
+
+		sprintf_s( keyString, 256, GFX_DRIVER_KEY_FMT, i );
+
+		CHAR* providerName = ReadRegStr( HKEY_LOCAL_MACHINE, keyString, "ProviderName" );
+
+		// No provider name means we're out of display enumerations
+		if( providerName == NULL )
+			break;
+
+		free( providerName );
+
+		// Check 64-bit driver names followed by 32-bit driver names
+		const char* driverKeys[] = {"UserModeDriverName", "UserModeDriverNameWoW", "OpenGLDriverName", "OpenGLDriverNameWoW", "InstalledDisplayDrivers" };
+		for( int j = 0; j < 6; ++j )
+		{
+			CHAR userModeList[4096] = {0};
+			
+			switch(j)
+			{
+				case 5:
+					strcpy_s( userModeList, 4095, OptimusDrivers );
+					break;
+				default:
+					{
+						CHAR* regString = ReadRegStr( HKEY_LOCAL_MACHINE, keyString, driverKeys[j] );
+						if( regString )
+						{
+							strcpy_s( userModeList, 4095, regString );
+							free( regString );
+						}
+
+					}
+					break;
+			}
+
+			char *nextToken = NULL;
+
+			if( userModeList )
+			{
+				char* first = strtok_s( userModeList, " ", &nextToken );
+				while( first )
+				{
+					if( strstr( libFileName, first ) != 0 )
+					{
+						if( j < 2 )
+							targetApi = DirectX;
+						else
+							targetApi = OpenGL;
+
+						return true;
+					}
+					first = strtok_s( NULL, " ", &nextToken );
+				}
+			}
+		}
+	}
+
+	return false;
+}
+
+static HMODULE createShim( LPCSTR lpLibFileName, OVRTargetAPI targetAPI )
+{
+	//Sleep(10000);
+	if( IN_COMPATIBILITY_MODE() )
+	{
+		return (*oldProcA)( lpLibFileName );
+	}
+
+	UNREFERENCED_PARAMETER( targetAPI );
+
+	HMODULE result = NULL;
+
+	result = (*oldProcA)( UMFilter );
+
+	if( result )
+	{
+		PreloadLibraryFn loadFunc = (PreloadLibraryFn)GetProcAddress( result, "PreloadLibrary" );
+		if( loadFunc )
+		{
+			HRESULT localRes = (*loadFunc)( oldProcA, lpLibFileName, &appDriver );
+			if( localRes != S_OK )
+				result = NULL;
+		}
+	}
+
+	if( !result )
+	{
+		OutputDebugString( L"createShim:  unable to load usermode filter\n" );
+		result = (*oldProcA)( lpLibFileName );
+	}
+	return result;
+}
+
+static HMODULE
+	WINAPI
+	OVRLoadLibraryA(
+	__in LPCSTR lpLibFileName
+	)
+{
+	OVRTargetAPI targetAPI = DirectX;
+	bool needShim = checkForOverride( lpLibFileName, targetAPI );
+	if( !needShim )
+		return (*oldProcA)( lpLibFileName );
+
+	return createShim( lpLibFileName, targetAPI );
+}
+
+static HMODULE
+	WINAPI
+	OVRLoadLibraryW(
+	__in LPCWSTR lpLibFileName
+	)
+{
+	USES_CONVERSION;
+
+	OVRTargetAPI targetAPI = DirectX;
+
+	bool needShim = checkForOverride( W2A( lpLibFileName ), targetAPI );
+	if( !needShim )	
+		return (*oldProcW)( lpLibFileName );
+
+	return createShim( W2A( lpLibFileName ), targetAPI );
+}
+
+static HMODULE
+	WINAPI
+	OVRLoadLibraryExA(
+	__in       LPCSTR lpLibFileName,
+	__reserved HANDLE hFile,
+	__in       DWORD dwFlags
+
+	)
+{
+	OVRTargetAPI targetAPI = DirectX;
+
+	bool needShim = checkForOverride( lpLibFileName, targetAPI );
+	if( !needShim )
+		return (*oldProcExA)( lpLibFileName, hFile, dwFlags );
+
+	// FIXME: Don't throw away the flags parameter
+	return createShim( lpLibFileName, targetAPI );
+}
+
+static HMODULE
+	WINAPI
+	OVRLoadLibraryExW(
+	__in       LPCWSTR lpLibFileName,
+	__reserved HANDLE hFile,
+	__in       DWORD dwFlags
+	)
+{
+	USES_CONVERSION;
+
+	OVRTargetAPI targetAPI = DirectX;
+
+	bool needShim = checkForOverride( W2A( lpLibFileName ), targetAPI );
+	if( !needShim )
+		return (*oldProcExW)( lpLibFileName, hFile, dwFlags );
+
+	// FIXME: Don't throw away the flags parameter
+	return createShim( W2A( lpLibFileName ), targetAPI );
+}
+
+static BOOL WINAPI OVRGetModuleHandleExA(
+	__in      DWORD dwFlags,
+	__in_opt  LPCSTR lpModuleName,
+	__out    HMODULE *phModule
+	)
+{
+	OVRTargetAPI targetAPI = DirectX;
+
+	bool needShim = checkForOverride( lpModuleName, targetAPI );
+	if( !needShim )
+	{
+		return (*oldProcModExA)( dwFlags, lpModuleName, phModule );
+	}
+	
+	*phModule = createShim( lpModuleName, targetAPI );
+
+	return TRUE;
+}
+
+static BOOL WINAPI OVRGetModuleHandleExW(
+	__in      DWORD dwFlags,
+	__in_opt  LPCWSTR lpModuleName,
+	__out    HMODULE *phModule
+	)
+{
+	USES_CONVERSION;
+
+	OVRTargetAPI targetAPI = DirectX;
+
+	bool needShim = checkForOverride( W2A( lpModuleName ), targetAPI );
+	if( !needShim )
+	{
+		return (*oldProcModExW)( dwFlags, lpModuleName, phModule );
+	}
+
+	*phModule = createShim( W2A( lpModuleName ), targetAPI );
+
+	return TRUE;
+}
+
+#ifdef _AMD64_
+static void restoreFunction( PROC pfnHookAPIAddr, PBYTE oldData )
+{
+	static const LONGLONG addressSize = sizeof(PROC);
+	static const LONGLONG jmpSize = addressSize + 6;
+
+	DWORD oldProtect;
+	VirtualProtect((LPVOID)pfnHookAPIAddr, OLD_DATA_BACKUP_SIZE,                       
+		PAGE_EXECUTE_READWRITE, &oldProtect);
+
+	memcpy(pfnHookAPIAddr, oldData, OLD_DATA_BACKUP_SIZE);  
+
+	VirtualProtect((LPVOID)pfnHookAPIAddr, OLD_DATA_BACKUP_SIZE, oldProtect, NULL);  
+}
+
+static void setFunction( PROC pfnHookAPIAddr, PROC replacementFunction, PBYTE oldData )
+{
+	static const LONGLONG addressSize = sizeof(PROC);
+	static const LONGLONG jmpSize = addressSize + 6;
+
+	INT_PTR jumpOffset = (INT_PTR)replacementFunction;
+
+	DWORD oldProtect;
+	VirtualProtect((LPVOID)pfnHookAPIAddr, OLD_DATA_BACKUP_SIZE,                       
+		PAGE_EXECUTE_READWRITE, &oldProtect);
+
+	memcpy(oldData, pfnHookAPIAddr, OLD_DATA_BACKUP_SIZE);
+
+	PBYTE functionData = (PBYTE)pfnHookAPIAddr;
+	functionData[0] = 0xff; // JMP [RIP+0]
+	functionData[1] = 0x25; //
+	functionData[2] = 0x00; //
+	functionData[3] = 0x00; //
+	functionData[4] = 0x00; //
+	functionData[5] = 0x00; //
+	memcpy( functionData + 6, &jumpOffset, sizeof( INT_PTR ) );
+
+	VirtualProtect((LPVOID)pfnHookAPIAddr, OLD_DATA_BACKUP_SIZE, oldProtect, NULL);  
+}
+#else
+static void restoreFunction( PROC pfnHookAPIAddr, PBYTE oldData )
+{
+	static const LONGLONG addressSize = sizeof(PROC);
+	static const LONGLONG jmpSize = addressSize + 1;
+
+	DWORD oldProtect;
+	VirtualProtect((LPVOID)pfnHookAPIAddr, jmpSize,                       
+		PAGE_EXECUTE_READWRITE, &oldProtect);
+
+	memcpy(pfnHookAPIAddr, oldData, jmpSize);  
+
+	VirtualProtect((LPVOID)pfnHookAPIAddr, jmpSize, oldProtect, NULL);  
+}
+
+static void setFunction( PROC pfnHookAPIAddr, PROC replacementFunction, PBYTE oldData )
+{
+	static const LONGLONG addressSize = sizeof(PROC);
+	static const LONGLONG jmpSize = addressSize + 1;
+
+	INT_PTR jumpOffset = (INT_PTR)replacementFunction - (INT_PTR)pfnHookAPIAddr - jmpSize;
+
+	DWORD oldProtect;
+	VirtualProtect((LPVOID)pfnHookAPIAddr, jmpSize,                       
+		PAGE_EXECUTE_READWRITE, &oldProtect);
+
+	memcpy(oldData, pfnHookAPIAddr, jmpSize);
+
+	PBYTE functionData = (PBYTE)pfnHookAPIAddr;
+	memcpy( oldData, functionData, jmpSize );
+	functionData[0] = 0xe9;
+	memcpy( functionData + 1, &jumpOffset, sizeof( INT_PTR ) );
+
+	VirtualProtect((LPVOID)pfnHookAPIAddr, jmpSize, oldProtect, NULL);  
+}
+#endif
+
+static BOOL WINAPI OVRLocalIsInitializingDisplay( PVOID context, UINT width, UINT height )
+{
+	UINT expectedWidth, expectedHeight, rotation;
+
+	OVRExpectedResolution( context, &expectedWidth, &expectedHeight, &rotation );
+
+	if( appDriver.pfnActiveAPIVersion )
+		apiVersion = (*appDriver.pfnActiveAPIVersion)( context );
+
+	switch( apiVersion )
+	{
+		case 1:  // OpenGL
+		case 10: // DirectX 1X
+			if( width == expectedWidth && height == expectedHeight )
+				return TRUE;
+			break;
+		case 9: // DirectX 9
+			if( rotation == 90 || rotation == 270 )
+			{
+				if( width == expectedHeight && height == expectedWidth )
+					return TRUE;
+			}
+			else
+			{
+				if( width == expectedWidth && height == expectedHeight )
+					return TRUE;
+			}
+			break;
+		default:
+			break;
+	}
+
+	return FALSE;
+}
+
+
+HRESULT APIENTRY OVRDirect3DCreate9Ex(UINT SDKVersion, void** aDevice)
+{
+	apiVersion = 9;
+
+	HRESULT result = S_OK;
+
+	restoreFunction( (PROC)oldDirectX9ExCreate, oldDirectX9ExCreateData );
+
+    if (IN_COMPATIBILITY_MODE())
+    {
+        result = (*oldDirectX9ExCreate)(SDKVersion, aDevice);
+    }
+    else
+    {
+        HMODULE rtFilterModule = (*oldProcA)(RTFilter);
+        WinDirect3DCreate9Ex createFunction = (WinDirect3DCreate9Ex)GetProcAddress(rtFilterModule, "Direct3DCreate9Ex");
+        result = (*createFunction)(SDKVersion, aDevice);
+    }
+
+	setFunction( (PROC)oldDirectX9ExCreate, (PROC)OVRDirect3DCreate9Ex, oldDirectX9ExCreateData );
+
+	printf("%s result 0x%x\n", __FUNCTION__, result);
+
+	return result;
+}
+
+void* APIENTRY OVRDirect3DCreate9(UINT SDKVersion)
+{
+	void* result = NULL;
+
+	OVRDirect3DCreate9Ex( SDKVersion, &result );
+
+	return result;
+}
+
+HRESULT APIENTRY OVRCreateDXGIFactory(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	)
+{
+	HRESULT result = E_FAIL;
+
+	restoreFunction( (PROC)oldCreateDXGIFactory, oldCreateDXGIFactoryData );
+
+    if (IN_COMPATIBILITY_MODE())
+    {
+        result = (*oldCreateDXGIFactory)(riid, ppFactory);
+    }
+    else
+    {
+        HMODULE rtFilterModule = (*oldProcA)(RTFilter);
+        WinCreateDXGIFactory createFunction = (WinCreateDXGIFactory)GetProcAddress(rtFilterModule, "CreateDXGIFactory");
+        result = (*createFunction)(riid, ppFactory);
+    }
+
+	setFunction( (PROC)oldCreateDXGIFactory, (PROC)OVRCreateDXGIFactory, oldCreateDXGIFactoryData );
+
+	printf("%s result 0x%x\n", __FUNCTION__, result);
+
+	return result;
+}
+
+HRESULT APIENTRY OVRCreateDXGIFactory1(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	)
+{
+	HRESULT result = E_FAIL;
+
+	restoreFunction( (PROC)oldCreateDXGIFactory1, oldCreateDXGIFactory1Data );
+
+    if (IN_COMPATIBILITY_MODE())
+    {
+        result = (*oldCreateDXGIFactory1)(riid, ppFactory);
+    }
+    else
+    {
+        HMODULE rtFilterModule = (*oldProcA)(RTFilter);
+        WinCreateDXGIFactory1 createFunction = (WinCreateDXGIFactory1)GetProcAddress(rtFilterModule, "CreateDXGIFactory1");
+        result = (*createFunction)(riid, ppFactory);
+    }
+
+	setFunction( (PROC)oldCreateDXGIFactory1, (PROC)OVRCreateDXGIFactory1, oldCreateDXGIFactory1Data );
+
+	printf("%s result 0x%x\n", __FUNCTION__, result);
+
+	return result;
+}
+
+HRESULT APIENTRY OVRCreateDXGIFactory2(
+	__in   UINT flags,
+	__in   const IID &riid,
+	__out  void **ppFactory
+	)
+{
+	HRESULT result = E_FAIL;
+
+	restoreFunction( (PROC)oldCreateDXGIFactory2, oldCreateDXGIFactory2Data );
+
+    if (IN_COMPATIBILITY_MODE())
+    {
+        result = (*oldCreateDXGIFactory2)(flags, riid, ppFactory);
+    }
+    else
+    {
+        HMODULE rtFilterModule = (*oldProcA)(RTFilter);
+        WinCreateDXGIFactory2 createFunction = (WinCreateDXGIFactory2)GetProcAddress(rtFilterModule, "CreateDXGIFactory2");
+        result = (*createFunction)(flags, riid, ppFactory);
+    }
+
+	setFunction( (PROC)oldCreateDXGIFactory2, (PROC)OVRCreateDXGIFactory2, oldCreateDXGIFactory2Data );
+
+	printf("%s result 0x%x\n", __FUNCTION__, result);
+
+	return result;
+}
+
+static PROC SetProcAddressDirect(
+	__in HINSTANCE hInstance,
+	__in LPCSTR lpProcName,
+	__in PROC  newFunction,
+	__inout  BYTE* oldData
+	)
+{
+	static const LONGLONG addressSize = sizeof(PROC);
+	static const LONGLONG jmpSize = addressSize + 1;
+
+	PROC result = NULL;
+
+	PROC pfnHookAPIAddr = GetProcAddress( hInstance, lpProcName );
+
+	if( pfnHookAPIAddr )
+	{
+		result = pfnHookAPIAddr;
+
+		setFunction( pfnHookAPIAddr, newFunction, oldData );
+	}
+
+	return result;
+}
+
+static PROC SetProcAddressA(
+	__in  HINSTANCE targetModule,
+	__in  LPCSTR lpLibFileName,
+	__in  LPCSTR lpProcName,
+	__in  PROC  newFunction
+	)
+{
+	PROC pfnHookAPIAddr = GetProcAddress( LoadLibraryA( lpLibFileName ), lpProcName );
+
+	HINSTANCE hInstance = targetModule; 
+
+	ULONG ulSize;
+	PIMAGE_IMPORT_DESCRIPTOR pImportDesc = 
+		(PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
+		hInstance,
+		TRUE,
+		IMAGE_DIRECTORY_ENTRY_IMPORT,
+		&ulSize
+		);
+
+	while (pImportDesc->Name)
+	{
+		PSTR pszModName = (PSTR)((PBYTE) hInstance + pImportDesc->Name);
+		if (_stricmp(pszModName, lpLibFileName) == 0) 
+			break;   
+		pImportDesc++;
+	}
+
+	PIMAGE_THUNK_DATA pThunk = 
+		(PIMAGE_THUNK_DATA)((PBYTE) hInstance + pImportDesc->FirstThunk);
+
+	while (pThunk->u1.Function)
+	{
+		PROC* ppfn = (PROC*) &pThunk->u1.Function;
+		BOOL bFound = (*ppfn == pfnHookAPIAddr);
+
+		if (bFound) 
+		{
+			MEMORY_BASIC_INFORMATION mbi;
+			VirtualQuery(
+				ppfn,
+				&mbi,
+				sizeof(MEMORY_BASIC_INFORMATION)
+				);
+			VirtualProtect(
+				mbi.BaseAddress,
+				mbi.RegionSize,
+				PAGE_READWRITE,
+				&mbi.Protect);
+
+			*ppfn = *newFunction;
+
+			DWORD dwOldProtect;
+			VirtualProtect(
+				mbi.BaseAddress,
+				mbi.RegionSize,
+				mbi.Protect,
+				&dwOldProtect
+				);
+			break;
+		}
+		pThunk++;
+	}
+
+	return pfnHookAPIAddr;
+}
+
+enum ShimedLibraries
+{
+	ShimLibDXGI =		 0,
+	ShimLibD3D9 =		 1,
+	ShimLibD3D11 =		 2,
+	ShimLibDXGIDebug =	 3,
+	ShimLibD3D10Core =	 4,
+	ShimLibD3D10 =		 5,
+	ShimLibGL =			 6,
+	ShimCountMax =		 7
+};
+
+void checkUMDriverOverrides( void* context )
+{
+	lastContext = context;
+	if( oldProcA == NULL )
+	{
+		char* dllList[ShimCountMax] = { "dxgi.dll", "d3d9.dll", "d3d11.dll", "dxgidebug.dll", "d3d10core.dll", "d3d10.dll", "opengl32.dll" };
+
+		PreloadLibraryRTFn loadFunc = NULL;
+
+		for( int i = 0; i < ShimCountMax; ++i )
+		{
+			HINSTANCE hInst = GetModuleHandleA( dllList[i] );
+			if( hInst == NULL )
+			{
+				try
+				{
+					hInst = LoadLibraryA(dllList[i]);
+				}
+				catch(...)
+				{
+
+				}
+				
+			}
+
+			if( hInst )
+			{
+				ShimedLibraries libCount = (ShimedLibraries)i;
+				switch( libCount )
+				{
+					case ShimLibDXGI:
+						oldCreateDXGIFactory = (WinCreateDXGIFactory)SetProcAddressDirect( hInst, "CreateDXGIFactory", (PROC)OVRCreateDXGIFactory, oldCreateDXGIFactoryData );
+						oldCreateDXGIFactory1 = (WinCreateDXGIFactory1)SetProcAddressDirect( hInst, "CreateDXGIFactory1", (PROC)OVRCreateDXGIFactory1, oldCreateDXGIFactory1Data );
+						oldCreateDXGIFactory2 = (WinCreateDXGIFactory2)SetProcAddressDirect( hInst, "CreateDXGIFactory2", (PROC)OVRCreateDXGIFactory2, oldCreateDXGIFactory2Data );
+						break;
+					case ShimLibD3D9:
+						oldDirectX9Create = (WinDirect3DCreate9)SetProcAddressDirect( hInst, "Direct3DCreate9", (PROC)OVRDirect3DCreate9, oldDirectX9CreateData );
+						oldDirectX9ExCreate = (WinDirect3DCreate9Ex)SetProcAddressDirect( hInst, "Direct3DCreate9Ex", (PROC)OVRDirect3DCreate9Ex, oldDirectX9ExCreateData );
+						break;
+					default:
+						break;
+				}
+
+				char* loaderLibraryList[4] = {"kernel32.dll", "api-ms-win-core-libraryloader-l1-2-0.dll", "api-ms-win-core-libraryloader-l1-1-0.dll", "api-ms-win-core-libraryloader-l1-1-1.dll"};
+
+				for( int j = 0; j < 4; ++j )
+				{
+					char* loaderLibrary = loaderLibraryList[j];
+
+					PROC temp = NULL;
+					temp = SetProcAddressA( hInst, loaderLibrary, "LoadLibraryA", (PROC)OVRLoadLibraryA  );
+					if( !oldProcA )
+						oldProcA = (WinLoadLibraryA)temp;
+
+					temp = SetProcAddressA( hInst, loaderLibrary, "LoadLibraryW", (PROC)OVRLoadLibraryW  );
+					if( !oldProcW )
+						oldProcW = (WinLoadLibraryW)temp;
+
+					temp = SetProcAddressA( hInst, loaderLibrary, "LoadLibraryExA", (PROC)OVRLoadLibraryExA  );
+					if( !oldProcExA )
+						oldProcExA = (WinLoadLibraryExA)temp;
+
+					temp = SetProcAddressA( hInst, loaderLibrary, "LoadLibraryExW", (PROC)OVRLoadLibraryExW  );
+					if( !oldProcExW )
+						oldProcExW = (WinLoadLibraryExW)temp;
+
+					temp = SetProcAddressA( hInst, loaderLibrary, "GetModuleHandleExA", (PROC)OVRGetModuleHandleExA );
+					if( !oldProcModExA )
+						oldProcModExA = (WinGetModuleHandleExA)temp;
+
+					temp = SetProcAddressA( hInst, loaderLibrary, "GetModuleHandleExW", (PROC)OVRGetModuleHandleExW );
+					if( !oldProcModExW )
+						oldProcModExW = (WinGetModuleHandleExW)temp;
+				}
+
+				if( loadFunc == NULL )
+					loadFunc = (PreloadLibraryRTFn)GetProcAddress( hInst, "PreloadLibraryRT" );
+			}
+		}
+
+		HMODULE rtFilterModule = (*oldProcA)( RTFilter );
+
+		if( loadFunc == NULL )
+			loadFunc = (PreloadLibraryRTFn)GetProcAddress( rtFilterModule, "PreloadLibraryRT" );
+		IsCreatingBackBuffer backBufferFunc = (IsCreatingBackBuffer)GetProcAddress( rtFilterModule, "OVRIsCreatingBackBuffer" );
+		ShouldVSync	shouldVSyncFunc = (ShouldVSync)GetProcAddress( rtFilterModule, "OVRShouldVSync" );
+
+		if( loadFunc )
+		{
+			appDriver.version = 1;
+			appDriver.context = lastContext;
+
+//			appDriver.pfnInitializingDisplay        = OVRIsInitializingDisplay;
+			appDriver.pfnInitializingDisplay        = OVRLocalIsInitializingDisplay;
+			appDriver.pfnRiftForContext             = OVRRiftForContext;
+			appDriver.pfnCloseRiftForContext        = OVRCloseRiftForContext;
+			appDriver.pfnWindowDisplayResolution    = OVRWindowDisplayResolution;
+			appDriver.pfnShouldEnableDebug          = OVRShouldEnableDebug;
+			appDriver.pfnIsCreatingBackBuffer       = (backBufferFunc == NULL) ? OVRIsCreatingBackBuffer : backBufferFunc;
+			appDriver.pfnShouldVSync                = (shouldVSyncFunc == NULL) ? OVRShouldVSync : shouldVSyncFunc;
+			appDriver.pfnExpectedResolution			= OVRExpectedResolution;
+			appDriver.pfnMirroringEnabled			= OVRMirroringEnabled;
+			appDriver.pfnGetWindowForContext		= OVRGetWindowForContext;
+			appDriver.pfnPresentRiftOnContext		= OVRShouldPresentOnContext;
+
+			appDriver.pfnDirect3DCreate9    = oldDirectX9Create;
+			appDriver.pfnDirect3DCreate9Ex  = oldDirectX9ExCreate;
+			appDriver.pfnCreateDXGIFactory  = oldCreateDXGIFactory;
+			appDriver.pfnCreateDXGIFactory1 = oldCreateDXGIFactory1;
+			appDriver.pfnCreateDXGIFactory2 = oldCreateDXGIFactory2;
+
+			(*loadFunc)( &appDriver );
+		}
+	}
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,230 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_ShimFunctions.cpp
+Content     :   Client-side shim callbacks for usermode/rt hooks
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "OVR_Win32_Display.h"
+#include "OVR_Win32_ShimFunctions.h"
+#include "OVR_Win32_Dxgi_Display.h"
+#include "../OVR_Stereo.h"
+#include "OVR_Win32_FocusReader.h"
+
+// Exported 
+extern void checkUMDriverOverrides( void* context );
+
+#include <stdio.h>
+#include <tchar.h>
+#include <string.h>
+#include <stdlib.h>
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <winioctl.h>
+#include <SetupAPI.h>
+#include <Mmsystem.h>
+#include <conio.h>
+
+
+//-------------------------------------------------------------------------------------
+// ***** User-mode Callbacks
+//
+// See IsInitializingDisplay, etc in Dxgi_Display.h for details
+//
+
+extern LINK_APPLICATION_DRIVER appDriver;
+
+BOOL WINAPI OVRIsInitializingDisplay(PVOID context, UINT width, UINT height)
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+	if (con->ExpectedWidth == (int)width && con->ExpectedHeight == (int)height)
+		return TRUE;
+
+	return FALSE;
+}
+
+BOOL WINAPI OVRExpectedResolution( PVOID context, UINT* width, UINT* height, UINT* rotationInDegrees )
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+
+	*width = con->ExpectedWidth;
+	*height = con->ExpectedHeight;
+	*rotationInDegrees = con->Rotation;
+	return TRUE;
+}
+
+BOOL WINAPI OVRIsCreatingBackBuffer(PVOID context)
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+	if( con->ExpectedWidth != -1 && con->ExpectedHeight != -1 )
+		return TRUE;
+
+	return FALSE;
+}
+
+BOOL WINAPI OVRShouldVSync( )
+{
+	return FALSE;
+}
+
+
+ULONG WINAPI OVRRiftForContext(PVOID context, HANDLE driverHandle)
+{
+	OVR_UNUSED( driverHandle );
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+
+    return con->ChildUid;
+}
+
+HWND WINAPI OVRGetWindowForContext(PVOID context)
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+
+	if( con->Active )
+	{
+		return con->hWindow;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+BOOL WINAPI OVRShouldPresentOnContext(PVOID context)
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+
+	return con->Active && ( con->hWindow == OVR::Win32::RenderFocusReader::GetInstance()->ReadActiveWindow() );
+}
+
+BOOL WINAPI OVRCloseRiftForContext( PVOID context, HANDLE driverHandle, ULONG rift )
+{
+	OVR_UNUSED( context ); OVR_UNUSED( driverHandle ); OVR_UNUSED( rift );
+	// TODO
+	return TRUE;
+}
+
+BOOL WINAPI OVRWindowDisplayResolution( PVOID context, UINT* width, UINT* height,
+									   UINT* titleHeight, UINT* borderWidth,
+									   BOOL* vsyncEnabled )
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+	void* handle = con->hWindow;
+
+	if( handle )
+	{
+		RECT winRect = { 0 };
+		GetWindowRect( (HWND)handle, &winRect );
+
+		RECT rect = {0};
+		if( GetClientRect( (HWND)handle, &rect ) )
+		{
+			LONG barHeight = (winRect.bottom - winRect.top) - (rect.bottom - rect.top);
+			LONG borderSize = (winRect.right - winRect.left) - (rect.right - rect.left);
+
+			*titleHeight = barHeight - borderSize + (borderSize / 2 );
+			*borderWidth = borderSize / 2;
+			*width = rect.right - rect.left + (borderSize / 2);
+			*height = rect.bottom - rect.top + *titleHeight;
+		}
+		else
+		{
+			return FALSE;
+		}
+	}
+	else
+	{
+		return FALSE;
+	}
+
+	*vsyncEnabled = TRUE;
+
+	return TRUE;
+}
+
+BOOL WINAPI OVRShouldEnableDebug()
+{
+	return FALSE;
+}
+
+BOOL WINAPI OVRMirroringEnabled( PVOID context )
+{
+	OVR::Win32::DisplayShim* con = (OVR::Win32::DisplayShim*)context;
+
+	return con->UseMirroring;
+}
+
+namespace OVR { namespace Win32 {
+
+DisplayShim::DisplayShim() :
+	ChildUid( 0 ),
+	ExpectedWidth( 1280 ),
+	ExpectedHeight( 800 ),
+	Rotation( 0 ),
+	hWindow( 0 ),
+	UseMirroring( TRUE )
+{
+
+}
+
+DisplayShim::~DisplayShim()
+{
+
+}
+
+bool DisplayShim::Initialize( bool inCompatibility )
+{
+	if( !inCompatibility )
+		checkUMDriverOverrides( this );
+
+	return true;
+}
+
+bool DisplayShim::Shutdown()
+{
+	return true;
+}
+
+bool DisplayShim::Update(Win32ShimInfo* shimInfo)
+{
+	ChildUid = shimInfo->DeviceNumber;
+	ExpectedWidth = shimInfo->NativeWidth;
+	ExpectedHeight = shimInfo->NativeHeight;
+	Rotation = shimInfo->Rotation;
+	UseMirroring = shimInfo->UseMirroring != 0;
+	return true;
+}
+
+void* DisplayShim::GetDX11SwapChain()
+{
+	if( appDriver.pfnGetDX11SwapChain )
+	{
+		return (*appDriver.pfnGetDX11SwapChain)(this);
+	}
+
+	return NULL;
+}
+
+
+} } // OVR::Win32
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,79 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_ShimFunctions.h
+Content     :   Client-side shim callbacks for usermode/rt hooks
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_ShimFunctions_h
+#define OVR_Win32_ShimFunctions_h
+
+#include "OVR_Win32_Display.h"
+
+namespace OVR {
+
+struct Win32ShimInfo;
+
+namespace Win32 {  
+
+
+class DisplayShim
+{
+public:
+
+public:
+	static DisplayShim& GetInstance()
+	{
+		static DisplayShim instance;
+		return instance;
+	}
+
+	bool Initialize( bool inCompatibility );
+	bool Shutdown();
+
+	bool Update( Win32ShimInfo* shimInfo );
+
+	void* GetDX11SwapChain();
+
+	ULONG   ChildUid;
+	int		ExpectedWidth;
+	int		ExpectedHeight;
+	int		Rotation;
+	HWND    hWindow;
+	bool	UseMirroring;
+	bool	Active;
+
+private:
+
+	DisplayShim();
+
+	virtual ~DisplayShim();
+
+	DisplayShim(DisplayShim const&);    // Don't Implement
+	void operator=(DisplayShim const&); // Don't implement
+
+};
+
+
+}} // namespace OVR::Win32
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,57 @@
+/************************************************************************************
+
+Filename    :   OVR_Alg.cpp
+Content     :   Static lookup tables for Alg functions
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Types.h"
+
+namespace OVR { namespace Alg {
+
+//------------------------------------------------------------------------
+extern const uint8_t UpperBitTable[256] =
+{
+    0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+};
+
+extern const uint8_t LowerBitTable[256] =
+{
+    8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
+    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
+};
+
+
+}} // OVE::Alg
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1062 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Alg.h
+Content     :   Simple general purpose algorithms: Sort, Binary Search, etc.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Alg_h
+#define OVR_Alg_h
+
+#include "OVR_Types.h"
+#include <string.h>
+
+namespace OVR { namespace Alg {
+
+
+//-----------------------------------------------------------------------------------
+// ***** Operator extensions
+
+template <typename T> OVR_FORCE_INLINE void Swap(T &a, T &b) 
+{  T temp(a); a = b; b = temp; }
+
+
+// ***** min/max are not implemented in Visual Studio 6 standard STL
+
+template <typename T> OVR_FORCE_INLINE const T Min(const T a, const T b)
+{ return (a < b) ? a : b; }
+
+template <typename T> OVR_FORCE_INLINE const T Max(const T a, const T b)
+{ return (b < a) ? a : b; }
+
+template <typename T> OVR_FORCE_INLINE const T Clamp(const T v, const T minVal, const T maxVal)
+{ return Max<T>(minVal, Min<T>(v, maxVal)); }
+
+template <typename T> OVR_FORCE_INLINE int     Chop(T f)
+{ return (int)f; }
+
+template <typename T> OVR_FORCE_INLINE T       Lerp(T a, T b, T f) 
+{ return (b - a) * f + a; }
+
+
+// These functions stand to fix a stupid VC++ warning (with /Wp64 on):
+// "warning C4267: 'argument' : conversion from 'size_t' to 'const unsigned', possible loss of data"
+// Use these functions instead of gmin/gmax if the argument has size
+// of the pointer to avoid the warning. Though, functionally they are
+// absolutelly the same as regular gmin/gmax.
+template <typename T>   OVR_FORCE_INLINE const T PMin(const T a, const T b)
+{
+    OVR_COMPILER_ASSERT(sizeof(T) == sizeof(size_t));
+    return (a < b) ? a : b;
+}
+template <typename T>   OVR_FORCE_INLINE const T PMax(const T a, const T b)
+{
+    OVR_COMPILER_ASSERT(sizeof(T) == sizeof(size_t));
+    return (b < a) ? a : b;
+}
+
+
+template <typename T>   OVR_FORCE_INLINE const T Abs(const T v)
+{ return (v>=0) ? v : -v; }
+
+
+//-----------------------------------------------------------------------------------
+// ***** OperatorLess
+//
+template<class T> struct OperatorLess
+{
+    static bool Compare(const T& a, const T& b)
+    {
+        return a < b;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The comparison predicate must be specified.
+template<class Array, class Less> 
+void QuickSortSliced(Array& arr, size_t start, size_t end, Less less)
+{
+    enum 
+    {
+        Threshold = 9
+    };
+
+    if(end - start <  2) return;
+
+    intptr_t  stack[80];
+    intptr_t* top   = stack; 
+    intptr_t  base  = (intptr_t)start;
+    intptr_t  limit = (intptr_t)end;
+
+    for(;;)
+    {
+        intptr_t len = limit - base;
+        intptr_t i, j, pivot;
+
+        if(len > Threshold)
+        {
+            // we use base + len/2 as the pivot
+            pivot = base + len / 2;
+            Swap(arr[base], arr[pivot]);
+
+            i = base + 1;
+            j = limit - 1;
+
+            // now ensure that *i <= *base <= *j 
+            if(less(arr[j],    arr[i])) Swap(arr[j],    arr[i]);
+            if(less(arr[base], arr[i])) Swap(arr[base], arr[i]);
+            if(less(arr[j], arr[base])) Swap(arr[j], arr[base]);
+
+            for(;;)
+            {
+                do i++; while( less(arr[i], arr[base]) );
+                do j--; while( less(arr[base], arr[j]) );
+
+                if( i > j )
+                {
+                    break;
+                }
+
+                Swap(arr[i], arr[j]);
+            }
+
+            Swap(arr[base], arr[j]);
+
+            // now, push the largest sub-array
+            if(j - base > limit - i)
+            {
+                top[0] = base;
+                top[1] = j;
+                base   = i;
+            }
+            else
+            {
+                top[0] = i;
+                top[1] = limit;
+                limit  = j;
+            }
+            top += 2;
+        }
+        else
+        {
+            // the sub-array is small, perform insertion sort
+            j = base;
+            i = j + 1;
+
+            for(; i < limit; j = i, i++)
+            {
+                for(; less(arr[j + 1], arr[j]); j--)
+                {
+                    Swap(arr[j + 1], arr[j]);
+                    if(j == base)
+                    {
+                        break;
+                    }
+                }
+            }
+            if(top > stack)
+            {
+                top  -= 2;
+                base  = top[0];
+                limit = top[1];
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The data type must have a defined "<" operator.
+template<class Array> 
+void QuickSortSliced(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    QuickSortSliced(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+// Same as corresponding G_QuickSortSliced but with checking array limits to avoid
+// crash in the case of wrong comparator functor.
+template<class Array, class Less> 
+bool QuickSortSlicedSafe(Array& arr, size_t start, size_t end, Less less)
+{
+    enum 
+    {
+        Threshold = 9
+    };
+
+    if(end - start <  2) return true;
+
+    intptr_t  stack[80];
+    intptr_t* top   = stack; 
+    intptr_t  base  = (intptr_t)start;
+    intptr_t  limit = (intptr_t)end;
+
+    for(;;)
+    {
+        intptr_t len = limit - base;
+        intptr_t i, j, pivot;
+
+        if(len > Threshold)
+        {
+            // we use base + len/2 as the pivot
+            pivot = base + len / 2;
+            Swap(arr[base], arr[pivot]);
+
+            i = base + 1;
+            j = limit - 1;
+
+            // now ensure that *i <= *base <= *j 
+            if(less(arr[j],    arr[i])) Swap(arr[j],    arr[i]);
+            if(less(arr[base], arr[i])) Swap(arr[base], arr[i]);
+            if(less(arr[j], arr[base])) Swap(arr[j], arr[base]);
+
+            for(;;)
+            {
+                do 
+                {   
+                    i++; 
+                    if (i >= limit)
+                        return false;
+                } while( less(arr[i], arr[base]) );
+                do 
+                {
+                    j--; 
+                    if (j < 0)
+                        return false;
+                } while( less(arr[base], arr[j]) );
+
+                if( i > j )
+                {
+                    break;
+                }
+
+                Swap(arr[i], arr[j]);
+            }
+
+            Swap(arr[base], arr[j]);
+
+            // now, push the largest sub-array
+            if(j - base > limit - i)
+            {
+                top[0] = base;
+                top[1] = j;
+                base   = i;
+            }
+            else
+            {
+                top[0] = i;
+                top[1] = limit;
+                limit  = j;
+            }
+            top += 2;
+        }
+        else
+        {
+            // the sub-array is small, perform insertion sort
+            j = base;
+            i = j + 1;
+
+            for(; i < limit; j = i, i++)
+            {
+                for(; less(arr[j + 1], arr[j]); j--)
+                {
+                    Swap(arr[j + 1], arr[j]);
+                    if(j == base)
+                    {
+                        break;
+                    }
+                }
+            }
+            if(top > stack)
+            {
+                top  -= 2;
+                base  = top[0];
+                limit = top[1];
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    return true;
+}
+
+template<class Array> 
+bool QuickSortSlicedSafe(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    return QuickSortSlicedSafe(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The comparison predicate must be specified.
+template<class Array, class Less> 
+void QuickSort(Array& arr, Less less)
+{
+    QuickSortSliced(arr, 0, arr.GetSize(), less);
+}
+
+// checks for boundaries
+template<class Array, class Less> 
+bool QuickSortSafe(Array& arr, Less less)
+{
+    return QuickSortSlicedSafe(arr, 0, arr.GetSize(), less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The data type must have a defined "<" operator.
+template<class Array> 
+void QuickSort(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    QuickSortSliced(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+template<class Array> 
+bool QuickSortSafe(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    return QuickSortSlicedSafe(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The comparison predicate must be specified.
+// Unlike Quick Sort, the Insertion Sort works much slower in average, 
+// but may be much faster on almost sorted arrays. Besides, it guarantees
+// that the elements will not be swapped if not necessary. For example, 
+// an array with all equal elements will remain "untouched", while 
+// Quick Sort will considerably shuffle the elements in this case.
+template<class Array, class Less> 
+void InsertionSortSliced(Array& arr, size_t start, size_t end, Less less)
+{
+    size_t j = start;
+    size_t i = j + 1;
+    size_t limit = end;
+
+    for(; i < limit; j = i, i++)
+    {
+        for(; less(arr[j + 1], arr[j]); j--)
+        {
+            Swap(arr[j + 1], arr[j]);
+            if(j <= start)
+            {
+                break;
+            }
+        }
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The data type must have a defined "<" operator.
+template<class Array> 
+void InsertionSortSliced(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    InsertionSortSliced(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The comparison predicate must be specified.
+
+template<class Array, class Less> 
+void InsertionSort(Array& arr, Less less)
+{
+    InsertionSortSliced(arr, 0, arr.GetSize(), less);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The data type must have a defined "<" operator.
+template<class Array> 
+void InsertionSort(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    InsertionSortSliced(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Median
+// Returns a median value of the input array.
+// Caveats: partially sorts the array, returns a reference to the array element
+// TBD: This needs to be optimized and generalized
+//
+template<class Array> 
+typename Array::ValueType& Median(Array& arr)
+{
+    size_t count = arr.GetSize();
+    size_t mid = (count - 1) / 2;
+    OVR_ASSERT(count > 0);
+
+	for (size_t j = 0; j <= mid; j++)
+    {
+		size_t min = j;
+		for (size_t k = j + 1; k < count; k++)
+            if (arr[k] < arr[min]) 
+                min = k;
+        Swap(arr[j], arr[min]);
+    }
+    return arr[mid];
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSliced
+//
+template<class Array, class Value, class Less>
+size_t LowerBoundSliced(const Array& arr, size_t start, size_t end, const Value& val, Less less)
+{
+    intptr_t first = (intptr_t)start;
+    intptr_t len   = (intptr_t)(end - start);
+    intptr_t half;
+    intptr_t middle;
+    
+    while(len > 0) 
+    {
+        half = len >> 1;
+        middle = first + half;
+        if(less(arr[middle], val)) 
+        {
+            first = middle + 1;
+            len   = len - half - 1;
+        }
+        else
+        {
+            len = half;
+        }
+    }
+    return (size_t)first;
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSliced
+//
+template<class Array, class Value>
+size_t LowerBoundSliced(const Array& arr, size_t start, size_t end, const Value& val)
+{
+    return LowerBoundSliced(arr, start, end, val, OperatorLess<Value>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSized
+//
+template<class Array, class Value>
+size_t LowerBoundSized(const Array& arr, size_t size, const Value& val)
+{
+    return LowerBoundSliced(arr, 0, size, val, OperatorLess<Value>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBound
+//
+template<class Array, class Value, class Less>
+size_t LowerBound(const Array& arr, const Value& val, Less less)
+{
+    return LowerBoundSliced(arr, 0, arr.GetSize(), val, less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBound
+//
+template<class Array, class Value>
+size_t LowerBound(const Array& arr, const Value& val)
+{
+    return LowerBoundSliced(arr, 0, arr.GetSize(), val, OperatorLess<Value>::Compare);
+}
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSliced
+//
+template<class Array, class Value, class Less>
+size_t UpperBoundSliced(const Array& arr, size_t start, size_t end, const Value& val, Less less)
+{
+    intptr_t first = (intptr_t)start;
+    intptr_t len   = (intptr_t)(end - start);
+    intptr_t half;
+    intptr_t middle;
+    
+    while(len > 0) 
+    {
+        half = len >> 1;
+        middle = first + half;
+        if(less(val, arr[middle]))
+        {
+            len = half;
+        }
+        else 
+        {
+            first = middle + 1;
+            len   = len - half - 1;
+        }
+    }
+    return (size_t)first;
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSliced
+//
+template<class Array, class Value>
+size_t UpperBoundSliced(const Array& arr, size_t start, size_t end, const Value& val)
+{
+    return UpperBoundSliced(arr, start, end, val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSized
+//
+template<class Array, class Value>
+size_t UpperBoundSized(const Array& arr, size_t size, const Value& val)
+{
+    return UpperBoundSliced(arr, 0, size, val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBound
+//
+template<class Array, class Value, class Less>
+size_t UpperBound(const Array& arr, const Value& val, Less less)
+{
+    return UpperBoundSliced(arr, 0, arr.GetSize(), val, less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBound
+//
+template<class Array, class Value>
+size_t UpperBound(const Array& arr, const Value& val)
+{
+    return UpperBoundSliced(arr, 0, arr.GetSize(), val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** ReverseArray
+//
+template<class Array> void ReverseArray(Array& arr)
+{
+    intptr_t from = 0;
+    intptr_t to   = arr.GetSize() - 1;
+    while(from < to)
+    {
+        Swap(arr[from], arr[to]);
+        ++from;
+        --to;
+    }
+}
+
+
+// ***** AppendArray
+//
+template<class CDst, class CSrc> 
+void AppendArray(CDst& dst, const CSrc& src)
+{
+    size_t i;
+    for(i = 0; i < src.GetSize(); i++) 
+        dst.PushBack(src[i]);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayAdaptor
+//
+// A simple adapter that provides the GetSize() method and overloads 
+// operator []. Used to wrap plain arrays in QuickSort and such.
+template<class T> class ArrayAdaptor
+{
+public:
+    typedef T ValueType;
+    ArrayAdaptor() : Data(0), Size(0) {}
+    ArrayAdaptor(T* ptr, size_t size) : Data(ptr), Size(size) {}
+    size_t GetSize() const { return Size; }
+	int GetSizeI() const { return (int)GetSize(); }
+    const T& operator [] (size_t i) const { return Data[i]; }
+          T& operator [] (size_t i)       { return Data[i]; }
+private:
+    T*      Data;
+    size_t  Size;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** GConstArrayAdaptor
+//
+// A simple const adapter that provides the GetSize() method and overloads 
+// operator []. Used to wrap plain arrays in LowerBound and such.
+template<class T> class ConstArrayAdaptor
+{
+public:
+    typedef T ValueType;
+    ConstArrayAdaptor() : Data(0), Size(0) {}
+    ConstArrayAdaptor(const T* ptr, size_t size) : Data(ptr), Size(size) {}
+    size_t GetSize() const { return Size; }
+	int GetSizeI() const { return (int)GetSize(); }
+	const T& operator [] (size_t i) const { return Data[i]; }
+private:
+    const T* Data;
+    size_t   Size;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+extern const uint8_t UpperBitTable[256];
+extern const uint8_t LowerBitTable[256];
+
+
+
+//-----------------------------------------------------------------------------------
+inline uint8_t UpperBit(size_t val)
+{
+#ifndef OVR_64BIT_POINTERS
+
+    if (val & 0xFFFF0000)
+    {
+        return (val & 0xFF000000) ? 
+            UpperBitTable[(val >> 24)       ] + 24: 
+            UpperBitTable[(val >> 16) & 0xFF] + 16;
+    }
+    return (val & 0xFF00) ?
+        UpperBitTable[(val >> 8) & 0xFF] + 8:
+        UpperBitTable[(val     ) & 0xFF];
+
+#else
+
+    if (val & 0xFFFFFFFF00000000)
+    {
+        if (val & 0xFFFF000000000000)
+        {
+            return (val & 0xFF00000000000000) ?
+                UpperBitTable[(val >> 56)       ] + 56: 
+                UpperBitTable[(val >> 48) & 0xFF] + 48;
+        }
+        return (val & 0xFF0000000000) ?
+            UpperBitTable[(val >> 40) & 0xFF] + 40:
+            UpperBitTable[(val >> 32) & 0xFF] + 32;
+    }
+    else
+    {
+        if (val & 0xFFFF0000)
+        {
+            return (val & 0xFF000000) ? 
+                UpperBitTable[(val >> 24)       ] + 24: 
+                UpperBitTable[(val >> 16) & 0xFF] + 16;
+        }
+        return (val & 0xFF00) ?
+            UpperBitTable[(val >> 8) & 0xFF] + 8:
+            UpperBitTable[(val     ) & 0xFF];
+    }
+
+#endif
+}
+
+//-----------------------------------------------------------------------------------
+inline uint8_t LowerBit(size_t val)
+{
+#ifndef OVR_64BIT_POINTERS
+
+    if (val & 0xFFFF)
+    {
+        return (val & 0xFF) ?
+            LowerBitTable[ val & 0xFF]:
+            LowerBitTable[(val >> 8) & 0xFF] + 8;
+    }
+    return (val & 0xFF0000) ?
+            LowerBitTable[(val >> 16) & 0xFF] + 16:
+            LowerBitTable[(val >> 24) & 0xFF] + 24;
+
+#else
+
+    if (val & 0xFFFFFFFF)
+    {
+        if (val & 0xFFFF)
+        {
+            return (val & 0xFF) ?
+                LowerBitTable[ val & 0xFF]:
+                LowerBitTable[(val >> 8) & 0xFF] + 8;
+        }
+        return (val & 0xFF0000) ?
+                LowerBitTable[(val >> 16) & 0xFF] + 16:
+                LowerBitTable[(val >> 24) & 0xFF] + 24;
+    }
+    else
+    {
+        if (val & 0xFFFF00000000)
+        {
+             return (val & 0xFF00000000) ?
+                LowerBitTable[(val >> 32) & 0xFF] + 32:
+                LowerBitTable[(val >> 40) & 0xFF] + 40;
+        }
+        return (val & 0xFF000000000000) ?
+            LowerBitTable[(val >> 48) & 0xFF] + 48:
+            LowerBitTable[(val >> 56) & 0xFF] + 56;
+    }
+
+#endif
+}
+
+
+
+// ******* Special (optimized) memory routines
+// Note: null (bad) pointer is not tested
+class MemUtil
+{
+public:
+                                    
+    // Memory compare
+    static int      Cmp  (const void* p1, const void* p2, size_t byteCount)      { return memcmp(p1, p2, byteCount); }
+    static int      Cmp16(const void* p1, const void* p2, size_t int16Count);
+    static int      Cmp32(const void* p1, const void* p2, size_t int32Count);
+    static int      Cmp64(const void* p1, const void* p2, size_t int64Count); 
+};
+
+// ** Inline Implementation
+
+inline int MemUtil::Cmp16(const void* p1, const void* p2, size_t int16Count)
+{
+    int16_t*  pa  = (int16_t*)p1; 
+    int16_t*  pb  = (int16_t*)p2;
+    unsigned ic  = 0;
+    if (int16Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int16Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+inline int MemUtil::Cmp32(const void* p1, const void* p2, size_t int32Count)
+{
+    int32_t*  pa  = (int32_t*)p1;
+    int32_t*  pb  = (int32_t*)p2;
+    unsigned ic  = 0;
+    if (int32Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int32Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+inline int MemUtil::Cmp64(const void* p1, const void* p2, size_t int64Count)
+{
+    int64_t*  pa  = (int64_t*)p1;
+    int64_t*  pb  = (int64_t*)p2;
+    unsigned ic  = 0;
+    if (int64Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int64Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+
+// ** End Inline Implementation
+
+
+//-----------------------------------------------------------------------------------
+// ******* Byte Order Conversions
+namespace ByteUtil {
+
+    // *** Swap Byte Order
+
+    // Swap the byte order of a byte array
+    inline void     SwapOrder(void* pv, int size)
+    {
+        uint8_t*  pb = (uint8_t*)pv;
+        uint8_t temp;
+        for (int i = 0; i < size>>1; i++)
+        { 
+            temp            = pb[size-1-i];
+            pb[size-1-i]    = pb[i];
+            pb[i]           = temp; 
+        }
+    }
+
+    // Swap the byte order of primitive types
+    inline uint8_t  SwapOrder(uint8_t v)    { return v; }
+    inline int8_t   SwapOrder(int8_t v)     { return v; }
+    inline uint16_t SwapOrder(uint16_t v)   { return uint16_t(v>>8)|uint16_t(v<<8); }
+    inline int16_t  SwapOrder(int16_t v)    { return int16_t((uint16_t(v)>>8)|(v<<8)); }
+    inline uint32_t SwapOrder(uint32_t v)   { return (v>>24)|((v&0x00FF0000)>>8)|((v&0x0000FF00)<<8)|(v<<24); }
+    inline int32_t  SwapOrder(int32_t p)    { return (int32_t)SwapOrder(uint32_t(p)); }
+    inline uint64_t SwapOrder(uint64_t v)
+    { 
+        return   (v>>56) |
+                 ((v&uint64_t(0x00FF000000000000ULL))>>40) |
+                 ((v&uint64_t(0x0000FF0000000000ULL))>>24) |
+                 ((v&uint64_t(0x000000FF00000000ULL))>>8)  |
+                 ((v&uint64_t(0x00000000FF000000ULL))<<8)  |
+                 ((v&uint64_t(0x0000000000FF0000ULL))<<24) |
+                 ((v&uint64_t(0x000000000000FF00ULL))<<40) |
+                 (v<<56); 
+    }
+    inline int64_t  SwapOrder(int64_t v)     { return (int64_t)SwapOrder(uint64_t(v)); }
+    inline float    SwapOrder(float p)      
+    { 
+        union {
+            float p;
+            uint32_t v;
+        } u;
+        u.p = p;
+        u.v = SwapOrder(u.v);
+        return u.p;
+    }
+
+    inline double   SwapOrder(double p)
+    { 
+        union {
+            double p;
+            uint64_t v;
+        } u;
+        u.p = p;
+        u.v = SwapOrder(u.v);
+        return u.p;
+    }
+    
+    // *** Byte-order conversion
+
+#if (OVR_BYTE_ORDER == OVR_LITTLE_ENDIAN)
+    // Little Endian to System (LE)
+    inline uint8_t  LEToSystem(uint8_t v)   { return v; }
+    inline int8_t   LEToSystem(int8_t v)    { return v; }
+    inline uint16_t LEToSystem(uint16_t v)  { return v; }
+    inline int16_t  LEToSystem(int16_t v)   { return v; }
+    inline uint32_t LEToSystem(uint32_t v)  { return v; }
+    inline int32_t  LEToSystem(int32_t v)   { return v; }
+    inline uint64_t LEToSystem(uint64_t v)  { return v; }
+    inline int64_t  LEToSystem(int64_t v)    { return v; }
+    inline float    LEToSystem(float  v)    { return v; }
+    inline double   LEToSystem(double v)    { return v; }
+
+    // Big Endian to System (LE)
+    inline uint8_t  BEToSystem(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   BEToSystem(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t BEToSystem(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  BEToSystem(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t BEToSystem(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  BEToSystem(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t BEToSystem(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  BEToSystem(int64_t v)    { return SwapOrder(v); }
+    inline float    BEToSystem(float  v)    { return SwapOrder(v); }
+    inline double   BEToSystem(double v)    { return SwapOrder(v); }
+
+    // System (LE) to Little Endian
+    inline uint8_t  SystemToLE(uint8_t v)   { return v; }
+    inline int8_t   SystemToLE(int8_t v)    { return v; }
+    inline uint16_t SystemToLE(uint16_t v)  { return v; }
+    inline int16_t  SystemToLE(int16_t v)   { return v; }
+    inline uint32_t SystemToLE(uint32_t v)  { return v; }
+    inline int32_t  SystemToLE(int32_t v)   { return v; }
+    inline uint64_t SystemToLE(uint64_t v)  { return v; }
+    inline int64_t  SystemToLE(int64_t v)    { return v; }
+    inline float    SystemToLE(float  v)    { return v; }
+    inline double   SystemToLE(double v)    { return v; }   
+
+    // System (LE) to Big Endian
+    inline uint8_t  SystemToBE(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   SystemToBE(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t SystemToBE(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  SystemToBE(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t SystemToBE(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  SystemToBE(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t SystemToBE(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  SystemToBE(int64_t v)    { return SwapOrder(v); }
+    inline float    SystemToBE(float  v)    { return SwapOrder(v); }
+    inline double   SystemToBE(double v)    { return SwapOrder(v); }
+
+#elif (OVR_BYTE_ORDER == OVR_BIG_ENDIAN)
+    // Little Endian to System (BE)
+    inline uint8_t  LEToSystem(uint8_t  v)  { return SwapOrder(v); }
+    inline int8_t   LEToSystem(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t LEToSystem(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  LEToSystem(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t LEToSystem(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  LEToSystem(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t LEToSystem(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  LEToSystem(int64_t v)    { return SwapOrder(v); }
+    inline float    LEToSystem(float  v)    { return SwapOrder(v); }
+    inline double   LEToSystem(double v)    { return SwapOrder(v); }
+
+    // Big Endian to System (BE)
+    inline uint8_t  BEToSystem(uint8_t v)   { return v; }
+    inline int8_t   BEToSystem(int8_t v)    { return v; }
+    inline uint16_t BEToSystem(uint16_t v)  { return v; }
+    inline int16_t  BEToSystem(int16_t v)   { return v; }
+    inline uint32_t BEToSystem(uint32_t v)  { return v; }
+    inline int32_t  BEToSystem(int32_t v)   { return v; }
+    inline uint64_t BEToSystem(uint64_t v)  { return v; }
+    inline int64_t  BEToSystem(int64_t v)    { return v; }
+    inline float    BEToSystem(float  v)    { return v; }
+    inline double   BEToSystem(double v)    { return v; }
+
+    // System (BE) to Little Endian
+    inline uint8_t  SystemToLE(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   SystemToLE(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t SystemToLE(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  SystemToLE(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t SystemToLE(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  SystemToLE(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t SystemToLE(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  SystemToLE(int64_t v)    { return SwapOrder(v); }
+    inline float    SystemToLE(float  v)    { return SwapOrder(v); }
+    inline double   SystemToLE(double v)    { return SwapOrder(v); }
+
+    // System (BE) to Big Endian
+    inline uint8_t  SystemToBE(uint8_t v)   { return v; }
+    inline int8_t   SystemToBE(int8_t v)    { return v; }
+    inline uint16_t SystemToBE(uint16_t v)  { return v; }
+    inline int16_t  SystemToBE(int16_t v)   { return v; }
+    inline uint32_t SystemToBE(uint32_t v)  { return v; }
+    inline int32_t  SystemToBE(int32_t v)   { return v; }
+    inline uint64_t SystemToBE(uint64_t v)  { return v; }
+    inline int64_t  SystemToBE(int64_t v)    { return v; }
+    inline float    SystemToBE(float  v)    { return v; }
+    inline double   SystemToBE(double v)    { return v; }
+
+#else
+    #error "OVR_BYTE_ORDER must be defined to OVR_LITTLE_ENDIAN or OVR_BIG_ENDIAN"
+#endif
+
+} // namespace ByteUtil
+
+
+
+// Used primarily for hardware interfacing such as sensor reports, firmware, etc.
+// Reported data is all little-endian.
+inline uint16_t DecodeUInt16(const uint8_t* buffer)
+{
+    return ByteUtil::LEToSystem ( *(const uint16_t*)buffer );
+}
+
+inline int16_t DecodeSInt16(const uint8_t* buffer)
+{
+    return ByteUtil::LEToSystem ( *(const int16_t*)buffer );
+}
+
+inline uint32_t DecodeUInt32(const uint8_t* buffer)
+{    
+    return ByteUtil::LEToSystem ( *(const uint32_t*)buffer );
+}
+
+inline int32_t DecodeSInt32(const uint8_t* buffer)
+{    
+    return ByteUtil::LEToSystem ( *(const int32_t*)buffer );
+}
+
+inline float DecodeFloat(const uint8_t* buffer)
+{
+    union {
+        uint32_t U;
+        float  F;
+    };
+
+    U = DecodeUInt32(buffer);
+    return F;
+}
+
+inline void EncodeUInt16(uint8_t* buffer, uint16_t val)
+{
+    *(uint16_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeSInt16(uint8_t* buffer, int16_t val)
+{
+    *(int16_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeUInt32(uint8_t* buffer, uint32_t val)
+{
+    *(uint32_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeSInt32(uint8_t* buffer, int32_t val)
+{
+    *(int32_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeFloat(uint8_t* buffer, float val)
+{
+    union {
+        uint32_t U;
+        float  F;
+    };
+
+    F = val;
+    EncodeUInt32(buffer, U);
+}
+
+// Converts an 8-bit binary-coded decimal
+inline int8_t DecodeBCD(uint8_t byte)
+{
+    uint8_t digit1 = (byte >> 4) & 0x0f;
+    uint8_t digit2 = byte & 0x0f;
+    int decimal = digit1 * 10 + digit2;   // maximum value = 99
+    return (int8_t)decimal;
+}
+
+
+}} // OVR::Alg
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,95 @@
+/************************************************************************************
+
+Filename    :   OVR_Allocator.cpp
+Content     :   Installable memory allocator implementation
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Allocator.h"
+#ifdef OVR_OS_MAC
+ #include <stdlib.h>
+#else
+ #include <malloc.h>
+#endif
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Allocator
+
+Allocator* Allocator::pInstance = 0;
+
+// Default AlignedAlloc implementation will delegate to Alloc/Free after doing rounding.
+void* Allocator::AllocAligned(size_t size, size_t align)
+{
+    OVR_ASSERT((align & (align-1)) == 0);
+    align = (align > sizeof(size_t)) ? align : sizeof(size_t);
+    size_t p = (size_t)Alloc(size+align);
+    size_t aligned = 0;
+    if (p)
+    {
+        aligned = (size_t(p) + align-1) & ~(align-1);
+        if (aligned == p) 
+            aligned += align;
+        *(((size_t*)aligned)-1) = aligned-p;
+    }
+    return (void*)aligned;
+}
+
+void Allocator::FreeAligned(void* p)
+{
+    size_t src = size_t(p) - *(((size_t*)p)-1);
+    Free((void*)src);
+}
+
+
+//------------------------------------------------------------------------
+// ***** Default Allocator
+
+// This allocator is created and used if no other allocator is installed.
+// Default allocator delegates to system malloc.
+
+void* DefaultAllocator::Alloc(size_t size)
+{
+    return malloc(size);
+}
+void* DefaultAllocator::AllocDebug(size_t size, const char* file, unsigned line)
+{
+#if defined(OVR_CC_MSVC) && defined(_CRTDBG_MAP_ALLOC)
+    return _malloc_dbg(size, _NORMAL_BLOCK, file, line);
+#else
+    OVR_UNUSED2(file, line);
+    return malloc(size);
+#endif
+}
+
+void* DefaultAllocator::Realloc(void* p, size_t newSize)
+{
+    return realloc(p, newSize);
+}
+void DefaultAllocator::Free(void *p)
+{
+    return free(p);
+}
+
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,347 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Allocator.h
+Content     :   Installable memory allocator
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Allocator_h
+#define OVR_Allocator_h
+
+#include "OVR_Types.h"
+
+//-----------------------------------------------------------------------------------
+
+// ***** Disable template-unfriendly MS VC++ warnings
+#if defined(OVR_CC_MSVC)
+// Pragma to prevent long name warnings in in VC++
+#pragma warning(disable : 4503)
+#pragma warning(disable : 4786)
+// In MSVC 7.1, warning about placement new POD default initializer
+#pragma warning(disable : 4345)
+#endif
+
+// Un-define new so that placement constructors work
+#undef new
+
+
+//-----------------------------------------------------------------------------------
+// ***** Placement new overrides
+
+// Calls constructor on own memory created with "new(ptr) type"
+#ifndef __PLACEMENT_NEW_INLINE
+#define __PLACEMENT_NEW_INLINE
+
+#   if defined(OVR_CC_MWERKS) || defined(OVR_CC_BORLAND) || defined(OVR_CC_GNU)
+#      include <new>
+#   else
+    // Useful on MSVC
+    OVR_FORCE_INLINE void* operator new     (size_t n, void *ptr) { OVR_UNUSED(n); return ptr; }
+    OVR_FORCE_INLINE void  operator delete  (void *, void *)     { }
+#   endif
+
+#endif // __PLACEMENT_NEW_INLINE
+
+
+
+//------------------------------------------------------------------------
+// ***** Macros to redefine class new/delete operators
+
+// Types specifically declared to allow disambiguation of address in
+// class member operator new.
+
+#define OVR_MEMORY_REDEFINE_NEW_IMPL(class_name, check_delete)                          \
+    void*   operator new(size_t sz)                                                      \
+    { void *p = OVR_ALLOC_DEBUG(sz, __FILE__, __LINE__); return p; }                                              \
+    void*   operator new(size_t sz, const char* file, int line)                          \
+    { void* p = OVR_ALLOC_DEBUG(sz, file, line); OVR_UNUSED2(file, line); return p; }   \
+    void    operator delete(void *p)                                                    \
+    { check_delete(class_name, p); OVR_FREE(p); }                                       \
+    void    operator delete(void *p, const char*, int)                                  \
+    { check_delete(class_name, p); OVR_FREE(p); }                          
+
+#define OVR_MEMORY_DEFINE_PLACEMENT_NEW                                                 \
+    void*   operator new        (size_t n, void *ptr)    { OVR_UNUSED(n); return ptr; }  \
+    void    operator delete     (void *ptr, void *ptr2) { OVR_UNUSED2(ptr,ptr2); }
+
+
+#define OVR_MEMORY_CHECK_DELETE_NONE(class_name, p)
+
+// Redefined all delete/new operators in a class without custom memory initialization
+#define OVR_MEMORY_REDEFINE_NEW(class_name) \
+    OVR_MEMORY_REDEFINE_NEW_IMPL(class_name, OVR_MEMORY_CHECK_DELETE_NONE)
+
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Construct / Destruct
+
+// Construct/Destruct functions are useful when new is redefined, as they can
+// be called instead of placement new constructors.
+
+
+template <class T>
+OVR_FORCE_INLINE T*  Construct(void *p)
+{
+    return ::new(p) T();
+}
+
+template <class T>
+OVR_FORCE_INLINE T*  Construct(void *p, const T& source)
+{
+    return ::new(p) T(source);
+}
+
+// Same as above, but allows for a different type of constructor.
+template <class T, class S>
+OVR_FORCE_INLINE T*  ConstructAlt(void *p, const S& source)
+{
+    return ::new(p) T(source);
+}
+
+template <class T, class S1, class S2>
+OVR_FORCE_INLINE T*  ConstructAlt(void *p, const S1& src1, const S2& src2)
+{
+    return ::new(p) T(src1, src2);
+}
+
+template <class T>
+OVR_FORCE_INLINE void ConstructArray(void *p, size_t count)
+{
+    uint8_t *pdata = (uint8_t*)p;
+    for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+    {
+        Construct<T>(pdata);
+    }
+}
+
+template <class T>
+OVR_FORCE_INLINE void ConstructArray(void *p, size_t count, const T& source)
+{
+    uint8_t *pdata = (uint8_t*)p;
+    for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+    {
+        Construct<T>(pdata, source);
+    }
+}
+
+template <class T>
+OVR_FORCE_INLINE void Destruct(T *pobj)
+{
+    pobj->~T();
+    OVR_UNUSED1(pobj); // Fix incorrect 'unused variable' MSVC warning.
+}
+
+template <class T>
+OVR_FORCE_INLINE void DestructArray(T *pobj, size_t count)
+{   
+    for (size_t i=0; i<count; ++i, ++pobj)
+        pobj->~T();
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** Allocator
+
+// Allocator defines a memory allocation interface that developers can override
+// to to provide memory for OVR; an instance of this class is typically created on
+// application startup and passed into System or OVR::System constructor.
+// 
+//
+// Users implementing this interface must provide three functions: Alloc, Free,
+// and Realloc. Implementations of these functions must honor the requested alignment.
+// Although arbitrary alignment requests are possible, requested alignment will
+// typically be small, such as 16 bytes or less.
+
+class Allocator
+{
+    friend class System;
+public:
+
+    // *** Standard Alignment Alloc/Free
+
+    // Allocate memory of specified size with default alignment.
+    // Alloc of size==0 will allocate a tiny block & return a valid pointer;
+    // this makes it suitable for new operator.
+    virtual void*   Alloc(size_t size) = 0;
+    // Same as Alloc, but provides an option of passing debug data.
+    virtual void*   AllocDebug(size_t size, const char* file, unsigned line)
+    { OVR_UNUSED2(file, line); return Alloc(size); }
+
+    // Reallocate memory block to a new size, copying data if necessary. Returns the pointer to
+    // new memory block, which may be the same as original pointer. Will return 0 if reallocation
+    // failed, in which case previous memory is still valid.
+    // Realloc to decrease size will never fail.
+    // Realloc of pointer == 0 is equivalent to Alloc
+    // Realloc to size == 0, shrinks to the minimal size, pointer remains valid and requires Free().
+    virtual void*   Realloc(void* p, size_t newSize) = 0;
+
+    // Frees memory allocated by Alloc/Realloc.
+    // Free of null pointer is valid and will do nothing.
+    virtual void    Free(void *p) = 0;
+
+
+    // *** Standard Alignment Alloc/Free
+
+    // Allocate memory of specified alignment.
+    // Memory allocated with AllocAligned MUST be freed with FreeAligned.
+    // Default implementation will delegate to Alloc/Free after doing rounding.
+    virtual void*   AllocAligned(size_t size, size_t align);    
+    // Frees memory allocated with AllocAligned.
+    virtual void    FreeAligned(void* p);
+    
+    // Returns the pointer to the current globally installed Allocator instance.
+    // This pointer is used for most of the memory allocations.
+    static Allocator* GetInstance() { return pInstance; }
+
+
+protected:
+    // onSystemShutdown is called on the allocator during System::Shutdown.
+    // At this point, all allocations should've been freed.
+    virtual void    onSystemShutdown() { }
+
+public:
+    static  void    setInstance(Allocator* palloc)    
+    {
+        OVR_ASSERT((pInstance == 0) || (palloc == 0));
+        pInstance = palloc;
+    }
+
+private:
+
+    static Allocator* pInstance;
+};
+
+
+
+//------------------------------------------------------------------------
+// ***** Allocator_SingletonSupport
+
+// Allocator_SingletonSupport is a Allocator wrapper class that implements
+// the InitSystemSingleton static function, used to create a global singleton
+// used for the OVR::System default argument initialization.
+//
+// End users implementing custom Allocator interface don't need to make use of this base
+// class; they can just create an instance of their own class on stack and pass it to System.
+
+template<class D>
+class Allocator_SingletonSupport : public Allocator
+{
+    struct AllocContainer
+    {        
+        size_t Data[(sizeof(D) + sizeof(size_t)-1) / sizeof(size_t)];
+        bool  Initialized;
+        AllocContainer() : Initialized(0) { }
+    };
+
+    AllocContainer* pContainer;
+
+public:
+    Allocator_SingletonSupport() : pContainer(0) { }
+
+    // Creates a singleton instance of this Allocator class used
+    // on OVR_DEFAULT_ALLOCATOR during System initialization.
+    static  D*  InitSystemSingleton()
+    {
+        static AllocContainer Container;
+        OVR_ASSERT(Container.Initialized == false);
+
+        Allocator_SingletonSupport<D> *presult = Construct<D>((void*)Container.Data);
+        presult->pContainer   = &Container;
+        Container.Initialized = true;
+        return (D*)presult;
+    }
+
+protected:
+    virtual void onSystemShutdown()
+    {
+        Allocator::onSystemShutdown();
+        if (pContainer)
+        {
+            pContainer->Initialized = false;
+            Destruct((D*)this);
+            pContainer = 0;
+        }
+    }
+};
+
+//------------------------------------------------------------------------
+// ***** Default Allocator
+
+// This allocator is created and used if no other allocator is installed.
+// Default allocator delegates to system malloc.
+
+class DefaultAllocator : public Allocator_SingletonSupport<DefaultAllocator>
+{
+public:
+    virtual void*   Alloc(size_t size);
+    virtual void*   AllocDebug(size_t size, const char* file, unsigned line);
+    virtual void*   Realloc(void* p, size_t newSize);
+    virtual void    Free(void *p);
+};
+
+
+//------------------------------------------------------------------------
+// ***** Memory Allocation Macros
+
+// These macros should be used for global allocation. In the future, these
+// macros will allows allocation to be extended with debug file/line information
+// if necessary.
+
+#define OVR_REALLOC(p,s)        OVR::Allocator::GetInstance()->Realloc((p),(s))
+#define OVR_FREE(p)             OVR::Allocator::GetInstance()->Free((p))
+#define OVR_ALLOC_ALIGNED(s,a)  OVR::Allocator::GetInstance()->AllocAligned((s),(a))
+#define OVR_FREE_ALIGNED(p)     OVR::Allocator::GetInstance()->FreeAligned((p))
+
+#ifdef OVR_BUILD_DEBUG
+#define OVR_ALLOC(s)            OVR::Allocator::GetInstance()->AllocDebug((s), __FILE__, __LINE__)
+#define OVR_ALLOC_DEBUG(s,f,l)  OVR::Allocator::GetInstance()->AllocDebug((s), f, l)
+#else
+#define OVR_ALLOC(s)            OVR::Allocator::GetInstance()->Alloc((s))
+#define OVR_ALLOC_DEBUG(s,f,l)  OVR::Allocator::GetInstance()->Alloc((s))
+#endif
+
+//------------------------------------------------------------------------
+
+// Base class that overrides the new and delete operators.
+// Deriving from this class, even as a multiple base, incurs no space overhead.
+class NewOverrideBase
+{
+public:
+
+    // Redefine all new & delete operators.
+    OVR_MEMORY_REDEFINE_NEW(NewOverrideBase)
+};
+
+
+} // OVR
+
+
+// Redefine operator 'new' if necessary.
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif
+
+
+#endif // OVR_Memory
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Array.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Array.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,834 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Array.h
+Content     :   Template implementation for Array
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Array_h
+#define OVR_Array_h
+
+#include "OVR_ContainerAllocator.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDefaultPolicy
+//
+// Default resize behavior. No minimal capacity, Granularity=4, 
+// Shrinking as needed. ArrayConstPolicy actually is the same as 
+// ArrayDefaultPolicy, but parametrized with constants. 
+// This struct is used only in order to reduce the template "matroska".
+struct ArrayDefaultPolicy
+{
+    ArrayDefaultPolicy() : Capacity(0) {}
+    ArrayDefaultPolicy(const ArrayDefaultPolicy&) : Capacity(0) {}
+
+    size_t GetMinCapacity() const { return 0; }
+    size_t GetGranularity() const { return 4; }
+    bool  NeverShrinking() const { return 0; }
+
+    size_t GetCapacity()    const      { return Capacity; }
+    void  SetCapacity(size_t capacity) { Capacity = capacity; }
+private:
+    size_t Capacity;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayConstPolicy
+//
+// Statically parametrized resizing behavior:
+// MinCapacity, Granularity, and Shrinking flag.
+template<int MinCapacity=0, int Granularity=4, bool NeverShrink=false>
+struct ArrayConstPolicy
+{
+    typedef ArrayConstPolicy<MinCapacity, Granularity, NeverShrink> SelfType;
+
+    ArrayConstPolicy() : Capacity(0) {}
+    ArrayConstPolicy(const SelfType&) : Capacity(0) {}
+
+    size_t GetMinCapacity() const { return MinCapacity; }
+    size_t GetGranularity() const { return Granularity; }
+    bool  NeverShrinking() const { return NeverShrink; }
+
+    size_t GetCapacity()    const      { return Capacity; }
+    void  SetCapacity(size_t capacity) { Capacity = capacity; }
+private:
+    size_t Capacity;
+};
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDataBase
+//
+// Basic operations with array data: Reserve, Resize, Free, ArrayPolicy.
+// For internal use only: ArrayData,ArrayDataCC and others.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayDataBase
+{
+    typedef T                                           ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     SelfType;
+
+    ArrayDataBase()
+        : Data(0), Size(0), Policy() {}
+
+    ArrayDataBase(const SizePolicy& p)
+        : Data(0), Size(0), Policy(p) {}
+
+    ~ArrayDataBase() 
+    {
+        Allocator::DestructArray(Data, Size);
+        Allocator::Free(Data);
+    }
+
+    size_t GetCapacity() const 
+    { 
+        return Policy.GetCapacity(); 
+    }
+
+    void ClearAndRelease()
+    {
+        Allocator::DestructArray(Data, Size);
+        Allocator::Free(Data);
+        Data = 0;
+        Size = 0;
+        Policy.SetCapacity(0);
+    }
+
+    void Reserve(size_t newCapacity)
+    {
+        if (Policy.NeverShrinking() && newCapacity < GetCapacity())
+            return;
+
+        if (newCapacity < Policy.GetMinCapacity())
+            newCapacity = Policy.GetMinCapacity();
+
+        // Resize the buffer.
+        if (newCapacity == 0)
+        {
+            if (Data)
+            {
+                Allocator::Free(Data);
+                Data = 0;
+            }
+            Policy.SetCapacity(0);
+        }
+        else
+        {
+            size_t gran = Policy.GetGranularity();
+            newCapacity = (newCapacity + gran - 1) / gran * gran;
+            if (Data)
+            {
+                if (Allocator::IsMovable())
+                {
+                    Data = (T*)Allocator::Realloc(Data, sizeof(T) * newCapacity);
+                }
+                else
+                {
+                    T* newData = (T*)Allocator::Alloc(sizeof(T) * newCapacity);
+                    size_t i, s;
+                    s = (Size < newCapacity) ? Size : newCapacity;
+                    for (i = 0; i < s; ++i)
+                    {
+                        Allocator::Construct(&newData[i], Data[i]);
+                        Allocator::Destruct(&Data[i]);
+                    }
+                    for (i = s; i < Size; ++i)
+                    {
+                        Allocator::Destruct(&Data[i]);
+                    }
+                    Allocator::Free(Data);
+                    Data = newData;
+                }
+            }
+            else
+            {
+                Data = (T*)Allocator::Alloc(sizeof(T) * newCapacity);
+                //memset(Buffer, 0, (sizeof(ValueType) * newSize)); // Do we need this?
+            }
+            Policy.SetCapacity(newCapacity);
+            // OVR_ASSERT(Data); // need to throw (or something) on alloc failure!
+        }
+    }
+
+    // This version of Resize DOES NOT construct the elements.
+    // It's done to optimize PushBack, which uses a copy constructor 
+    // instead of the default constructor and assignment
+    void ResizeNoConstruct(size_t newSize)
+    {
+        size_t oldSize = Size;
+
+        if (newSize < oldSize)
+        {
+            Allocator::DestructArray(Data + newSize, oldSize - newSize);
+            if (newSize < (Policy.GetCapacity() >> 1))
+            {
+                Reserve(newSize);
+            }
+        }
+        else if(newSize >= Policy.GetCapacity())
+        {
+            Reserve(newSize + (newSize >> 2));
+        }
+        //! IMPORTANT to modify Size only after Reserve completes, because garbage collectable
+        // array may use this array and may traverse it during Reserve (in the case, if 
+        // collection occurs because of heap limit exceeded).
+        Size = newSize;
+    }
+
+    ValueType*  Data;
+    size_t      Size;
+    SizePolicy  Policy;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayData
+//
+// General purpose array data.
+// For internal use only in Array, ArrayLH, ArrayPOD and so on.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayData : ArrayDataBase<T, Allocator, SizePolicy>
+{
+    typedef T ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     BaseType;
+    typedef ArrayData    <T, Allocator, SizePolicy>     SelfType;
+
+    ArrayData()
+        : BaseType() { }
+
+    ArrayData(size_t size)
+        : BaseType() { Resize(size); }
+
+    ArrayData(const SelfType& a)
+        : BaseType(a.Policy) { Append(a.Data, a.Size); }
+
+
+    void Resize(size_t newSize)
+    {
+        size_t oldSize = this->Size;
+        BaseType::ResizeNoConstruct(newSize);
+        if(newSize > oldSize)
+            Allocator::ConstructArray(this->Data + oldSize, newSize - oldSize);
+    }
+
+    void PushBack(const ValueType& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::Construct(this->Data + this->Size - 1, val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::ConstructAlt(this->Data + this->Size - 1, val);
+    }
+
+    // Append the given data to the array.
+    void Append(const ValueType other[], size_t count)
+    {
+        if (count)
+        {
+            size_t oldSize = this->Size;
+            BaseType::ResizeNoConstruct(this->Size + count);
+            Allocator::ConstructArray(this->Data + oldSize, count, other);
+        }
+    }
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDataCC
+//
+// A modification of ArrayData that always copy-constructs new elements
+// using a specified DefaultValue. For internal use only in ArrayCC.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayDataCC : ArrayDataBase<T, Allocator, SizePolicy>
+{
+    typedef T                                           ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     BaseType;
+    typedef ArrayDataCC  <T, Allocator, SizePolicy>     SelfType;
+
+    ArrayDataCC(const ValueType& defval)
+        : BaseType(), DefaultValue(defval) { }
+
+    ArrayDataCC(const ValueType& defval, size_t size)
+        : BaseType(), DefaultValue(defval) { Resize(size); }
+
+    ArrayDataCC(const SelfType& a)
+        : BaseType(a.Policy), DefaultValue(a.DefaultValue) { Append(a.Data, a.Size); }
+
+
+    void Resize(size_t newSize)
+    {
+        size_t oldSize = this->Size;
+        BaseType::ResizeNoConstruct(newSize);
+        if(newSize > oldSize)
+            Allocator::ConstructArray(this->Data + oldSize, newSize - oldSize, DefaultValue);
+    }
+
+    void PushBack(const ValueType& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::Construct(this->Data + this->Size - 1, val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::ConstructAlt(this->Data + this->Size - 1, val);
+    }
+
+    // Append the given data to the array.
+    void Append(const ValueType other[], size_t count)
+    {
+        if (count)
+        {
+            size_t oldSize = this->Size;
+            BaseType::ResizeNoConstruct(this->Size + count);
+            Allocator::ConstructArray(this->Data + oldSize, count, other);
+        }
+    }
+
+    ValueType   DefaultValue;
+};
+
+
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayBase
+//
+// Resizable array. The behavior can be POD (suffix _POD) and 
+// Movable (no suffix) depending on the allocator policy.
+// In case of _POD the constructors and destructors are not called.
+// 
+// Arrays can't handle non-movable objects! Don't put anything in here 
+// that can't be moved around by bitwise copy. 
+// 
+// The addresses of elements are not persistent! Don't keep the address 
+// of an element; the array contents will move around as it gets resized.
+template<class ArrayData>
+class ArrayBase
+{
+public:
+    typedef typename ArrayData::ValueType       ValueType;
+    typedef typename ArrayData::AllocatorType   AllocatorType;
+    typedef typename ArrayData::SizePolicyType  SizePolicyType;
+    typedef ArrayBase<ArrayData>                SelfType;
+
+
+#undef new
+    OVR_MEMORY_REDEFINE_NEW(ArrayBase)
+// Redefine operator 'new' if necessary.
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif
+
+
+    ArrayBase()
+        : Data() {}
+    ArrayBase(size_t size)
+        : Data(size) {}
+    ArrayBase(const SelfType& a)
+        : Data(a.Data) {}
+
+    ArrayBase(const ValueType& defval)
+        : Data(defval) {}
+    ArrayBase(const ValueType& defval, size_t size)
+        : Data(defval, size) {}
+  
+    SizePolicyType* GetSizePolicy() const                  { return Data.Policy; }
+    void            SetSizePolicy(const SizePolicyType& p) { Data.Policy = p; }
+
+    bool    NeverShrinking()const       { return Data.Policy.NeverShrinking(); }
+	size_t  GetSize()       const       { return Data.Size; }
+	int     GetSizeI()      const       { return (int)Data.Size; }
+	bool    IsEmpty()       const       { return Data.Size == 0; }
+    size_t  GetCapacity()   const       { return Data.GetCapacity(); }
+    size_t  GetNumBytes()   const       { return Data.GetCapacity() * sizeof(ValueType); }
+
+    void    ClearAndRelease()           { Data.ClearAndRelease(); }
+    void    Clear()                     { Data.Resize(0); }
+    void    Resize(size_t newSize)       { Data.Resize(newSize); }
+
+    // Reserve can only increase the capacity
+    void    Reserve(size_t newCapacity)  
+    { 
+        if (newCapacity > Data.GetCapacity())
+            Data.Reserve(newCapacity); 
+    }
+
+    // Basic access.
+    ValueType& At(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+    const ValueType& At(size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    ValueType ValueAt(size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    // Basic access.
+    ValueType& operator [] (size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+    const ValueType& operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    // Raw pointer to the data. Use with caution!
+    const ValueType* GetDataPtr() const { return Data.Data; }
+          ValueType* GetDataPtr()       { return Data.Data; }
+
+    // Insert the given element at the end of the array.
+    void    PushBack(const ValueType& val)
+    {
+        // DO NOT pass elements of your own vector into
+        // push_back()!  Since we're using references,
+        // resize() may munge the element storage!
+        // OVR_ASSERT(&val < &Buffer[0] || &val > &Buffer[BufferSize]);
+        Data.PushBack(val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        Data.PushBackAlt(val);
+    }
+
+    // Remove the last element.
+    void    PopBack(size_t count = 1)
+    {
+        OVR_ASSERT(Data.Size >= count);
+        Data.Resize(Data.Size - count);
+    }
+
+    ValueType& PushDefault()
+    {
+        Data.PushBack(ValueType());
+        return Back();
+    }
+
+    ValueType Pop()
+    {
+        ValueType t = Back();
+        PopBack();
+        return t;
+    }
+
+
+    // Access the first element.
+    ValueType&          Front()         { return At(0); }
+    const ValueType&    Front() const   { return At(0); }
+
+    // Access the last element.
+    ValueType&          Back()          { return At(Data.Size - 1); }
+    const ValueType&    Back() const    { return At(Data.Size - 1); }
+
+    // Array copy.  Copies the contents of a into this array.
+    const SelfType& operator = (const SelfType& a)   
+    {
+        Resize(a.GetSize());
+        for (size_t i = 0; i < Data.Size; i++) {
+            *(Data.Data + i) = a[i];
+        }
+        return *this;
+    }
+
+    // Removing multiple elements from the array.
+    void    RemoveMultipleAt(size_t index, size_t num)
+    {
+        OVR_ASSERT(index + num <= Data.Size);
+        if (Data.Size == num)
+        {
+            Clear();
+        }
+        else
+        {
+            AllocatorType::DestructArray(Data.Data + index, num);
+            AllocatorType::CopyArrayForward(
+                Data.Data + index, 
+                Data.Data + index + num,
+                Data.Size - num - index);
+            Data.Size -= num;
+        }
+    }
+
+    // Removing an element from the array is an expensive operation!
+    // It compacts only after removing the last element.
+    // If order of elements in the array is not important then use 
+    // RemoveAtUnordered, that could be much faster than the regular
+    // RemoveAt.
+    void    RemoveAt(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        if (Data.Size == 1)
+        {
+            Clear();
+        }
+        else
+        {
+            AllocatorType::Destruct(Data.Data + index);
+            AllocatorType::CopyArrayForward(
+                Data.Data + index, 
+                Data.Data + index + 1,
+                Data.Size - 1 - index);
+            --Data.Size;
+        }
+    }
+
+    // Removes an element from the array without respecting of original order of 
+    // elements for better performance. Do not use on array where order of elements
+    // is important, otherwise use it instead of regular RemoveAt().
+    void    RemoveAtUnordered(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        if (Data.Size == 1)
+        {
+            Clear();
+        }
+        else
+        {
+            // copy the last element into the 'index' position 
+            // and decrement the size (instead of moving all elements
+            // in [index + 1 .. size - 1] range).
+            const size_t lastElemIndex = Data.Size - 1;
+            if (index < lastElemIndex)
+            {
+                AllocatorType::Destruct(Data.Data + index);
+                AllocatorType::Construct(Data.Data + index, Data.Data[lastElemIndex]);
+            }
+            AllocatorType::Destruct(Data.Data + lastElemIndex);
+            --Data.Size;
+        }
+    }
+
+    // Insert the given object at the given index shifting all the elements up.
+    void    InsertAt(size_t index, const ValueType& val = ValueType())
+    {
+        OVR_ASSERT(index <= Data.Size);
+
+        Data.Resize(Data.Size + 1);
+        if (index < Data.Size - 1)
+        {
+            AllocatorType::CopyArrayBackward(
+                Data.Data + index + 1, 
+                Data.Data + index, 
+                Data.Size - 1 - index);
+        }
+        AllocatorType::Construct(Data.Data + index, val);
+    }
+
+    // Insert the given object at the given index shifting all the elements up.
+    void    InsertMultipleAt(size_t index, size_t num, const ValueType& val = ValueType())
+    {
+        OVR_ASSERT(index <= Data.Size);
+
+        Data.Resize(Data.Size + num);
+        if (index < Data.Size - num)
+        {
+            AllocatorType::CopyArrayBackward(
+                Data.Data + index + num,
+                Data.Data + index,
+                Data.Size - num - index);
+        }
+        for (size_t i = 0; i < num; ++i)
+            AllocatorType::Construct(Data.Data + index + i, val);
+    }
+
+    // Append the given data to the array.
+    void    Append(const SelfType& other)
+    {
+        Append(other.Data.Data, other.GetSize());
+    }
+
+    // Append the given data to the array.
+    void    Append(const ValueType other[], size_t count)
+    {
+        Data.Append(other, count);
+    }
+
+    class Iterator
+    {
+        SelfType*       pArray;
+        intptr_t        CurIndex;
+
+    public:
+        Iterator() : pArray(0), CurIndex(-1) {}
+        Iterator(SelfType* parr, intptr_t idx = 0) : pArray(parr), CurIndex(idx) {}
+
+        bool operator==(const Iterator& it) const { return pArray == it.pArray && CurIndex == it.CurIndex; }
+        bool operator!=(const Iterator& it) const { return pArray != it.pArray || CurIndex != it.CurIndex; }
+
+        Iterator& operator++()
+        {
+            if (pArray)
+            {
+                if (CurIndex < (intptr_t)pArray->GetSize())
+                    ++CurIndex;
+            }
+            return *this;
+        }
+        Iterator operator++(int)
+        {
+            Iterator it(*this);
+            operator++();
+            return it;
+        }
+        Iterator& operator--()
+        {
+            if (pArray)
+            {
+                if (CurIndex >= 0)
+                    --CurIndex;
+            }
+            return *this;
+        }
+        Iterator operator--(int)
+        {
+            Iterator it(*this);
+            operator--();
+            return it;
+        }
+        Iterator operator+(int delta) const
+        {
+            return Iterator(pArray, CurIndex + delta);
+        }
+        Iterator operator-(int delta) const
+        {
+            return Iterator(pArray, CurIndex - delta);
+        }
+        intptr_t operator-(const Iterator& right) const
+        {
+            OVR_ASSERT(pArray == right.pArray);
+            return CurIndex - right.CurIndex;
+        }
+        ValueType& operator*() const    { OVR_ASSERT(pArray); return  (*pArray)[CurIndex]; }
+        ValueType* operator->() const   { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+        ValueType* GetPtr() const       { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+
+        bool IsFinished() const { return !pArray || CurIndex < 0 || CurIndex >= (int)pArray->GetSize(); }
+
+        void Remove()
+        {
+            if (!IsFinished())
+                pArray->RemoveAt(CurIndex);
+        }
+
+        intptr_t GetIndex() const { return CurIndex; }
+    };
+
+    Iterator Begin() { return Iterator(this); }
+    Iterator End()   { return Iterator(this, (intptr_t)GetSize()); }
+    Iterator Last()  { return Iterator(this, (intptr_t)GetSize() - 1); }
+
+    class ConstIterator
+    {
+        const SelfType* pArray;
+        intptr_t        CurIndex;
+
+    public:
+        ConstIterator() : pArray(0), CurIndex(-1) {}
+        ConstIterator(const SelfType* parr, intptr_t idx = 0) : pArray(parr), CurIndex(idx) {}
+
+        bool operator==(const ConstIterator& it) const { return pArray == it.pArray && CurIndex == it.CurIndex; }
+        bool operator!=(const ConstIterator& it) const { return pArray != it.pArray || CurIndex != it.CurIndex; }
+
+        ConstIterator& operator++()
+        {
+            if (pArray)
+            {
+                if (CurIndex < (int)pArray->GetSize())
+                    ++CurIndex;
+            }
+            return *this;
+        }
+        ConstIterator operator++(int)
+        {
+            ConstIterator it(*this);
+            operator++();
+            return it;
+        }
+        ConstIterator& operator--()
+        {
+            if (pArray)
+            {
+                if (CurIndex >= 0)
+                    --CurIndex;
+            }
+            return *this;
+        }
+        ConstIterator operator--(int)
+        {
+            ConstIterator it(*this);
+            operator--();
+            return it;
+        }
+        ConstIterator operator+(int delta) const
+        {
+            return ConstIterator(pArray, CurIndex + delta);
+        }
+        ConstIterator operator-(int delta) const
+        {
+            return ConstIterator(pArray, CurIndex - delta);
+        }
+        intptr_t operator-(const ConstIterator& right) const
+        {
+            OVR_ASSERT(pArray == right.pArray);
+            return CurIndex - right.CurIndex;
+        }
+        const ValueType& operator*() const  { OVR_ASSERT(pArray); return  (*pArray)[CurIndex]; }
+        const ValueType* operator->() const { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+        const ValueType* GetPtr() const     { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+
+        bool IsFinished() const { return !pArray || CurIndex < 0 || CurIndex >= (int)pArray->GetSize(); }
+
+        intptr_t GetIndex()  const { return CurIndex; }
+    };
+    ConstIterator Begin() const { return ConstIterator(this); }
+    ConstIterator End() const   { return ConstIterator(this, (intptr_t)GetSize()); }
+    ConstIterator Last() const  { return ConstIterator(this, (intptr_t)GetSize() - 1); }
+
+protected:
+    ArrayData   Data;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Array
+//
+// General purpose array for movable objects that require explicit 
+// construction/destruction.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class Array : public ArrayBase<ArrayData<T, ContainerAllocator<T>, SizePolicy> >
+{
+public:
+    typedef T                                                           ValueType;
+    typedef ContainerAllocator<T>                                       AllocatorType;
+    typedef SizePolicy                                                  SizePolicyType;
+    typedef Array<T, SizePolicy>                                        SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator<T>, SizePolicy> > BaseType;
+
+    Array() : BaseType() {}
+    Array(size_t size) : BaseType(size) {}
+    Array(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    Array(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+// ***** ArrayPOD
+//
+// General purpose array for movable objects that DOES NOT require  
+// construction/destruction. Constructors and destructors are not called! 
+// Global heap is in use.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayPOD : public ArrayBase<ArrayData<T, ContainerAllocator_POD<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator_POD<T>                                       AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayPOD<T, SizePolicy>                                         SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator_POD<T>, SizePolicy> > BaseType;
+
+    ArrayPOD() : BaseType() {}
+    ArrayPOD(size_t size) : BaseType(size) {}
+    ArrayPOD(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    ArrayPOD(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+
+// ***** ArrayCPP
+//
+// General purpose, fully C++ compliant array. Can be used with non-movable data.
+// Global heap is in use.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayCPP : public ArrayBase<ArrayData<T, ContainerAllocator_CPP<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator_CPP<T>                                       AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayCPP<T, SizePolicy>                                         SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator_CPP<T>, SizePolicy> > BaseType;
+
+    ArrayCPP() : BaseType() {}
+    ArrayCPP(size_t size) : BaseType(size) {}
+    ArrayCPP(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    ArrayCPP(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+
+// ***** ArrayCC
+//
+// A modification of the array that uses the given default value to
+// construct the elements. The constructors and destructors are 
+// properly called, the objects must be movable.
+
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayCC : public ArrayBase<ArrayDataCC<T, ContainerAllocator<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator<T>                                           AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayCC<T, SizePolicy>                                          SelfType;
+    typedef ArrayBase<ArrayDataCC<T, ContainerAllocator<T>, SizePolicy> >   BaseType;
+
+    ArrayCC(const ValueType& defval) : BaseType(defval) {}
+    ArrayCC(const ValueType& defval, size_t size) : BaseType(defval, size) {}
+    ArrayCC(const ValueType& defval, const SizePolicyType& p) : BaseType(defval) { SetSizePolicy(p); }
+    ArrayCC(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,162 @@
+/************************************************************************************
+
+Filename    :   OVR_Atomic.cpp
+Content     :   Contains atomic operations and inline fastest locking
+                functionality. Will contain #ifdefs for OS efficiency.
+                Have non-thread-safe implementation if not available.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Atomic.h"
+#include "OVR_Allocator.h"
+
+#ifdef OVR_ENABLE_THREADS
+
+// Include Windows 8-Metro compatible Synchronization API
+#if defined(OVR_OS_WIN32) && defined(NTDDI_WIN8) && (NTDDI_VERSION >= NTDDI_WIN8)
+#include <synchapi.h>
+#endif
+
+
+namespace OVR {
+
+// ***** Windows Lock implementation
+
+#if defined(OVR_OS_WIN32)
+
+// ***** Standard Win32 Lock implementation
+
+// Constructors
+Lock::Lock(unsigned spinCount)
+{
+#if defined(NTDDI_WIN8) && (NTDDI_VERSION >= NTDDI_WIN8)
+   // On Windows 8 we use InitializeCriticalSectionEx due to Metro-Compatibility
+   InitializeCriticalSectionEx(&cs, spinCount,
+                               OVR_DEBUG_SELECT(NULL, CRITICAL_SECTION_NO_DEBUG_INFO));
+#else
+    // Spin count init critical section function prototype for Window NT
+    typedef BOOL (WINAPI *Function_InitializeCriticalSectionAndSpinCount) 
+                 (LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
+
+
+    // Try to load function dynamically so that we don't require NT
+    // On Windows NT we will use InitializeCriticalSectionAndSpinCount
+    static  bool initTried = 0;
+    static  Function_InitializeCriticalSectionAndSpinCount pInitFn = 0;
+
+    if (!initTried)
+    {
+        HMODULE hmodule = ::LoadLibrary(OVR_STR("kernel32.dll"));
+        pInitFn     = (Function_InitializeCriticalSectionAndSpinCount)
+                      ::GetProcAddress(hmodule, "InitializeCriticalSectionAndSpinCount");
+        initTried   = true;
+    }
+
+    // Initialize the critical section
+    if (pInitFn)
+        pInitFn(&cs, spinCount);
+    else
+        ::InitializeCriticalSection(&cs);
+#endif
+   
+}
+
+
+Lock::~Lock()
+{
+    DeleteCriticalSection(&cs);
+}
+
+
+#endif
+
+
+//-------------------------------------------------------------------------------------
+// ***** SharedLock
+
+// This is a general purpose globally shared Lock implementation that should probably be
+// moved to Kernel.
+// May in theory busy spin-wait if we hit contention on first lock creation,
+// but this shouldn't matter in practice since Lock* should be cached.
+
+
+enum { LockInitMarker = 0xFFFFFFFF };
+
+Lock* SharedLock::GetLockAddRef()
+{
+    int oldUseCount;
+
+    do {
+        oldUseCount = UseCount;
+        if (oldUseCount == LockInitMarker)
+            continue;
+
+        if (oldUseCount == 0)
+        {
+            // Initialize marker
+            if (AtomicOps<int>::CompareAndSet_Sync(&UseCount, 0, LockInitMarker))
+            {
+                Construct<Lock>(Buffer);
+                do { }
+                while (!AtomicOps<int>::CompareAndSet_Sync(&UseCount, LockInitMarker, 1));
+                return toLock();
+            }
+            continue;
+        }
+
+    } while (!AtomicOps<int>::CompareAndSet_NoSync(&UseCount, oldUseCount, oldUseCount + 1));
+
+    return toLock();
+}
+
+void SharedLock::ReleaseLock(Lock* plock)
+{
+    OVR_UNUSED(plock);
+    OVR_ASSERT(plock == toLock());
+
+    int oldUseCount;
+
+    do {
+        oldUseCount = UseCount;
+        OVR_ASSERT(oldUseCount != LockInitMarker);
+
+        if (oldUseCount == 1)
+        {
+            // Initialize marker
+            if (AtomicOps<int>::CompareAndSet_Sync(&UseCount, 1, LockInitMarker))
+            {
+                Destruct<Lock>(toLock());
+
+                do { }
+                while (!AtomicOps<int>::CompareAndSet_Sync(&UseCount, LockInitMarker, 0));
+
+                return;
+            }
+            continue;
+        }
+
+    } while (!AtomicOps<int>::CompareAndSet_NoSync(&UseCount, oldUseCount, oldUseCount - 1));
+}
+
+} // OVR
+
+#endif // OVR_ENABLE_THREADS
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,893 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Atomic.h
+Content     :   Contains atomic operations and inline fastest locking
+                functionality. Will contain #ifdefs for OS efficiency.
+                Have non-thread-safe implementaion if not available.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Atomic_h
+#define OVR_Atomic_h
+
+#include "OVR_Types.h"
+
+// Include System thread functionality.
+#if defined(OVR_OS_WIN32)
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#include <Windows.h>
+#else
+#include <pthread.h>
+#endif
+
+
+namespace OVR {
+
+
+// ****** Declared classes
+
+// If there is NO thread support we implement AtomicOps and
+// Lock objects as no-ops. The other classes are not defined.
+template<class C> class AtomicOps;
+template<class T> class AtomicInt;
+template<class T> class AtomicPtr;
+
+class Lock;
+
+
+//-----------------------------------------------------------------------------------
+// ***** AtomicOps
+
+// Atomic operations are provided by the AtomicOps templates class,
+// implemented through system-specific AtomicOpsRaw specializations.
+// It provides several fundamental operations such as Exchange, ExchangeAdd
+// CompareAndSet, and Store_Release. Each function includes several memory
+// synchronization versions, important for multiprocessing CPUs with weak
+// memory consistency. The following memory fencing strategies are supported:
+//
+//  - NoSync.  No memory synchronization is done for atomic op.
+//  - Release. All other memory writes are completed before atomic op
+//             writes its results.
+//  - Acquire. Further memory reads are forced to wait until atomic op
+//             executes, guaranteeing that the right values will be seen.
+//  - Sync.    A combination of Release and Acquire.
+
+
+// *** AtomicOpsRaw
+
+// AtomicOpsRaw is a specialized template that provides atomic operations 
+// used by AtomicOps. This class has two fundamental qualities: (1) it
+// defines a type T of correct size, and (2) provides operations that work
+// atomically, such as Exchange_Sync and CompareAndSet_Release.
+
+// AtomicOpsRawBase class contains shared constants/classes for AtomicOpsRaw.
+// The primary thing is does is define sync class objects, whose destructor and
+// constructor provide places to insert appropriate synchronization calls, on 
+// systems where such calls are necessary. So far, the breakdown is as follows:
+// 
+//  - X86 systems don't need custom syncs, since their exchange/atomic
+//    instructions are implicitly synchronized.
+//  - PowerPC requires lwsync/isync instructions that can use this mechanism.
+//  - If some other systems require a mechanism where syncing type is associated
+//    with a particular instruction, the default implementation (which implements
+//    all Sync, Acquire, and Release modes in terms of NoSync and fence) may not
+//    work. Ii that case it will need to be #ifdef-ed conditionally.
+
+struct AtomicOpsRawBase
+{
+#if !defined(OVR_ENABLE_THREADS) || defined(OVR_CPU_X86) || defined(OVR_OS_WIN32) || defined(OVR_OS_IPHONE)
+    // Need to have empty constructor to avoid class 'unused' variable warning.
+    struct FullSync { inline FullSync() { } };
+    struct AcquireSync { inline AcquireSync() { } };
+    struct ReleaseSync { inline ReleaseSync() { } };
+
+#elif defined(OVR_CPU_PPC64) || defined(OVR_CPU_PPC)
+    struct FullSync { inline FullSync() { asm volatile("sync\n"); } ~FullSync() { asm volatile("isync\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("isync\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("sync\n"); } };
+
+#elif defined(OVR_CPU_MIPS)
+    struct FullSync { inline FullSync() { asm volatile("sync\n"); } ~FullSync() { asm volatile("sync\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("sync\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("sync\n"); } };
+
+#elif defined(OVR_CPU_ARM)
+    struct FullSync { inline FullSync() { asm volatile("dmb\n"); } ~FullSync() { asm volatile("dmb\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("dmb\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("dmb\n"); } };
+
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4)
+    // __sync functions are already full sync
+    struct FullSync { inline FullSync() { } };
+    struct AcquireSync { inline AcquireSync() { } };
+    struct ReleaseSync { inline ReleaseSync() { } };
+#endif
+};
+
+
+// 4-Byte raw data atomic op implementation class.
+struct AtomicOpsRaw_4ByteImpl : public AtomicOpsRawBase
+{
+#if !defined(OVR_ENABLE_THREADS)
+
+    // Provide a type for no-thread-support cases. Used by AtomicOpsRaw_DefImpl.
+    typedef uint32_t T;   
+
+    // *** Thread - Safe Atomic Versions.
+
+#elif defined(OVR_OS_WIN32)  
+
+    // Use special defined for VC6, where volatile is not used and
+    // InterlockedCompareExchange is declared incorrectly.
+    typedef LONG T;      
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC < 1300)
+    typedef T* InterlockTPtr;
+    typedef LPVOID ET;
+    typedef ET* InterlockETPtr;
+#else
+    typedef volatile T* InterlockTPtr;
+    typedef T ET;
+    typedef InterlockTPtr InterlockETPtr;
+#endif
+    inline static T     Exchange_NoSync(volatile T* p, T val)            { return InterlockedExchange((InterlockTPtr)p, val); }
+    inline static T     ExchangeAdd_NoSync(volatile T* p, T val)         { return InterlockedExchangeAdd((InterlockTPtr)p, val); }
+    inline static bool  CompareAndSet_NoSync(volatile T* p, T c, T val)  { return InterlockedCompareExchange((InterlockETPtr)p, (ET)val, (ET)c) == (ET)c; }
+
+#elif defined(OVR_CPU_PPC64) || defined(OVR_CPU_PPC)
+    typedef uint32_t T;
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "stwcx. %[j],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret) : [i] "b" (i), [j] "b" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "add    %[o],%[r],%[j]\n\t"
+                     "stwcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "cmpw   0,%[r],%[cmp]\n\t"
+                     "mfcr   %[r]\n\t"
+                     "bne-   2f\n\t"
+                     "stwcx. %[val],0,%[i]\n\t"
+                     "bne-   1b\n\t"
+                     "2:\n"
+                     : "+m" (*i), [r] "=&b" (ret) : [i] "b" (i), [cmp] "b" (c), [val] "b" (value) : "cc", "memory");
+
+        return (ret & 0x20000000) ? 1 : 0;
+    }
+
+#elif defined(OVR_CPU_MIPS)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "ll     %[r],0(%[i])\n\t"
+                     "sc     %[j],0(%[i])\n\t"
+                     "beq    %[j],$0,1b\n\t"
+                     "nop    \n"
+                     : "+m" (*i), [r] "=&d" (ret) : [i] "d" (i), [j] "d" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "ll     %[r],0(%[i])\n\t"
+                     "addu   %[j],%[r],%[j]\n\t"
+                     "sc     %[j],0(%[i])\n\t"
+                     "beq    %[j],$0,1b\n\t"
+                     "nop    \n"
+                     : "+m" (*i), [r] "=&d" (ret) : [i] "d" (i), [j] "d" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret, dummy;
+
+        asm volatile("1:\n\t"
+                     "move   %[r],$0\n\t"
+                     "ll     %[o],0(%[i])\n\t"
+                     "bne    %[o],%[c],2f\n\t"
+                     "move   %[r],%[v]\n\t"
+                     "sc     %[r],0(%[i])\n\t"
+                     "beq    %[r],$0,1b\n\t"
+                     "nop    \n\t"
+                     "2:\n"
+                     : "+m" (*i),[r] "=&d" (ret), [o] "=&d" (dummy) : [i] "d" (i), [c] "d" (c), [v] "d" (value)
+                     : "cc", "memory");
+
+        return ret;
+    }
+
+#elif defined(OVR_CPU_ARM) && defined(OVR_CC_ARM)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (__strex(j, i) == 0)
+                return r;
+        }
+    }
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (__strex(r + j, i) == 0)
+                return r;
+        }
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (r != c)
+                return 0;
+            if (__strex(value, i) == 0)
+                return 1;
+        }
+    }
+
+#elif defined(OVR_CPU_ARM)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret, dummy;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[r],[%[i]]\n\t"
+            "strex  %[t],%[j],[%[i]]\n\t"
+            "cmp    %[t],#0\n\t"
+            "bne    1b\n\t"
+            : "+m" (*i), [r] "=&r" (ret), [t] "=&r" (dummy) : [i] "r" (i), [j] "r" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret, dummy, test;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[r],[%[i]]\n\t"
+            "add    %[o],%[r],%[j]\n\t"
+            "strex  %[t],%[o],[%[i]]\n\t"
+            "cmp    %[t],#0\n\t"
+            "bne    1b\n\t"
+            : "+m" (*i), [r] "=&r" (ret), [o] "=&r" (dummy), [t] "=&r" (test)  : [i] "r" (i), [j] "r" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret = 1, dummy, test;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[o],[%[i]]\n\t"
+            "cmp    %[o],%[c]\n\t"
+            "bne    2f\n\t"
+            "strex  %[r],%[v],[%[i]]\n\t"
+            "cmp    %[r],#0\n\t"
+            "bne    1b\n\t"
+            "2:\n"
+            : "+m" (*i),[r] "=&r" (ret), [o] "=&r" (dummy), [t] "=&r" (test) : [i] "r" (i), [c] "r" (c), [v] "r" (value)
+            : "cc", "memory");
+
+        return !ret;
+    }
+
+#elif defined(OVR_CPU_X86)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        asm volatile("xchgl %1,%[i]\n"
+                     : "+m" (*i), "=q" (j) : [i] "m" (*i), "1" (j) : "cc", "memory");
+
+        return j;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        asm volatile("lock; xaddl %1,%[i]\n"
+                     : "+m" (*i), "+q" (j) : [i] "m" (*i) : "cc", "memory");
+
+        return j;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret;
+
+        asm volatile("lock; cmpxchgl %[v],%[i]\n"
+                     : "+m" (*i), "=a" (ret) : [i] "m" (*i), "1" (c), [v] "q" (value) : "cc", "memory");
+
+        return (ret == c);
+    }
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4 && __GNUC_MINOR__ >= 1)
+
+    typedef uint32_t T;
+
+    static inline T   Exchange_NoSync(volatile T *i, T j)
+    {
+        T v;
+        do {
+            v = *i;
+        } while (!__sync_bool_compare_and_swap(i, v, j));
+        return v;
+    }
+
+    static inline T   ExchangeAdd_NoSync(volatile T *i, T j)
+    {
+        return __sync_fetch_and_add(i, j);
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile T *i, T c, T value)
+    {
+        return __sync_bool_compare_and_swap(i, c, value);
+    }
+
+#endif // OS
+};
+
+
+// 8-Byte raw data data atomic op implementation class.
+// Currently implementation is provided only on systems with 64-bit pointers.
+struct AtomicOpsRaw_8ByteImpl : public AtomicOpsRawBase
+{    
+#if !defined(OVR_64BIT_POINTERS) || !defined(OVR_ENABLE_THREADS)
+
+    // Provide a type for no-thread-support cases. Used by AtomicOpsRaw_DefImpl.
+    typedef uint64_t T;
+
+    // *** Thread - Safe OS specific versions.
+#elif defined(OVR_OS_WIN32) 
+
+    // This is only for 64-bit systems.
+    typedef LONG64      T;
+    typedef volatile T* InterlockTPtr;    
+    inline static T     Exchange_NoSync(volatile T* p, T val)            { return InterlockedExchange64((InterlockTPtr)p, val); }
+    inline static T     ExchangeAdd_NoSync(volatile T* p, T val)         { return InterlockedExchangeAdd64((InterlockTPtr)p, val); }
+    inline static bool  CompareAndSet_NoSync(volatile T* p, T c, T val)  { return InterlockedCompareExchange64((InterlockTPtr)p, val, c) == c; }
+
+#elif defined(OVR_CPU_PPC64)
+ 
+    typedef uint64_t T;
+
+    static inline uint64_t Exchange_NoSync(volatile uint64_t *i, uint64_t j)
+    {
+        uint64_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "mr     %[o],%[j]\n\t"
+                     "stdcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc");
+
+        return ret;
+    }
+
+    static inline uint64_t ExchangeAdd_NoSync(volatile uint64_t *i, uint64_t j)
+    {
+        uint64_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "add    %[o],%[r],%[j]\n\t"
+                     "stdcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint64_t *i, uint64_t c, uint64_t value)
+    {
+        uint64_t ret, dummy;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "cmpw   0,%[r],%[cmp]\n\t"
+                     "mfcr   %[r]\n\t"
+                     "bne-   2f\n\t"
+                     "stdcx. %[val],0,%[i]\n\t"
+                     "bne-   1b\n\t"
+                     "2:\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [cmp] "b" (c), [val] "b" (value) : "cc");
+
+        return (ret & 0x20000000) ? 1 : 0;
+    }
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4 && __GNUC_MINOR__ >= 1)
+
+    typedef uint64_t T;
+
+    static inline T   Exchange_NoSync(volatile T *i, T j)
+    {
+        T v;
+        do {
+            v = *i;
+        } while (!__sync_bool_compare_and_swap(i, v, j));
+        return v;
+    }
+
+    static inline T   ExchangeAdd_NoSync(volatile T *i, T j)
+    {
+        return __sync_fetch_and_add(i, j);
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile T *i, T c, T value)
+    {
+        return __sync_bool_compare_and_swap(i, c, value);
+    }
+
+#endif // OS
+};
+
+
+// Default implementation for AtomicOpsRaw; provides implementation of mem-fenced
+// atomic operations where fencing is done with a sync object wrapped around a NoSync
+// operation implemented in the base class. If such implementation is not possible
+// on a given platform, #ifdefs can be used to disable it and then op functions can be
+// implemented individually in the appropriate AtomicOpsRaw<size> class.
+
+template<class O>
+struct AtomicOpsRaw_DefImpl : public O
+{
+    typedef typename O::T O_T;
+    typedef typename O::FullSync    O_FullSync;
+    typedef typename O::AcquireSync O_AcquireSync;
+    typedef typename O::ReleaseSync O_ReleaseSync;
+
+    // If there is no thread support, provide the default implementation. In this case,
+    // the base class (0) must still provide the T declaration.
+#ifndef OVR_ENABLE_THREADS
+
+    // Atomic exchange of val with argument. Returns old val.
+    inline static O_T   Exchange_NoSync(volatile O_T* p, O_T val)           { O_T old = *p; *p = val; return old; }
+    // Adds a new val to argument; returns its old val.
+    inline static O_T   ExchangeAdd_NoSync(volatile O_T* p, O_T val)        { O_T old = *p; *p += val; return old; }
+    // Compares the argument data with 'c' val.
+    // If succeeded, stores val int '*p' and returns true; otherwise returns false.
+    inline static bool  CompareAndSet_NoSync(volatile O_T* p, O_T c, O_T val) { if (*p==c) { *p = val; return 1; } return 0; }
+
+#endif
+
+    // If NoSync wrapped implementation may not be possible, it this block should be
+    //  replaced with per-function implementation in O.
+    // "AtomicOpsRaw_DefImpl<O>::" prefix in calls below.
+    inline static O_T   Exchange_Sync(volatile O_T* p, O_T val)                { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }
+    inline static O_T   Exchange_Release(volatile O_T* p, O_T val)             { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }
+    inline static O_T   Exchange_Acquire(volatile O_T* p, O_T val)             { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }  
+    inline static O_T   ExchangeAdd_Sync(volatile O_T* p, O_T val)             { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static O_T   ExchangeAdd_Release(volatile O_T* p, O_T val)          { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static O_T   ExchangeAdd_Acquire(volatile O_T* p, O_T val)          { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static bool  CompareAndSet_Sync(volatile O_T* p, O_T c, O_T val)    { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+    inline static bool  CompareAndSet_Release(volatile O_T* p, O_T c, O_T val) { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+    inline static bool  CompareAndSet_Acquire(volatile O_T* p, O_T c, O_T val) { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+
+    // Loads and stores with memory fence. These have only the relevant versions.
+#ifdef OVR_CPU_X86
+    // On X86, Store_Release is implemented as exchange. Note that we can also
+    // consider 'sfence' in the future, although it is not as compatible with older CPUs.
+    inline static void  Store_Release(volatile O_T* p, O_T val)  { Exchange_Release(p, val); }
+#else
+    inline static void  Store_Release(volatile O_T* p, O_T val)  { O_ReleaseSync sync; OVR_UNUSED(sync); *p = val; }
+#endif
+    inline static O_T   Load_Acquire(const volatile O_T* p)      { O_AcquireSync sync; OVR_UNUSED(sync); return *p; }
+};
+
+
+template<int size>
+struct AtomicOpsRaw : public AtomicOpsRawBase { };
+
+template<>
+struct AtomicOpsRaw<4> : public AtomicOpsRaw_DefImpl<AtomicOpsRaw_4ByteImpl>
+{   
+    // Ensure that assigned type size is correct.
+    AtomicOpsRaw()
+    { OVR_COMPILER_ASSERT(sizeof(AtomicOpsRaw_DefImpl<AtomicOpsRaw_4ByteImpl>::T) == 4); }
+};
+template<>
+struct AtomicOpsRaw<8> : public AtomicOpsRaw_DefImpl<AtomicOpsRaw_8ByteImpl>
+{
+    AtomicOpsRaw()
+    { OVR_COMPILER_ASSERT(sizeof(AtomicOpsRaw_DefImpl<AtomicOpsRaw_8ByteImpl>::T) == 8); }
+};
+
+
+// *** AtomicOps - implementation of atomic Ops for specified class
+
+// Implements atomic ops on a class, provided that the object is either
+// 4 or 8 bytes in size (depending on the AtomicOpsRaw specializations
+// available). Relies on AtomicOpsRaw for much of implementation.
+
+template<class C>
+class AtomicOps
+{
+    typedef AtomicOpsRaw<sizeof(C)>       Ops;
+    typedef typename Ops::T               T;
+    typedef volatile typename Ops::T*     PT;
+    // We cast through unions to (1) avoid pointer size compiler warnings
+    // and (2) ensure that there are no problems with strict pointer aliasing.
+    union C2T_union { C c; T t; };
+
+public:
+    // General purpose implementation for standard syncs.    
+    inline static C     Exchange_Sync(volatile C* p, C val)             { C2T_union u; u.c = val; u.t = Ops::Exchange_Sync((PT)p, u.t); return u.c; }
+    inline static C     Exchange_Release(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::Exchange_Release((PT)p, u.t); return u.c; }
+    inline static C     Exchange_Acquire(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::Exchange_Acquire((PT)p, u.t); return u.c; }
+    inline static C     Exchange_NoSync(volatile C* p, C val)           { C2T_union u; u.c = val; u.t = Ops::Exchange_NoSync((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Sync(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Sync((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Release(volatile C* p, C val)       { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Release((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Acquire(volatile C* p, C val)       { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Acquire((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_NoSync(volatile C* p, C val)        { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_NoSync((PT)p, u.t); return u.c; }
+    inline static bool  CompareAndSet_Sync(volatile C* p, C c, C val)   { C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Sync((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_Release(volatile C* p, C c, C val){ C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Release((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_Relse(volatile C* p, C c, C val){ C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Acquire((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_NoSync(volatile C* p, C c, C val) { C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_NoSync((PT)p, cu.t, u.t); }
+    // Loads and stores with memory fence. These have only the relevant versions.    
+    inline static void  Store_Release(volatile C* p, C val)             { C2T_union u; u.c = val; Ops::Store_Release((PT)p, u.t); }    
+    inline static C     Load_Acquire(const volatile C* p)               { C2T_union u; u.t = Ops::Load_Acquire((PT)p); return u.c; }
+};
+
+
+
+// Atomic value base class - implements operations shared for integers and pointers.
+template<class T>
+class AtomicValueBase
+{
+protected:
+    typedef AtomicOps<T> Ops;
+public:
+
+    volatile T  Value;
+
+    inline AtomicValueBase()                  { }
+    explicit inline AtomicValueBase(T val)    { Ops::Store_Release(&Value, val); }
+
+    // Most libraries (TBB and Joshua Scholar's) library do not do Load_Acquire
+    // here, since most algorithms do not require atomic loads. Needs some research.    
+    inline operator T() const { return Value; }
+
+    // *** Standard Atomic inlines
+    inline T     Exchange_Sync(T val)               { return Ops::Exchange_Sync(&Value,  val); }
+    inline T     Exchange_Release(T val)            { return Ops::Exchange_Release(&Value, val); }
+    inline T     Exchange_Acquire(T val)            { return Ops::Exchange_Acquire(&Value, val); }
+    inline T     Exchange_NoSync(T val)             { return Ops::Exchange_NoSync(&Value, val); }
+    inline bool  CompareAndSet_Sync(T c, T val)     { return Ops::CompareAndSet_Sync(&Value, c, val); }
+    inline bool  CompareAndSet_Release(T c, T val)  { return Ops::CompareAndSet_Release(&Value, c, val); }
+    inline bool  CompareAndSet_Acquire(T c, T val)  { return Ops::CompareAndSet_Relse(&Value, c, val); }
+    inline bool  CompareAndSet_NoSync(T c, T val)   { return Ops::CompareAndSet_NoSync(&Value, c, val); }
+    // Load & Store.
+    inline void  Store_Release(T val)               { Ops::Store_Release(&Value, val); }
+    inline T     Load_Acquire() const               { return Ops::Load_Acquire(&Value);  }
+};
+
+
+// ***** AtomicPtr - Atomic pointer template
+
+// This pointer class supports atomic assignments with release,
+// increment / decrement operations, and conditional compare + set.
+
+template<class T>
+class AtomicPtr : public AtomicValueBase<T*>
+{
+    typedef typename AtomicValueBase<T*>::Ops Ops;
+
+public:
+    // Initialize pointer value to 0 by default; use Store_Release only with explicit constructor.
+    inline AtomicPtr() : AtomicValueBase<T*>()                     { this->Value = 0; }
+    explicit inline AtomicPtr(T* val) : AtomicValueBase<T*>(val)   { }
+        
+    // Pointer access.
+    inline T* operator -> () const     { return this->Load_Acquire(); }
+
+    // It looks like it is convenient to have Load_Acquire characteristics
+    // for this, since that is convenient for algorithms such as linked
+    // list traversals that can be added to bu another thread.
+    inline operator T* () const        { return this->Load_Acquire(); }
+
+
+    // *** Standard Atomic inlines (applicable to pointers)
+
+    // ExhangeAdd considers pointer size for pointers.
+    template<class I>
+    inline T*     ExchangeAdd_Sync(I incr)      { return Ops::ExchangeAdd_Sync(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_Release(I incr)   { return Ops::ExchangeAdd_Release(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_Acquire(I incr)   { return Ops::ExchangeAdd_Acquire(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_NoSync(I incr)    { return Ops::ExchangeAdd_NoSync(&this->Value, ((T*)0) + incr); }
+
+    // *** Atomic Operators
+
+    inline T* operator = (T* val)  { this->Store_Release(val); return val; }
+
+    template<class I>
+    inline T* operator += (I val) { return ExchangeAdd_Sync(val) + val; }
+    template<class I>
+    inline T* operator -= (I val) { return operator += (-val); }
+
+    inline T* operator ++ ()      { return ExchangeAdd_Sync(1) + 1; }
+    inline T* operator -- ()      { return ExchangeAdd_Sync(-1) - 1; }
+    inline T* operator ++ (int)   { return ExchangeAdd_Sync(1); }
+    inline T* operator -- (int)   { return ExchangeAdd_Sync(-1); }
+};
+
+
+// ***** AtomicInt - Atomic integer template
+
+// Implements an atomic integer type; the exact type to use is provided 
+// as an argument. Supports atomic Acquire / Release semantics, atomic
+// arithmetic operations, and atomic conditional compare + set.
+
+template<class T>
+class AtomicInt : public AtomicValueBase<T>
+{
+    typedef typename AtomicValueBase<T>::Ops Ops;
+
+public:
+    inline AtomicInt() : AtomicValueBase<T>()                     { }
+    explicit inline AtomicInt(T val) : AtomicValueBase<T>(val)    { }
+
+
+    // *** Standard Atomic inlines (applicable to int)   
+    inline T     ExchangeAdd_Sync(T val)            { return Ops::ExchangeAdd_Sync(&this->Value, val); }
+    inline T     ExchangeAdd_Release(T val)         { return Ops::ExchangeAdd_Release(&this->Value, val); }
+    inline T     ExchangeAdd_Acquire(T val)         { return Ops::ExchangeAdd_Acquire(&this->Value, val); }
+    inline T     ExchangeAdd_NoSync(T val)          { return Ops::ExchangeAdd_NoSync(&this->Value, val); }
+    // These increments could be more efficient because they don't return a value.
+    inline void  Increment_Sync()                   { ExchangeAdd_Sync((T)1); }
+    inline void  Increment_Release()                { ExchangeAdd_Release((T)1); }
+    inline void  Increment_Acquire()                { ExchangeAdd_Acquire((T)1); }    
+    inline void  Increment_NoSync()                 { ExchangeAdd_NoSync((T)1); }
+
+    // *** Atomic Operators
+
+    inline T operator = (T val)  { this->Store_Release(val); return val; }
+    inline T operator += (T val) { return ExchangeAdd_Sync(val) + val; }
+    inline T operator -= (T val) { return ExchangeAdd_Sync(0 - val) - val; }
+
+    inline T operator ++ ()      { return ExchangeAdd_Sync((T)1) + 1; }
+    inline T operator -- ()      { return ExchangeAdd_Sync(((T)0)-1) - 1; }
+    inline T operator ++ (int)   { return ExchangeAdd_Sync((T)1); }
+    inline T operator -- (int)   { return ExchangeAdd_Sync(((T)0)-1); }
+
+    // More complex atomic operations. Leave it to compiler whether to optimize them or not.
+    T operator &= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp & arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator |= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp | arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator ^= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp ^ arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator *= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp * arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator /= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp / arg;
+        } while(!CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator >>= (unsigned bits)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp >> bits;
+        } while(!CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator <<= (unsigned bits)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp << bits;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Lock
+
+// Lock is a simplest and most efficient mutual-exclusion lock class.
+// Unlike Mutex, it cannot be waited on.
+
+class Lock
+{
+    // NOTE: Locks are not allocatable and they themselves should not allocate 
+    // memory by standard means. This is the case because StandardAllocator
+    // relies on this class.
+    // Make 'delete' private. Don't do this for 'new' since it can be redefined.  
+    void    operator delete(void*) {}
+
+
+    // *** Lock implementation for various platforms.
+    
+#if !defined(OVR_ENABLE_THREADS)
+
+public:
+    // With no thread support, lock does nothing.
+    inline Lock() { }
+    inline Lock(unsigned) { }
+    inline ~Lock() { }    
+    inline void DoLock() { }
+    inline void Unlock() { }
+
+   // Windows.   
+#elif defined(OVR_OS_WIN32) 
+
+    CRITICAL_SECTION cs;
+public:   
+    Lock(unsigned spinCount = 0);      
+    ~Lock();
+    // Locking functions.
+    inline void DoLock()    { ::EnterCriticalSection(&cs); }
+    inline void Unlock()    { ::LeaveCriticalSection(&cs); }
+
+#else
+    pthread_mutex_t mutex;
+
+public:
+    static pthread_mutexattr_t RecursiveAttr;
+    static bool                RecursiveAttrInit;
+
+    Lock (unsigned dummy = 0)
+    {
+        OVR_UNUSED(dummy);
+        if (!RecursiveAttrInit)
+        {
+            pthread_mutexattr_init(&RecursiveAttr);
+            pthread_mutexattr_settype(&RecursiveAttr, PTHREAD_MUTEX_RECURSIVE);
+            RecursiveAttrInit = 1;
+        }
+        pthread_mutex_init(&mutex,&RecursiveAttr);
+    }
+    ~Lock ()                { pthread_mutex_destroy(&mutex); }
+    inline void DoLock()    { pthread_mutex_lock(&mutex); }
+    inline void Unlock()    { pthread_mutex_unlock(&mutex); }
+
+#endif // OVR_ENABLE_THREDS
+
+
+public:
+    // Locker class, used for automatic locking
+    class Locker
+    {
+    public:     
+        Lock *pLock;
+        inline Locker(Lock *plock)
+        { pLock = plock; pLock->DoLock(); }
+        inline ~Locker()
+        { pLock->Unlock();  }
+    };
+};
+
+
+//-------------------------------------------------------------------------------------
+// Globally shared Lock implementation used for MessageHandlers, etc.
+
+class SharedLock
+{    
+public:
+    SharedLock() : UseCount(0) {}
+
+    Lock* GetLockAddRef();
+    void  ReleaseLock(Lock* plock);
+   
+private:
+    Lock* toLock() { return (Lock*)Buffer; }
+
+    // UseCount and max alignment.
+    volatile int    UseCount;
+    uint64_t        Buffer[(sizeof(Lock)+sizeof(uint64_t)-1)/sizeof(uint64_t)];
+};
+
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Color.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Color.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,68 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Color.h
+Content     :   Contains color struct.
+Created     :   February 7, 2013
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_Color_h
+#define OVR_Color_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+struct Color
+{
+    uint8_t R,G,B,A;
+
+    Color() {}
+
+    // Constructs color by channel. Alpha is set to 0xFF (fully visible)
+    // if not specified.
+    Color(unsigned char r,unsigned char g,unsigned char b, unsigned char a = 0xFF)
+        : R(r), G(g), B(b), A(a) { }
+
+    // 0xAARRGGBB - Common HTML color Hex layout
+    Color(unsigned c)
+        : R((unsigned char)(c>>16)), G((unsigned char)(c>>8)),
+        B((unsigned char)c), A((unsigned char)(c>>24)) { }
+
+    bool operator==(const Color& b) const
+    {
+        return R == b.R && G == b.G && B == b.B && A == b.A;
+    }
+
+    void  GetRGBA(float *r, float *g, float *b, float* a) const
+    {
+        *r = R / 255.0f;
+        *g = G / 255.0f;
+        *b = B / 255.0f;
+        *a = A / 255.0f;
+    }
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Compiler.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Compiler.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1523 @@
+/************************************************************************************
+
+PublicHeader:   OVR.h
+Filename    :   OVR_Compiler.h
+Content     :   Compiler-specific feature identification and utilities
+Created     :   June 19, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+
+#ifndef OVR_Compiler_h
+#define OVR_Compiler_h
+
+#pragma once
+
+
+// References
+//    https://gcc.gnu.org/projects/cxx0x.html
+//    https://gcc.gnu.org/projects/cxx1y.html
+//    http://clang.llvm.org/cxx_status.html
+//    http://msdn.microsoft.com/en-us/library/hh567368.aspx
+//    https://docs.google.com/spreadsheet/pub?key=0AoBblDsbooe4dHZuVTRoSTFBejk5eFBfVk1GWlE5UlE&output=html
+//    http://nadeausoftware.com/articles/2012/10/c_c_tip_how_detect_compiler_name_and_version_using_compiler_predefined_macros
+
+
+//-----------------------------------------------------------------------------------
+// ***** Compiler
+//
+//  The following compilers are defined: (OVR_CC_x)
+//
+//     MSVC     - Microsoft Visual C/C++
+//     INTEL    - Intel C++ for Linux / Windows
+//     GNU      - GNU C++
+//     ARM      - ARM C/C++
+
+#if defined(__INTEL_COMPILER)
+// Intel 4.0                    = 400
+// Intel 5.0                    = 500
+// Intel 6.0                    = 600
+// Intel 8.0                    = 800
+// Intel 9.0                    = 900
+#  define OVR_CC_INTEL       __INTEL_COMPILER
+
+#elif defined(_MSC_VER)
+// MSVC 5.0                     = 1100
+// MSVC 6.0                     = 1200
+// MSVC 7.0 (VC2002)            = 1300
+// MSVC 7.1 (VC2003)            = 1310
+// MSVC 8.0 (VC2005)            = 1400
+// MSVC 9.0 (VC2008)            = 1500
+// MSVC 10.0 (VC2010)           = 1600
+// MSVC 11.0 (VC2012)           = 1700
+// MSVC 12.0 (VC2013)           = 1800
+#  define OVR_CC_MSVC        _MSC_VER
+
+#if _MSC_VER == 0x1600
+#  if _MSC_FULL_VER < 160040219
+#     error "Oculus does not support VS2010 without SP1 installed."
+#  endif
+#endif
+
+#elif defined(__GNUC__)
+#  define OVR_CC_GNU
+
+#elif defined(__clang__)
+#  define OVR_CC_CLANG
+
+#elif defined(__CC_ARM)
+#  define OVR_CC_ARM
+
+#else
+#  error "Oculus does not support this Compiler"
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_VERSION
+//
+//    M = major version
+//    m = minor version
+//    p = patch release
+//    b = build number
+//
+//    Compiler      Format   Example
+//    ----------------------------
+//    OVR_CC_GNU    Mmm      408 means GCC 4.8
+//    OVR_CC_CLANG  Mmm      305 means clang 3.5 
+//    OVR_CC_MSVC   MMMM     1700 means VS2012
+//    OVR_CC_ARM    Mmpbbb   401677 means 4.0, patch 1, build 677
+//    OVR_CC_INTEL  MMmm     1210 means 12.10
+//    OVR_CC_EDG    Mmm      407 means EDG 4.7
+//
+#if defined(OVR_CC_GNU)
+    #define OVR_CC_VERSION ((__GNUC__ * 100) + __GNUC_MINOR__)
+#elif defined(OVR_CC_CLANG)
+    #define OVR_CC_VERSION ((__clang_major__ * 100) + __clang_minor__)
+#elif defined(OVR_CC_MSVC)
+    #define OVR_CC_VERSION _MSC_VER // Question: Should we recognize _MSC_FULL_VER?
+#elif defined(OVR_CC_ARM)
+    #define OVR_CC_VERSION __ARMCC_VERSION
+#elif defined(OVR_CC_INTEL)
+    #if defined(__INTEL_COMPILER)
+        #define OVR_CC_VERSION __INTEL_COMPILER
+    #elif defined(__ICL)
+        #define OVR_CC_VERSION __ICL
+    #elif defined(__ICC)
+        #define OVR_CC_VERSION __ICC
+    #elif defined(__ECC)
+        #define OVR_CC_VERSION __ECC
+    #endif
+#elif defined(OVR_CC_EDG)
+    #define OVR_CC_VERSION __EDG_VERSION__  // This is a generic fallback for EDG-based compilers which aren't specified above (e.g. as OVR_CC_ARM)
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_OPTIMIZATION / OVR_RESTORE_OPTIMIZATION
+//
+// Allows for the dynamic disabling and restoring of compiler optimizations in code.
+// This is useful for helping deal with potential compiler code generation problems.
+// With VC++ the usage must be outside of function bodies. This can be used only to
+// temporarily disable optimization for a block of code and not to temporarily enable
+// optimization for a block of code.
+//
+// Clang doesn't support this as of June 2014, though function __attribute__((optimize(0))
+// is supposedly supported by clang in addition to GCC. To consider: Make a wrapper for
+// this attribute-based functionality.
+//
+// Example usage:
+//     OVR_DISABLE_OPTIMIZATION()
+//     void Test() { ... }
+//     OVR_RESTORE_OPTIMIZATION()
+//
+#if !defined(OVR_DISABLE_OPTIMIZATION)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION > 404) && (defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64))
+        #define OVR_DISABLE_OPTIMIZATION() \
+            _Pragma("GCC push_options")    \
+            _Pragma("GCC optimize 0")
+    #elif defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_OPTIMIZATION() __pragma(optimize("", off))
+    #else
+        #define OVR_DISABLE_OPTIMIZATION()
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_OPTIMIZATION)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION > 404) && (defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64))
+        #define OVR_RESTORE_OPTIMIZATION() _Pragma("GCC pop_options")
+    #elif defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_OPTIMIZATION() __pragma(optimize("", on))
+    #else
+        #define OVR_RESTORE_OPTIMIZATION()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// *****  OVR_DISABLE_GNU_WARNING / OVR_RESTORE_GNU_WARNING
+//
+// Portable wrapper for disabling GCC compiler warnings, one at a time. See example
+// usage for usage by example.
+//
+// Example usage:
+//     OVR_DISABLE_GNU_WARNING(-Wmissing-braces)  // Only one warning per usage.
+//     OVR_DISABLE_GNU_WARNING(-Wunused-variable)
+//     <code>
+//     OVR_RESTORE_GNU_WARNINGS()
+//     OVR_RESTORE_GNU_WARNINGS()                 // Must match each disable with a restore.
+//
+#if !defined(OVR_DISABLE_GNU_WARNING)
+    #if defined(OVR_CC_GNU)
+        #define ODGW1(x) #x
+        #define ODGW2(x) ODGW1(GCC diagnostic ignored x)
+        #define ODGW3(x) ODGW2(#x)
+    #endif
+
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 406)
+        #define OVR_DISABLE_GNU_WARNING(w)  \
+            _Pragma("GCC diagnostic push")  \
+            _Pragma(ODGW3(w))
+    #elif defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 404)  // GCC 4.4 doesn't support diagnostic push, but supports disabling warnings.
+        #define OVR_DISABLE_GNU_WARNING(w)  \
+            _Pragma(ODGW3(w))
+    #else
+        #define OVR_DISABLE_GNU_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_GNU_WARNING)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 4006)
+        #define OVR_RESTORE_GNU_WARNINGS()  \
+            _Pragma("GCC diagnostic pop")
+    #else
+        #define OVR_RESTORE_GNU_WARNING()
+    #endif
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// *****  OVR_DISABLE_CLANG_WARNING / OVR_RESTORE_CLANG_WARNING
+//
+// Portable wrapper for disabling GCC compiler warnings, one at a time. See example
+// usage for usage by example.
+//
+// Example usage:
+//     OVR_DISABLE_CLANG_WARNING(-Wmissing-braces)  // Only one warning per usage.
+//     OVR_DISABLE_CLANG_WARNING(-Wunused-variable)
+//     <code>
+//     OVR_RESTORE_CLANG_WARNINGS()
+//     OVR_RESTORE_CLANG_WARNINGS()                 // Must match each disable with a restore.
+//
+//
+#if !defined(OVR_DISABLE_CLANG_WARNING)
+    #if defined(OVR_CC_CLANG)
+        #define ODCW1(x) #x
+        #define ODCW2(x) ODCW1(clang diagnostic ignored x)
+        #define ODCW3(x) ODCW2(#x)
+
+        #define OVR_DISABLE_CLANG_WARNING(w)   \
+            _Pragma("clang diagnostic push")  \
+            _Pragma(ODCW3(w))
+    #else
+        #define OVR_DISABLE_CLANG_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_CLANG_WARNING)
+    #if defined(OVR_CC_CLANG)
+        #define OVR_RESTORE_CLANG_WARNING()    \
+            _Pragma("clang diagnostic pop")
+    #else
+        #define OVR_RESTORE_CLANG_WARNING()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_MSVC_WARNING / OVR_RESTORE_MSVC_WARNING
+//
+// Portable wrapper for disabling VC++ compiler warnings. See example usage for usage
+// by example.
+//
+// Example usage:
+//     OVR_DISABLE_MSVC_WARNING(4556 4782 4422)
+//     <code>
+//     OVR_RESTORE_MSVC_WARNING()
+//
+#if !defined(OVR_DISABLE_MSVC_WARNING)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_MSVC_WARNING(w) \
+            __pragma(warning(push))         \
+            __pragma(warning(disable:w))
+    #else
+        #define OVR_DISABLE_MSVC_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_MSVC_WARNING)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_MSVC_WARNING() \
+            __pragma(warning(pop))
+    #else
+        #define OVR_RESTORE_MSVC_WARNING()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_ALL_MSVC_WARNINGS / OVR_RESTORE_ALL_MSVC_WARNINGS
+//
+// Portable wrapper for disabling all VC++ compiler warnings.
+// OVR_RESTORE_ALL_MSVC_WARNINGS restores warnings that were disabled by 
+// OVR_DISABLE_ALL_MSVC_WARNINGS. Any previously enabled warnings will still be 
+// enabled after OVR_RESTORE_ALL_MSVC_WARNINGS.
+//
+// Example usage:
+//     OVR_DISABLE_ALL_MSVC_WARNINGS()
+//     <code>
+//     OVR_RESTORE_ALL_MSVC_WARNINGS()
+
+#if !defined(OVR_DISABLE_ALL_MSVC_WARNINGS)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_ALL_MSVC_WARNINGS() \
+            __pragma(warning(push, 0))
+    #else
+        #define OVR_DISABLE_ALL_MSVC_WARNINGS()
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_ALL_MSVC_WARNINGS)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_ALL_MSVC_WARNINGS() \
+            __pragma(warning(pop))
+    #else
+        #define OVR_RESTORE_ALL_MSVC_WARNINGS()
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_HAS_FEATURE
+//
+// This is a portable way to use compile-time feature identification available 
+// with some compilers in a clean way. Direct usage of __has_feature in preprocessing
+// statements of non-supporting compilers results in a preprocessing error.
+//
+// Example usage:
+//     #if OVR_CC_HAS_FEATURE(is_pod)
+//         if(__is_pod(T)) // If the type is plain data then we can safely memcpy it.
+//             memcpy(&destObject, &srcObject, sizeof(object));
+//     #endif
+//
+#if !defined(OVR_CC_HAS_FEATURE)
+    #if defined(__clang__) // http://clang.llvm.org/docs/LanguageExtensions.html#id2
+        #define OVR_CC_HAS_FEATURE(x) __has_feature(x)
+    #else
+        #define OVR_CC_HAS_FEATURE(x) 0
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_HAS_BUILTIN
+//
+//
+// This is a portable way to use compile-time builtin identification available 
+// with some compilers in a clean way. Direct usage of __has_builtin in preprocessing
+// statements of non-supporting compilers results in a preprocessing error.
+//
+// Example usage:
+//     #if OVR_CC_HAS_BUILTIN(__builtin_trap)
+//         #define DEBUG_BREAK __builtin_trap
+//     #endif
+//  
+#if !defined(OVR_CC_HAS_BUILTIN)
+    #if defined(__clang__) 
+        #define OVR_CC_HAS_BUILTIN(x) __has_builtin(x) // http://clang.llvm.org/docs/LanguageExtensions.html#id2
+    #else
+        #define OVR_CC_HAS_BUILTIN(x) 0
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP11_ENABLED / OVR_CPP_CPP14_ENABLED
+//
+// Defined as 1 if the compiler has its available C++11 support enabled, else undefined.
+// This does not mean that all of C++11 or any particular feature of C++11 is supported
+// by the compiler. It means that whatever C++11 support the compiler has is enabled.
+// This also includes existing and older compilers that still identify C++11 as C++0x.
+//
+#if !defined(OVR_CPP11_ENABLED) && defined(__cplusplus)
+    #if defined(__GNUC__) && defined(__GXX_EXPERIMENTAL_CXX0X__)
+        #define OVR_CPP11_ENABLED 1
+    #elif defined(_MSC_VER) && (_MSC_VER >= 1500)   // VS2010+, the first version with any significant C++11 support. 
+        #define OVR_CPP11_ENABLED 1
+    #elif (__cplusplus >= 201103L)                  // 201103 is the first C++11 version.
+        #define OVR_CPP11_ENABLED 1
+    #else
+        // Leave undefined
+    #endif
+#endif
+
+#if !defined(OVR_CPP_CPP14_ENABLED) && defined(__cplusplus)
+    #if defined(_MSC_VER) && (_MSC_VER >= 1800)     // VS2013+, the first version with any significant C++14 support. 
+        #define OVR_CPP_CPP14_ENABLED 1
+    #elif (__cplusplus > 201103L)
+        #define OVR_CPP_CPP14_ENABLED 1
+    #else
+        // Leave undefined
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXCEPTIONS / OVR_CPP_NO_UNWIND
+//
+// OVR_CPP_NO_EXCEPTIONS is defined as 1 if the compiler doesn't support C++ 
+// exceptions or is configured to disable support for them. Else not defined.
+// If OVR_CPP_NO_EXCEPTIONS is defined then attempts to use try/catch
+// related C++ statements result in a compilation error with many
+// compilers.
+//
+// OVR_CPP_NO_UNWIND is defined as 1 if the compiler supports exceptions but 
+// doesn't support stack unwinding in the presence of an exception. Else not defined.
+// For the Microsoft compiler, disabling exceptions means disabling stack unwinding
+// and not disabling exceptions themselves.
+//
+// Example usage:
+//     void Test() {
+//         #if !defined(OVR_CPP_NO_EXCEPTIONS)
+//             try {
+//         #endif
+//             void* ptr = new Object;
+//         #if !defined(OVR_CPP_NO_EXCEPTIONS)
+//             catch(...) { ... }
+//         #endif
+
+#if !defined(OVR_CPP_NO_EXCEPTIONS)
+    #if defined(OVR_CPP_GNUC) && defined(_NO_EX)
+        #define OVR_CPP_NO_EXCEPTIONS 1
+    #elif (defined(OVR_CC_GNU) || defined(OVR_CC_CLANG) || defined(OVR_CC_INTEL) || defined(OVR_CC_ARM)) && !defined(__EXCEPTIONS)
+        #define OVR_CPP_NO_EXCEPTIONS 1
+    #elif defined(OVR_CC_MSVC) && !defined(_CPPUNWIND)
+        #define OVR_CPP_NO_UNWIND 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RTTI
+//
+// Defined as 1 if C++ run-time type information support is unavailable or disabled
+// by the compiler. Else undefined. Allows you to write portable code in the face
+// of the possibility that RTTI is disabled.
+//
+// Example usage:
+//     #if !OVR_CPP_NO_RTTI
+//         #include <typeinfo>
+//         int x = std::dynamic_cast<int>(3.4f);
+//     #endif
+
+#if defined(__clang__) && !OVR_CC_HAS_FEATURE(cxx_rtti)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(__GNUC__) && !defined(__GXX_RTTI)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(_MSC_VER) && !defined(_CPPRTTI)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(__CC_ARM) && defined(__TARGET_CPU_MPCORE) && !defined(__RTTI)
+    #define OVR_CPP_NO_RTTI 1
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STATIC_ASSERT
+//
+// Defined as 1 if C++ run-time type information support is available and enabled
+// by the compiler. Else undefined.
+//
+// Example usage:
+//     #if OVR_CPP_NO_STATIC_ASSERT
+//         #define MY_ASSERT(x) { int zero = 0; switch(zero) {case 0: case (x):;} }
+//     #else
+//         #define MY_ASSERT(x) static_assert((x), #x)
+//     #endif
+
+#if !defined(OVR_CPP_NO_STATIC_ASSERT)
+    #if !(defined(__GNUC__) && (defined(__GXX_EXPERIMENTAL_CXX0X__) || (defined(__cplusplus) && (__cplusplus >= 201103L)))) && \
+        !(defined(__clang__) && defined(__cplusplus) && OVR_CC_HAS_FEATURE(cxx_static_assert)) &&                              \
+        !(defined(_MSC_VER) && (_MSC_VER >= 1600) && defined(__cplusplus)) &&                 /* VS2010+  */                   \
+        !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401) && defined(OVR_CPP11_ENABLED)) /* EDG 4.1+ */
+	    #define OVR_CPP_NO_STATIC_ASSERT 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NULLPTR
+//
+// Defined as 1 if the compiler doesn't support C++11 nullptr built in type. 
+// Otherwise undefined. Does not identify if the standard library defines 
+// std::nullptr_t, as some standard libraries are further behind in standardization 
+// than the compilers using them (e.g. Apple clang with the supplied libstdc++). 
+//
+// OVR_Nullptr.h provides a portable nullptr and std::nullptr_t for when the 
+// compiler or standard library do not.
+
+#if !defined(OVR_CPP_NO_NULLPTR)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_nullptr))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))          /* GCC 4.6+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))  /* EDG 4.3+  */    
+        #define OVR_CPP_NO_NULLPTR 1
+    #endif
+#endif  
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RVALUE_REFERENCES
+//
+// Defined as 1 if the compiler doesn't support C++11 rvalue references and move semantics.
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_RVALUE_REFERENCES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_rvalue_references)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                   /* GCC 4.5+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                         /* VS2010+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))           /* EDG 4.3+ */    
+        #define OVR_CPP_NO_RVALUE_REFERENCES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_AUTO
+// 
+// Defined as 1 if the compiler doesn't support C++11 auto keyword. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_AUTO)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_auto_type))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))            /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                  /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 309)))    /* EDG 3.9+  */  
+        #define OVR_CPP_NO_AUTO 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RANGE_BASED_FOR_LOOP
+//
+// Defined as 1 if the compiler doesn't support C++11 range-based for loops.
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_RANGE_BASED_FOR_LOOP)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_range_for)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))           /* GCC 4.6+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                 /* VS2012+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))   /* EDG 4.5+ */    
+        #define OVR_CPP_NO_RANGE_BASED_FOR_LOOP 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_CONSTEXPR / OVR_CPP_NO_RELAXED_CONSTEXPR
+//
+// OVR_CPP_NO_CONSTEXPR is defined as 1 if the compiler doesn't support C++11 constexpr.
+// OVR_CPP_NO_RELAXED_CONSTEXPR is defined as 1 if the compiler doesn't support C++14 constexpr.
+// Otherwise undefined.
+// See the OVR_CONSTEXPR / OVR_CONSTEXPR_OR_CONST macros for portable wrappers of this functionality.
+
+#if !defined(OVR_CPP_NO_CONSTEXPR)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_constexpr))  /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))            /* GCC 4.6+ */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))    /* EDG 4.6+ */    
+        // Not supported by VC++ through at least VS2013.
+        #define OVR_CPP_NO_CONSTEXPR 1
+    #endif
+#endif
+
+#if !defined(OVR_CPP_NO_RELAXED_CONSTEXPR)
+    #if !defined(OVR_CPP14_ENABLED) || \
+        !(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_relaxed_constexpr)) /* clang */
+        // Supported only by clang as of this writing.
+        #define OVR_CPP_NO_RELAXED_CONSTEXPR 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_LAMBDA_EXPRESSIONS
+//
+// Defined as 1 if the compiler doesn't support C++11 lambda expressions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_LAMBDA_EXPRESSIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_lambdas))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))          /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))  /* EDG 4.1+  */ 
+        // Conversion of lambdas to function pointers is not supported until EDG 4.5.
+        #define OVR_CPP_NO_LAMBDA_EXPRESSIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_ALIGNOF
+//
+// Defined as 1 if the compiler supports C++11 alignof. Otherwise undefined.
+// Some compilers support __alignof__ instead of alignof, so for portability you 
+// should use OVR_ALIGNOF instead of directly using C++11 alignof.
+
+#if !defined(OVR_CPP_NO_ALIGNOF)
+    #if (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 300))  /* Apple clang 3.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 401))                    /* GCC 4.1+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 400)))            /* EDG 4.0+         */
+        #define OVR_CPP_NO_ALIGNOF 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_ALIGNAS
+//
+// Defined as 1 if the compiler supports C++11 alignas. Otherwise undefined.
+// See the OVR_ALIGNAS for a portable wrapper for alignas functionality.
+
+#if !defined(OVR_CPP_NO_ALIGNAS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300))  /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                    /* GCC 4.8+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        #define OVR_CPP_NO_ALIGNAS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_OVERRIDE
+//
+// Defined as 1 if the compiler doesn't support C++11 override. Otherwise undefined.
+// See the OVR_OVERRIDE and OVR_FINALOVERRIDE macros for a portable wrapper.
+
+#if !defined(OOVR_CPP_NO_OVERRIDE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209)) /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400)) /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                   /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                         /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))           /* EDG 4.8+         */     
+        #define OVR_CPP_NO_OVERRIDE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FINAL
+// 
+// Defined as 1 if the compiler doesn't support C++11 final attribute. Otherwise undefined.
+// See the OVR_FINAL and OVR_FINALOVERRIDE macros for a portable wrapper.
+
+#if !defined(OOVR_CPP_NO_FINAL)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                          /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */    
+        #define OVR_CPP_NO_FINAL 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTERN_TEMPLATE
+//
+// Defined as 1 if the compiler doesn't support C++11 extern template.
+// Otherwise undefined. See OVR_EXTERN_TEMPLATE for wrapper macro.
+
+#if !defined(OVR_CPP_NO_EXTERN_TEMPLATE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                          /* VS2012+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */ 
+        #define OVR_CPP_NO_EXTERN_TEMPLATE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_VARIADIC_TEMPLATES
+//
+// Defined as 1 if the compiler doesn't support C++11 variadic templates. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_VARIADIC_TEMPLATES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_variadic_templates)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))            /* EDG 4.3+  */   
+        #define OVR_CPP_NO_VARIADIC_TEMPLATES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NOEXCEPT
+//
+// Defined as 1 if the compiler supports C++11 noexcept. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/noexcept
+// See OVR_NOEXCEPT / OVR_NOEXCEPT_IF / OVR_NOEXCEPT_EXPR for a portable wrapper
+// for noexcept functionality.
+
+#if !defined(OVR_CPP_NO_NOEXCEPT)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_noexcept))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))           /* GCC 4.6+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                 /* VS2014+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))   /* EDG 4.5+  */
+        #define OVR_CPP_NO_NOEXCEPT 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DECLTYPE
+//
+// Defined as 1 if the compiler doesn't support C++11 decltype. Otherwise undefined.
+// Some compilers (e.g. VS2012) support most uses of decltype but don't support 
+// decltype with incomplete types (which is an uncommon usage seen usually in 
+// template metaprogramming).  We don't include this support as a requirement for
+// our definition of decltype support here.
+
+#if !defined(OVR_CPP_NO_DECLTYPE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_decltype))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))           /* GCC 4.3+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                 /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))   /* EDG 4.2+  */       
+        // VC++ fails to support decltype for incomplete types until VS2013.
+        // EDG fails to support decltype for incomplete types until v4.8.
+        #define OVR_CPP_NO_DECLTYPE 1
+    #endif
+#endif  
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DEFAULTED_FUNCTIONS
+// 
+// Defined as 1 if the compiler doesn't support C++11 defaulted functions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_DEFAULTED_FUNCTIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_defaulted_functions))/* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+ */
+        // Up through at least VS2013 it's unsupported for defaulted move constructors and move assignment operators.
+        // Until EDG 4.8 it's unsupported for defaulted move constructors and move assigment operators.
+        #define OVR_CPP_NO_DEFAULTED_FUNCTIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DELETED_FUNCTIONS
+// 
+// Defined as 1 if the compiler doesn't support C++11 deleted functions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_defaulted_functions)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                     /* GCC 4.4+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                           /* VS2013+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))             /* EDG 4.1+ */  
+        // Up through at least VS2013 it's unsupported for defaulted move constructors and move assignment operators.
+        // Until EDG 4.8 it's unsupported for defaulted move constructors and move assigment operators.
+        #define OVR_CPP_NO_DELETED_FUNCTIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STANDARD_LAYOUT_TYPES
+// 
+// Defined as 1 if the compiler doesn't support C++11 standard layout (relaxed POD). Otherwise undefined.
+// http://en.cppreference.com/w/cpp/types/is_standard_layout
+
+#if !defined(OVR_CPP_NO_STANDARD_LAYOUT_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300)) /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401)) /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                   /* GCC 4.5+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                         /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))           /* EDG 4.6+         */  
+        #define OVR_CPP_NO_STANDARD_LAYOUT_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FORWARD_DECLARED_ENUMS
+//
+// Defined as 1 if the compiler doesn't support C++11 forward declared enums. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_FORWARD_DECLARED_ENUMS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                          /* VS2012+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */ 
+        #define OVR_CPP_NO_FORWARD_DECLARED_ENUMS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STRONGLY_TYPED_ENUMS
+//
+// Defined as 1 if the compiler doesn't support C++11 strongly typed enums. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_STRONGLY_TYPED_ENUMS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_strong_enums))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))               /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                     /* VS2012+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 400)))       /* EDG 4.0+ */ 
+        #define OVR_CPP_NO_STRONGLY_TYPED_ENUMS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_TRAILING_RETURN_TYPES
+//
+// Defined as 1 if the compiler doesn't support C++11 trailing return types. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#Alternative_function_syntax
+
+#if !defined(OVR_CPP_NO_TRAILING_RETURN_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_trailing_return)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                 /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                       /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))         /* EDG 4.1+ */    
+        #define OVR_CPP_NO_TRAILING_RETURN_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_TEMPLATE_ALIASES
+//
+// Defined as 1 if the compiler doesn't support C++11 template aliases. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_TEMPLATE_ALIASES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_alias_templates)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                 /* GCC 4.7+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                       /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))         /* EDG 4.2+  */ 
+        #define OVR_CPP_NO_TEMPLATE_ALIASES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INITIALIZER_LISTS
+//
+// Defined as 1 if the compiler doesn't support C++11 initializer lists. Otherwise undefined.
+// This refers to the compiler support for this and not the Standard Library support for std::initializer_list,
+// as a new compiler with an old standard library (e.g. Apple clang with libstdc++) may not support std::initializer_list.
+
+#if !defined(OVR_CPP_NO_INITIALIZER_LISTS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_generalized_initializers)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                          /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                                /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))                  /* EDG 4.5+  */
+        #define OVR_CPP_NO_INITIALIZER_LISTS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NORETURN
+//
+// Defined as 1 if the compiler doesn't support the C++11 noreturn attribute. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/attributes
+//
+#if !defined(OVR_CPP_NO_NORETURN)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                    /* GCC 4.8+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                          /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))            /* EDG 4.2+         */
+        // Supported with VC++ only via __declspec(noreturn) (see OVR_NORETURN).
+        #define OVR_CPP_NO_NORETURN 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS
+//
+// Defined as 1 if the compiler doesn't support C++11 in-class non-static member initializers. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/data_members
+
+#if !defined(OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))            /* EDG 4.6+         */
+        #define OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DOUBLE_TEMPLATE_BRACKETS
+//
+// Defined as 1 if the compiler supports nested template declarations with >>, 
+// as supported by C++11. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_DOUBLE_TEMPLATE_ANGLE_BRACKETS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))                    /* GCC 4.3+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                          /* VS2010+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */
+        #define OVR_CPP_NO_DOUBLE_TEMPLATE_BRACKETS 1
+    #endif
+#endif
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INHERITING_CONSTRUCTORS
+//
+// Defined as 1 if the compiler supports C++11 inheriting constructors. Otherwise undefined.
+// Example usage:
+//     struct A { explicit A(int x){} };
+//     struct B : public A { using A::A; }; // As if B redeclared A::A(int).
+
+#if !defined(OVR_CPP_NO_INHERITING_CONSTRUCTORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_inheriting_constructors))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                          /* GCC 4.8+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                                /* VS2014+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))                  /* EDG 4.8+  */
+        #define OVR_CPP_NO_INHERITING_CONSTRUCTORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DELEGATING_CONSTRUCTORS
+//
+// Defined as 1 if the compiler supports C++11 delegating constructors. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_DELEGATING_CONSTRUCTORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300))  /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))            /* EDG 4.7+         */
+        #define OVR_CPP_NO_DELEGATING_CONSTRUCTORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS
+//  
+// Defined as 1 if the compiler supports C++11 function template default arguments. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))                    /* GCC 4.3+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))            /* EDG 4.3+         */
+        #define OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNRESTRICTED_UNIONS
+//
+// Defined as 1 if the compiler supports C++11 unrestricted unions. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_UNRESTRICTED_UNIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))            /* EDG 4.6+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_UNRESTRICTED_UNIONS 1
+    #endif
+#endif
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTENDED_SIZEOF
+//
+// Defined as 1 if the compiler supports C++11 class sizeof extensions (e.g. sizeof SomeClass::someMember). 
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_EXTENDED_SIZEOF)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                    /* GCC 4.5+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */
+        #define OVR_CPP_NO_EXTENDED_SIZEOF 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INLINE_NAMESPACES
+//
+// Defined as 1 if the compiler supports C++11 inlined namespaces. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/namespace#Inline_namespaces
+
+#if !defined(OVR_CPP_NO_INLINE_NAMESPACES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_INLINE_NAMESPACES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS
+//
+// Defined as 1 if the compiler supports C++11 explicit conversion operators. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/explicit
+
+#if !defined(OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_explicit_conversions))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                       /* GCC 4.5+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                             /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 404)))               /* EDG 4.4+  */
+        #define OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS
+//
+// Defined as 1 if the compiler supports C++11 local class template parameters. Otherwise undefined.
+// Example:
+//     void Test() {   
+//         struct LocalClass{ };
+//         SomeTemplateClass<LocalClass> t; // Allowed only in C++11
+//     }
+
+#if !defined(OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS) 
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_local_type_template_args))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                           /* GCC 4.5+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                                 /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))                   /* EDG 4.2+  */
+        #define OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NEW_CHARACTER_TYPES
+//
+// Defined as 1 if the compiler natively supports C++11 char16_t and char32_t. Otherwise undefined.
+// VC++ through at least VS2013 defines char16_t as unsigned short in its standard library,
+// but it is not a native type or unique type, nor can you for a string literal with it.
+
+#if !defined(OVR_CPP_NO_NEW_CHARACTER_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_unicode_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                   /* GCC 4.4+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))           /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_NEW_CHARACTER_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 \u and \U character literals for 
+// native char16_t and char32_t types.
+//
+#if !defined(OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                    /* GCC 4.5+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        // Not supported by VC++ as of VS2013. VC++'s existing \U and \u are non-conforming.
+        #define OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_USER_DEFINED_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 user-defined literals. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_USER_DEFINED_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_USER_DEFINED_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNICODE_STRING_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 Unicode string literals. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#New_string_literals
+
+#if !defined(OVR_CPP_NO_UNICODE_STRING_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_unicode_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                   /* GCC 4.4+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))           /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_UNICODE_STRING_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RAW_STRING_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 raw literals. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#New_string_literals
+
+#if !defined(OVR_CPP_NO_RAW_STRING_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_raw_string_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                      /* GCC 4.5+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))              /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_RAW_STRING_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX
+//
+// Defined as 1 if the compiler supports C++11 unified initialization.
+// http://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization
+
+#if !defined(OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_generalized_initializers))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                           /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                                 /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))                   /* EDG 4.6+  */
+        #define OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS
+//
+// Defined as 1 if the compiler supports C++11 extended friends.
+
+#if !defined(OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                          /* VS2010+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */
+        #define OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_THREAD_LOCAL
+//
+// Defined as 1 if the compiler supports C++11 thread_local. Else undefined. Does not
+// indicate if the compiler supports C thread-local compiler extensions such as __thread
+// and declspec(thread). Use OVR_THREAD_LOCAL if you want to declare a thread-local 
+// variable that supports C++11 thread_local when available but the C extension when 
+// it's available. The primary difference between C++11 thread_local and C extensions is
+// that C++11 thread_local supports non-PODs and calls their constructors and destructors.
+//
+// Note that thread_local requires both compiler and linker support, and so it's possible
+// that the compiler may support thread_local but the linker does not.
+
+#if !defined(OVR_CPP_NO_THREAD_LOCAL)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_thread_local))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))               /* GCC 4.8+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))       /* EDG 4.8+  */
+        #define OVR_CPP_NO_THREAD_LOCAL 1
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_ALIGNAS / OVR_ALIGNOF
+//
+//    OVR_ALIGNAS(n)        // Specifies a size_t power of two alignment for a type or instance.
+//    OVR_ALIGNOF(type)     // Returns the size_t alignment of a type or instance.
+//
+// Example usage:
+//    OVR_ALIGNAS(8) char c = 'c';                      // Specifies that the instance c be aligned to an 8 byte boundary.
+//    typedef OVR_ALIGNAS(8) char C;                    // Specifies that the type C be aligned to an 8 byte boundary.
+//    struct OVR_ALIGNAS(64) S{ char array[16]; };      // Specfies that the struct S have a natural alignment of 64.
+//    OVR_ALIGNAS(32) S s;                              // Specifies that the instance s of struct S be aligned to an 32 byte boundary.
+//    OVR_ALIGNAS(32) struct T{ char array[16]; } t;    // Specfies that the instance t of struct T have a natural alignment of 32.
+//    struct OVR_ALIGNAS(T) U{};                        // Specifes that U be aligned the same as T. Supported only by C++11 compilers (see OVR_CPP_NO_ALIGNAS).
+//
+//    size_t a = OVR_ALIGNOF(double);                   // Returns the natural alignment of the double type.
+//    size_t a = OVR_ALIGNOF(S);                        // Returns the natural alignment of the struct S type.
+//
+// Note: If C++11 alignas is supported, then alignas/OVR_ALIGNAS may take a const expression in addition to a constant.
+// Note: The C11 Standard species the _Alignas keyword and alignas as a macro for it in <stdalign.h>
+
+#if !defined(OVR_ALIGNAS)
+    #if defined(OVR_CC_GNU) && !defined(OVR_CPP_NO_ALIGNAS)     // If C++11 alignas is supported...
+        #define OVR_ALIGNAS(n) alignas(n)
+    #elif defined(__clang__) && !defined(OVR_CPP_NO_ALIGNAS)
+        #define OVR_ALIGNAS(n) alignas(n)
+    #elif defined(OVR_CC_GNU) || defined(__clang__)
+        #define OVR_ALIGNAS(n) __attribute__((aligned(n)))
+    #elif defined(OVR_CC_MSVC) || defined(OVR_CC_INTEL)
+        #define OVR_ALIGNAS(n) __declspec(align(n))             // For Microsoft the alignment must be a literal integer.
+    #elif defined(OVR_CC_ARM)
+        #define OVR_ALIGNAS(n) __align(n)
+    #else
+        #error Need to define OVR_ALIGNAS
+    #endif
+#endif
+
+#if !defined(OVR_ALIGNOF)
+    #if defined(OVR_CC_GNU) && !defined(OVR_CPP_NO_ALIGNOF)     // If C++11 alignof is supported...
+        #define OVR_ALIGNOF(type) alignof(t)
+    #elif defined(__clang__) && !defined(OVR_CPP_NO_ALIGNOF)
+        #define OVR_ALIGNOF(type) alignof(t)
+    #elif defined(OVR_CC_GNU) || defined(__clang__)
+        #define OVR_ALIGNOF(type) ((size_t)__alignof__(type))
+    #elif defined(OVR_CC_MSVC) || defined(OVR_CC_INTEL)
+        #define OVR_ALIGNOF(type) ((size_t)__alignof(type))
+    #elif defined(OVR_CC_ARM)
+        #define OVR_ALIGNOF(type) ((size_t)__ALIGNOF__(type))
+    #else
+        #error Need to define OVR_ALIGNOF
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_ASSUME / OVR_ANALYSIS_ASSUME
+//
+// This is a portable wrapper for VC++'s __assume and __analysis_assume.
+// __analysis_assume is typically used to quell VC++ static analysis warnings.
+//
+// Example usage:
+//    void Test(char c){
+//       switch(c){
+//          case 'a':
+//          case 'b':
+//          case 'c':
+//          case 'd':
+//             break;
+//          default:
+//             OVR_ASSUME(0); // Unreachable code.
+//       }
+//    }
+//
+//    size_t Test(char* str){
+//       OVR_ANALYSIS_ASSUME(str != nullptr);
+//       return strlen(str);
+//    }
+
+#if !defined(OVR_ASSUME)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_ASSUME(x)          __assume(x)
+        #define OVR_ANALYSIS_ASSUME(x) __analysis_assume(!!(x))
+    #else
+        #define OVR_ASSUME(x)
+        #define OVR_ANALYSIS_ASSUME(x)
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_RESTRICT
+//
+// Wraps the C99 restrict keyword in a portable way.
+// C++11 and C++14 don't have restrict but this functionality is supported by 
+// all C++ compilers.
+//
+// Example usage:
+//    void* memcpy(void* OVR_RESTRICT s1, const void* OVR_RESTRICT s2, size_t n);
+
+#if !defined(OVR_RESTRICT)
+    #define OVR_RESTRICT __restrict // Currently supported by all compilers of significance to us.
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_NOEXCEPT / OVR_NOEXCEPT_IF(predicate) / OVR_NOEXCEPT_EXPR(expression)
+//
+// Implements a portable wrapper for C++11 noexcept.
+// http://en.cppreference.com/w/cpp/language/noexcept
+//
+// Example usage:
+//     void Test() OVR_NOEXCEPT {} // This function doesn't throw.
+//
+//     template <typename T>
+//     void DoNothing() OVR_NOEXCEPT_IF(OVR_NOEXCEPT_EXPR(T())) // Throws an if and only if T::T(int) throws.
+//         { T t(3); }
+//
+#if !defined(OVR_NOEXCEPT)
+    #if defined(OVR_CPP_NOEXCEPT)
+        #define OVR_NOEXCEPT
+        #define OVR_NOEXCEPT_IF(predicate)
+        #define OVR_NOEXCEPT_EXPR(expression) false
+    #else
+        #define OVR_NOEXCEPT noexcept
+        #define OVR_NOEXCEPT_IF(predicate) noexcept((predicate))
+        #define OVR_NOEXCEPT_EXPR(expression) noexcept((expression))
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FINAL
+//
+// Wraps the C++11 final keyword in a portable way.
+// http://en.cppreference.com/w/cpp/language/final
+//
+// Example usage:
+//     struct Test { virtual int GetValue() OVR_FINAL; };
+
+#if !defined(OVR_FINAL)
+    #if defined(OVR_CC_MSVC) && (OVR_CC_VERSION < 1700) // VC++ 2012 and earlier
+        #define OVR_FINAL sealed
+    #elif defined(OVR_CPP_INHERITANCE_FINAL)
+        #define OVR_FINAL
+    #else
+        #define OVR_FINAL final
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_OVERRIDE
+//
+// Wraps the C++11 override keyword in a portable way.
+// http://en.cppreference.com/w/cpp/language/override
+//
+// Example usage:
+//        struct Parent { virtual void Func(int); };
+//        struct Child : public Parent { void Func(int) OVR_OVERRIDE; };
+
+#if !defined(OVR_CPP11_ENABLED)
+#define OVR_OVERRIDE
+#elif !defined(OVR_OVERRIDE)
+    #if defined(OVR_CPP_OVERRIDE)
+        #define OVR_OVERRIDE
+    #else
+        #if (defined(_MSC_VER) && (_MSC_VER <= 1600))
+            #pragma warning(disable : 4481)
+        #endif
+        #define OVR_OVERRIDE override
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FINAL_OVERRIDE
+//
+// Wraps the C++11 final+override keywords (a common combination) in a portable way.
+//
+// Example usage:
+//     struct Parent { virtual void Func(); };
+//     struct Child : public Parent { virtual void Func() OVR_FINAL_OVERRIDE; };
+
+#if !defined(OVR_FINAL_OVERRIDE)
+    #define OVR_FINAL_OVERRIDE OVR_FINAL OVR_OVERRIDE
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_EXTERN_TEMPLATE
+//
+// Portable wrapper for C++11 extern template. This tells the compiler to not instantiate
+// the template in the current translation unit, which can significantly speed up 
+// compilation and avoid problems due to two translation units compiling code with 
+// different settings.
+//
+// Example usage:
+//     OVR_EXTERN_TEMPLATE(class basic_string<char>); // Nothing to do for non-C++11 compilers.
+
+#if !defined(OVR_EXTERN_TEMPLATE)
+    #if defined(OVR_CPP_EXTERN_TEMPLATE)
+        #define OVR_EXTERN_TEMPLATE(decl)
+    #else
+        #define OVR_EXTERN_TEMPLATE(decl) extern template decl
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_CONSTEXPR  / OVR_CONSTEXPR_OR_CONST
+//
+// Portable wrapper for C++11 constexpr. Doesn't include C++14 relaxed constexpr,
+// for which a different wrapper name is reserved.
+//
+// Example usage:
+//     OVR_CONSTEXPR int Test() { return 15; }          // This can be optimized better by a C++11 compiler that supports constexpr.
+//     OVR_CONSTEXPR_OR_CONST float x = 3.14159f;       // This can be optimized better by a C++11 compiler, but if not then at least make it const.
+
+#if !defined(OVR_CONSTEXPR)
+    #if defined(OVR_CPP_NO_CONSTEXPR)
+        #define OVR_CONSTEXPR
+    #else
+        #define OVR_CONSTEXPR constexpr
+    #endif
+#endif
+
+#if !defined(OVR_CONSTEXPR_OR_CONST)
+    #if defined(OVR_CPP_NO_CONSTEXPR)
+        #define OVR_CONSTEXPR_OR_CONST const
+    #else
+        #define OVR_CONSTEXPR_OR_CONST constexpr
+    #endif
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FUNCTION_DELETE / OVR_FUNCTION_DEFAULT
+//
+// Wraps the C++11 delete and default keywords in a way that allows for cleaner code
+// while making for a better version of uncallable or default functions.
+//
+// Example usage:
+//     struct Test{
+//         Test() OVR_FUNCTION_DEFAULT;            // Non-C++11 compilers will require a separate definition for Test().
+//     private:                                   // Users should put OVR_FUNCTION_DELETE usage in a private 
+//         void Uncallable() OVR_FUNCTION_DELETE;  // area for compatibility with pre-C++11 compilers.
+//     };
+
+#if defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+    #define OVR_FUNCTION_DELETE
+#else
+    #define OVR_FUNCTION_DELETE = delete
+#endif
+
+#if defined(OVR_CPP_NO_DEFAULTED_FUNCTIONS)
+    #define OVR_FUNCTION_DEFAULT
+#else
+    #define OVR_FUNCTION_DEFAULT = default
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_NON_COPYABLE
+//
+// Allows you to specify a class as being neither copy-constructible nor assignable,
+// which is a commonly needed pattern in C++ programming. Classes with this declaration
+// are required to be default constructible (as are most classes). For pre-C++11
+// compilers this macro declares a private section for the class, which will be
+// inherited by whatever code is directly below the macro invocation by default.
+//
+// Example usage:
+//    struct Test {
+//       Test();
+//       ...
+//       OVR_NON_COPYABLE(Test)
+//    };
+
+#if !defined(OVR_NON_COPYABLE)
+    #if defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+        #define OVR_NON_COPYABLE(Type)   \
+            private:                     \
+            Type(const Type&);           \
+            void operator=(const Type&);
+    #else
+        #define OVR_NON_COPYABLE(Type)   \
+            Type(const Type&) = delete;  \
+            void operator=(const Type&) = delete;
+    #endif
+#endif
+
+
+
+#endif  // header include guard
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ContainerAllocator.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ContainerAllocator.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,267 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_ContainerAllocator.h
+Content     :   Template allocators and constructors for containers.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_ContainerAllocator_h
+#define OVR_ContainerAllocator_h
+
+#include "OVR_Allocator.h"
+#include <string.h>
+
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------------
+// ***** Container Allocator
+
+// ContainerAllocator serves as a template argument for allocations done by
+// containers, such as Array and Hash; replacing it could allow allocator
+// substitution in containers.
+
+class ContainerAllocatorBase
+{
+public:
+    static void* Alloc(size_t size)                { return OVR_ALLOC(size); }
+    static void* Realloc(void* p, size_t newSize)  { return OVR_REALLOC(p, newSize); }
+    static void  Free(void *p)                    { OVR_FREE(p); }
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Constructors, Destructors, Copiers
+
+// Plain Old Data - movable, no special constructors/destructor.
+template<class T> 
+class ConstructorPOD
+{
+public:
+    static void Construct(void *) {}
+    static void Construct(void *p, const T& source) 
+    { 
+        *(T*)p = source;
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void *p, const S& source)
+    {
+        *(T*)p = source;
+    }
+
+    static void ConstructArray(void*, size_t) {}
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t *pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            *(T*)pdata = source;
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        memcpy(p, psource, sizeof(T) * count);
+    }
+
+    static void Destruct(T*) {}
+    static void DestructArray(T*, size_t) {}
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static bool IsMovable() { return true; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ConstructorMov
+//
+// Correct C++ construction and destruction for movable objects
+template<class T> 
+class ConstructorMov
+{
+public:
+    static void Construct(void* p) 
+    { 
+        OVR::Construct<T>(p);
+    }
+
+    static void Construct(void* p, const T& source) 
+    { 
+        OVR::Construct<T>(p, source);
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void* p, const S& source)
+    {
+        OVR::ConstructAlt<T,S>(p, source);
+    }
+
+    static void ConstructArray(void* p, size_t count)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, source);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, *psource++);
+    }
+
+    static void Destruct(T* p)
+    {
+        p->~T();
+        OVR_UNUSED(p); // Suppress silly MSVC warning
+    }
+
+    static void DestructArray(T* p, size_t count)
+    {   
+        p += count - 1;
+        for (size_t i=0; i<count; ++i, --p)
+            p->~T();
+    }
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static bool IsMovable() { return true; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ConstructorCPP
+//
+// Correct C++ construction and destruction for movable objects
+template<class T> 
+class ConstructorCPP
+{
+public:
+    static void Construct(void* p) 
+    { 
+        OVR::Construct<T>(p);        
+    }
+
+    static void Construct(void* p, const T& source) 
+    { 
+        OVR::Construct<T>(p, source);        
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void* p, const S& source)
+    {
+        OVR::ConstructAlt<T,S>(p, source);        
+    }
+
+    static void ConstructArray(void* p, size_t count)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, source);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, *psource++);
+    }
+
+    static void Destruct(T* p)
+    {
+        p->~T();
+        OVR_UNUSED(p); // Suppress silly MSVC warning
+    }
+
+    static void DestructArray(T* p, size_t count)
+    {   
+        p += count - 1;
+        for (size_t i=0; i<count; ++i, --p)
+            p->~T();
+    }
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        for(size_t i = 0; i < count; ++i)
+            dst[i] = src[i];
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        for(size_t i = count; i; --i)
+            dst[i-1] = src[i-1];
+    }
+
+    static bool IsMovable() { return false; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Container Allocator with movement policy
+//
+// Simple wraps as specialized allocators
+template<class T> struct ContainerAllocator_POD : ContainerAllocatorBase, ConstructorPOD<T> {};
+template<class T> struct ContainerAllocator     : ContainerAllocatorBase, ConstructorMov<T> {};
+template<class T> struct ContainerAllocator_CPP : ContainerAllocatorBase, ConstructorCPP<T> {};
+
+
+} // OVR
+
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,85 @@
+/************************************************************************************
+
+Filename    :   OVR_CRC32.cpp
+Content     :   CRC-32 with polynomial used for sensor devices
+Created     :   June 20, 2014
+Author      :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_CRC32.h"
+
+namespace OVR {
+
+
+static const uint32_t CRC_Table[256] = {
+	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
+	0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
+	0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
+	0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
+	0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
+	0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
+	0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
+	0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
+	0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
+	0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
+	0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
+	0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
+	0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
+	0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
+	0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
+	0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
+	0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
+	0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+
+//// CRC-32
+
+uint32_t CRC32_Calculate(const void* data, int bytes, uint32_t accumulator)
+{
+	const uint8_t* inputBytes = reinterpret_cast<const uint8_t*>( data );
+
+	for (int j = 0; j < bytes; ++j)
+	{
+		int i = ((uint32_t)(accumulator >> 24) ^ *inputBytes++) & 0xFF;
+
+		accumulator = (accumulator << 8) ^ CRC_Table[i];
+	}
+
+	return ~accumulator;
+}
+
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,45 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_CRC32.h
+Content     :   CRC-32 with polynomial used for sensor devices
+Created     :   June 20, 2014
+Author      :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CRC32_h
+#define OVR_CRC32_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------------
+// ***** CRC-32
+
+// Polynomial used and algorithm details are proprietary to our sensor board
+uint32_t CRC32_Calculate(const void* data, int bytes, uint32_t prevCRC = 0);
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Delegates.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Delegates.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,541 @@
+/************************************************************************************
+
+Filename    :   OVR_Delegates.h
+Content     :   C++ Delegates
+Created     :   June 15, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+/*
+	Based on The Impossibly Fast C++ Delegates by Sergey Ryazanov from
+	http://www.codeproject.com/KB/cpp/ImpossiblyFastCppDelegate.aspx (2005)
+*/
+
+/*
+	Usage:
+
+	Declare a delegate with a void (int) signature, also known as a
+	function that returns void and has one parameter that is an int:
+		typedef Delegate1<void, int> MyDelegate;
+		MyDelegate d;
+
+	Point the delegate to a member function:
+		d.SetMember<A, &A::TestFunctionA>(&a);
+		d = MyDelegate::FromMember<A, &A::TestFunctionA>(&a);
+
+	Point the delegate to a const member function:
+		d.SetConstMember<C, &C::TestFunctionA>(&c);
+		d = MyDelegate::FromConstMember<C, &C::TestFunctionA>(&c);
+
+	Point the delegate to a free function:
+		d.SetFree<&FreeFunctionX>();
+		d = MyDelegate::FromFree<&FreeFunctionX>();
+
+	Invoke the function via the delegate (works for all 3 cases):
+		d(1000);
+
+	By default the delegates are uninitialized.
+	To clear an array of delegates quickly just zero the memory.
+
+	This implementation is nicer than FastDelegates in my opinion
+	because it is simple and easy to read.  It is a little slower
+	for virtual functions, but the size of the delegate is small,
+	and it will only get better as compilers improve.
+*/
+
+#ifndef OVR_Delegates_h
+#define OVR_Delegates_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+template <class ret_type>
+class Delegate0
+{
+	typedef ret_type (*StubPointer)(void *);
+	typedef Delegate0<ret_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate0(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)()>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object)
+	{
+		return (F)();
+	}
+
+	template <class T, ret_type (T::*F)()>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)();
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)();
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate0() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()() const
+	{
+		return (*_stub)(_object);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)()>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)()>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)()>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)()>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type>
+class Delegate1
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type);
+	typedef Delegate1<ret_type, arg1_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate1(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1)
+	{
+		return (F)(a1);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate1() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1) const
+	{
+		return (*_stub)(_object, a1);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type, class arg2_type>
+class Delegate2
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type, arg2_type);
+	typedef Delegate2<ret_type, arg1_type, arg2_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate2(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		return (F)(a1, a2);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate2() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1, arg2_type a2) const
+	{
+		return (*_stub)(_object, a1, a2);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type, class arg2_type, class arg3_type>
+class Delegate3
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type, arg2_type, arg3_type);
+	typedef Delegate3<ret_type, arg1_type, arg2_type, arg3_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate3(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		return (F)(a1, a2, a3);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2, a3);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2, a3);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate3() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1, arg2_type a2, arg3_type a3) const
+	{
+		return (*_stub)(_object, a1, a2, a3);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+// Add more here if needed, but keep in mind that a short, simple interface
+// is rewarded by making the delegates faster...
+
+
+} // namespace OVR
+
+#endif // OVR_Delegates_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Deque.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Deque.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,316 @@
+/************************************************************************************
+
+Filename    :   OVR_Deque.h
+Content     :   Deque container
+Created     :   Nov. 15, 2013
+Authors     :   Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Deque_h
+#define OVR_Deque_h
+
+#include "OVR_ContainerAllocator.h"
+
+namespace OVR{ 
+
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class Deque
+{
+public:
+    enum
+    {
+        DefaultCapacity = 500
+    };
+
+    Deque(int capacity = DefaultCapacity);
+    virtual ~Deque(void);
+
+    virtual void         PushBack   (const Elem &Item);    // Adds Item to the end
+    virtual void         PushFront  (const Elem &Item);    // Adds Item to the beginning
+    virtual Elem         PopBack    (void);                // Removes Item from the end
+    virtual Elem         PopFront   (void);                // Removes Item from the beginning
+    virtual const Elem&  PeekBack   (int count = 0) const; // Returns count-th Item from the end
+    virtual const Elem&  PeekFront  (int count = 0) const; // Returns count-th Item from the beginning
+
+	virtual inline size_t GetSize    (void)          const; // Returns Number of Elements
+	OVR_FORCE_INLINE int GetSizeI   (void)          const
+	{
+		return (int)GetSize();
+	}
+    virtual inline size_t GetCapacity(void)          const; // Returns the maximum possible number of elements
+    virtual void         Clear      (void);				   // Remove all elements
+    virtual inline bool  IsEmpty    ()              const;
+    virtual inline bool  IsFull     ()              const;
+
+protected:
+    Elem        *Data;          // The actual Data array
+    const int   Capacity;       // Deque capacity
+    int         Beginning;      // Index of the first element
+    int         End;            // Index of the next after last element
+
+    // Instead of calculating the number of elements, using this variable
+    // is much more convenient.
+    int         ElemCount;
+
+private:
+    Deque&      operator= (const Deque& q) { }; // forbidden
+    Deque(const Deque<Elem, Allocator> &OtherDeque) { };
+};
+
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class InPlaceMutableDeque : public Deque<Elem, Allocator>
+{
+    typedef Deque<Elem, Allocator> BaseType;
+
+public:
+    InPlaceMutableDeque( int capacity = BaseType::DefaultCapacity ) : BaseType( capacity ) {}
+	virtual ~InPlaceMutableDeque() {};
+
+    using BaseType::PeekBack;
+    using BaseType::PeekFront;
+	virtual Elem& PeekBack  (int count = 0); // Returns count-th Item from the end
+	virtual Elem& PeekFront (int count = 0); // Returns count-th Item from the beginning
+};
+
+// Same as Deque, but allows to write more elements than maximum capacity
+// Old elements are lost as they are overwritten with the new ones
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class CircularBuffer : public InPlaceMutableDeque<Elem, Allocator>
+{
+    typedef InPlaceMutableDeque<Elem, Allocator> BaseType;
+
+public:
+    CircularBuffer(int MaxSize = BaseType::DefaultCapacity) : BaseType(MaxSize) { };
+
+    // The following methods are inline as a workaround for a VS bug causing erroneous C4505 warnings
+    // See: http://stackoverflow.com/questions/3051992/compiler-warning-at-c-template-base-class
+    inline virtual void PushBack  (const Elem &Item);    // Adds Item to the end, overwriting the oldest element at the beginning if necessary
+    inline virtual void PushFront (const Elem &Item);    // Adds Item to the beginning, overwriting the oldest element at the end if necessary
+};
+
+//----------------------------------------------------------------------------------
+
+// Deque Constructor function
+template <class Elem, class Allocator>
+Deque<Elem, Allocator>::Deque(int capacity) :
+Capacity( capacity ), Beginning(0), End(0), ElemCount(0)
+{
+    Data = (Elem*) Allocator::Alloc(Capacity * sizeof(Elem));
+}
+
+// Deque Destructor function
+template <class Elem, class Allocator>
+Deque<Elem, Allocator>::~Deque(void)
+{
+    Clear();
+    Allocator::Free(Data);
+}
+
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::Clear()
+{
+    if (!IsEmpty())
+    {
+        if (Beginning < End)
+        {
+            // no wrap-around
+            Allocator::DestructArray(Data + Beginning, End - Beginning);
+        }
+        else
+        {
+            // wrap-around
+            Allocator::DestructArray(Data + Beginning, Capacity - Beginning);
+            Allocator::DestructArray(Data, End);
+        }
+    }
+    
+    Beginning = 0;
+    End       = 0;
+    ElemCount = 0;
+}
+
+// Push functions
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::PushBack(const Elem &Item)
+{
+    // Error Check: Make sure we aren't  
+    // exceeding our maximum storage space
+    OVR_ASSERT( ElemCount < Capacity );
+
+    Allocator::Construct(Data + End, Item);
+    ++End;
+    ++ElemCount;
+
+    // Check for wrap-around
+    if (End >= Capacity)
+        End -= Capacity;
+}
+
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::PushFront(const Elem &Item)
+{
+    // Error Check: Make sure we aren't  
+    // exceeding our maximum storage space
+    OVR_ASSERT( ElemCount < Capacity );
+
+    --Beginning;
+    // Check for wrap-around
+    if (Beginning < 0)
+        Beginning += Capacity;
+
+    Allocator::Construct(Data + Beginning, Item);
+    ++ElemCount;
+}
+
+// Pop functions
+template <class Elem, class Allocator>
+Elem Deque<Elem, Allocator>::PopFront(void)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > 0 );
+
+	Elem ReturnValue = Data[ Beginning ];
+    Allocator::Destruct(Data + Beginning);
+
+	++Beginning;
+    --ElemCount;
+
+    // Check for wrap-around
+    if (Beginning >= Capacity)
+        Beginning -= Capacity;
+
+    return ReturnValue;
+}
+
+template <class Elem, class Allocator>
+Elem Deque<Elem, Allocator>::PopBack(void)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > 0 );
+
+    --End;
+    --ElemCount;
+
+    // Check for wrap-around
+    if (End < 0)
+        End += Capacity;
+
+    Elem ReturnValue = Data[ End ];
+    Allocator::Destruct(Data + End);
+
+    return ReturnValue;
+}
+
+// Peek functions
+template <class Elem, class Allocator>
+const Elem& Deque<Elem, Allocator>::PeekFront(int count) const
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > count );
+
+    int idx = Beginning + count;
+    if (idx >= Capacity)
+        idx -= Capacity;
+    return Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+const Elem& Deque<Elem, Allocator>::PeekBack(int count) const
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > count );
+
+    int idx = End - count - 1;
+    if (idx < 0)
+        idx += Capacity;
+    return Data[ idx ];
+}
+
+// Mutable Peek functions
+template <class Elem, class Allocator>
+Elem& InPlaceMutableDeque<Elem, Allocator>::PeekFront(int count)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( BaseType::ElemCount > count );
+
+    int idx = BaseType::Beginning + count;
+    if (idx >= BaseType::Capacity)
+        idx -= BaseType::Capacity;
+    return BaseType::Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+Elem& InPlaceMutableDeque<Elem, Allocator>::PeekBack(int count)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( BaseType::ElemCount > count );
+
+    int idx = BaseType::End - count - 1;
+    if (idx < 0)
+        idx += BaseType::Capacity;
+    return BaseType::Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+inline size_t Deque<Elem, Allocator>::GetCapacity(void) const
+{
+    return Capacity;
+}
+
+template <class Elem, class Allocator>
+inline size_t Deque<Elem, Allocator>::GetSize(void) const
+{
+    return ElemCount;
+}
+
+template <class Elem, class Allocator>
+inline bool Deque<Elem, Allocator>::IsEmpty(void) const
+{
+    return ElemCount == 0;
+}
+
+template <class Elem, class Allocator>
+inline bool Deque<Elem, Allocator>::IsFull(void) const
+{
+    return ElemCount == Capacity;
+}
+
+// ******* CircularBuffer<Elem> *******
+// Push functions
+template <class Elem, class Allocator>
+void CircularBuffer<Elem, Allocator>::PushBack(const Elem &Item)
+{
+    if (this->IsFull())
+        this->PopFront();
+    BaseType::PushBack(Item);
+}
+
+template <class Elem, class Allocator>
+void CircularBuffer<Elem, Allocator>::PushFront(const Elem &Item)
+{
+    if (this->IsFull())
+        this->PopBack();
+    BaseType::PushFront(Item);
+}
+
+};   
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,585 @@
+/**************************************************************************
+
+Filename    :   OVR_File.cpp
+Content     :   File wrapper class implementation (Win32)
+
+Created     :   April 5, 1999
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+**************************************************************************/
+
+#define  GFILE_CXX
+
+// Standard C library (Captain Obvious guarantees!)
+#include <stdio.h>
+
+#include "OVR_File.h"
+
+namespace OVR {
+
+// Buffered file adds buffering to an existing file
+// FILEBUFFER_SIZE defines the size of internal buffer, while
+// FILEBUFFER_TOLERANCE controls the amount of data we'll effectively try to buffer
+#define FILEBUFFER_SIZE         (8192-8)
+#define FILEBUFFER_TOLERANCE    4096
+
+// ** Constructor/Destructor
+
+// Hidden constructor
+// Not supposed to be used
+BufferedFile::BufferedFile() : DelegatedFile(0)
+{
+    pBuffer     = (uint8_t*)OVR_ALLOC(FILEBUFFER_SIZE);
+    BufferMode  = NoBuffer;
+    FilePos     = 0;
+    Pos         = 0;
+    DataSize    = 0;
+}
+
+// Takes another file as source
+BufferedFile::BufferedFile(File *pfile) : DelegatedFile(pfile)
+{
+    pBuffer     = (uint8_t*)OVR_ALLOC(FILEBUFFER_SIZE);
+    BufferMode  = NoBuffer;
+    FilePos     = pfile->LTell();
+    Pos         = 0;
+    DataSize    = 0;
+}
+
+
+// Destructor
+BufferedFile::~BufferedFile()
+{
+    // Flush in case there's data
+    if (pFile)
+        FlushBuffer();
+    // Get rid of buffer
+    if (pBuffer)
+        OVR_FREE(pBuffer);
+}
+
+/*
+bool    BufferedFile::VCopy(const Object &source)
+{
+    if (!DelegatedFile::VCopy(source))
+        return 0;
+
+    // Data members
+    BufferedFile *psource = (BufferedFile*)&source;
+
+    // Buffer & the mode it's in
+    pBuffer         = psource->pBuffer;
+    BufferMode      = psource->BufferMode;
+    Pos             = psource->Pos;
+    DataSize        = psource->DataSize;
+    return 1;
+}
+*/
+
+// Initializes buffering to a certain mode
+bool    BufferedFile::SetBufferMode(BufferModeType mode)
+{
+    if (!pBuffer)
+        return false;
+    if (mode == BufferMode)
+        return true;
+     
+    FlushBuffer();
+
+    // Can't set write mode if we can't write
+    if ((mode==WriteBuffer) && (!pFile || !pFile->IsWritable()) )
+        return 0;
+
+    // And SetMode
+    BufferMode = mode;
+    Pos        = 0;
+    DataSize   = 0;
+    return 1;
+}
+
+// Flushes buffer
+void    BufferedFile::FlushBuffer()
+{
+    switch(BufferMode)
+    {
+        case WriteBuffer:
+            // Write data in buffer
+            FilePos += pFile->Write(pBuffer,Pos);
+            Pos = 0;
+            break;
+
+        case ReadBuffer:
+            // Seek back & reset buffer data
+            if ((DataSize-Pos)>0)
+                FilePos = pFile->LSeek(-(int)(DataSize-Pos), Seek_Cur);
+            DataSize = 0;
+            Pos      = 0;
+            break;
+        default:
+            // not handled!
+            break;
+    }
+}
+
+// Reloads data for ReadBuffer
+void    BufferedFile::LoadBuffer()
+{
+    if (BufferMode == ReadBuffer)
+    {
+        // We should only reload once all of pre-loaded buffer is consumed.
+        OVR_ASSERT(Pos == DataSize);
+
+        // WARNING: Right now LoadBuffer() assumes the buffer's empty
+        int sz   = pFile->Read(pBuffer,FILEBUFFER_SIZE);
+        DataSize = sz<0 ? 0 : (unsigned)sz;
+        Pos      = 0;
+        FilePos  += DataSize;
+    }
+}
+
+
+// ** Overridden functions
+
+// We override all the functions that can possibly
+// require buffer mode switch, flush, or extra calculations
+
+// Tell() requires buffer adjustment
+int     BufferedFile::Tell()
+{
+    if (BufferMode == ReadBuffer)
+        return int (FilePos - DataSize + Pos);
+
+    int pos = pFile->Tell();
+    // Adjust position based on buffer mode & data
+    if (pos!=-1)
+    {
+        OVR_ASSERT(BufferMode != ReadBuffer);
+        if (BufferMode == WriteBuffer)
+            pos += Pos;
+    }
+    return pos;
+}
+
+int64_t BufferedFile::LTell()
+{
+    if (BufferMode == ReadBuffer)
+        return FilePos - DataSize + Pos;
+
+    int64_t pos = pFile->LTell();
+    if (pos!=-1)
+    {
+        OVR_ASSERT(BufferMode != ReadBuffer);
+        if (BufferMode == WriteBuffer)
+            pos += Pos;
+    }
+    return pos;
+}
+
+int     BufferedFile::GetLength()
+{
+    int len = pFile->GetLength();
+    // If writing through buffer, file length may actually be bigger
+    if ((len!=-1) && (BufferMode==WriteBuffer))
+    {
+        int currPos = pFile->Tell() + Pos;
+        if (currPos>len)
+            len = currPos;
+    }
+    return len;
+}
+int64_t BufferedFile::LGetLength()
+{
+    int64_t len = pFile->LGetLength();
+    // If writing through buffer, file length may actually be bigger
+    if ((len!=-1) && (BufferMode==WriteBuffer))
+    {
+        int64_t currPos = pFile->LTell() + Pos;
+        if (currPos>len)
+            len = currPos;
+    }
+    return len;
+}
+
+/*
+bool    BufferedFile::Stat(FileStats *pfs)
+{
+    // Have to fix up length is stat
+    if (pFile->Stat(pfs))
+    {
+        if (BufferMode==WriteBuffer)
+        {
+            int64_t currPos = pFile->LTell() + Pos;
+            if (currPos > pfs->Size)
+            {
+                pfs->Size   = currPos;
+                // ??
+                pfs->Blocks = (pfs->Size+511) >> 9;
+            }
+        }
+        return 1;
+    }
+    return 0;
+}
+*/
+
+int     BufferedFile::Write(const uint8_t *psourceBuffer, int numBytes)
+{
+    if ( (BufferMode==WriteBuffer) || SetBufferMode(WriteBuffer))
+    {
+        // If not data space in buffer, flush
+        if ((FILEBUFFER_SIZE-(int)Pos)<numBytes)
+        {
+            FlushBuffer();
+            // If bigger then tolerance, just write directly
+            if (numBytes>FILEBUFFER_TOLERANCE)
+            {
+                int sz = pFile->Write(psourceBuffer,numBytes);
+                if (sz > 0)
+                    FilePos += sz;
+                return sz;
+            }
+        }
+
+        // Enough space in buffer.. so copy to it
+        memcpy(pBuffer+Pos, psourceBuffer, numBytes);
+        Pos += numBytes;
+        return numBytes;
+    }
+    int sz = pFile->Write(psourceBuffer,numBytes);
+    if (sz > 0)
+        FilePos += sz;
+    return sz;
+}
+
+int     BufferedFile::Read(uint8_t *pdestBuffer, int numBytes)
+{
+    if ( (BufferMode==ReadBuffer) || SetBufferMode(ReadBuffer))
+    {
+        // Data in buffer... copy it
+        if ((int)(DataSize-Pos) >= numBytes)
+        {
+            memcpy(pdestBuffer, pBuffer+Pos, numBytes);
+            Pos += numBytes;
+            return numBytes;
+        }
+
+        // Not enough data in buffer, copy buffer
+        int     readBytes = DataSize-Pos;
+        memcpy(pdestBuffer, pBuffer+Pos, readBytes);
+        numBytes    -= readBytes;
+        pdestBuffer += readBytes;
+        Pos = DataSize;
+
+        // Don't reload buffer if more then tolerance
+        // (No major advantage, and we don't want to write a loop)
+        if (numBytes>FILEBUFFER_TOLERANCE)
+        {
+            numBytes = pFile->Read(pdestBuffer,numBytes);
+            if (numBytes > 0)
+            {
+                FilePos += numBytes;
+                Pos = DataSize = 0;
+            }
+            return readBytes + ((numBytes==-1) ? 0 : numBytes);
+        }
+
+        // Reload the buffer
+        // WARNING: Right now LoadBuffer() assumes the buffer's empty
+        LoadBuffer();
+        if ((int)(DataSize-Pos) < numBytes)
+            numBytes = (int)DataSize-Pos;
+
+        memcpy(pdestBuffer, pBuffer+Pos, numBytes);
+        Pos += numBytes;
+        return numBytes + readBytes;
+        
+        /*
+        // Alternative Read implementation. The one above is probably better
+        // due to FILEBUFFER_TOLERANCE.
+        int     total = 0;
+
+        do {
+            int     bufferBytes = (int)(DataSize-Pos);
+            int     copyBytes = (bufferBytes > numBytes) ? numBytes : bufferBytes;
+
+            memcpy(pdestBuffer, pBuffer+Pos, copyBytes);
+            numBytes    -= copyBytes;
+            pdestBuffer += copyBytes;
+            Pos         += copyBytes;
+            total       += copyBytes;
+
+            if (numBytes == 0)
+                break;
+            LoadBuffer();
+
+        } while (DataSize > 0);
+
+        return total;
+        */     
+    }
+    int sz = pFile->Read(pdestBuffer,numBytes);
+    if (sz > 0)
+        FilePos += sz;
+    return sz;
+}
+
+
+int     BufferedFile::SkipBytes(int numBytes)
+{
+    int skippedBytes = 0;
+
+    // Special case for skipping a little data in read buffer
+    if (BufferMode==ReadBuffer)
+    {
+        skippedBytes = (((int)DataSize-(int)Pos) >= numBytes) ? numBytes : (DataSize-Pos);
+        Pos          += skippedBytes;
+        numBytes     -= skippedBytes;
+    }
+
+    if (numBytes)
+    {
+        numBytes = pFile->SkipBytes(numBytes);
+        // Make sure we return the actual number skipped, or error
+        if (numBytes!=-1)
+        {
+            skippedBytes += numBytes;
+            FilePos += numBytes;
+            Pos = DataSize = 0;
+        }
+        else if (skippedBytes <= 0)
+            skippedBytes = -1;
+    }
+    return skippedBytes;
+}
+
+int     BufferedFile::BytesAvailable()
+{
+    int available = pFile->BytesAvailable();
+    // Adjust available size based on buffers
+    switch(BufferMode)
+    {
+        case ReadBuffer:
+            available += DataSize-Pos;
+            break;
+        case WriteBuffer:
+            available -= Pos;
+            if (available<0)
+                available= 0;
+            break;
+        default:
+            break;
+    }
+    return available;
+}
+
+bool    BufferedFile::Flush()
+{
+    FlushBuffer();
+    return pFile->Flush();
+}
+
+// Seeking could be optimized better..
+int     BufferedFile::Seek(int offset, int origin)
+{    
+    if (BufferMode == ReadBuffer)
+    {
+        if (origin == Seek_Cur)
+        {
+            // Seek can fall either before or after Pos in the buffer,
+            // but it must be within bounds.
+            if (((unsigned(offset) + Pos)) <= DataSize)
+            {
+                Pos += offset;
+                return int (FilePos - DataSize + Pos);
+            }
+
+            // Lightweight buffer "Flush". We do this to avoid an extra seek
+            // back operation which would take place if we called FlushBuffer directly.
+            origin = Seek_Set;
+            OVR_ASSERT(((FilePos - DataSize + Pos) + (uint64_t)offset) < ~(uint64_t)0);
+            offset = (int)(FilePos - DataSize + Pos) + offset;
+            Pos = DataSize = 0;
+        }
+        else if (origin == Seek_Set)
+        {
+            if (((unsigned)offset - (FilePos-DataSize)) <= DataSize)
+            {
+                OVR_ASSERT((FilePos-DataSize) < ~(uint64_t)0);
+                Pos = (unsigned)offset - (unsigned)(FilePos-DataSize);
+                return offset;
+            }
+            Pos = DataSize = 0;
+        }
+        else
+        {
+            FlushBuffer();
+        }
+    }
+    else
+    {
+        FlushBuffer();
+    }    
+
+    /*
+    // Old Seek Logic
+    if (origin == Seek_Cur && offset + Pos < DataSize)
+    {
+        //OVR_ASSERT((FilePos - DataSize) >= (FilePos - DataSize + Pos + offset));
+        Pos += offset;
+        OVR_ASSERT(int (Pos) >= 0);
+        return int (FilePos - DataSize + Pos);
+    }
+    else if (origin == Seek_Set && unsigned(offset) >= FilePos - DataSize && unsigned(offset) < FilePos)
+    {
+        Pos = unsigned(offset - FilePos + DataSize);
+        OVR_ASSERT(int (Pos) >= 0);
+        return int (FilePos - DataSize + Pos);
+    }   
+    
+    FlushBuffer();
+    */
+
+
+    FilePos = pFile->Seek(offset,origin);
+    return int (FilePos);
+}
+
+int64_t BufferedFile::LSeek(int64_t offset, int origin)
+{
+    if (BufferMode == ReadBuffer)
+    {
+        if (origin == Seek_Cur)
+        {
+            // Seek can fall either before or after Pos in the buffer,
+            // but it must be within bounds.
+            if (((unsigned(offset) + Pos)) <= DataSize)
+            {
+                Pos += (unsigned)offset;
+                return int64_t(FilePos - DataSize + Pos);
+            }
+
+            // Lightweight buffer "Flush". We do this to avoid an extra seek
+            // back operation which would take place if we called FlushBuffer directly.
+            origin = Seek_Set;            
+            offset = (int64_t)(FilePos - DataSize + Pos) + offset;
+            Pos = DataSize = 0;
+        }
+        else if (origin == Seek_Set)
+        {
+            if (((uint64_t)offset - (FilePos-DataSize)) <= DataSize)
+            {                
+                Pos = (unsigned)((uint64_t)offset - (FilePos-DataSize));
+                return offset;
+            }
+            Pos = DataSize = 0;
+        }
+        else
+        {
+            FlushBuffer();
+        }
+    }
+    else
+    {
+        FlushBuffer();
+    }
+
+/*
+    OVR_ASSERT(BufferMode != NoBuffer);
+
+    if (origin == Seek_Cur && offset + Pos < DataSize)
+    {
+        Pos += int (offset);
+        return FilePos - DataSize + Pos;
+    }
+    else if (origin == Seek_Set && offset >= int64_t(FilePos - DataSize) && offset < int64_t(FilePos))
+    {
+        Pos = unsigned(offset - FilePos + DataSize);
+        return FilePos - DataSize + Pos;
+    }
+
+    FlushBuffer();
+    */
+
+    FilePos = pFile->LSeek(offset,origin);
+    return FilePos;
+}
+
+int     BufferedFile::CopyFromStream(File *pstream, int byteSize)
+{
+    // We can't rely on overridden Write()
+    // because delegation doesn't override virtual pointers
+    // So, just re-implement
+    uint8_t*  buff = new uint8_t[0x4000];
+    int     count = 0;
+    int     szRequest, szRead, szWritten;
+
+    while(byteSize)
+    {
+        szRequest = (byteSize > int(sizeof(buff))) ? int(sizeof(buff)) : byteSize;
+
+        szRead    = pstream->Read(buff,szRequest);
+        szWritten = 0;
+        if (szRead > 0)
+            szWritten = Write(buff,szRead);
+
+        count   +=szWritten;
+        byteSize-=szWritten;
+        if (szWritten < szRequest)
+            break;
+    }
+
+	delete[] buff;
+
+    return count;
+}
+
+// Closing files
+bool    BufferedFile::Close()
+{
+    switch(BufferMode)
+    {
+        case WriteBuffer:
+            FlushBuffer();
+            break;
+        case ReadBuffer:
+            // No need to seek back on close
+            BufferMode = NoBuffer;
+            break;
+        default:
+            break;
+    }
+    return pFile->Close();
+}
+
+
+// ***** Global path helpers
+
+// Find trailing short filename in a path.
+const char* OVR_CDECL GetShortFilename(const char* purl)
+{    
+    size_t len = OVR_strlen(purl);
+    for (size_t i=len; i>0; i--) 
+        if (purl[i]=='\\' || purl[i]=='/')
+            return purl+i+1;
+    return purl;
+}
+
+} // OVR
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,529 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_File.h
+Content     :   Header for all internal file management - functions and structures
+                to be inherited by OS specific subclasses.
+Created     :   September 19, 2012
+Notes       : 
+
+Notes       :   errno may not be preserved across use of BaseFile member functions
+            :   Directories cannot be deleted while files opened from them are in use
+                (For the GetFullName function)
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_File_h
+#define OVR_File_h
+
+#include "OVR_RefCount.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+#include <stdio.h>
+#include "OVR_String.h"
+
+namespace OVR {
+
+// ***** Declared classes
+class   FileConstants;
+class   File;
+class   DelegatedFile;
+class   BufferedFile;
+
+
+// ***** Flags for File & Directory accesses
+
+class FileConstants
+{
+public:
+
+    // *** File open flags
+    enum OpenFlags
+    {
+        Open_Read       = 1,
+        Open_Write      = 2,
+        Open_ReadWrite  = 3,
+
+        // Opens file and truncates it to zero length
+        // - file must have write permission
+        // - when used with Create, it opens an existing 
+        //   file and empties it or creates a new file
+        Open_Truncate   = 4,
+
+        // Creates and opens new file 
+        // - does not erase contents if file already
+        //   exists unless combined with Truncate
+        Open_Create     = 8,
+
+         // Returns an error value if the file already exists
+        Open_CreateOnly = 24,
+
+        // Open file with buffering
+        Open_Buffered    = 32
+    };
+
+    // *** File Mode flags
+    enum Modes
+    {
+        Mode_Read       = 0444,
+        Mode_Write      = 0222,
+        Mode_Execute    = 0111,
+
+        Mode_ReadWrite  = 0666
+    };
+
+    // *** Seek operations
+    enum SeekOps
+    {
+        Seek_Set        = 0,
+        Seek_Cur        = 1,
+        Seek_End        = 2
+    };
+
+    // *** Errors
+    enum Errors
+    {
+        Error_FileNotFound  = 0x1001,
+        Error_Access        = 0x1002,
+        Error_IOError       = 0x1003,
+        Error_DiskFull      = 0x1004
+    };
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** File Class
+
+// The pure virtual base random-access file
+// This is a base class to all files
+
+class File : public RefCountBase<File>, public FileConstants
+{   
+public:
+    File() { }
+    // ** Location Information
+
+    // Returns a file name path relative to the 'reference' directory
+    // This is often a path that was used to create a file
+    // (this is not a global path, global path can be obtained with help of directory)
+    virtual const char* GetFilePath() = 0;
+                                                                                        
+
+    // ** File Information
+
+    // Return 1 if file's usable (open)
+    virtual bool        IsValid() = 0;
+    // Return 1 if file's writable, otherwise 0                                         
+    virtual bool        IsWritable() = 0;
+                                                                                        
+    // Return position
+    virtual int         Tell() = 0;
+    virtual int64_t     LTell() = 0;
+    
+    // File size                                                                        
+    virtual int         GetLength() = 0;
+    virtual int64_t     LGetLength() = 0;
+                                                                                        
+    // Returns file stats                                                               
+    // 0 for failure                                                                    
+    //virtual bool      Stat(FileStats *pfs) = 0;
+                                                                                        
+    // Return errno-based error code                                                    
+    // Useful if any other function failed                                              
+    virtual int         GetErrorCode() = 0;
+                                                                                        
+                                                                                        
+    // ** Stream implementation & I/O
+
+    // Blocking write, will write in the given number of bytes to the stream
+    // Returns : -1 for error
+    //           Otherwise number of bytes read 
+    virtual int         Write(const uint8_t *pbufer, int numBytes) = 0;
+    // Blocking read, will read in the given number of bytes or less from the stream
+    // Returns : -1 for error
+    //           Otherwise number of bytes read,
+    //           if 0 or < numBytes, no more bytes available; end of file or the other side of stream is closed
+    virtual int         Read(uint8_t *pbufer, int numBytes) = 0;
+
+    // Skips (ignores) a given # of bytes
+    // Same return values as Read
+    virtual int         SkipBytes(int numBytes) = 0;
+        
+    // Returns the number of bytes available to read from a stream without blocking
+    // For a file, this should generally be number of bytes to the end
+    virtual int         BytesAvailable() = 0;
+
+    // Causes any implementation's buffered data to be delivered to destination
+    // Return 0 for error
+    virtual bool        Flush() = 0;
+                                                                                            
+
+    // Need to provide a more optimized implementation that doe snot necessarily involve a lot of seeking
+    inline bool         IsEOF() { return !BytesAvailable(); }
+    
+
+    // Seeking                                                                              
+    // Returns new position, -1 for error                                                   
+    virtual int         Seek(int offset, int origin=Seek_Set) = 0;
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set) = 0;
+    // Seek simplification
+    int                 SeekToBegin()           {return Seek(0); }
+    int                 SeekToEnd()             {return Seek(0,Seek_End); }
+    int                 Skip(int numBytes)     {return Seek(numBytes,Seek_Cur); }
+                        
+
+    // Appends other file data from a stream
+    // Return -1 for error, else # of bytes written
+    virtual int         CopyFromStream(File *pstream, int byteSize) = 0;
+
+    // Closes the file
+    // After close, file cannot be accessed 
+    virtual bool        Close() = 0;
+
+
+    // ***** Inlines for convenient primitive type serialization
+
+    // Read/Write helpers
+private:
+    uint64_t  PRead64()           { uint64_t v = 0; Read((uint8_t*)&v, 8); return v; }
+    uint32_t  PRead32()           { uint32_t v = 0; Read((uint8_t*)&v, 4); return v; }
+    uint16_t  PRead16()           { uint16_t v = 0; Read((uint8_t*)&v, 2); return v; }
+    uint8_t PRead8()            { uint8_t  v = 0; Read((uint8_t*)&v, 1); return v; }
+    void    PWrite64(uint64_t v)  { Write((uint8_t*)&v, 8); }
+    void    PWrite32(uint32_t v)  { Write((uint8_t*)&v, 4); }
+    void    PWrite16(uint16_t v)  { Write((uint8_t*)&v, 2); }
+    void    PWrite8(uint8_t v)  { Write((uint8_t*)&v, 1); }
+
+public:
+
+    // Writing primitive types - Little Endian
+    inline void    WriteUByte(uint8_t v)       { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteSByte(int8_t v)        { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteUInt8(uint8_t v)       { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteSInt8(int8_t v)        { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteUInt16(uint16_t v)       { PWrite16((uint16_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt16(int16_t v)       { PWrite16((uint16_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteUInt32(uint32_t v)       { PWrite32((uint32_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt32(int32_t v)       { PWrite32((uint32_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteUInt64(uint64_t v)       { PWrite64((uint64_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt64(int64_t v)       { PWrite64((uint64_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteFloat(float v)         { v = Alg::ByteUtil::SystemToLE(v); Write((uint8_t*)&v, 4); } 
+    inline void    WriteDouble(double v)       { v = Alg::ByteUtil::SystemToLE(v); Write((uint8_t*)&v, 8); }
+    // Writing primitive types - Big Endian
+    inline void    WriteUByteBE(uint8_t v)     { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteSByteBE(int8_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteUInt8BE(uint16_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteSInt8BE(int16_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteUInt16BE(uint16_t v)     { PWrite16((uint16_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt16BE(uint16_t v)     { PWrite16((uint16_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteUInt32BE(uint32_t v)     { PWrite32((uint32_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt32BE(uint32_t v)     { PWrite32((uint32_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteUInt64BE(uint64_t v)     { PWrite64((uint64_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt64BE(uint64_t v)     { PWrite64((uint64_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteFloatBE(float v)       { v = Alg::ByteUtil::SystemToBE(v); Write((uint8_t*)&v, 4); }
+    inline void    WriteDoubleBE(double v)     { v = Alg::ByteUtil::SystemToBE(v); Write((uint8_t*)&v, 8); }
+        
+    // Reading primitive types - Little Endian
+    inline uint8_t ReadUByte()                 { return (uint8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline int8_t  ReadSByte()                 { return (int8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline uint8_t ReadUInt8()                 { return (uint8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline int8_t  ReadSInt8()                 { return (int8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline uint16_t  ReadUInt16()                { return (uint16_t)Alg::ByteUtil::LEToSystem(PRead16());  }
+    inline int16_t ReadSInt16()                { return (int16_t)Alg::ByteUtil::LEToSystem(PRead16());  }
+    inline uint32_t  ReadUInt32()                { return (uint32_t)Alg::ByteUtil::LEToSystem(PRead32());  }
+    inline int32_t ReadSInt32()                { return (int32_t)Alg::ByteUtil::LEToSystem(PRead32());  }
+    inline uint64_t  ReadUInt64()                { return (uint64_t)Alg::ByteUtil::LEToSystem(PRead64());  }
+    inline int64_t ReadSInt64()                { return (int64_t)Alg::ByteUtil::LEToSystem(PRead64());  }
+    inline float   ReadFloat()                 { float v = 0.0f; Read((uint8_t*)&v, 4); return Alg::ByteUtil::LEToSystem(v); }
+    inline double  ReadDouble()                { double v = 0.0; Read((uint8_t*)&v, 8); return Alg::ByteUtil::LEToSystem(v); }
+    // Reading primitive types - Big Endian
+    inline uint8_t ReadUByteBE()               { return (uint8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline int8_t  ReadSByteBE()               { return (int8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline uint8_t ReadUInt8BE()               { return (uint8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline int8_t  ReadSInt8BE()               { return (int8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline uint16_t  ReadUInt16BE()              { return (uint16_t)Alg::ByteUtil::BEToSystem(PRead16());  }
+    inline int16_t ReadSInt16BE()              { return (int16_t)Alg::ByteUtil::BEToSystem(PRead16());  }
+    inline uint32_t  ReadUInt32BE()              { return (uint32_t)Alg::ByteUtil::BEToSystem(PRead32());  }
+    inline int32_t ReadSInt32BE()              { return (int32_t)Alg::ByteUtil::BEToSystem(PRead32());  }
+    inline uint64_t  ReadUInt64BE()              { return (uint64_t)Alg::ByteUtil::BEToSystem(PRead64());  }
+    inline int64_t ReadSInt64BE()              { return (int64_t)Alg::ByteUtil::BEToSystem(PRead64());  }
+    inline float   ReadFloatBE()               { float v = 0.0f; Read((uint8_t*)&v, 4); return Alg::ByteUtil::BEToSystem(v); }
+    inline double  ReadDoubleBE()              { double v = 0.0; Read((uint8_t*)&v, 8); return Alg::ByteUtil::BEToSystem(v); }
+};
+
+
+// *** Delegated File
+
+class DelegatedFile : public File
+{
+protected:
+    // Delegating file pointer
+    Ptr<File>     pFile;
+
+    // Hidden default constructor
+    DelegatedFile() : pFile(0)                             { }
+    DelegatedFile(const DelegatedFile &source) : File()    { OVR_UNUSED(source); }
+public:
+    // Constructors
+    DelegatedFile(File *pfile) : pFile(pfile)     { }
+
+    // ** Location Information  
+    virtual const char* GetFilePath()                               { return pFile->GetFilePath(); }    
+
+    // ** File Information                                                      
+    virtual bool        IsValid()                                   { return pFile && pFile->IsValid(); }   
+    virtual bool        IsWritable()                                { return pFile->IsWritable(); }
+//  virtual bool        IsRecoverable()                             { return pFile->IsRecoverable(); }          
+                                                                    
+    virtual int         Tell()                                      { return pFile->Tell(); }
+    virtual int64_t     LTell()                                     { return pFile->LTell(); }
+    
+    virtual int         GetLength()                                 { return pFile->GetLength(); }
+    virtual int64_t     LGetLength()                                { return pFile->LGetLength(); }
+    
+    //virtual bool      Stat(FileStats *pfs)                        { return pFile->Stat(pfs); }
+    
+    virtual int         GetErrorCode()                              { return pFile->GetErrorCode(); }
+    
+    // ** Stream implementation & I/O
+    virtual int         Write(const uint8_t *pbuffer, int numBytes)   { return pFile->Write(pbuffer,numBytes); }  
+    virtual int         Read(uint8_t *pbuffer, int numBytes)          { return pFile->Read(pbuffer,numBytes); }   
+    
+    virtual int         SkipBytes(int numBytes)                     { return pFile->SkipBytes(numBytes); }      
+    
+    virtual int         BytesAvailable()                            { return pFile->BytesAvailable(); } 
+    
+    virtual bool        Flush()                                     { return pFile->Flush(); }
+                                                                    
+    // Seeking                                                      
+    virtual int         Seek(int offset, int origin=Seek_Set)       { return pFile->Seek(offset,origin); }
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set)   { return pFile->LSeek(offset,origin); }
+
+    virtual int         CopyFromStream(File *pstream, int byteSize) { return pFile->CopyFromStream(pstream,byteSize); }
+                        
+    // Closing the file 
+    virtual bool        Close()                                     { return pFile->Close(); }    
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Buffered File
+
+// This file class adds buffering to an existing file
+// Buffered file never fails by itself; if there's not
+// enough memory for buffer, no buffer's used
+
+class BufferedFile : public DelegatedFile
+{   
+protected:  
+    enum BufferModeType
+    {
+        NoBuffer,
+        ReadBuffer,
+        WriteBuffer
+    };
+
+    // Buffer & the mode it's in
+    uint8_t*          pBuffer;
+    BufferModeType  BufferMode;
+    // Position in buffer
+    unsigned        Pos;
+    // Data in buffer if reading
+    unsigned        DataSize;
+    // Underlying file position 
+    uint64_t        FilePos;
+
+    // Initializes buffering to a certain mode
+    bool    SetBufferMode(BufferModeType mode);
+    // Flushes buffer
+    // WriteBuffer - write data to disk, ReadBuffer - reset buffer & fix file position  
+    void    FlushBuffer();
+    // Loads data into ReadBuffer
+    // WARNING: Right now LoadBuffer() assumes the buffer's empty
+    void    LoadBuffer();
+
+    // Hidden constructor
+    BufferedFile();
+    inline BufferedFile(const BufferedFile &source) : DelegatedFile() { OVR_UNUSED(source); }
+public:
+
+    // Constructor
+    // - takes another file as source
+    BufferedFile(File *pfile);
+    ~BufferedFile();
+    
+    
+    // ** Overridden functions
+
+    // We override all the functions that can possibly
+    // require buffer mode switch, flush, or extra calculations
+    virtual int         Tell();
+    virtual int64_t     LTell();
+
+    virtual int         GetLength();
+    virtual int64_t     LGetLength();
+
+//  virtual bool        Stat(GFileStats *pfs);  
+
+    virtual int         Write(const uint8_t *pbufer, int numBytes);
+    virtual int         Read(uint8_t *pbufer, int numBytes);
+
+    virtual int         SkipBytes(int numBytes);
+
+    virtual int         BytesAvailable();
+
+    virtual bool        Flush();
+
+    virtual int         Seek(int offset, int origin=Seek_Set);
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set);
+
+    virtual int         CopyFromStream(File *pstream, int byteSize);
+    
+    virtual bool        Close();    
+};                          
+
+
+//-----------------------------------------------------------------------------------
+// ***** Memory File
+
+class MemoryFile : public File
+{
+public:
+
+    const char* GetFilePath()       { return FilePath.ToCStr(); }
+
+    bool        IsValid()           { return Valid; }
+    bool        IsWritable()        { return false; }
+
+    bool        Flush()             { return true; }
+    int         GetErrorCode()      { return 0; }
+
+    int         Tell()              { return FileIndex; }
+    int64_t     LTell()             { return (int64_t) FileIndex; }
+
+    int         GetLength()         { return FileSize; }
+    int64_t     LGetLength()        { return (int64_t) FileSize; }
+
+    bool        Close()
+    {
+        Valid = false;
+        return false;
+    }
+
+    int         CopyFromStream(File *pstream, int byteSize)
+    {   OVR_UNUSED2(pstream, byteSize);
+        return 0;
+    }
+
+    int         Write(const uint8_t *pbuffer, int numBytes)
+    {   OVR_UNUSED2(pbuffer, numBytes);
+        return 0;
+    }
+
+    int         Read(uint8_t *pbufer, int numBytes)
+    {
+        if (FileIndex + numBytes > FileSize)
+        {
+            numBytes = FileSize - FileIndex;
+        }
+
+        if (numBytes > 0)
+        {
+            ::memcpy (pbufer, &FileData [FileIndex], numBytes);
+
+            FileIndex += numBytes;
+        }
+
+        return numBytes;
+    }
+
+    int         SkipBytes(int numBytes)
+    {
+        if (FileIndex + numBytes > FileSize)
+        {
+            numBytes = FileSize - FileIndex;
+        }
+
+        FileIndex += numBytes;
+
+        return numBytes;
+    }
+
+    int         BytesAvailable()
+    {
+        return (FileSize - FileIndex);
+    }
+
+    int         Seek(int offset, int origin = Seek_Set)
+    {
+        switch (origin)
+        {
+        case Seek_Set : FileIndex  = offset;               break;
+        case Seek_Cur : FileIndex += offset;               break;
+        case Seek_End : FileIndex  = FileSize - offset;  break;
+        }
+
+        return FileIndex;
+    }
+
+    int64_t     LSeek(int64_t offset, int origin = Seek_Set)
+    {
+        return (int64_t) Seek((int) offset, origin);
+    }
+
+public:
+
+    MemoryFile (const String& fileName, const uint8_t *pBuffer, int buffSize)
+        : FilePath(fileName)
+    {
+        FileData  = pBuffer;
+        FileSize  = buffSize;
+        FileIndex = 0;
+        Valid     = (!fileName.IsEmpty() && pBuffer && buffSize > 0) ? true : false;
+    }
+
+    // pfileName should be encoded as UTF-8 to support international file names.
+    MemoryFile (const char* pfileName, const uint8_t *pBuffer, int buffSize)
+        : FilePath(pfileName)
+    {
+        FileData  = pBuffer;
+        FileSize  = buffSize;
+        FileIndex = 0;
+        Valid     = (pfileName && pBuffer && buffSize > 0) ? true : false;
+    }
+private:
+
+    String       FilePath;
+    const uint8_t *FileData;
+    int          FileSize;
+    int          FileIndex;
+    bool         Valid;
+};
+
+
+// ***** Global path helpers
+
+// Find trailing short filename in a path.
+const char* OVR_CDECL GetShortFilename(const char* purl);
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_FileFILE.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_FileFILE.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,599 @@
+/**************************************************************************
+
+Filename    :   OVR_FileFILE.cpp
+Content     :   File wrapper class implementation (Win32)
+
+Created     :   April 5, 1999
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+**************************************************************************/
+
+#define  GFILE_CXX
+
+#include "OVR_Types.h"
+#include "OVR_Log.h"
+
+// Standard C library (Captain Obvious guarantees!)
+#include <stdio.h>
+#ifndef OVR_OS_WINCE
+#include <sys/stat.h>
+#endif
+
+#include "OVR_SysFile.h"
+
+#ifndef OVR_OS_WINCE
+#include <errno.h>
+#endif
+
+namespace OVR {
+
+// ***** File interface
+
+// ***** FILEFile - C streams file
+
+static int SFerror ()
+{
+    if (errno == ENOENT)
+        return FileConstants::Error_FileNotFound;
+    else if (errno == EACCES || errno == EPERM)
+        return FileConstants::Error_Access;
+    else if (errno == ENOSPC)
+        return FileConstants::Error_DiskFull;
+    else
+        return FileConstants::Error_IOError;
+};
+
+#if defined(OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include "windows.h"
+// A simple helper class to disable/enable system error mode, if necessary
+// Disabling happens conditionally only if a drive name is involved
+class SysErrorModeDisabler
+{
+    BOOL    Disabled;
+    UINT    OldMode;
+public:
+    SysErrorModeDisabler(const char* pfileName)
+    {
+        if (pfileName && (pfileName[0]!=0) && pfileName[1]==':')
+        {
+            Disabled = 1;
+            OldMode = ::SetErrorMode(SEM_FAILCRITICALERRORS);
+        }
+        else
+            Disabled = 0;
+    }
+
+    ~SysErrorModeDisabler()
+    {
+        if (Disabled) ::SetErrorMode(OldMode);
+    }
+};
+#else
+class SysErrorModeDisabler
+{
+public:
+    SysErrorModeDisabler(const char* pfileName) { OVR_UNUSED(pfileName); }
+};
+#endif // OVR_OS_WIN32
+
+
+// This macro enables verification of I/O results after seeks against a pre-loaded
+// full file buffer copy. This is generally not necessary, but can been used to debug
+// memory corruptions; we've seen this fail due to EAX2/DirectSound corrupting memory
+// under FMOD with XP64 (32-bit) and Realtek HA Audio driver.
+//#define GFILE_VERIFY_SEEK_ERRORS
+
+
+// This is the simplest possible file implementation, it wraps around the descriptor
+// This file is delegated to by SysFile.
+
+class FILEFile : public File
+{
+protected:
+
+    // Allocated filename
+    String      FileName;
+
+    // File handle & open mode
+    bool        Opened;
+    FILE*       fs;
+    int         OpenFlags;
+    // Error code for last request
+    int         ErrorCode;
+
+    int         LastOp;
+
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+    uint8_t*      pFileTestBuffer;
+    unsigned    FileTestLength;
+    unsigned    TestPos; // File pointer position during tests.
+#endif
+
+public:
+
+    FILEFile()
+    {
+        Opened = 0; FileName = "";
+
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+        pFileTestBuffer =0;
+        FileTestLength  =0;
+        TestPos         =0;
+#endif
+    }
+    // Initialize file by opening it
+    FILEFile(const String& fileName, int flags, int Mode);
+    // The 'pfileName' should be encoded as UTF-8 to support international file names.
+    FILEFile(const char* pfileName, int flags, int Mode);
+
+    ~FILEFile()
+    {
+        if (Opened)
+            Close();
+    }
+
+    virtual const char* GetFilePath();
+
+    // ** File Information
+    virtual bool        IsValid();
+    virtual bool        IsWritable();
+
+    // Return position / file size
+    virtual int         Tell();
+    virtual int64_t     LTell();
+    virtual int         GetLength();
+    virtual int64_t     LGetLength();
+
+//  virtual bool        Stat(FileStats *pfs);
+    virtual int         GetErrorCode();
+
+    // ** Stream implementation & I/O
+    virtual int         Write(const uint8_t *pbuffer, int numBytes);
+    virtual int         Read(uint8_t *pbuffer, int numBytes);
+    virtual int         SkipBytes(int numBytes);
+    virtual int         BytesAvailable();
+    virtual bool        Flush();
+    virtual int         Seek(int offset, int origin);
+    virtual int64_t     LSeek(int64_t offset, int origin);
+    
+    virtual int         CopyFromStream(File *pStream, int byteSize);
+    virtual bool        Close();    
+private:
+    void                init();
+};
+
+
+// Initialize file by opening it
+FILEFile::FILEFile(const String& fileName, int flags, int mode)
+  : FileName(fileName), OpenFlags(flags)
+{
+    OVR_UNUSED(mode);
+    init();
+}
+
+// The 'pfileName' should be encoded as UTF-8 to support international file names.
+FILEFile::FILEFile(const char* pfileName, int flags, int mode)
+  : FileName(pfileName), OpenFlags(flags)
+{
+    OVR_UNUSED(mode);
+    init();
+}
+
+void FILEFile::init()
+{
+    // Open mode for file's open
+    const char *omode = "rb";
+
+    if (OpenFlags & Open_Truncate)
+    {
+        if (OpenFlags & Open_Read)
+            omode = "w+b";
+        else
+            omode = "wb";
+    }
+    else if (OpenFlags & Open_Create)
+    {
+        if (OpenFlags & Open_Read)
+            omode = "a+b";
+        else
+            omode = "ab";
+    }
+    else if (OpenFlags & Open_Write)
+        omode = "r+b";
+
+#if defined(OVR_OS_WIN32) 
+    SysErrorModeDisabler disabler(FileName.ToCStr());
+#endif
+
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+    wchar_t womode[16];
+    wchar_t *pwFileName = (wchar_t*)OVR_ALLOC((UTF8Util::GetLength(FileName.ToCStr())+1) * sizeof(wchar_t));
+    UTF8Util::DecodeString(pwFileName, FileName.ToCStr());
+    OVR_ASSERT(strlen(omode) < sizeof(womode)/sizeof(womode[0]));
+    UTF8Util::DecodeString(womode, omode);
+    _wfopen_s(&fs, pwFileName, womode);
+    OVR_FREE(pwFileName);
+#else
+    fs = fopen(FileName.ToCStr(), omode);
+#endif
+    if (fs)
+        rewind (fs);
+    Opened = (fs != NULL);
+    // Set error code
+    if (!Opened)
+        ErrorCode = SFerror();
+    else
+    {
+        // If we are testing file seek correctness, pre-load the entire file so
+        // that we can do comparison tests later.
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS        
+        TestPos         = 0;
+        fseek(fs, 0, SEEK_END);
+        FileTestLength  = ftell(fs);
+        fseek(fs, 0, SEEK_SET);
+        pFileTestBuffer = (uint8_t*)OVR_ALLOC(FileTestLength);
+        if (pFileTestBuffer)
+        {
+            OVR_ASSERT(FileTestLength == (unsigned)Read(pFileTestBuffer, FileTestLength));
+            Seek(0, Seek_Set);
+        }        
+#endif
+
+        ErrorCode = 0;
+    }
+    LastOp = 0;
+}
+
+
+const char* FILEFile::GetFilePath()
+{
+    return FileName.ToCStr();
+}
+
+
+// ** File Information
+bool    FILEFile::IsValid()
+{
+    return Opened;
+}
+bool    FILEFile::IsWritable()
+{
+    return IsValid() && (OpenFlags&Open_Write);
+}
+/*
+bool    FILEFile::IsRecoverable()
+{
+    return IsValid() && ((OpenFlags&OVR_FO_SAFETRUNC) == OVR_FO_SAFETRUNC);
+}
+*/
+
+// Return position / file size
+int     FILEFile::Tell()
+{
+    int pos = (int)ftell (fs);
+    if (pos < 0)
+        ErrorCode = SFerror();
+    return pos;
+}
+
+int64_t FILEFile::LTell()
+{
+    int64_t pos = ftell(fs);
+    if (pos < 0)
+        ErrorCode = SFerror();
+    return pos;
+}
+
+int     FILEFile::GetLength()
+{
+    int pos = Tell();
+    if (pos >= 0)
+    {
+        Seek (0, Seek_End);
+        int size = Tell();
+        Seek (pos, Seek_Set);
+        return size;
+    }
+    return -1;
+}
+int64_t FILEFile::LGetLength()
+{
+    int64_t pos = LTell();
+    if (pos >= 0)
+    {
+        LSeek (0, Seek_End);
+        int64_t size = LTell();
+        LSeek (pos, Seek_Set);
+        return size;
+    }
+    return -1;
+}
+
+int     FILEFile::GetErrorCode()
+{
+    return ErrorCode;
+}
+
+// ** Stream implementation & I/O
+int     FILEFile::Write(const uint8_t *pbuffer, int numBytes)
+{
+    if (LastOp && LastOp != Open_Write)
+        fflush(fs);
+    LastOp = Open_Write;
+    int written = (int) fwrite(pbuffer, 1, numBytes, fs);
+    if (written < numBytes)
+        ErrorCode = SFerror();
+
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+    if (written > 0)
+        TestPos += written;
+#endif
+
+    return written;
+}
+
+int     FILEFile::Read(uint8_t *pbuffer, int numBytes)
+{
+    if (LastOp && LastOp != Open_Read)
+        fflush(fs);
+    LastOp = Open_Read;
+    int read = (int) fread(pbuffer, 1, numBytes, fs);
+    if (read < numBytes)
+        ErrorCode = SFerror();
+
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+    if (read > 0)
+    {
+        // Read-in data must match our pre-loaded buffer data!
+        uint8_t* pcompareBuffer = pFileTestBuffer + TestPos;
+        for (int i=0; i< read; i++)
+        {
+            OVR_ASSERT(pcompareBuffer[i] == pbuffer[i]);
+        }
+
+        //OVR_ASSERT(!memcmp(pFileTestBuffer + TestPos, pbuffer, read));
+        TestPos += read;
+        OVR_ASSERT(ftell(fs) == (int)TestPos);
+    }
+#endif
+
+    return read;
+}
+
+// Seeks ahead to skip bytes
+int     FILEFile::SkipBytes(int numBytes)
+{
+    int64_t pos    = LTell();
+    int64_t newPos = LSeek(numBytes, Seek_Cur);
+
+    // Return -1 for major error
+    if ((pos==-1) || (newPos==-1))
+    {
+        return -1;
+    }
+    //ErrorCode = ((NewPos-Pos)<numBytes) ? errno : 0;
+
+    return int (newPos-(int)pos);
+}
+
+// Return # of bytes till EOF
+int     FILEFile::BytesAvailable()
+{
+    int64_t pos    = LTell();
+    int64_t endPos = LGetLength();
+
+    // Return -1 for major error
+    if ((pos==-1) || (endPos==-1))
+    {
+        ErrorCode = SFerror();
+        return 0;
+    }
+    else
+        ErrorCode = 0;
+
+    return int (endPos-(int)pos);
+}
+
+// Flush file contents
+bool    FILEFile::Flush()
+{
+    return !fflush(fs);
+}
+
+int     FILEFile::Seek(int offset, int origin)
+{
+    int newOrigin = 0;
+    switch(origin)
+    {
+    case Seek_Set: newOrigin = SEEK_SET; break;
+    case Seek_Cur: newOrigin = SEEK_CUR; break;
+    case Seek_End: newOrigin = SEEK_END; break;
+    }
+
+    if (newOrigin == SEEK_SET && offset == Tell())
+        return Tell();
+
+    if (fseek (fs, offset, newOrigin))
+    {
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+        OVR_ASSERT(0);
+#endif
+        return -1;
+    }
+    
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+    // Track file position after seeks for read verification later.
+    switch(origin)
+    {
+    case Seek_Set:  TestPos = offset;       break;
+    case Seek_Cur:  TestPos += offset;      break;    
+    case Seek_End:  TestPos = FileTestLength + offset; break;
+    }
+    OVR_ASSERT((int)TestPos == Tell());
+#endif
+
+    return (int)Tell();
+}
+
+int64_t FILEFile::LSeek(int64_t offset, int origin)
+{
+    return Seek((int)offset,origin);
+}
+
+int FILEFile::CopyFromStream(File *pstream, int byteSize)
+{
+    uint8_t*  buff = new uint8_t[0x4000];
+    int     count = 0;
+    int     szRequest, szRead, szWritten;
+
+    while (byteSize)
+    {
+        szRequest = (byteSize > int(sizeof(buff))) ? int(sizeof(buff)) : byteSize;
+
+        szRead    = pstream->Read(buff, szRequest);
+        szWritten = 0;
+        if (szRead > 0)
+            szWritten = Write(buff, szRead);
+
+        count    += szWritten;
+        byteSize -= szWritten;
+        if (szWritten < szRequest)
+            break;
+    }
+
+	delete[] buff;
+
+    return count;
+}
+
+
+bool FILEFile::Close()
+{
+#ifdef OVR_FILE_VERIFY_SEEK_ERRORS
+    if (pFileTestBuffer)
+    {
+        OVR_FREE(pFileTestBuffer);
+        pFileTestBuffer = 0;
+        FileTestLength  = 0;
+    }
+#endif
+
+    bool closeRet = !fclose(fs);
+
+    if (!closeRet)
+    {
+        ErrorCode = SFerror();
+        return 0;
+    }
+    else
+    {
+        Opened    = 0;
+        fs        = 0;
+        ErrorCode = 0;
+    }
+
+    // Handle safe truncate
+    /*
+    if ((OpenFlags & OVR_FO_SAFETRUNC) == OVR_FO_SAFETRUNC)
+    {
+        // Delete original file (if it existed)
+        DWORD oldAttributes = FileUtilWin32::GetFileAttributes(FileName);
+        if (oldAttributes!=0xFFFFFFFF)
+            if (!FileUtilWin32::DeleteFile(FileName))
+            {
+                // Try to remove the readonly attribute
+                FileUtilWin32::SetFileAttributes(FileName, oldAttributes & (~FILE_ATTRIBUTE_READONLY) );
+                // And delete the file again
+                if (!FileUtilWin32::DeleteFile(FileName))
+                    return 0;
+            }
+
+        // Rename temp file to real filename
+        if (!FileUtilWin32::MoveFile(TempName, FileName))
+        {
+            //ErrorCode = errno;
+            return 0;
+        }
+    }
+    */
+    return 1;
+}
+
+/*
+bool    FILEFile::CloseCancel()
+{
+    bool closeRet = (bool)::CloseHandle(fd);
+
+    if (!closeRet)
+    {
+        //ErrorCode = errno;
+        return 0;
+    }
+    else
+    {
+        Opened    = 0;
+        fd        = INVALID_HANDLE_VALUE;
+        ErrorCode = 0;
+    }
+
+    // Handle safe truncate (delete tmp file, leave original unchanged)
+    if ((OpenFlags&OVR_FO_SAFETRUNC) == OVR_FO_SAFETRUNC)
+        if (!FileUtilWin32::DeleteFile(TempName))
+        {
+            //ErrorCode = errno;
+            return 0;
+        }
+    return 1;
+}
+*/
+
+Ptr<File> FileFILEOpen(const String& path, int flags, int mode)
+{
+    Ptr<File> result = *new FILEFile(path, flags, mode);
+	return result;
+}
+
+// Helper function: obtain file information time.
+bool    SysFile::GetFileStat(FileStat* pfileStat, const String& path)
+{
+#if defined(OVR_OS_WIN32) 
+    // 64-bit implementation on Windows.
+    struct __stat64 fileStat;
+    // Stat returns 0 for success.
+    wchar_t *pwpath = (wchar_t*)OVR_ALLOC((UTF8Util::GetLength(path.ToCStr())+1)*sizeof(wchar_t));
+    UTF8Util::DecodeString(pwpath, path.ToCStr());
+
+    int ret = _wstat64(pwpath, &fileStat);
+    OVR_FREE(pwpath);
+    if (ret) return false;
+#else
+    struct stat fileStat;
+    // Stat returns 0 for success.
+    if (stat(path, &fileStat) != 0)
+        return false;
+#endif
+    pfileStat->AccessTime = fileStat.st_atime;
+    pfileStat->ModifyTime = fileStat.st_mtime;
+    pfileStat->FileSize   = fileStat.st_size;
+    return true;
+}
+
+} // Namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Hash.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Hash.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1304 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Hash.h
+Content     :   Template hash-table/set implementation
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Hash_h
+#define OVR_Hash_h
+
+#include "OVR_ContainerAllocator.h"
+#include "OVR_Alg.h"
+
+// 'new' operator is redefined/used in this file.
+#undef new
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Hash Table Implementation
+
+// HastSet and Hash.
+//
+// Hash table, linear probing, internal chaining.  One  interesting/nice thing
+// about this implementation is that the table itself is a flat chunk of memory
+// containing no pointers, only relative indices. If the key and value types
+// of the Hash contain no pointers, then the Hash can be serialized using raw IO.
+//
+// Never shrinks, unless you explicitly Clear() it.  Expands on
+// demand, though.  For best results, if you know roughly how big your
+// table will be, default it to that size when you create it.
+//
+// Key usability feature:
+//
+//   1. Allows node hash values to either be cached or not.
+//
+//   2. Allows for alternative keys with methods such as GetAlt(). Handy
+//      if you need to search nodes by their components; no need to create
+//      temporary nodes.
+//
+
+
+// *** Hash functors:
+//
+//  IdentityHash  - use when the key is already a good hash
+//  HFixedSizeHash - general hash based on object's in-memory representation.
+
+
+// Hash is just the input value; can use this for integer-indexed hash tables.
+template<class C>
+class IdentityHash
+{
+public:
+    size_t operator()(const C& data) const
+    { return (size_t) data; }
+};
+
+// Computes a hash of an object's representation.
+template<class C>
+class FixedSizeHash
+{
+public:
+    // Alternative: "sdbm" hash function, suggested at same web page
+    // above, http::/www.cs.yorku.ca/~oz/hash.html
+    // This is somewhat slower then Bernstein, but it works way better than the above
+    // hash function for hashing large numbers of 32-bit ints.
+    static OVR_FORCE_INLINE size_t SDBM_Hash(const void* data_in, size_t size, size_t seed = 5381)     
+    {
+        const uint8_t* data = (const uint8_t*) data_in;
+        size_t       h = seed;
+        while (size > 0)
+        {
+            size--;
+            h = (h << 16) + (h << 6) - h + (size_t)data[size];
+        }   
+        return h;
+    }
+
+    size_t operator()(const C& data) const
+    {
+        unsigned char*  p = (unsigned char*) &data;
+        int size = sizeof(C);
+
+        return SDBM_Hash(p, size);
+    }
+};
+
+
+
+// *** HashsetEntry Entry types. 
+
+// Compact hash table Entry type that re-computes hash keys during hash traversal.
+// Good to use if the hash function is cheap or the hash value is already cached in C.
+template<class C, class HashF>
+class HashsetEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t    NextInChain;
+    C           Value;
+
+    HashsetEntry()
+        : NextInChain(-2) { }
+    HashsetEntry(const HashsetEntry& e)
+        : NextInChain(e.NextInChain), Value(e.Value) { }
+    HashsetEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+
+    bool    IsEmpty() const          { return NextInChain == -2;  }
+    bool    IsEndOfChain() const     { return NextInChain == -1;  }
+
+    // Cached hash value access - can be optimized bu storing hash locally.
+    // Mask value only needs to be used if SetCachedHash is not implemented.
+    size_t  GetCachedHash(size_t maskValue) const  { return HashF()(Value) & maskValue; }
+    void    SetCachedHash(size_t)                  {}
+
+    void    Clear()
+    {        
+        Value.~C(); // placement delete
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+// Hash table Entry type that caches the Entry hash value for nodes, so that it
+// does not need to be re-computed during access.
+template<class C, class HashF>
+class HashsetCachedEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t    NextInChain;
+    size_t      HashValue;
+    C           Value;
+
+    HashsetCachedEntry()
+        : NextInChain(-2) { }
+    HashsetCachedEntry(const HashsetCachedEntry& e)
+        : NextInChain(e.NextInChain), HashValue(e.HashValue), Value(e.Value) { }
+    HashsetCachedEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+
+    bool    IsEmpty() const          { return NextInChain == -2;  }
+    bool    IsEndOfChain() const     { return NextInChain == -1;  }
+
+    // Cached hash value access - can be optimized bu storing hash locally.
+    // Mask value only needs to be used if SetCachedHash is not implemented.
+    size_t  GetCachedHash(size_t maskValue) const  { OVR_UNUSED(maskValue); return HashValue; }
+    void    SetCachedHash(size_t hashValue)        { HashValue = hashValue; }
+
+    void    Clear()
+    {
+        Value.~C();
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+
+//-----------------------------------------------------------------------------------
+// *** HashSet implementation - relies on either cached or regular entries.
+//
+// Use: Entry = HashsetCachedEntry<C, HashF> if hashes are expensive to
+//              compute and thus need caching in entries.
+//      Entry = HashsetEntry<C, HashF> if hashes are already externally cached.
+//
+template<class C, class HashF = FixedSizeHash<C>,
+         class AltHashF = HashF, 
+         class Allocator = ContainerAllocator<C>,
+         class Entry = HashsetCachedEntry<C, HashF> >
+class HashSetBase
+{
+    enum { HashMinSize = 8 };
+
+public:
+    OVR_MEMORY_REDEFINE_NEW(HashSetBase)
+
+    typedef HashSetBase<C, HashF, AltHashF, Allocator, Entry>    SelfType;
+
+    HashSetBase() : pTable(NULL)                       {   }
+    HashSetBase(int sizeHint) : pTable(NULL)           { SetCapacity(this, sizeHint);  }
+    HashSetBase(const SelfType& src) : pTable(NULL)    { Assign(this, src); }
+
+    ~HashSetBase()                                     
+    { 
+        if (pTable)
+        {
+            // Delete the entries.
+            for (size_t i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (!e->IsEmpty())             
+                    e->Free();
+            }            
+
+            Allocator::Free(pTable);
+            pTable = NULL;
+        }
+    }
+
+
+    void Assign(const SelfType& src)
+    {
+        Clear();
+        if (src.IsEmpty() == false)
+        {
+            SetCapacity(src.GetSize());
+
+            for (ConstIterator it = src.Begin(); it != src.End(); ++it)
+            {
+                Add(*it);
+            }
+        }
+    }
+
+
+    // Remove all entries from the HashSet table.
+    void Clear() 
+    {
+        if (pTable)
+        {
+            // Delete the entries.
+            for (size_t i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (!e->IsEmpty())             
+                    e->Clear();
+            }            
+                
+            Allocator::Free(pTable);
+            pTable = NULL;
+        }
+    }
+
+    // Returns true if the HashSet is empty.
+    bool IsEmpty() const
+    {
+        return pTable == NULL || pTable->EntryCount == 0;
+    }
+
+
+    // Set a new or existing value under the key, to the value.
+    // Pass a different class of 'key' so that assignment reference object
+    // can be passed instead of the actual object.
+    template<class CRef>
+    void Set(const CRef& key)
+    {
+        size_t hashValue = HashF()(key);
+        intptr_t  index     = (intptr_t)-1;
+
+        if (pTable != NULL)
+            index = findIndexCore(key, hashValue & pTable->SizeMask);
+
+        if (index >= 0)
+        {            
+            E(index).Value = key;
+        }
+        else
+        {
+            // Entry under key doesn't exist.
+            add(key, hashValue);
+        }
+    }
+
+    template<class CRef>
+    inline void Add(const CRef& key)
+    {
+        size_t hashValue = HashF()(key);
+        add(key, hashValue);
+    }
+
+    // Remove by alternative key.
+    template<class K>
+    void RemoveAlt(const K& key)
+    {   
+        if (pTable == NULL)
+            return;
+
+        size_t   hashValue = AltHashF()(key);
+        intptr_t index     = hashValue & pTable->SizeMask;
+
+        Entry*  e = &E(index);
+
+        // If empty node or occupied by collider, we have nothing to remove.
+        if (e->IsEmpty() || (e->GetCachedHash(pTable->SizeMask) != (size_t)index))
+            return;        
+
+        // Save index
+        intptr_t naturalIndex = index;
+        intptr_t prevIndex    = -1;
+
+        while ((e->GetCachedHash(pTable->SizeMask) != (size_t)naturalIndex) || !(e->Value == key))
+        {
+            // Keep looking through the chain.
+            prevIndex   = index;
+            index       = e->NextInChain;
+            if (index == -1)
+                return; // End of chain, item not found
+            e = &E(index);
+        }
+
+        // Found it - our item is at index
+        if (naturalIndex == index)
+        {
+            // If we have a follower, move it to us
+            if (!e->IsEndOfChain())
+            {               
+                Entry*  enext = &E(e->NextInChain);
+                e->Clear();
+                new (e) Entry(*enext);
+                // Point us to the follower's cell that will be cleared
+                e = enext;
+            }
+        }
+        else
+        {
+            // We are not at natural index, so deal with the prev items next index
+            E(prevIndex).NextInChain = e->NextInChain;
+        }
+
+        // Clear us, of the follower cell that was moved.
+        e->Clear();
+        pTable->EntryCount --;
+        // Should we check the size to condense hash? ...
+    }
+
+    // Remove by main key.
+    template<class CRef>
+    void Remove(const CRef& key)
+    {
+        RemoveAlt(key);
+    }
+
+    // Retrieve the pointer to a value under the given key.
+    //  - If there's no value under the key, then return NULL.    
+    //  - If there is a value, return the pointer.    
+    template<class K>
+    C* Get(const K& key)
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return &E(index).Value;        
+        return 0;
+    }   
+
+    template<class K>
+    const C* Get(const K& key) const
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return &E(index).Value;        
+        return 0;
+    }
+
+    // Alternative key versions of Get. Used by Hash.
+    template<class K>
+    const C* GetAlt(const K& key) const
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return &E(index).Value;
+        return 0;
+    }
+
+    template<class K>
+    C* GetAlt(const K& key)
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return &E(index).Value;
+        return 0;
+    }   
+
+    template<class K>
+    bool GetAlt(const K& key, C* pval) const
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)
+        {
+            if (pval)
+                *pval = E(index).Value;
+            return true;
+        }
+        return false;
+    }
+
+
+    size_t GetSize() const
+    {
+        return pTable == NULL ? 0 : (size_t)pTable->EntryCount;
+    }
+	int GetSizeI() const { return (int)GetSize(); }
+
+
+    // Resize the HashSet table to fit one more Entry.  Often this
+    // doesn't involve any action.
+    void CheckExpand()
+    {
+        if (pTable == NULL)
+        {
+            // Initial creation of table.  Make a minimum-sized table.
+            setRawCapacity(HashMinSize);
+        }
+        else if (pTable->EntryCount * 5 > (pTable->SizeMask + 1) * 4)
+        {
+            // pTable is more than 5/4 ths full.  Expand.
+            setRawCapacity((pTable->SizeMask + 1) * 2);
+        }
+    }
+
+    // Hint the bucket count to >= n.
+    void Resize(size_t n)    
+    {
+        // Not really sure what this means in relation to
+        // STLport's hash_map... they say they "increase the
+        // bucket count to at least n" -- but does that mean
+        // their real capacity after Resize(n) is more like
+        // n*2 (since they do linked-list chaining within
+        // buckets?).
+        SetCapacity(n);
+    }
+
+    // Size the HashSet so that it can comfortably contain the given
+    // number of elements.  If the HashSet already contains more
+    // elements than newSize, then this may be a no-op.
+    void SetCapacity(size_t newSize)
+    {
+        size_t newRawSize = (newSize * 5) / 4;
+        if (newRawSize <= GetSize())
+            return;
+        setRawCapacity(newRawSize);
+    }
+
+    // Disable inappropriate 'operator ->' warning on MSVC6.
+#ifdef OVR_CC_MSVC
+#if (OVR_CC_MSVC < 1300)
+# pragma warning(disable : 4284)
+#endif
+#endif
+
+    // Iterator API, like STL.
+    struct ConstIterator
+    {   
+        const C&    operator * () const
+        {            
+            OVR_ASSERT(Index >= 0 && Index <= (intptr_t)pHash->pTable->SizeMask);
+            return pHash->E(Index).Value;
+        }
+
+        const C*    operator -> () const
+        {
+            OVR_ASSERT(Index >= 0 && Index <= (intptr_t)pHash->pTable->SizeMask);
+            return &pHash->E(Index).Value;
+        }
+
+        void    operator ++ ()
+        {
+            // Find next non-empty Entry.
+            if (Index <= (intptr_t)pHash->pTable->SizeMask)
+            {
+                Index++;
+                while ((size_t)Index <= pHash->pTable->SizeMask &&
+                    pHash->E(Index).IsEmpty())
+                {
+                    Index++;
+                }
+            }
+        }
+
+        bool    operator == (const ConstIterator& it) const
+        {
+            if (IsEnd() && it.IsEnd())
+            {
+                return true;
+            }
+            else
+            {
+                return (pHash == it.pHash) && (Index == it.Index);
+            }
+        }
+
+        bool    operator != (const ConstIterator& it) const
+        {
+            return ! (*this == it);
+        }
+
+
+        bool    IsEnd() const
+        {
+            return (pHash == NULL) || 
+                (pHash->pTable == NULL) || 
+                (Index > (intptr_t)pHash->pTable->SizeMask);
+        }
+
+        ConstIterator()
+            : pHash(NULL), Index(0)
+        { }
+
+    public:
+        // Constructor was intentionally made public to allow create
+        // iterator with arbitrary index.
+        ConstIterator(const SelfType* h, intptr_t index)
+            : pHash(h), Index(index)
+        { }
+
+        const SelfType* GetContainer() const
+        {
+            return pHash;
+        }
+        intptr_t GetIndex() const
+        {
+            return Index;
+        }
+
+    protected:
+        friend class HashSetBase<C, HashF, AltHashF, Allocator, Entry>;
+
+        const SelfType* pHash;
+        intptr_t        Index;
+    };
+
+    friend struct ConstIterator;
+
+
+    // Non-const Iterator; Get most of it from ConstIterator.
+    struct Iterator : public ConstIterator
+    {      
+        // Allow non-const access to entries.
+        C&  operator*() const
+        {            
+            OVR_ASSERT(ConstIterator::Index >= 0 && ConstIterator::Index <= (intptr_t)ConstIterator::pHash->pTable->SizeMask);
+            return const_cast<SelfType*>(ConstIterator::pHash)->E(ConstIterator::Index).Value;
+        }    
+
+        C*  operator->() const 
+        {
+            return &(operator*());
+        }
+
+        Iterator()
+            : ConstIterator(NULL, 0)
+        { }
+
+        // Removes current element from Hash
+        void Remove()
+        {
+            RemoveAlt(operator*());
+        }
+
+        template <class K>
+        void RemoveAlt(const K& key)
+        {
+            SelfType*   phash = const_cast<SelfType*>(ConstIterator::pHash);
+            //Entry*      ee = &phash->E(ConstIterator::Index);
+            //const C&    key = ee->Value;
+
+            size_t      hashValue = AltHashF()(key);
+            intptr_t    index     = hashValue & phash->pTable->SizeMask;
+
+            Entry*      e = &phash->E(index);
+
+            // If empty node or occupied by collider, we have nothing to remove.
+            if (e->IsEmpty() || (e->GetCachedHash(phash->pTable->SizeMask) != (size_t)index))
+                return;        
+
+            // Save index
+            intptr_t   naturalIndex = index;
+            intptr_t   prevIndex    = -1;
+
+            while ((e->GetCachedHash(phash->pTable->SizeMask) != (size_t)naturalIndex) || !(e->Value == key))
+            {
+                // Keep looking through the chain.
+                prevIndex   = index;
+                index       = e->NextInChain;
+                if (index == -1)
+                    return; // End of chain, item not found
+                e = &phash->E(index);
+            }
+
+            if (index == (intptr_t)ConstIterator::Index)
+            {
+                // Found it - our item is at index
+                if (naturalIndex == index)
+                {
+                    // If we have a follower, move it to us
+                    if (!e->IsEndOfChain())
+                    {               
+                        Entry*  enext = &phash->E(e->NextInChain);
+                        e->Clear();
+                        new (e) Entry(*enext);
+                        // Point us to the follower's cell that will be cleared
+                        e = enext;
+                        --ConstIterator::Index;
+                    }
+                }
+                else
+                {
+                    // We are not at natural index, so deal with the prev items next index
+                    phash->E(prevIndex).NextInChain = e->NextInChain;
+                }
+
+                // Clear us, of the follower cell that was moved.
+                e->Clear();
+                phash->pTable->EntryCount --;
+            }
+            else 
+                OVR_ASSERT(0); //?
+        }
+
+    private:
+        friend class HashSetBase<C, HashF, AltHashF, Allocator, Entry>;
+
+        Iterator(SelfType* h, intptr_t i0)
+            : ConstIterator(h, i0)
+        { }
+    };
+
+    friend struct Iterator;
+
+    Iterator    Begin()
+    {
+        if (pTable == 0)
+            return Iterator(NULL, 0);
+
+        // Scan till we hit the First valid Entry.
+        size_t i0 = 0;
+        while (i0 <= pTable->SizeMask && E(i0).IsEmpty())
+        {
+            i0++;
+        }
+        return Iterator(this, i0);
+    }
+    Iterator        End()           { return Iterator(NULL, 0); }
+
+    ConstIterator   Begin() const   { return const_cast<SelfType*>(this)->Begin();     }
+    ConstIterator   End() const     { return const_cast<SelfType*>(this)->End();   }
+
+    template<class K>
+    Iterator Find(const K& key)
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return Iterator(this, index);        
+        return Iterator(NULL, 0);
+    }
+
+    template<class K>
+    Iterator FindAlt(const K& key)
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return Iterator(this, index);        
+        return Iterator(NULL, 0);
+    }
+
+    template<class K>
+    ConstIterator Find(const K& key) const       { return const_cast<SelfType*>(this)->Find(key); }
+
+    template<class K>
+    ConstIterator FindAlt(const K& key) const    { return const_cast<SelfType*>(this)->FindAlt(key); }
+
+private:
+    // Find the index of the matching Entry.  If no match, then return -1.
+    template<class K>
+    intptr_t findIndex(const K& key) const
+    {
+        if (pTable == NULL)
+            return -1;
+        size_t hashValue = HashF()(key) & pTable->SizeMask;
+        return findIndexCore(key, hashValue);
+    }
+
+    template<class K>
+    intptr_t findIndexAlt(const K& key) const
+    {
+        if (pTable == NULL)
+            return -1;
+        size_t hashValue = AltHashF()(key) & pTable->SizeMask;
+        return findIndexCore(key, hashValue);
+    }
+
+    // Find the index of the matching Entry.  If no match, then return -1.
+    template<class K>
+    intptr_t findIndexCore(const K& key, size_t hashValue) const
+    {
+        // Table must exist.
+        OVR_ASSERT(pTable != 0);
+        // Hash key must be 'and-ed' by the caller.
+        OVR_ASSERT((hashValue & ~pTable->SizeMask) == 0);
+
+        size_t          index = hashValue;
+        const Entry*    e     = &E(index);
+
+        // If empty or occupied by a collider, not found.
+        if (e->IsEmpty() || (e->GetCachedHash(pTable->SizeMask) != index))
+            return -1;
+
+        while(1)
+        {
+            OVR_ASSERT(e->GetCachedHash(pTable->SizeMask) == hashValue);
+
+            if (e->GetCachedHash(pTable->SizeMask) == hashValue && e->Value == key)
+            {
+                // Found it.
+                return index;
+            }
+            // Values can not be equal at this point.
+            // That would mean that the hash key for the same value differs.
+            OVR_ASSERT(!(e->Value == key));
+
+            // Keep looking through the chain.
+            index = e->NextInChain;
+            if (index == (size_t)-1)
+                break; // end of chain
+
+            e = &E(index);
+            OVR_ASSERT(!e->IsEmpty());
+        }
+        return -1;
+    }
+
+
+    // Add a new value to the HashSet table, under the specified key.
+    template<class CRef>
+    void add(const CRef& key, size_t hashValue)
+    {
+        CheckExpand();
+        hashValue &= pTable->SizeMask;
+
+        pTable->EntryCount++;
+
+        intptr_t   index        = hashValue;
+        Entry*  naturalEntry = &(E(index));
+
+        if (naturalEntry->IsEmpty())
+        {
+            // Put the new Entry in.
+            new (naturalEntry) Entry(key, -1);
+        }
+        else
+        {
+            // Find a blank spot.
+            intptr_t blankIndex = index;
+            do {
+                blankIndex = (blankIndex + 1) & pTable->SizeMask;
+            } while(!E(blankIndex).IsEmpty());
+
+            Entry*  blankEntry = &E(blankIndex);
+
+            if (naturalEntry->GetCachedHash(pTable->SizeMask) == (size_t)index)
+            {
+                // Collision.  Link into this chain.
+
+                // Move existing list head.
+                new (blankEntry) Entry(*naturalEntry);    // placement new, copy ctor
+
+                // Put the new info in the natural Entry.
+                naturalEntry->Value       = key;
+                naturalEntry->NextInChain = blankIndex;
+            }
+            else
+            {
+                // Existing Entry does not naturally
+                // belong in this slot.  Existing
+                // Entry must be moved.
+
+                // Find natural location of collided element (i.e. root of chain)
+                intptr_t collidedIndex = naturalEntry->GetCachedHash(pTable->SizeMask);
+                OVR_ASSERT(collidedIndex >= 0 && collidedIndex <= (intptr_t)pTable->SizeMask);
+                for (;;)
+                {
+                    Entry*  e = &E(collidedIndex);
+                    if (e->NextInChain == index)
+                    {
+                        // Here's where we need to splice.
+                        new (blankEntry) Entry(*naturalEntry);
+                        e->NextInChain = blankIndex;
+                        break;
+                    }
+                    collidedIndex = e->NextInChain;
+                    OVR_ASSERT(collidedIndex >= 0 && collidedIndex <= (intptr_t)pTable->SizeMask);
+                }
+
+                // Put the new data in the natural Entry.
+                naturalEntry->Value       = key;
+                naturalEntry->NextInChain = -1;                
+            }            
+        }
+
+        // Record hash value: has effect only if cached node is used.
+        naturalEntry->SetCachedHash(hashValue);
+    }
+
+    // Index access helpers.
+    Entry& E(size_t index)
+    {
+        // Must have pTable and access needs to be within bounds.
+        OVR_ASSERT(index <= pTable->SizeMask);
+        return *(((Entry*) (pTable + 1)) + index);
+    }
+    const Entry& E(size_t index) const
+    {        
+        OVR_ASSERT(index <= pTable->SizeMask);
+        return *(((Entry*) (pTable + 1)) + index);
+    }
+
+
+    // Resize the HashSet table to the given size (Rehash the
+    // contents of the current table).  The arg is the number of
+    // HashSet table entries, not the number of elements we should
+    // actually contain (which will be less than this).
+    void    setRawCapacity(size_t newSize)    
+    {
+        if (newSize == 0)
+        {
+            // Special case.
+            Clear();
+            return;
+        }
+
+        // Minimum size; don't incur rehashing cost when expanding
+        // very small tables. Not that we perform this check before 
+        // 'log2f' call to avoid fp exception with newSize == 1.
+        if (newSize < HashMinSize)        
+            newSize = HashMinSize;       
+        else
+        {
+            // Force newSize to be a power of two.
+            int bits = Alg::UpperBit(newSize-1) + 1; // Chop( Log2f((float)(newSize-1)) + 1);
+            OVR_ASSERT((size_t(1) << bits) >= newSize);
+            newSize = size_t(1) << bits;
+        }
+
+        SelfType  newHash;
+        newHash.pTable = (TableType*)
+            Allocator::Alloc(                
+                sizeof(TableType) + sizeof(Entry) * newSize);
+        // Need to do something on alloc failure!
+        OVR_ASSERT(newHash.pTable);
+
+        newHash.pTable->EntryCount = 0;
+        newHash.pTable->SizeMask = newSize - 1;
+        size_t i, n;
+
+        // Mark all entries as empty.
+        for (i = 0; i < newSize; i++)
+            newHash.E(i).NextInChain = -2;
+
+        // Copy stuff to newHash
+        if (pTable)
+        {            
+            for (i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (e->IsEmpty() == false)
+                {
+                    // Insert old Entry into new HashSet.
+                    newHash.Add(e->Value);
+                    // placement delete of old element
+                    e->Clear();
+                }
+            }
+
+            // Delete our old data buffer.
+            Allocator::Free(pTable);
+        }
+
+        // Steal newHash's data.
+        pTable = newHash.pTable;
+        newHash.pTable = NULL;
+    }
+
+    struct TableType
+    {
+        size_t EntryCount;
+        size_t SizeMask;
+        // Entry array follows this structure
+        // in memory.
+    };
+    TableType*  pTable;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+template<class C, class HashF = FixedSizeHash<C>,
+         class AltHashF = HashF, 
+         class Allocator = ContainerAllocator<C>,
+         class Entry = HashsetCachedEntry<C, HashF> >
+class HashSet : public HashSetBase<C, HashF, AltHashF, Allocator, Entry>
+{
+public:
+    typedef HashSetBase<C, HashF, AltHashF, Allocator, Entry> BaseType;
+    typedef HashSet<C, HashF, AltHashF, Allocator, Entry>     SelfType;
+
+    HashSet()                                      {   }
+    HashSet(int sizeHint) : BaseType(sizeHint)     {   }
+    HashSet(const SelfType& src) : BaseType(src)   {   }
+    ~HashSet()                                     {   }
+
+    void operator = (const SelfType& src)   { BaseType::Assign(src); }
+
+    // Set a new or existing value under the key, to the value.
+    // Pass a different class of 'key' so that assignment reference object
+    // can be passed instead of the actual object.
+    template<class CRef>
+    void Set(const CRef& key)
+    {
+        BaseType::Set(key);
+    }
+
+    template<class CRef>
+    inline void Add(const CRef& key)
+    {
+        BaseType::Add(key);
+    }
+
+    // Hint the bucket count to >= n.
+    void Resize(size_t n)    
+    {
+        BaseType::SetCapacity(n);
+    }
+
+    // Size the HashSet so that it can comfortably contain the given
+    // number of elements.  If the HashSet already contains more
+    // elements than newSize, then this may be a no-op.
+    void SetCapacity(size_t newSize)
+    {
+        BaseType::SetCapacity(newSize);
+    }
+
+};
+
+// HashSet with uncached hash code; declared for convenience.
+template<class C, class HashF = FixedSizeHash<C>,
+                  class AltHashF = HashF,
+                  class Allocator = ContainerAllocator<C> >
+class HashSetUncached : public HashSet<C, HashF, AltHashF, Allocator, HashsetEntry<C, HashF> >
+{
+public:
+    
+    typedef HashSetUncached<C, HashF, AltHashF, Allocator>                  SelfType;
+    typedef HashSet<C, HashF, AltHashF, Allocator, HashsetEntry<C, HashF> > BaseType;
+
+    // Delegated constructors.
+    HashSetUncached()                                        { }
+    HashSetUncached(int sizeHint) : BaseType(sizeHint)       { }
+    HashSetUncached(const SelfType& src) : BaseType(src)     { }
+    ~HashSetUncached()                                       { }
+    
+    void    operator = (const SelfType& src)
+    {
+        BaseType::operator = (src);
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Hash hash table implementation
+
+// Node for Hash - necessary so that Hash can delegate its implementation
+// to HashSet.
+template<class C, class U, class HashF>
+struct HashNode
+{
+    typedef HashNode<C, U, HashF>   SelfType;
+    typedef C                       FirstType;
+    typedef U                       SecondType;
+
+    C   First;
+    U   Second;
+
+    // NodeRef is used to allow passing of elements into HashSet
+    // without using a temporary object.
+    struct NodeRef
+    {
+        const C*   pFirst;
+        const U*   pSecond;
+
+        NodeRef(const C& f, const U& s) : pFirst(&f), pSecond(&s) { }
+        NodeRef(const NodeRef& src)     : pFirst(src.pFirst), pSecond(src.pSecond) { }
+
+        // Enable computation of ghash_node_hashf.
+        inline size_t GetHash() const            { return HashF()(*pFirst); } 
+        // Necessary conversion to allow HashNode::operator == to work.
+        operator const C& () const              { return *pFirst; }
+    };
+
+    // Note: No default constructor is necessary.
+     HashNode(const HashNode& src) : First(src.First), Second(src.Second)    { }
+     HashNode(const NodeRef& src) : First(*src.pFirst), Second(*src.pSecond)  { }
+    void operator = (const NodeRef& src)  { First  = *src.pFirst; Second = *src.pSecond; }
+
+    template<class K>
+    bool operator == (const K& src) const   { return (First == src); }
+
+    template<class K>
+    static size_t CalcHash(const K& data)   { return HashF()(data); }
+    inline size_t GetHash() const           { return HashF()(First); }
+
+    // Hash functors used with this node. A separate functor is used for alternative
+    // key lookup so that it does not need to access the '.First' element.    
+    struct NodeHashF
+    {    
+        template<class K>
+        size_t operator()(const K& data) const { return data.GetHash(); } 
+    };    
+    struct NodeAltHashF
+    {
+        template<class K>
+        size_t operator()(const K& data) const { return HashNode<C,U,HashF>::CalcHash(data); }
+    };
+};
+
+
+
+// **** Extra hashset_entry types to allow NodeRef construction.
+
+// The big difference between the below types and the ones used in hash_set is that
+// these allow initializing the node with 'typename C::NodeRef& keyRef', which
+// is critical to avoid temporary node allocation on stack when using placement new.
+
+// Compact hash table Entry type that re-computes hash keys during hash traversal.
+// Good to use if the hash function is cheap or the hash value is already cached in C.
+template<class C, class HashF>
+class HashsetNodeEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t NextInChain;
+    C     Value;
+
+    HashsetNodeEntry()
+        : NextInChain(-2) { }
+    HashsetNodeEntry(const HashsetNodeEntry& e)
+        : NextInChain(e.NextInChain), Value(e.Value) { }
+    HashsetNodeEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }    
+    HashsetNodeEntry(const typename C::NodeRef& keyRef, intptr_t next)
+        : NextInChain(next), Value(keyRef) { }
+
+    bool    IsEmpty() const             { return NextInChain == -2;  }
+    bool    IsEndOfChain() const        { return NextInChain == -1;  }
+    size_t  GetCachedHash(size_t maskValue) const  { return HashF()(Value) & maskValue; }
+    void    SetCachedHash(size_t hashValue)        { OVR_UNUSED(hashValue); }
+
+    void    Clear()
+    {        
+        Value.~C(); // placement delete
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+// Hash table Entry type that caches the Entry hash value for nodes, so that it
+// does not need to be re-computed during access.
+template<class C, class HashF>
+class HashsetCachedNodeEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t NextInChain;
+    size_t HashValue;
+    C     Value;
+
+    HashsetCachedNodeEntry()
+        : NextInChain(-2) { }
+    HashsetCachedNodeEntry(const HashsetCachedNodeEntry& e)
+        : NextInChain(e.NextInChain), HashValue(e.HashValue), Value(e.Value) { }
+    HashsetCachedNodeEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+    HashsetCachedNodeEntry(const typename C::NodeRef& keyRef, intptr_t next)
+        : NextInChain(next), Value(keyRef) { }
+
+    bool    IsEmpty() const            { return NextInChain == -2;  }
+    bool    IsEndOfChain() const       { return NextInChain == -1;  }
+    size_t  GetCachedHash(size_t maskValue) const  { OVR_UNUSED(maskValue); return HashValue; }
+    void    SetCachedHash(size_t hashValue)        { HashValue = hashValue; }
+
+    void    Clear()
+    {
+        Value.~C();
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+
+//-----------------------------------------------------------------------------------
+template<class C, class U,
+         class HashF = FixedSizeHash<C>,
+         class Allocator = ContainerAllocator<C>,
+         class HashNode = OVR::HashNode<C,U,HashF>,
+         class Entry = HashsetCachedNodeEntry<HashNode, typename HashNode::NodeHashF>,
+         class Container =  HashSet<HashNode, typename HashNode::NodeHashF,
+             typename HashNode::NodeAltHashF, Allocator,
+             Entry> >
+class Hash
+{
+public:
+    OVR_MEMORY_REDEFINE_NEW(Hash)
+
+    // Types used for hash_set.
+    typedef U                                                           ValueType;
+    typedef Hash<C, U, HashF, Allocator, HashNode, Entry, Container>    SelfType;
+
+    // Actual hash table itself, implemented as hash_set.
+    Container   mHash;
+
+public:
+    Hash()     {  }
+    Hash(int sizeHint) : mHash(sizeHint)                        { }
+    Hash(const SelfType& src) : mHash(src.mHash)                { }
+    ~Hash()                                                     { }
+
+    void    operator = (const SelfType& src)    { mHash = src.mHash; }
+
+    // Remove all entries from the Hash table.
+    inline void    Clear() { mHash.Clear(); }
+    // Returns true if the Hash is empty.
+    inline bool    IsEmpty() const { return mHash.IsEmpty(); }
+
+    // Access (set).
+    inline void    Set(const C& key, const U& value)
+    {
+        typename HashNode::NodeRef e(key, value);
+        mHash.Set(e);
+    }
+    inline void    Add(const C& key, const U& value)
+    {
+        typename HashNode::NodeRef e(key, value);
+        mHash.Add(e);
+    }
+
+    // Removes an element by clearing its Entry.
+    inline void     Remove(const C& key)
+    {   
+        mHash.RemoveAlt(key);
+    }
+    template<class K>
+    inline void     RemoveAlt(const K& key)
+    {   
+        mHash.RemoveAlt(key);
+    }
+
+    // Retrieve the value under the given key.    
+    //  - If there's no value under the key, then return false and leave *pvalue alone.
+    //  - If there is a value, return true, and Set *Pvalue to the Entry's value.
+    //  - If value == NULL, return true or false according to the presence of the key.    
+    bool    Get(const C& key, U* pvalue) const   
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        if (p)
+        {
+            if (pvalue)
+                *pvalue = p->Second;
+            return true;
+        }
+        return false;
+    }
+
+    template<class K>
+    bool    GetAlt(const K& key, U* pvalue) const   
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        if (p)
+        {
+            if (pvalue)
+                *pvalue = p->Second;
+            return true;
+        }
+        return false;
+    }
+
+    // Retrieve the pointer to a value under the given key.    
+    //  - If there's no value under the key, then return NULL.    
+    //  - If there is a value, return the pointer.    
+    inline U*  Get(const C& key)
+    {
+        HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+    inline const U* Get(const C& key) const
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+
+    template<class K>
+    inline U*  GetAlt(const K& key)
+    {
+        HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+    template<class K>
+    inline const U* GetAlt(const K& key) const
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+
+    // Sizing methods - delegate to Hash.
+    inline size_t  GetSize() const              { return mHash.GetSize(); }    
+	inline int     GetSizeI() const             { return (int)GetSize(); }
+	inline void    Resize(size_t n)              { mHash.Resize(n); }
+    inline void    SetCapacity(size_t newSize)   { mHash.SetCapacity(newSize); }
+
+    // Iterator API, like STL.
+    typedef typename Container::ConstIterator   ConstIterator;
+    typedef typename Container::Iterator        Iterator;
+
+    inline Iterator        Begin()              { return mHash.Begin(); }
+    inline Iterator        End()                { return mHash.End(); }
+    inline ConstIterator   Begin() const        { return mHash.Begin(); }
+    inline ConstIterator   End() const          { return mHash.End();   }
+
+    Iterator        Find(const C& key)          { return mHash.FindAlt(key);  }
+    ConstIterator   Find(const C& key) const    { return mHash.FindAlt(key);  }
+
+    template<class K>
+    Iterator        FindAlt(const K& key)       { return mHash.FindAlt(key);  }
+    template<class K>
+    ConstIterator   FindAlt(const K& key) const { return mHash.FindAlt(key);  }
+};
+
+
+
+// Hash with uncached hash code; declared for convenience.
+template<class C, class U, class HashF = FixedSizeHash<C>, class Allocator = ContainerAllocator<C> >
+class HashUncached
+    : public Hash<C, U, HashF, Allocator, HashNode<C,U,HashF>,
+                   HashsetNodeEntry<HashNode<C,U,HashF>, typename HashNode<C,U,HashF>::NodeHashF> >
+{
+public:
+    typedef HashUncached<C, U, HashF, Allocator>                SelfType;
+    typedef Hash<C, U, HashF, Allocator, HashNode<C,U,HashF>,
+                 HashsetNodeEntry<HashNode<C,U,HashF>,
+                 typename HashNode<C,U,HashF>::NodeHashF> >     BaseType;
+
+    // Delegated constructors.
+    HashUncached()                                        { }
+    HashUncached(int sizeHint) : BaseType(sizeHint)       { }
+    HashUncached(const SelfType& src) : BaseType(src)     { }
+    ~HashUncached()                                       { }
+    void operator = (const SelfType& src)                 { BaseType::operator = (src); }
+};
+
+
+
+// And identity hash in which keys serve as hash value. Can be uncached,
+// since hash computation is assumed cheap.
+template<class C, class U, class Allocator = ContainerAllocator<C>, class HashF = IdentityHash<C> >
+class HashIdentity
+    : public HashUncached<C, U, HashF, Allocator>
+{
+public:
+    typedef HashIdentity<C, U, Allocator, HashF> SelfType;
+    typedef HashUncached<C, U, HashF, Allocator> BaseType;
+
+    // Delegated constructors.
+    HashIdentity()                                        { }
+    HashIdentity(int sizeHint) : BaseType(sizeHint)       { }
+    HashIdentity(const SelfType& src) : BaseType(src)     { }
+    ~HashIdentity()                                       { }
+    void operator = (const SelfType& src)                 { BaseType::operator = (src); }
+};
+
+
+} // OVR
+
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_KeyCodes.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_KeyCodes.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,251 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_KeyCodes.h
+Content     :   Common keyboard constants
+Created     :   September 19, 2012
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_KeyCodes_h
+#define OVR_KeyCodes_h
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** KeyCode
+
+// KeyCode enumeration defines platform-independent keyboard key constants.
+// Note that Key_A through Key_Z are mapped to capital ascii constants.
+
+enum KeyCode
+{
+    // Key_None indicates that no key was specified.
+    Key_None            = 0, 
+
+    // A through Z and numbers 0 through 9.
+    Key_A               = 65,
+    Key_B,
+    Key_C,
+    Key_D,
+    Key_E,
+    Key_F,
+    Key_G,
+    Key_H,
+    Key_I,
+    Key_J,
+    Key_K,
+    Key_L,
+    Key_M,
+    Key_N,
+    Key_O,
+    Key_P,
+    Key_Q,
+    Key_R,
+    Key_S,
+    Key_T,
+    Key_U,
+    Key_V,
+    Key_W,
+    Key_X,
+    Key_Y,
+    Key_Z,
+    Key_Num0            = 48,
+    Key_Num1,
+    Key_Num2,
+    Key_Num3,
+    Key_Num4,
+    Key_Num5,
+    Key_Num6,
+    Key_Num7,
+    Key_Num8,
+    Key_Num9,
+
+    // Numeric keypad.
+    Key_KP_0            = 0xa0,
+    Key_KP_1,
+    Key_KP_2,
+    Key_KP_3,
+    Key_KP_4,
+    Key_KP_5,
+    Key_KP_6,
+    Key_KP_7,
+    Key_KP_8,
+    Key_KP_9,
+    Key_KP_Multiply,
+    Key_KP_Add,
+    Key_KP_Enter,
+    Key_KP_Subtract,
+    Key_KP_Decimal,
+    Key_KP_Divide,
+    
+    // Function keys.
+    Key_F1              = 0xb0,
+    Key_F2,
+    Key_F3,
+    Key_F4,
+    Key_F5,
+    Key_F6,
+    Key_F7,
+    Key_F8,
+    Key_F9,
+    Key_F10,
+    Key_F11,
+    Key_F12,
+    Key_F13,
+    Key_F14,
+    Key_F15,
+    
+    // Other keys.
+    Key_Backspace       = 8,
+    Key_Tab,
+    Key_Clear           = 12,
+    Key_Return,
+    Key_Shift           = 16,
+    Key_Control,
+    Key_Alt,
+    Key_Pause,
+    Key_CapsLock        = 20, // Toggle
+    Key_Escape          = 27,
+    Key_Space           = 32,
+    Key_Quote           = 39,
+    Key_PageUp          = 0xc0,
+    Key_PageDown,
+    Key_End,
+    Key_Home,
+    Key_Left,
+    Key_Up,
+    Key_Right,
+    Key_Down,
+    Key_Insert,
+    Key_Delete,
+    Key_Help,
+    
+    Key_Comma           = 44,
+    Key_Minus,
+    Key_Slash           = 47,
+    Key_Period,
+    Key_NumLock         = 144, // Toggle
+    Key_ScrollLock      = 145, // Toggle
+    
+    Key_Semicolon       = 59,
+    Key_Equal           = 61,
+    Key_Backtick        = 96,   // ` and tilda~ when shifted (US keyboard)
+    Key_BracketLeft     = 91,
+    Key_Backslash,
+    Key_BracketRight,
+
+    Key_OEM_AX          = 0xE1,  //  'AX' key on Japanese AX keyboard
+    Key_OEM_102         = 0xE2,  //  "<>" or "\|" on RT 102-key keyboard.
+    Key_ICO_HELP        = 0xE3,  //  Help key on ICO
+    Key_ICO_00          = 0xE4,  //  00 key on ICO
+
+    Key_Meta,
+
+    // Total number of keys.
+    Key_CodeCount
+};
+
+
+//-----------------------------------------------------------------------------------
+
+class KeyModifiers 
+{
+public:
+    enum
+    {
+        Key_ShiftPressed    = 0x01,
+        Key_CtrlPressed     = 0x02,
+        Key_AltPressed      = 0x04,
+        Key_MetaPressed     = 0x08,
+        Key_CapsToggled     = 0x10,
+        Key_NumToggled      = 0x20,
+        Key_ScrollToggled   = 0x40,
+
+        Initialized_Bit     = 0x80,
+        Initialized_Mask    = 0xFF
+    };
+    unsigned char States;
+
+    KeyModifiers() : States(0) { }
+        KeyModifiers(unsigned char st) : States((unsigned char)(st | Initialized_Bit)) { }
+
+    void Reset() { States = 0; }
+
+    bool IsShiftPressed() const { return (States & Key_ShiftPressed) != 0; }
+    bool IsCtrlPressed() const  { return (States & Key_CtrlPressed) != 0; }
+    bool IsAltPressed() const   { return (States & Key_AltPressed) != 0; }
+    bool IsMetaPressed() const  { return (States & Key_MetaPressed) != 0; }
+    bool IsCapsToggled() const  { return (States & Key_CapsToggled) != 0; }
+    bool IsNumToggled() const   { return (States & Key_NumToggled) != 0; }
+    bool IsScrollToggled() const{ return (States & Key_ScrollToggled) != 0; }
+
+    void SetShiftPressed(bool v = true)  { (v) ? States |= Key_ShiftPressed : States &= ~Key_ShiftPressed; }
+    void SetCtrlPressed(bool v = true)   { (v) ? States |= Key_CtrlPressed  : States &= ~Key_CtrlPressed; }
+    void SetAltPressed(bool v = true)    { (v) ? States |= Key_AltPressed   : States &= ~Key_AltPressed; }
+    void SetMetaPressed(bool v = true)   { (v) ? States |= Key_MetaPressed  : States &= ~Key_MetaPressed; }
+    void SetCapsToggled(bool v = true)   { (v) ? States |= Key_CapsToggled  : States &= ~Key_CapsToggled; }
+    void SetNumToggled(bool v = true)    { (v) ? States |= Key_NumToggled   : States &= ~Key_NumToggled; }
+    void SetScrollToggled(bool v = true) { (v) ? States |= Key_ScrollToggled: States &= ~Key_ScrollToggled; }
+
+    bool IsInitialized() const { return (States & Initialized_Mask) != 0; }
+};
+
+
+//-----------------------------------------------------------------------------------
+
+/*
+enum PadKeyCode
+{
+    Pad_None, // Indicates absence of key code.
+    Pad_Back,
+    Pad_Start,
+    Pad_A,
+    Pad_B,
+    Pad_X,
+    Pad_Y,
+    Pad_R1,  // RightShoulder;
+    Pad_L1,  // LeftShoulder;
+    Pad_R2,  // RightTrigger;
+    Pad_L2,  // LeftTrigger;
+    Pad_Up,
+    Pad_Down,
+    Pad_Right,
+    Pad_Left,
+    Pad_Plus,
+    Pad_Minus,
+    Pad_1,
+    Pad_2,
+    Pad_H,
+    Pad_C,
+    Pad_Z,
+    Pad_O,
+    Pad_T,
+    Pad_S,
+    Pad_Select,
+    Pad_Home,
+    Pad_RT,  // RightThumb;
+    Pad_LT   // LeftThumb;
+};
+*/
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_List.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_List.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,336 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_List.h
+Content     :   Template implementation for doubly-connected linked List
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_List_h
+#define OVR_List_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** ListNode
+//
+// Base class for the elements of the intrusive linked list.
+// To store elements in the List do:
+//
+// struct MyData : ListNode<MyData>
+// {
+//     . . .
+// };
+
+template<class T>
+struct ListNode
+{
+    union {
+        T*    pPrev;
+        void* pVoidPrev;
+    };
+    union {
+        T*    pNext;
+        void* pVoidNext;
+    };
+
+    void    RemoveNode()
+    {
+        pPrev->pNext = pNext;
+        pNext->pPrev = pPrev;
+    }
+
+    // Removes us from the list and inserts pnew there instead.
+    void    ReplaceNodeWith(T* pnew)
+    {
+        pPrev->pNext = pnew;
+        pNext->pPrev = pnew;
+        pnew->pPrev = pPrev;
+        pnew->pNext = pNext;
+    }
+       
+    // Inserts the argument linked list node after us in the list.
+    void    InsertNodeAfter(T* p)
+    {
+        p->pPrev          = pNext->pPrev; // this
+        p->pNext          = pNext;
+        pNext->pPrev      = p;
+        pNext             = p;
+    }
+    // Inserts the argument linked list node before us in the list.
+    void    InsertNodeBefore(T* p)
+    {
+        p->pNext          = pNext->pPrev; // this
+        p->pPrev          = pPrev;
+        pPrev->pNext      = p;
+        pPrev             = p;
+    }
+
+    void    Alloc_MoveTo(ListNode<T>* pdest)
+    {
+        pdest->pNext = pNext;
+        pdest->pPrev = pPrev;
+        pPrev->pNext = (T*)pdest;
+        pNext->pPrev = (T*)pdest;
+    }
+};
+
+
+//------------------------------------------------------------------------
+// ***** List
+//
+// Doubly linked intrusive list. 
+// The data type must be derived from ListNode.
+// 
+// Adding:   PushFront(), PushBack().
+// Removing: Remove() - the element must be in the list!
+// Moving:   BringToFront(), SendToBack() - the element must be in the list!
+//
+// Iterating:
+//    MyData* data = MyList.GetFirst();
+//    while (!MyList.IsNull(data))
+//    {
+//        . . .
+//        data = MyList.GetNext(data);
+//    }
+//
+// Removing:
+//    MyData* data = MyList.GetFirst();
+//    while (!MyList.IsNull(data))
+//    {
+//        MyData* next = MyList.GetNext(data);
+//        if (ToBeRemoved(data))
+//             MyList.Remove(data);
+//        data = next;
+//    }
+//
+
+// List<> represents a doubly-linked list of T, where each T must derive
+// from ListNode<B>. B specifies the base class that was directly
+// derived from ListNode, and is only necessary if there is an intermediate
+// inheritance chain.
+
+template<class T, class B = T> class List
+{
+public:
+    typedef T ValueType;
+
+    List()
+    {
+        Root.pNext = Root.pPrev = (ValueType*)&Root;
+    }
+
+    void Clear()
+    {
+        Root.pNext = Root.pPrev = (ValueType*)&Root;
+    }
+
+    const ValueType* GetFirst() const { return (const ValueType*)Root.pNext; }
+    const ValueType* GetLast () const { return (const ValueType*)Root.pPrev; }
+          ValueType* GetFirst()       { return (ValueType*)Root.pNext; }
+          ValueType* GetLast ()       { return (ValueType*)Root.pPrev; }
+
+    // Determine if list is empty (i.e.) points to itself.
+    // Go through void* access to avoid issues with strict-aliasing optimizing out the
+    // access after RemoveNode(), etc.
+    bool IsEmpty()                   const { return Root.pVoidNext == (const T*)(const B*)&Root; }
+    bool IsFirst(const ValueType* p) const { return p == Root.pNext; }
+    bool IsLast (const ValueType* p) const { return p == Root.pPrev; }
+    bool IsNull (const ValueType* p) const { return p == (const T*)(const B*)&Root; }
+
+    inline static const ValueType* GetPrev(const ValueType* p) { return (const ValueType*)p->pPrev; }
+    inline static const ValueType* GetNext(const ValueType* p) { return (const ValueType*)p->pNext; }
+    inline static       ValueType* GetPrev(      ValueType* p) { return (ValueType*)p->pPrev; }
+    inline static       ValueType* GetNext(      ValueType* p) { return (ValueType*)p->pNext; }
+
+    void PushFront(ValueType* p)
+    {
+        p->pNext          =  Root.pNext;
+        p->pPrev          = (ValueType*)&Root;
+        Root.pNext->pPrev =  p;
+        Root.pNext        =  p;
+    }
+
+    void PushBack(ValueType* p)
+    {
+        p->pPrev          =  Root.pPrev;
+        p->pNext          = (ValueType*)&Root;
+        Root.pPrev->pNext =  p;
+        Root.pPrev        =  p;
+    }
+
+    static void Remove(ValueType* p)
+    {
+        p->pPrev->pNext = p->pNext;
+        p->pNext->pPrev = p->pPrev;
+    }
+
+    void BringToFront(ValueType* p)
+    {
+        Remove(p);
+        PushFront(p);
+    }
+
+    void SendToBack(ValueType* p)
+    {
+        Remove(p);
+        PushBack(p);
+    }
+
+    // Appends the contents of the argument list to the front of this list;
+    // items are removed from the argument list.
+    void PushListToFront(List<T>& src)
+    {
+        if (!src.IsEmpty())
+        {
+            ValueType* pfirst = src.GetFirst();
+            ValueType* plast  = src.GetLast();
+            src.Clear();
+            plast->pNext   = Root.pNext;
+            pfirst->pPrev  = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+    void PushListToBack(List<T>& src)
+    {
+        if (!src.IsEmpty())
+        {
+            ValueType* pfirst = src.GetFirst();
+            ValueType* plast  = src.GetLast();
+            src.Clear();
+            plast->pNext   = (ValueType*)&Root;
+            pfirst->pPrev  = Root.pPrev;
+            Root.pPrev->pNext = pfirst;
+            Root.pPrev        = plast;
+        }
+    }
+
+    // Removes all source list items after (and including) the 'pfirst' node from the 
+    // source list and adds them to out list.
+    void    PushFollowingListItemsToFront(List<T>& src, ValueType *pfirst)
+    {
+        if (pfirst != &src.Root)
+        {
+            ValueType *plast = src.Root.pPrev;
+
+            // Remove list remainder from source.
+            pfirst->pPrev->pNext = (ValueType*)&src.Root;
+            src.Root.pPrev      = pfirst->pPrev;
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+    // Removes all source list items up to but NOT including the 'pend' node from the 
+    // source list and adds them to out list.
+    void    PushPrecedingListItemsToFront(List<T>& src, ValueType *ptail)
+    {
+        if (src.GetFirst() != ptail)
+        {
+            ValueType *pfirst = src.Root.pNext;
+            ValueType *plast  = ptail->pPrev;
+
+            // Remove list remainder from source.
+            ptail->pPrev      = (ValueType*)&src.Root;
+            src.Root.pNext    = ptail;            
+
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+
+    // Removes a range of source list items starting at 'pfirst' and up to, but not including 'pend',
+    // and adds them to out list. Note that source items MUST already be in the list.
+    void    PushListItemsToFront(ValueType *pfirst, ValueType *pend)
+    {
+        if (pfirst != pend)
+        {
+            ValueType *plast = pend->pPrev;
+
+            // Remove list remainder from source.
+            pfirst->pPrev->pNext = pend;
+            pend->pPrev          = pfirst->pPrev;
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+
+    void    Alloc_MoveTo(List<T>* pdest)
+    {
+        if (IsEmpty())
+            pdest->Clear();
+        else
+        {
+            pdest->Root.pNext = Root.pNext;
+            pdest->Root.pPrev = Root.pPrev;
+
+            Root.pNext->pPrev = (ValueType*)&pdest->Root;
+            Root.pPrev->pNext = (ValueType*)&pdest->Root;
+        }        
+    }
+
+
+private:
+    // Copying is prohibited
+    List(const List<T>&);
+    const List<T>& operator = (const List<T>&);
+
+    ListNode<B> Root;
+};
+
+
+//------------------------------------------------------------------------
+// ***** FreeListElements
+//
+// Remove all elements in the list and free them in the allocator
+
+template<class List, class Allocator>
+void FreeListElements(List& list, Allocator& allocator)
+{
+    typename List::ValueType* self = list.GetFirst();
+    while(!list.IsNull(self))
+    {
+        typename List::ValueType* next = list.GetNext(self);
+        allocator.Free(self);
+        self = next;
+    }
+    list.Clear();
+}
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,228 @@
+/************************************************************************************
+
+Filename    :   OVR_Lockless.cpp
+Content     :   Test logic for lock-less classes
+Created     :   December 27, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "OVR_Lockless.h"
+
+#ifdef OVR_LOCKLESS_TEST
+
+#include "OVR_Threads.h"
+#include "OVR_Timer.h"
+#include "OVR_Log.h"
+
+namespace OVR { namespace LocklessTest {
+
+
+const int TestIterations = 10000000;
+
+// Use volatile dummys to force compiler to do spinning.
+volatile int Dummy1;
+int          Unused1[32];
+volatile int Dummy2;
+int          Unused2[32];
+volatile int Dummy3;
+int          Unused3[32];
+
+
+// Data block out of 20 consecutive integers, should be internally consistent.
+struct TestData
+{
+    enum { ItemCount = 20 };
+
+    int Data[ItemCount];
+
+
+    void Set(int val)
+    {
+        for (int i=0; i<ItemCount; i++)
+        {
+            Data[i] = val*100 + i;
+        }
+    }
+
+    int ReadAndCheckConsistency(int prevValue) const
+    {
+        int val = Data[0];
+
+        for (int i=1; i<ItemCount; i++)
+        {
+            
+            if (Data[i] != (val + i))
+            {
+                // Only complain once per same-value entry
+                if (prevValue != val / 100) 
+                {
+                    LogText("LocklessTest Fail - corruption at %d inside block %d\n",
+                            i, val/100);
+                    // OVR_ASSERT(Data[i] == val + i);
+                }
+                break;
+            }
+        }
+
+        return val / 100;
+    }
+};
+
+
+
+volatile bool              FirstItemWritten = false;
+LocklessUpdater<TestData>  TestDataUpdater;
+
+// Use this lock to verify that testing algorithm is otherwise correct...
+Lock                       TestLock;   
+
+
+//-------------------------------------------------------------------------------------
+
+// Consumer thread reads values from TestDataUpdater and
+// ensures that each one is internally consistent.
+
+class Consumer : public Thread
+{
+    virtual int Run()
+    {
+        LogText("LocklessTest::Consumer::Run started.\n");
+        
+        while (!FirstItemWritten)
+        {
+            // spin until producer wrote first value...
+        }
+
+        TestData d;
+        int      oldValue = 0;
+        int      newValue;
+
+        do 
+        {
+            {
+                //Lock::Locker scope(&TestLock);
+                d = TestDataUpdater.GetState();
+            }
+            
+            newValue = d.ReadAndCheckConsistency(oldValue);
+            
+            // Values should increase or stay the same!
+            if (newValue < oldValue)
+            {
+                LogText("LocklessTest Fail - %d after %d;  delta = %d\n",
+                        newValue, oldValue, newValue - oldValue);
+         //       OVR_ASSERT(0);
+            }
+            
+
+            if (oldValue != newValue)
+            {
+                oldValue = newValue;
+
+                if (oldValue % (TestIterations/30) == 0)
+                {
+                    LogText("LocklessTest::Consumer - %5.2f%% done\n",
+                            100.0f * (float)oldValue/(float)TestIterations);
+                }
+            }            
+
+            // Spin a while
+            for (int j = 0; j< 300; j++)
+            {
+                Dummy3 = j;
+            }
+
+
+        } while (oldValue < (TestIterations * 99 / 100));
+
+        LogText("LocklessTest::Consumer::Run exiting.\n");
+        return 0;
+    }
+
+};
+
+
+//-------------------------------------------------------------------------------------
+
+class Producer : public Thread
+{
+
+    virtual int Run()
+    {
+        LogText("LocklessTest::Producer::Run started.\n");        
+
+        for (int testVal = 0; testVal < TestIterations; testVal++)
+        {
+            TestData d;
+            d.Set(testVal);
+
+            {
+                //Lock::Locker scope(&TestLock);
+                TestDataUpdater.SetState(d);
+            }
+
+            FirstItemWritten = true;
+
+            // Spin a bit
+            for(int j = 0; j < 1000; j++)
+            {
+                Dummy2 = j;
+            }
+
+            if (testVal % (TestIterations/30) == 0)
+            {
+                LogText("LocklessTest::Producer - %5.2f%% done\n",
+                        100.0f * (float)testVal/(float)TestIterations);
+            }
+        }
+
+        LogText("LocklessTest::Producer::Run exiting.\n");
+        return 0;
+    }
+};
+
+
+} // namespace LocklessTest
+
+
+
+void StartLocklessTest()
+{
+    // These threads will release themselves once done
+    Ptr<LocklessTest::Producer> producerThread = *new LocklessTest::Producer;
+    Ptr<LocklessTest::Consumer> consumerThread = *new LocklessTest::Consumer;
+
+    producerThread->Start();
+    consumerThread->Start();
+
+    /*
+    while (!producerThread->IsFinished() && consumerThread->IsFinished())
+    {
+        Thread::MSleep(500);
+    } */
+
+    // TBD: Cleanup
+}
+
+
+} // namespace OVR
+
+#endif // OVR_LOCKLESS_TEST
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,117 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Lockless.h
+Content     :   Lock-less classes for producer/consumer communication
+Created     :   November 9, 2013
+Authors     :   John Carmack
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Lockless_h
+#define OVR_Lockless_h
+
+#include "OVR_Atomic.h"
+
+// Define this to compile-in Lockless test logic
+//#define OVR_LOCKLESS_TEST
+
+namespace OVR {
+
+
+// ***** LocklessUpdater
+
+// For single producer cases where you only care about the most recent update, not
+// necessarily getting every one that happens (vsync timing, SensorFusion updates).
+//
+// This is multiple consumer safe, but is currently only used with a single consumer.
+//
+// The SlotType can be the same as T, but should probably be a larger fixed size.
+// This allows for forward compatibility when the updater is shared between processes.
+
+// FIXME: ExchangeAdd_Sync() should be replaced with a portable read-only primitive,
+// so that the lockless pose state can be read-only on remote processes and to reduce
+// false sharing between processes and improve performance.
+
+template<class T, class SlotType>
+class LocklessUpdater
+{
+public:
+	LocklessUpdater() : UpdateBegin( 0 ), UpdateEnd( 0 )
+    {
+        OVR_COMPILER_ASSERT(sizeof(T) <= sizeof(SlotType));
+    }
+
+	T		GetState() const
+	{
+		// Copy the state out, then retry with the alternate slot
+		// if we determine that our copy may have been partially
+		// stepped on by a new update.
+		T	state;
+		int	begin, end, final;
+
+		for(;;)
+		{
+			// We are adding 0, only using these as atomic memory barriers, so it
+			// is ok to cast off the const, allowing GetState() to remain const.
+            end   = UpdateEnd.ExchangeAdd_Sync(0);
+            state = Slots[ end & 1 ];
+            begin = UpdateBegin.ExchangeAdd_Sync(0);
+			if ( begin == end ) {
+				break;
+			}
+
+			// The producer is potentially blocked while only having partially
+			// written the update, so copy out the other slot.
+            state = Slots[ (begin & 1) ^ 1 ];
+            final = UpdateBegin.ExchangeAdd_NoSync(0);
+			if ( final == begin ) {
+				break;
+			}
+
+			// The producer completed the last update and started a new one before
+			// we got it copied out, so try fetching the current buffer again.
+		}
+		return state;
+	}
+
+	void	SetState( T state )
+	{
+        const int slot = UpdateBegin.ExchangeAdd_Sync(1) & 1;
+        // Write to (slot ^ 1) because ExchangeAdd returns 'previous' value before add.
+        Slots[slot ^ 1] = state;
+        UpdateEnd.ExchangeAdd_Sync(1);
+	}
+
+    mutable AtomicInt<int> UpdateBegin;
+    mutable AtomicInt<int> UpdateEnd;
+    SlotType               Slots[2];
+};
+
+
+#ifdef OVR_LOCKLESS_TEST
+void StartLocklessTest();
+#endif
+
+
+} // namespace OVR
+
+#endif // OVR_Lockless_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,218 @@
+/************************************************************************************
+
+Filename    :   OVR_Log.cpp
+Content     :   Logging support
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Log.h"
+#include "OVR_Std.h"
+#include <stdarg.h>
+#include <stdio.h>
+
+#if defined(OVR_OS_WIN32) 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#elif defined(OVR_OS_ANDROID)
+#include <android/log.h>
+#elif defined(OVR_OS_LINUX) || defined(OVR_OS_MAC)
+#include <syslog.h>
+#endif
+
+namespace OVR {
+
+// Global Log pointer.
+Log* volatile OVR_GlobalLog = 0;
+
+//-----------------------------------------------------------------------------------
+// ***** Log Implementation
+
+Log::Log(unsigned logMask) :
+    LoggingMask(logMask)
+{
+#ifdef OVR_OS_WIN32
+    hEventSource = RegisterEventSourceA(NULL, "OculusVR");
+    OVR_ASSERT(hEventSource != NULL);
+#endif
+}
+
+Log::~Log()
+{
+#ifdef OVR_OS_WIN32
+    if (hEventSource)
+    {
+        DeregisterEventSource(hEventSource);
+    }
+#endif
+
+    // Clear out global log
+    if (this == OVR_GlobalLog)
+    {
+        // TBD: perhaps we should ASSERT if this happens before system shutdown?
+        OVR_GlobalLog = 0;
+    }
+}
+
+void Log::LogMessageVarg(LogMessageType messageType, const char* fmt, va_list argList)
+{
+    if ((messageType & LoggingMask) == 0)
+        return;
+#ifndef OVR_BUILD_DEBUG
+    if (IsDebugMessage(messageType))
+        return;
+#endif
+
+    char buffer[MaxLogBufferMessageSize];
+    FormatLog(buffer, MaxLogBufferMessageSize, messageType, fmt, argList);
+    DefaultLogOutput(buffer, messageType);
+}
+
+void OVR::Log::LogMessage(LogMessageType messageType, const char* pfmt, ...)
+{
+    va_list argList;
+    va_start(argList, pfmt);
+    LogMessageVarg(messageType, pfmt, argList);
+    va_end(argList);
+}
+
+
+void Log::FormatLog(char* buffer, unsigned bufferSize, LogMessageType messageType,
+                    const char* fmt, va_list argList)
+{    
+    bool addNewline = true;
+
+    switch(messageType)
+    {
+    case Log_Error:         OVR_strcpy(buffer, bufferSize, "Error: ");     break;
+    case Log_Debug:         OVR_strcpy(buffer, bufferSize, "Debug: ");     break;
+    case Log_Assert:        OVR_strcpy(buffer, bufferSize, "Assert: ");    break;
+    case Log_Text:       buffer[0] = 0; addNewline = false; break;
+    case Log_DebugText:  buffer[0] = 0; addNewline = false; break;
+    default:        
+        buffer[0] = 0;
+        addNewline = false;
+        break;
+    }
+
+    size_t prefixLength = OVR_strlen(buffer);
+    char *buffer2      = buffer + prefixLength;
+    OVR_vsprintf(buffer2, bufferSize - prefixLength, fmt, argList);
+
+    if (addNewline)
+        OVR_strcat(buffer, bufferSize, "\n");
+}
+
+
+void Log::DefaultLogOutput(const char* formattedText, LogMessageType messageType)
+{
+    bool debug = IsDebugMessage(messageType);
+
+#if defined(OVR_OS_WIN32)
+    // Under Win32, output regular messages to console if it exists; debug window otherwise.
+    static DWORD dummyMode;
+    static bool  hasConsole = (GetStdHandle(STD_OUTPUT_HANDLE) != INVALID_HANDLE_VALUE) &&
+                              (GetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), &dummyMode));
+
+    if (!hasConsole || debug)
+    {
+        ::OutputDebugStringA(formattedText);
+    }
+
+	fputs(formattedText, stdout);
+
+#elif defined(OVR_OS_ANDROID)
+    __android_log_write(ANDROID_LOG_INFO, "OVR", formattedText);
+
+#else
+    fputs(formattedText, stdout);
+
+#endif
+
+    if (messageType == Log_Error)
+    {
+#if defined(OVR_OS_WIN32)
+        if (!ReportEventA(hEventSource, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 1, 0, &formattedText, NULL))
+        {
+            OVR_ASSERT(false);
+        }
+#elif defined(OVR_OS_ANDROID)
+        // TBD
+#elif defined(OVR_OS_MAC) || defined(OVR_OS_LINUX)
+        syslog(LOG_ERR, "%s", formattedText);
+#else
+        // TBD
+#endif
+    }
+
+    // Just in case.
+    OVR_UNUSED2(formattedText, debug);
+}
+
+
+//static
+void Log::SetGlobalLog(Log *log)
+{
+    OVR_GlobalLog = log;
+}
+//static
+Log* Log::GetGlobalLog()
+{
+// No global log by default?
+//    if (!OVR_GlobalLog)
+//        OVR_GlobalLog = GetDefaultLog();
+    return OVR_GlobalLog;
+}
+
+//static
+Log* Log::GetDefaultLog()
+{
+    // Create default log pointer statically so that it can be used
+    // even during startup.
+    static Log defaultLog;
+    return &defaultLog;
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** Global Logging functions
+
+#define OVR_LOG_FUNCTION_IMPL(Name)  \
+    void Log##Name(const char* fmt, ...) \
+    {                                                                    \
+        if (OVR_GlobalLog)                                               \
+        {                                                                \
+            va_list argList; va_start(argList, fmt);                     \
+            OVR_GlobalLog->LogMessageVarg(Log_##Name, fmt, argList);  \
+            va_end(argList);                                             \
+        }                                                                \
+    }
+
+OVR_LOG_FUNCTION_IMPL(Text)
+OVR_LOG_FUNCTION_IMPL(Error)
+
+#ifdef OVR_BUILD_DEBUG
+OVR_LOG_FUNCTION_IMPL(DebugText)
+OVR_LOG_FUNCTION_IMPL(Debug)
+OVR_LOG_FUNCTION_IMPL(Assert)
+#endif
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,209 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_Log.h
+Content     :   Logging support
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Log_h
+#define OVR_Log_h
+
+#include "OVR_Types.h"
+#include <stdarg.h>
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Logging Constants
+
+// LogMaskConstants defined bit mask constants that describe what log messages
+// should be displayed.
+enum LogMaskConstants
+{
+    LogMask_Regular = 0x100,
+    LogMask_Debug   = 0x200,
+    LogMask_None    = 0,
+    LogMask_All     = LogMask_Regular|LogMask_Debug
+};
+
+
+// LogMessageType describes the type of the log message, controls when it is
+// displayed and what prefix/suffix is given to it. Messages are subdivided into
+// regular and debug logging types. Debug logging is only generated in debug builds.
+//
+// Log_Text         - General output text displayed without prefix or new-line.
+//                    Used in OVR libraries for general log flow messages
+//                    such as "Device Initialized".
+//
+// Log_Error        - Error message output with "Error: %s\n", intended for
+//                    application/sample-level use only, in cases where an expected
+//                    operation failed. OVR libraries should not use this internally,
+//                    reporting status codes instead.
+//
+// Log_DebugText    - Message without prefix or new lines; output in Debug build only.
+//
+// Log_Debug        - Debug-build only message, formatted with "Debug: %s\n".
+//                    Intended to comment on incorrect API usage that doesn't lead
+//                    to crashes but can be avoided with proper use.
+//                    There is no Debug Error on purpose, since real errors should
+//                    be handled by API user.
+//
+// Log_Assert      -  Debug-build only message, formatted with "Assert: %s\n".
+//                    Intended for severe unrecoverable conditions in library
+//                    source code. Generated though OVR_ASSERT_MSG(c, "Text").
+
+enum LogMessageType
+{    
+    // General Logging
+    Log_Text        = LogMask_Regular | 0,    
+    Log_Error       = LogMask_Regular | 1, // "Error: %s\n".
+    
+    // Debug-only messages (not generated in release build)
+    Log_DebugText   = LogMask_Debug | 0,
+    Log_Debug       = LogMask_Debug | 1,   // "Debug: %s\n".
+    Log_Assert      = LogMask_Debug | 2,   // "Assert: %s\n".
+};
+
+
+// LOG_VAARG_ATTRIBUTE macro, enforces printf-style fromatting for message types
+#ifdef __GNUC__
+#  define OVR_LOG_VAARG_ATTRIBUTE(a,b) __attribute__((format (printf, a, b)))
+#else
+#  define OVR_LOG_VAARG_ATTRIBUTE(a,b)
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Log
+
+// Log defines a base class interface that can be implemented to catch both
+// debug and runtime messages.
+// Debug logging can be overridden by calling Log::SetGlobalLog.
+
+class Log
+{
+    friend class System;
+
+#ifdef OVR_OS_WIN32
+    void* hEventSource;
+#endif
+
+public: 
+    Log(unsigned logMask = LogMask_Debug);
+    virtual ~Log();
+
+    // Log formating buffer size used by default LogMessageVarg. Longer strings are truncated.
+    enum { MaxLogBufferMessageSize = 4096 };
+
+    unsigned        GetLoggingMask() const            { return LoggingMask; }
+    void            SetLoggingMask(unsigned logMask)  { LoggingMask = logMask; }
+
+    // This virtual function receives all the messages,
+    // developers should override this function in order to do custom logging
+    virtual void    LogMessageVarg(LogMessageType messageType, const char* fmt, va_list argList);
+
+    // Call the logging function with specific message type, with no type filtering.
+    void            LogMessage(LogMessageType messageType,
+                               const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(3,4);
+
+
+    // Helper used by LogMessageVarg to format the log message, writing the resulting
+    // string into buffer. It formats text based on fmt and appends prefix/new line
+    // based on LogMessageType.
+    static void     FormatLog(char* buffer, unsigned bufferSize, LogMessageType messageType,
+                              const char* fmt, va_list argList);
+
+    // Default log output implementation used by by LogMessageVarg.
+    // Debug flag may be used to re-direct output on some platforms, but doesn't
+    // necessarily disable it in release builds; that is the job of the called.    
+    void            DefaultLogOutput(const char* textBuffer, LogMessageType messageType);
+
+    // Determines if the specified message type is for debugging only.
+    static bool     IsDebugMessage(LogMessageType messageType)
+    {
+        return (messageType & LogMask_Debug) != 0;
+    }
+
+    // *** Global APIs
+
+    // Global Log registration APIs.
+    //  - Global log is used for OVR_DEBUG messages. Set global log to null (0)
+    //    to disable all logging.
+    static void     SetGlobalLog(Log *log);
+    static Log*     GetGlobalLog();
+
+    // Returns default log singleton instance.
+    static Log*     GetDefaultLog();
+
+    // Applies logMask to the default log and returns a pointer to it.
+    // By default, only Debug logging is enabled, so to avoid SDK generating console
+    // messages in user app (those are always disabled in release build,
+    // even if the flag is set). This function is useful in System constructor.
+    static Log*     ConfigureDefaultLog(unsigned logMask = LogMask_Debug)
+    {
+        Log* log = GetDefaultLog();
+        log->SetLoggingMask(logMask);
+        return log;
+    }
+
+private:
+    // Logging mask described by LogMaskConstants.
+    unsigned    LoggingMask;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Global Logging Functions and Debug Macros
+
+// These functions will output text to global log with semantics described by
+// their LogMessageType.
+void LogText(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+void LogError(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+
+#ifdef OVR_BUILD_DEBUG
+
+    // Debug build only logging.
+    void LogDebugText(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+    void LogDebug(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+    void LogAssert(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+
+    // Macro to do debug logging, printf-style.
+    // An extra set of set of parenthesis must be used around arguments,
+    // as in: OVR_DEBUG_LOG(("Value %d", 2)).
+    #define OVR_DEBUG_LOG(args)       do { OVR::LogDebug args; } while(0)
+    #define OVR_DEBUG_LOG_TEXT(args)  do { OVR::LogDebugText args; } while(0)
+
+    #define OVR_ASSERT_LOG(c, args)   do { if (!(c)) { OVR::LogAssert args; OVR_DEBUG_BREAK; } } while(0)
+
+#else
+
+    // If not in debug build, macros do nothing.
+    #define OVR_DEBUG_LOG(args)         ((void)0)
+    #define OVR_DEBUG_LOG_TEXT(args)    ((void)0)
+    #define OVR_ASSERT_LOG(c, args)     ((void)0)
+
+#endif
+
+} // OVR 
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,58 @@
+/************************************************************************************
+
+Filename    :   OVR_Math.h
+Content     :   Implementation of 3D primitives such as vectors, matrices.
+Created     :   September 4, 2012
+Authors     :   Andrew Reisse, Michael Antonov, Anna Yershova
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "OVR_Math.h"
+#include "OVR_Log.h"
+
+#include <float.h>
+
+
+namespace OVR {
+
+
+//-------------------------------------------------------------------------------------
+// ***** Constants
+
+template<>
+const Vector3<float> Vector3<float>::ZERO = Vector3<float>();
+
+template<>
+const Vector3<double> Vector3<double>::ZERO = Vector3<double>();
+
+template<>
+const Matrix4<float> Matrix4<float>::IdentityValue = Matrix4<float>(1.0f, 0.0f, 0.0f, 0.0f, 
+                                                                    0.0f, 1.0f, 0.0f, 0.0f, 
+                                                                    0.0f, 0.0f, 1.0f, 0.0f,
+                                                                    0.0f, 0.0f, 0.0f, 1.0f);
+
+template<>
+const Matrix4<double> Matrix4<double>::IdentityValue = Matrix4<double>(1.0, 0.0, 0.0, 0.0, 
+                                                                       0.0, 1.0, 0.0, 0.0, 
+                                                                       0.0, 0.0, 1.0, 0.0,
+                                                                       0.0, 0.0, 0.0, 1.0);
+
+
+} // Namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,2766 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Math.h
+Content     :   Implementation of 3D primitives such as vectors, matrices.
+Created     :   September 4, 2012
+Authors     :   Andrew Reisse, Michael Antonov, Steve LaValle, 
+				Anna Yershova, Max Katsev, Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Math_h
+#define OVR_Math_h
+
+#include <assert.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "OVR_Types.h"
+#include "OVR_RefCount.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+
+namespace OVR {
+
+//-------------------------------------------------------------------------------------
+// ***** Constants for 3D world/axis definitions.
+
+// Definitions of axes for coordinate and rotation conversions.
+enum Axis
+{
+    Axis_X = 0, Axis_Y = 1, Axis_Z = 2
+};
+
+// RotateDirection describes the rotation direction around an axis, interpreted as follows:
+//  CW  - Clockwise while looking "down" from positive axis towards the origin.
+//  CCW - Counter-clockwise while looking from the positive axis towards the origin,
+//        which is in the negative axis direction.
+//  CCW is the default for the RHS coordinate system. Oculus standard RHS coordinate
+//  system defines Y up, X right, and Z back (pointing out from the screen). In this
+//  system Rotate_CCW around Z will specifies counter-clockwise rotation in XY plane.
+enum RotateDirection
+{
+    Rotate_CCW = 1,
+    Rotate_CW  = -1 
+};
+
+// Constants for right handed and left handed coordinate systems
+enum HandedSystem
+{
+    Handed_R = 1, Handed_L = -1
+};
+
+// AxisDirection describes which way the coordinate axis points. Used by WorldAxes.
+enum AxisDirection
+{
+    Axis_Up    =  2,
+    Axis_Down  = -2,
+    Axis_Right =  1,
+    Axis_Left  = -1,
+    Axis_In    =  3,
+    Axis_Out   = -3
+};
+
+struct WorldAxes
+{
+    AxisDirection XAxis, YAxis, ZAxis;
+
+    WorldAxes(AxisDirection x, AxisDirection y, AxisDirection z)
+        : XAxis(x), YAxis(y), ZAxis(z) 
+    { OVR_ASSERT(abs(x) != abs(y) && abs(y) != abs(z) && abs(z) != abs(x));}
+};
+
+} // namespace OVR
+
+
+//------------------------------------------------------------------------------------//
+// ***** C Compatibility Types
+
+// These declarations are used to support conversion between C types used in
+// LibOVR C interfaces and their C++ versions. As an example, they allow passing
+// Vector3f into a function that expects ovrVector3f.
+
+typedef struct ovrQuatf_ ovrQuatf;
+typedef struct ovrQuatd_ ovrQuatd;
+typedef struct ovrSizei_ ovrSizei;
+typedef struct ovrSizef_ ovrSizef;
+typedef struct ovrRecti_ ovrRecti;
+typedef struct ovrVector2i_ ovrVector2i;
+typedef struct ovrVector2f_ ovrVector2f;
+typedef struct ovrVector3f_ ovrVector3f;
+typedef struct ovrVector3d_ ovrVector3d;
+typedef struct ovrMatrix3d_ ovrMatrix3d;
+typedef struct ovrMatrix4f_ ovrMatrix4f;
+typedef struct ovrPosef_ ovrPosef;
+typedef struct ovrPosed_ ovrPosed;
+typedef struct ovrPoseStatef_ ovrPoseStatef;
+typedef struct ovrPoseStated_ ovrPoseStated;
+
+namespace OVR {
+
+// Forward-declare our templates.
+template<class T> class Quat;
+template<class T> class Size;
+template<class T> class Rect;
+template<class T> class Vector2;
+template<class T> class Vector3;
+template<class T> class Matrix3;
+template<class T> class Matrix4;
+template<class T> class Pose;
+template<class T> class PoseState;
+
+// CompatibleTypes::Type is used to lookup a compatible C-version of a C++ class.
+template<class C>
+struct CompatibleTypes
+{    
+    // Declaration here seems necessary for MSVC; specializations are
+    // used instead.
+    typedef struct {} Type;
+};
+
+// Specializations providing CompatibleTypes::Type value.
+template<> struct CompatibleTypes<Quat<float> >     { typedef ovrQuatf Type; };
+template<> struct CompatibleTypes<Quat<double> >    { typedef ovrQuatd Type; };
+template<> struct CompatibleTypes<Matrix3<double> > { typedef ovrMatrix3d Type; };
+template<> struct CompatibleTypes<Matrix4<float> >  { typedef ovrMatrix4f Type; };
+template<> struct CompatibleTypes<Size<int> >       { typedef ovrSizei Type; };
+template<> struct CompatibleTypes<Size<float> >     { typedef ovrSizef Type; };
+template<> struct CompatibleTypes<Rect<int> >       { typedef ovrRecti Type; };
+template<> struct CompatibleTypes<Vector2<int> >    { typedef ovrVector2i Type; };
+template<> struct CompatibleTypes<Vector2<float> >  { typedef ovrVector2f Type; };
+template<> struct CompatibleTypes<Vector3<float> >  { typedef ovrVector3f Type; };
+template<> struct CompatibleTypes<Vector3<double> > { typedef ovrVector3d Type; };
+
+template<> struct CompatibleTypes<Pose<float> > { typedef ovrPosef Type; };
+template<> struct CompatibleTypes<Pose<double> > { typedef ovrPosed Type; };
+
+//------------------------------------------------------------------------------------//
+// ***** Math
+//
+// Math class contains constants and functions. This class is a template specialized
+// per type, with Math<float> and Math<double> being distinct.
+template<class Type>
+class Math
+{  
+public:
+    // By default, support explicit conversion to float. This allows Vector2<int> to
+    // compile, for example.
+    typedef float OtherFloatType;
+};
+
+
+#define MATH_FLOAT_PI                (3.1415926f)
+#define MATH_FLOAT_TWOPI             (2.0f *MATH_FLOAT_PI)
+#define MATH_FLOAT_PIOVER2           (0.5f *MATH_FLOAT_PI)
+#define MATH_FLOAT_PIOVER4           (0.25f*MATH_FLOAT_PI)
+#define MATH_FLOAT_E                 (2.7182818f)
+#define MATH_FLOAT_MAXVALUE			 (FLT_MAX) 
+#define MATH_FLOAT MINPOSITIVEVALUE  (FLT_MIN)  
+#define MATH_FLOAT_RADTODEGREEFACTOR (360.0f / MATH_FLOAT_TWOPI)
+#define MATH_FLOAT_DEGREETORADFACTOR (MATH_FLOAT_TWOPI / 360.0f)
+#define MATH_FLOAT_TOLERANCE		 (0.00001f)
+#define MATH_FLOAT_SINGULARITYRADIUS (0.0000001f) // Use for Gimbal lock numerical problems
+
+#define MATH_DOUBLE_PI                (3.14159265358979)
+#define MATH_DOUBLE_TWOPI             (2.0f *MATH_DOUBLE_PI)
+#define MATH_DOUBLE_PIOVER2           (0.5f *MATH_DOUBLE_PI)
+#define MATH_DOUBLE_PIOVER4           (0.25f*MATH_DOUBLE_PI)
+#define MATH_DOUBLE_E                 (2.71828182845905)
+#define MATH_DOUBLE_MAXVALUE		  (DBL_MAX)
+#define MATH_DOUBLE MINPOSITIVEVALUE  (DBL_MIN)
+#define MATH_DOUBLE_RADTODEGREEFACTOR (360.0f / MATH_DOUBLE_TWOPI)
+#define MATH_DOUBLE_DEGREETORADFACTOR (MATH_DOUBLE_TWOPI / 360.0f)
+#define MATH_DOUBLE_TOLERANCE		  (0.00001)
+#define MATH_DOUBLE_SINGULARITYRADIUS (0.000000000001) // Use for Gimbal lock numerical problems
+
+
+
+
+// Single-precision Math constants class.
+template<>
+class Math<float>
+{
+public:
+     typedef double OtherFloatType;
+};
+
+// Double-precision Math constants class.
+template<>
+class Math<double>
+{
+public:
+    typedef float OtherFloatType;
+};
+
+
+typedef Math<float>  Mathf;
+typedef Math<double> Mathd;
+
+// Conversion functions between degrees and radians
+template<class T>
+T RadToDegree(T rads) { return rads * ((T)MATH_DOUBLE_RADTODEGREEFACTOR); }
+template<class T>
+T DegreeToRad(T rads) { return rads * ((T)MATH_DOUBLE_DEGREETORADFACTOR); }
+
+// Numerically stable acos function
+template<class T>
+T Acos(T val) { 
+		if (val > T(1))				return T(0);
+		else if (val < T(-1))		return ((T)MATH_DOUBLE_PI);
+		else						return acos(val); 
+};
+
+// Numerically stable asin function
+template<class T>
+T Asin(T val) { 
+	if (val > T(1))				return ((T)MATH_DOUBLE_PIOVER2);
+	else if (val < T(-1))		return ((T)MATH_DOUBLE_PIOVER2) * T(3);
+	else						return asin(val); 
+};
+
+#ifdef OVR_CC_MSVC
+inline int isnan(double x) { return _isnan(x); };
+#endif
+
+template<class T>
+class Quat;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Vector2<>
+
+// Vector2f (Vector2d) represents a 2-dimensional vector or point in space,
+// consisting of coordinates x and y
+
+template<class T>
+class Vector2
+{
+public:
+    T x, y;
+
+    Vector2() : x(0), y(0) { }
+    Vector2(T x_, T y_) : x(x_), y(y_) { }
+    explicit Vector2(T s) : x(s), y(s) { }
+    explicit Vector2(const Vector2<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y) { }
+
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Vector2<T> >::Type CompatibleType;
+
+    Vector2(const CompatibleType& s) : x(s.x), y(s.y) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector2<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+        
+    bool     operator== (const Vector2& b) const  { return x == b.x && y == b.y; }
+    bool     operator!= (const Vector2& b) const  { return x != b.x || y != b.y; }
+             
+    Vector2  operator+  (const Vector2& b) const  { return Vector2(x + b.x, y + b.y); }
+    Vector2& operator+= (const Vector2& b)        { x += b.x; y += b.y; return *this; }
+    Vector2  operator-  (const Vector2& b) const  { return Vector2(x - b.x, y - b.y); }
+    Vector2& operator-= (const Vector2& b)        { x -= b.x; y -= b.y; return *this; }
+    Vector2  operator- () const                   { return Vector2(-x, -y); }
+
+    // Scalar multiplication/division scales vector.
+    Vector2  operator*  (T s) const               { return Vector2(x*s, y*s); }
+    Vector2& operator*= (T s)                     { x *= s; y *= s; return *this; }
+
+    Vector2  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector2(x*rcp, y*rcp); }
+    Vector2& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp;
+                                                    return *this; }
+
+    static Vector2  Min(const Vector2& a, const Vector2& b) { return Vector2((a.x < b.x) ? a.x : b.x,
+                                                                             (a.y < b.y) ? a.y : b.y); }
+    static Vector2  Max(const Vector2& a, const Vector2& b) { return Vector2((a.x > b.x) ? a.x : b.x,
+                                                                             (a.y > b.y) ? a.y : b.y); }
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool	Compare(const Vector2&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE))  
+    {
+        return (fabs(b.x-x) < tolerance) && (fabs(b.y-y) < tolerance);
+    }
+    
+	// Access element by index
+	T& operator[] (int idx)
+	{
+		OVR_ASSERT(0 <= idx && idx < 2);
+		return *(&x + idx);
+	}
+	const T& operator[] (int idx) const
+	{
+		OVR_ASSERT(0 <= idx && idx < 2);
+		return *(&x + idx);
+	}
+
+    // Entry-wise product of two vectors
+    Vector2	EntrywiseMultiply(const Vector2& b) const	{ return Vector2(x * b.x, y * b.y);}
+
+
+    // Multiply and divide operators do entry-wise math. Used Dot() for dot product.
+    Vector2  operator*  (const Vector2& b) const        { return Vector2(x * b.x,  y * b.y); }
+    Vector2  operator/  (const Vector2& b) const        { return Vector2(x / b.x,  y / b.y); }
+
+	// Dot product
+    // Used to calculate angle q between two vectors among other things,
+    // as (A dot B) = |a||b|cos(q).
+    T		Dot(const Vector2& b) const                 { return x*b.x + y*b.y; }
+
+    // Returns the angle from this vector to b, in radians.
+    T       Angle(const Vector2& b) const        
+	{ 
+		T div = LengthSq()*b.LengthSq();
+		OVR_ASSERT(div != T(0));
+		T result = Acos((this->Dot(b))/sqrt(div));
+		return result;
+	}
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+
+    // Returns squared distance between two points represented by vectors.
+    T       DistanceSq(const Vector2& b) const   { return (*this - b).LengthSq(); }
+
+	// Returns distance between two points represented by vectors.
+    T       Distance(const Vector2& b) const     { return (*this - b).Length(); }
+
+	// Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector2 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Linearly interpolates from this vector to another.
+    // Factor should be between 0.0 and 1.0, with 0 giving full value to this.
+    Vector2 Lerp(const Vector2& b, T f) const    { return *this*(T(1) - f) + b*f; }
+
+    // Projects this vector onto the argument; in other words,
+    // A.Project(B) returns projection of vector A onto B.
+    Vector2 ProjectTo(const Vector2& b) const    
+	{ 
+		T l2 = b.LengthSq();
+		OVR_ASSERT(l2 != T(0));
+		return b * ( Dot(b) / l2 ); 
+	}
+};
+
+
+typedef Vector2<float>  Vector2f;
+typedef Vector2<double> Vector2d;
+typedef Vector2<int>    Vector2i;
+
+typedef Vector2<float>  Point2f;
+typedef Vector2<double> Point2d;
+typedef Vector2<int>    Point2i;
+
+//-------------------------------------------------------------------------------------
+// ***** Vector3<> - 3D vector of {x, y, z}
+
+//
+// Vector3f (Vector3d) represents a 3-dimensional vector or point in space,
+// consisting of coordinates x, y and z.
+
+template<class T>
+class Vector3
+{
+public:
+    T x, y, z;
+
+    // FIXME: default initialization of a vector class can be very expensive in a full-blown
+    // application.  A few hundred thousand vector constructions is not unlikely and can add
+    // up to milliseconds of time on processors like the PS3 PPU.
+    Vector3() : x(0), y(0), z(0) { }
+    Vector3(T x_, T y_, T z_ = 0) : x(x_), y(y_), z(z_) { }
+    explicit Vector3(T s) : x(s), y(s), z(s) { }
+    explicit Vector3(const Vector3<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z) { }
+
+    static const Vector3 ZERO;
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Vector3<T> >::Type CompatibleType;
+
+    Vector3(const CompatibleType& s) : x(s.x), y(s.y), z(s.z) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector3<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    bool     operator== (const Vector3& b) const  { return x == b.x && y == b.y && z == b.z; }
+    bool     operator!= (const Vector3& b) const  { return x != b.x || y != b.y || z != b.z; }
+             
+    Vector3  operator+  (const Vector3& b) const  { return Vector3(x + b.x, y + b.y, z + b.z); }
+    Vector3& operator+= (const Vector3& b)        { x += b.x; y += b.y; z += b.z; return *this; }
+    Vector3  operator-  (const Vector3& b) const  { return Vector3(x - b.x, y - b.y, z - b.z); }
+    Vector3& operator-= (const Vector3& b)        { x -= b.x; y -= b.y; z -= b.z; return *this; }
+    Vector3  operator- () const                   { return Vector3(-x, -y, -z); }
+
+    // Scalar multiplication/division scales vector.
+    Vector3  operator*  (T s) const               { return Vector3(x*s, y*s, z*s); }
+    Vector3& operator*= (T s)                     { x *= s; y *= s; z *= s; return *this; }
+
+    Vector3  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector3(x*rcp, y*rcp, z*rcp); }
+    Vector3& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp; z *= rcp;
+                                                    return *this; }
+
+    static Vector3  Min(const Vector3& a, const Vector3& b)
+    {
+        return Vector3((a.x < b.x) ? a.x : b.x,
+                       (a.y < b.y) ? a.y : b.y,
+                       (a.z < b.z) ? a.z : b.z);
+    }
+    static Vector3  Max(const Vector3& a, const Vector3& b)
+    { 
+        return Vector3((a.x > b.x) ? a.x : b.x,
+                       (a.y > b.y) ? a.y : b.y,
+                       (a.z > b.z) ? a.z : b.z);
+    }        
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool      Compare(const Vector3&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE)) 
+    {
+        return (fabs(b.x-x) < tolerance) && 
+			   (fabs(b.y-y) < tolerance) && 
+			   (fabs(b.z-z) < tolerance);
+    }
+    
+    T& operator[] (int idx)
+    {
+        OVR_ASSERT(0 <= idx && idx < 3);
+        return *(&x + idx);
+    }
+
+    const T& operator[] (int idx) const
+    {
+        OVR_ASSERT(0 <= idx && idx < 3);
+        return *(&x + idx);
+    }
+
+    // Entrywise product of two vectors
+    Vector3	EntrywiseMultiply(const Vector3& b) const	{ return Vector3(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z);}
+
+    // Multiply and divide operators do entry-wise math
+    Vector3  operator*  (const Vector3& b) const        { return Vector3(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z); }
+
+    Vector3  operator/  (const Vector3& b) const        { return Vector3(x / b.x, 
+																		 y / b.y, 
+																		 z / b.z); }
+
+
+	// Dot product
+    // Used to calculate angle q between two vectors among other things,
+    // as (A dot B) = |a||b|cos(q).
+     T      Dot(const Vector3& b) const          { return x*b.x + y*b.y + z*b.z; }
+
+    // Compute cross product, which generates a normal vector.
+    // Direction vector can be determined by right-hand rule: Pointing index finder in
+    // direction a and middle finger in direction b, thumb will point in a.Cross(b).
+    Vector3 Cross(const Vector3& b) const        { return Vector3(y*b.z - z*b.y,
+                                                                  z*b.x - x*b.z,
+                                                                  x*b.y - y*b.x); }
+
+    // Returns the angle from this vector to b, in radians.
+    T       Angle(const Vector3& b) const 
+	{
+		T div = LengthSq()*b.LengthSq();
+		OVR_ASSERT(div != T(0));
+		T result = Acos((this->Dot(b))/sqrt(div));
+		return result;
+	}
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y + z * z); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+
+    // Returns squared distance between two points represented by vectors.
+    T       DistanceSq(Vector3 const& b) const         { return (*this - b).LengthSq(); }
+
+    // Returns distance between two points represented by vectors.
+    T       Distance(Vector3 const& b) const     { return (*this - b).Length(); }
+    
+    // Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector3 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Linearly interpolates from this vector to another.
+    // Factor should be between 0.0 and 1.0, with 0 giving full value to this.
+    Vector3 Lerp(const Vector3& b, T f) const    { return *this*(T(1) - f) + b*f; }
+
+    // Projects this vector onto the argument; in other words,
+    // A.Project(B) returns projection of vector A onto B.
+    Vector3 ProjectTo(const Vector3& b) const    
+	{ 
+		T l2 = b.LengthSq();
+		OVR_ASSERT(l2 != T(0));
+		return b * ( Dot(b) / l2 ); 
+	}
+
+    // Projects this vector onto a plane defined by a normal vector
+    Vector3 ProjectToPlane(const Vector3& normal) const { return *this - this->ProjectTo(normal); }
+};
+
+typedef Vector3<float>  Vector3f;
+typedef Vector3<double> Vector3d;
+typedef Vector3<int32_t>  Vector3i;
+
+typedef Vector3<float>   Point3f;
+typedef Vector3<double>  Point3d;
+typedef Vector3<int32_t>  Point3i;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Vector4<> - 4D vector of {x, y, z, w}
+
+//
+// Vector4f (Vector4d) represents a 3-dimensional vector or point in space,
+// consisting of coordinates x, y, z and w.
+
+template<class T>
+class Vector4
+{
+public:
+    T x, y, z, w;
+
+	// FIXME: default initialization of a vector class can be very expensive in a full-blown
+	// application.  A few hundred thousand vector constructions is not unlikely and can add
+	// up to milliseconds of time on processors like the PS3 PPU.
+    Vector4() : x(0), y(0), z(0), w(0) { }
+    Vector4(T x_, T y_, T z_, T w_) : x(x_), y(y_), z(z_), w(w_) { }
+    explicit Vector4(T s) : x(s), y(s), z(s), w(s) { }
+	explicit Vector4(const Vector3<T>& v, const float w_=1) : x(v.x), y(v.y), z(v.z), w(w_) { }
+    explicit Vector4(const Vector4<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z), w((T)src.w) { }
+
+    static const Vector4 ZERO;
+
+    // C-interop support.
+    typedef  typename CompatibleTypes< Vector4<T> >::Type CompatibleType;
+
+    Vector4(const CompatibleType& s) : x(s.x), y(s.y), z(s.z), w(s.w) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector4<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+	Vector4& operator= (const Vector3<T>& other)  { x=other.x; y=other.y; z=other.z; w=1; return *this; }
+    bool     operator== (const Vector4& b) const  { return x == b.x && y == b.y && z == b.z && w == b.w; }
+    bool     operator!= (const Vector4& b) const  { return x != b.x || y != b.y || z != b.z || w != b.w; }
+             
+    Vector4  operator+  (const Vector4& b) const  { return Vector4(x + b.x, y + b.y, z + b.z, w + b.w); }
+    Vector4& operator+= (const Vector4& b)        { x += b.x; y += b.y; z += b.z; w += b.w; return *this; }
+    Vector4  operator-  (const Vector4& b) const  { return Vector4(x - b.x, y - b.y, z - b.z, w - b.w); }
+    Vector4& operator-= (const Vector4& b)        { x -= b.x; y -= b.y; z -= b.z; w -= b.w; return *this; }
+    Vector4  operator- () const                   { return Vector4(-x, -y, -z, -w); }
+
+    // Scalar multiplication/division scales vector.
+    Vector4  operator*  (T s) const               { return Vector4(x*s, y*s, z*s, w*s); }
+    Vector4& operator*= (T s)                     { x *= s; y *= s; z *= s; w *= s;return *this; }
+
+    Vector4  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector4(x*rcp, y*rcp, z*rcp, w*rcp); }
+    Vector4& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp; z *= rcp; w *= rcp;
+                                                    return *this; }
+
+    static Vector4  Min(const Vector4& a, const Vector4& b)
+    {
+        return Vector4((a.x < b.x) ? a.x : b.x,
+                       (a.y < b.y) ? a.y : b.y,
+                       (a.z < b.z) ? a.z : b.z,
+					   (a.w < b.w) ? a.w : b.w);
+    }
+    static Vector4  Max(const Vector4& a, const Vector4& b)
+    { 
+        return Vector4((a.x > b.x) ? a.x : b.x,
+                       (a.y > b.y) ? a.y : b.y,
+                       (a.z > b.z) ? a.z : b.z,
+					   (a.w > b.w) ? a.w : b.w);
+    }        
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool      Compare(const Vector4&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE))
+    {
+        return (fabs(b.x-x) < tolerance) && 
+			   (fabs(b.y-y) < tolerance) && 
+			   (fabs(b.z-z) < tolerance) &&
+			   (fabs(b.w-w) < tolerance);
+    }
+    
+    T& operator[] (int idx)
+    {
+        OVR_ASSERT(0 <= idx && idx < 4);
+        return *(&x + idx);
+    }
+
+    const T& operator[] (int idx) const
+    {
+        OVR_ASSERT(0 <= idx && idx < 4);
+        return *(&x + idx);
+    }
+
+    // Entry wise product of two vectors
+    Vector4	EntrywiseMultiply(const Vector4& b) const	{ return Vector4(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z);}
+
+    // Multiply and divide operators do entry-wise math
+    Vector4  operator*  (const Vector4& b) const        { return Vector4(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z,
+																		 w * b.w); }
+
+    Vector4  operator/  (const Vector4& b) const        { return Vector4(x / b.x, 
+																		 y / b.y, 
+																		 z / b.z,
+																		 w / b.w); }
+
+
+	// Dot product
+    T       Dot(const Vector4& b) const          { return x*b.x + y*b.y + z*b.z + w*b.w; }
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y + z * z + w * w); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+    
+    // Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < Math<T>::Tolerance; }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector4 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+};
+
+typedef Vector4<float>  Vector4f;
+typedef Vector4<double> Vector4d;
+typedef Vector4<int>    Vector4i;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Bounds3
+
+// Bounds class used to describe a 3D axis aligned bounding box.
+
+template<class T>
+class Bounds3
+{
+public:
+	Vector3<T>	b[2];
+
+	Bounds3()
+	{
+	}
+
+	Bounds3( const Vector3<T> & mins, const Vector3<T> & maxs )
+{
+		b[0] = mins;
+		b[1] = maxs;
+	}
+
+	void Clear()
+	{
+		b[0].x = b[0].y = b[0].z = Math<T>::MaxValue;
+		b[1].x = b[1].y = b[1].z = -Math<T>::MaxValue;
+	}
+
+	void AddPoint( const Vector3<T> & v )
+	{
+		b[0].x = Alg::Min( b[0].x, v.x );
+		b[0].y = Alg::Min( b[0].y, v.y );
+		b[0].z = Alg::Min( b[0].z, v.z );
+		b[1].x = Alg::Max( b[1].x, v.x );
+		b[1].y = Alg::Max( b[1].y, v.y );
+		b[1].z = Alg::Max( b[1].z, v.z );
+	}
+
+	const Vector3<T> & GetMins() const { return b[0]; }
+	const Vector3<T> & GetMaxs() const { return b[1]; }
+
+	Vector3<T> & GetMins() { return b[0]; }
+	Vector3<T> & GetMaxs() { return b[1]; }
+};
+
+typedef Bounds3<float>	Bounds3f;
+typedef Bounds3<double>	Bounds3d;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Size
+
+// Size class represents 2D size with Width, Height components.
+// Used to describe distentions of render targets, etc.
+
+template<class T>
+class Size
+{
+public:
+    T   w, h;
+
+    Size()              : w(0), h(0)   { }
+    Size(T w_, T h_)    : w(w_), h(h_) { }
+    explicit Size(T s)  : w(s), h(s)   { }
+    explicit Size(const Size<typename Math<T>::OtherFloatType> &src)
+        : w((T)src.w), h((T)src.h) { }
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Size<T> >::Type CompatibleType;
+
+    Size(const CompatibleType& s) : w(s.w), h(s.h) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Size<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    bool     operator== (const Size& b) const  { return w == b.w && h == b.h; }
+    bool     operator!= (const Size& b) const  { return w != b.w || h != b.h; }
+             
+    Size  operator+  (const Size& b) const  { return Size(w + b.w, h + b.h); }
+    Size& operator+= (const Size& b)        { w += b.w; h += b.h; return *this; }
+    Size  operator-  (const Size& b) const  { return Size(w - b.w, h - b.h); }
+    Size& operator-= (const Size& b)        { w -= b.w; h -= b.h; return *this; }
+    Size  operator- () const                { return Size(-w, -h); }
+    Size  operator*  (const Size& b) const  { return Size(w * b.w, h * b.h); }
+    Size& operator*= (const Size& b)        { w *= b.w; h *= b.h; return *this; }
+    Size  operator/  (const Size& b) const  { return Size(w / b.w, h / b.h); }
+    Size& operator/= (const Size& b)        { w /= b.w; h /= b.h; return *this; }
+
+    // Scalar multiplication/division scales both components.
+    Size  operator*  (T s) const            { return Size(w*s, h*s); }
+    Size& operator*= (T s)                  { w *= s; h *= s; return *this; }    
+    Size  operator/  (T s) const            { return Size(w/s, h/s); }
+    Size& operator/= (T s)                  { w /= s; h /= s; return *this; }
+
+    static Size Min(const Size& a, const Size& b)  { return Size((a.w  < b.w)  ? a.w  : b.w,
+                                                                 (a.h < b.h) ? a.h : b.h); }
+    static Size Max(const Size& a, const Size& b)  { return Size((a.w  > b.w)  ? a.w  : b.w,
+                                                                 (a.h > b.h) ? a.h : b.h); }
+    
+    T       Area() const                    { return w * h; }
+
+    inline  Vector2<T> ToVector() const     { return Vector2<T>(w, h); }
+};
+
+
+typedef Size<int>       Sizei;
+typedef Size<unsigned>  Sizeu;
+typedef Size<float>     Sizef;
+typedef Size<double>    Sized;
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Rect
+
+// Rect describes a rectangular area for rendering, that includes position and size.
+template<class T>
+class Rect
+{
+public:
+    T x, y;
+    T w, h;
+
+    Rect() { }
+    Rect(T x1, T y1, T w1, T h1)                   : x(x1), y(y1), w(w1), h(h1) { }    
+    Rect(const Vector2<T>& pos, const Size<T>& sz) : x(pos.x), y(pos.y), w(sz.w), h(sz.h) { }
+    Rect(const Size<T>& sz)                        : x(0), y(0), w(sz.w), h(sz.h) { }
+    
+    // C-interop support.
+    typedef  typename CompatibleTypes<Rect<T> >::Type CompatibleType;
+
+    Rect(const CompatibleType& s) : x(s.Pos.x), y(s.Pos.y), w(s.Size.w), h(s.Size.h) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Rect<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    Vector2<T> GetPos() const                { return Vector2<T>(x, y); }
+    Size<T>    GetSize() const               { return Size<T>(w, h); }
+    void       SetPos(const Vector2<T>& pos) { x = pos.x; y = pos.y; }
+    void       SetSize(const Size<T>& sz)    { w = sz.w; h = sz.h; }
+
+    bool operator == (const Rect& vp) const
+    { return (x == vp.x) && (y == vp.y) && (w == vp.w) && (h == vp.h); }
+    bool operator != (const Rect& vp) const
+    { return !operator == (vp); }
+};
+
+typedef Rect<int> Recti;
+
+
+//-------------------------------------------------------------------------------------//
+// ***** Quat
+//
+// Quatf represents a quaternion class used for rotations.
+// 
+// Quaternion multiplications are done in right-to-left order, to match the
+// behavior of matrices.
+
+
+template<class T>
+class Quat
+{
+public:
+    // w + Xi + Yj + Zk
+    T x, y, z, w;    
+
+    Quat() : x(0), y(0), z(0), w(1) { }
+    Quat(T x_, T y_, T z_, T w_) : x(x_), y(y_), z(z_), w(w_) { }
+    explicit Quat(const Quat<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z), w((T)src.w) { }
+
+    typedef  typename CompatibleTypes<Quat<T> >::Type CompatibleType;
+
+    // C-interop support.
+    Quat(const CompatibleType& s) : x(s.x), y(s.y), z(s.z), w(s.w) { }
+
+    operator CompatibleType () const
+    {
+        CompatibleType result;
+        result.x = x;
+        result.y = y;
+        result.z = z;
+        result.w = w;
+        return result;
+    }
+
+    // Constructs quaternion for rotation around the axis by an angle.
+    Quat(const Vector3<T>& axis, T angle)
+    {
+        // Make sure we don't divide by zero. 
+        if (axis.LengthSq() == 0)
+        {
+            // Assert if the axis is zero, but the angle isn't
+            OVR_ASSERT(angle == 0);
+            x = 0; y = 0; z = 0; w = 1;
+            return;
+        }
+
+		Vector3<T> unitAxis = axis.Normalized();
+		T          sinHalfAngle = sin(angle * T(0.5));
+
+		w = cos(angle * T(0.5));
+		x = unitAxis.x * sinHalfAngle;
+		y = unitAxis.y * sinHalfAngle;
+		z = unitAxis.z * sinHalfAngle;
+    }
+
+    // Constructs quaternion for rotation around one of the coordinate axis by an angle.
+    Quat(Axis A, T angle, RotateDirection d = Rotate_CCW, HandedSystem s = Handed_R)
+    {
+        T sinHalfAngle = s * d *sin(angle * T(0.5));
+        T v[3];
+        v[0] = v[1] = v[2] = T(0);
+        v[A] = sinHalfAngle;
+
+        w = cos(angle * T(0.5));
+        x = v[0];
+        y = v[1];
+        z = v[2];
+    }
+
+    // Compute axis and angle from quaternion
+    void GetAxisAngle(Vector3<T>* axis, T* angle) const
+    {
+		if ( x*x + y*y + z*z > ((T)MATH_DOUBLE_TOLERANCE) * ((T)MATH_DOUBLE_TOLERANCE) ) {
+			*axis  = Vector3<T>(x, y, z).Normalized();
+			*angle = 2 * Acos(w);
+			if (*angle > ((T)MATH_DOUBLE_PI)) // Reduce the magnitude of the angle, if necessary
+			{
+				*angle = ((T)MATH_DOUBLE_TWOPI) - *angle;
+				*axis = *axis * (-1);
+			}
+		}
+		else 
+		{
+			*axis = Vector3<T>(1, 0, 0);
+			*angle= 0;
+		}
+    }
+
+    // Constructs the quaternion from a rotation matrix
+    explicit Quat(const Matrix4<T>& m)
+    {
+        T trace = m.M[0][0] + m.M[1][1] + m.M[2][2];
+
+        // In almost all cases, the first part is executed.
+        // However, if the trace is not positive, the other
+        // cases arise.
+        if (trace > T(0)) 
+        {
+            T s = sqrt(trace + T(1)) * T(2); // s=4*qw
+            w = T(0.25) * s;
+            x = (m.M[2][1] - m.M[1][2]) / s;
+            y = (m.M[0][2] - m.M[2][0]) / s;
+            z = (m.M[1][0] - m.M[0][1]) / s; 
+        } 
+        else if ((m.M[0][0] > m.M[1][1])&&(m.M[0][0] > m.M[2][2])) 
+        {
+            T s = sqrt(T(1) + m.M[0][0] - m.M[1][1] - m.M[2][2]) * T(2);
+            w = (m.M[2][1] - m.M[1][2]) / s;
+            x = T(0.25) * s;
+            y = (m.M[0][1] + m.M[1][0]) / s;
+            z = (m.M[2][0] + m.M[0][2]) / s;
+        } 
+        else if (m.M[1][1] > m.M[2][2]) 
+        {
+            T s = sqrt(T(1) + m.M[1][1] - m.M[0][0] - m.M[2][2]) * T(2); // S=4*qy
+            w = (m.M[0][2] - m.M[2][0]) / s;
+            x = (m.M[0][1] + m.M[1][0]) / s;
+            y = T(0.25) * s;
+            z = (m.M[1][2] + m.M[2][1]) / s;
+        } 
+        else 
+        {
+            T s = sqrt(T(1) + m.M[2][2] - m.M[0][0] - m.M[1][1]) * T(2); // S=4*qz
+            w = (m.M[1][0] - m.M[0][1]) / s;
+            x = (m.M[0][2] + m.M[2][0]) / s;
+            y = (m.M[1][2] + m.M[2][1]) / s;
+            z = T(0.25) * s;
+        }
+    }
+
+	// Constructs the quaternion from a rotation matrix
+	explicit Quat(const Matrix3<T>& m)
+	{
+		T trace = m.M[0][0] + m.M[1][1] + m.M[2][2];
+
+		// In almost all cases, the first part is executed.
+		// However, if the trace is not positive, the other
+		// cases arise.
+		if (trace > T(0)) 
+		{
+			T s = sqrt(trace + T(1)) * T(2); // s=4*qw
+			w = T(0.25) * s;
+			x = (m.M[2][1] - m.M[1][2]) / s;
+			y = (m.M[0][2] - m.M[2][0]) / s;
+			z = (m.M[1][0] - m.M[0][1]) / s; 
+		} 
+		else if ((m.M[0][0] > m.M[1][1])&&(m.M[0][0] > m.M[2][2])) 
+		{
+			T s = sqrt(T(1) + m.M[0][0] - m.M[1][1] - m.M[2][2]) * T(2);
+			w = (m.M[2][1] - m.M[1][2]) / s;
+			x = T(0.25) * s;
+			y = (m.M[0][1] + m.M[1][0]) / s;
+			z = (m.M[2][0] + m.M[0][2]) / s;
+		} 
+		else if (m.M[1][1] > m.M[2][2]) 
+		{
+			T s = sqrt(T(1) + m.M[1][1] - m.M[0][0] - m.M[2][2]) * T(2); // S=4*qy
+			w = (m.M[0][2] - m.M[2][0]) / s;
+			x = (m.M[0][1] + m.M[1][0]) / s;
+			y = T(0.25) * s;
+			z = (m.M[1][2] + m.M[2][1]) / s;
+		} 
+		else 
+		{
+			T s = sqrt(T(1) + m.M[2][2] - m.M[0][0] - m.M[1][1]) * T(2); // S=4*qz
+			w = (m.M[1][0] - m.M[0][1]) / s;
+			x = (m.M[0][2] + m.M[2][0]) / s;
+			y = (m.M[1][2] + m.M[2][1]) / s;
+			z = T(0.25) * s;
+		}
+	}
+
+    bool operator== (const Quat& b) const   { return x == b.x && y == b.y && z == b.z && w == b.w; }
+    bool operator!= (const Quat& b) const   { return x != b.x || y != b.y || z != b.z || w != b.w; }
+
+    Quat  operator+  (const Quat& b) const  { return Quat(x + b.x, y + b.y, z + b.z, w + b.w); }
+    Quat& operator+= (const Quat& b)        { w += b.w; x += b.x; y += b.y; z += b.z; return *this; }
+    Quat  operator-  (const Quat& b) const  { return Quat(x - b.x, y - b.y, z - b.z, w - b.w); }
+    Quat& operator-= (const Quat& b)        { w -= b.w; x -= b.x; y -= b.y; z -= b.z; return *this; }
+
+    Quat  operator*  (T s) const            { return Quat(x * s, y * s, z * s, w * s); }
+    Quat& operator*= (T s)                  { w *= s; x *= s; y *= s; z *= s; return *this; }
+    Quat  operator/  (T s) const            { T rcp = T(1)/s; return Quat(x * rcp, y * rcp, z * rcp, w *rcp); }
+    Quat& operator/= (T s)                  { T rcp = T(1)/s; w *= rcp; x *= rcp; y *= rcp; z *= rcp; return *this; }
+
+
+    // Get Imaginary part vector
+    Vector3<T> Imag() const                 { return Vector3<T>(x,y,z); }
+
+    // Get quaternion length.
+    T       Length() const                  { return sqrt(LengthSq()); }
+
+    // Get quaternion length squared.
+    T       LengthSq() const                { return (x * x + y * y + z * z + w * w); }
+
+    // Simple Euclidean distance in R^4 (not SLERP distance, but at least respects Haar measure)
+    T       Distance(const Quat& q) const	
+	{ 
+        T d1 = (*this - q).Length();
+        T d2 = (*this + q).Length(); // Antipodal point check
+        return (d1 < d2) ? d1 : d2;
+	}
+
+    T       DistanceSq(const Quat& q) const
+    {
+        T d1 = (*this - q).LengthSq();
+        T d2 = (*this + q).LengthSq(); // Antipodal point check
+        return (d1 < d2) ? d1 : d2;
+    }
+
+    T       Dot(const Quat& q) const
+    {
+        return x * q.x + y * q.y + z * q.z + w * q.w;
+    }
+
+	// Angle between two quaternions in radians
+    T       Angle(const Quat& q) const
+	{
+		return 2 * Acos(Alg::Abs(Dot(q)));
+	}
+
+    // Normalize
+    bool    IsNormalized() const            { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    void    Normalize()                     
+	{
+ 		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+	Quat    Normalized() const              
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Returns conjugate of the quaternion. Produces inverse rotation if quaternion is normalized.
+    Quat    Conj() const                    { return Quat(-x, -y, -z, w); }
+
+    // Quaternion multiplication. Combines quaternion rotations, performing the one on the 
+    // right hand side first.
+    Quat  operator* (const Quat& b) const   { return Quat(w * b.x + x * b.w + y * b.z - z * b.y,
+                                                          w * b.y - x * b.z + y * b.w + z * b.x,
+                                                          w * b.z + x * b.y - y * b.x + z * b.w,
+                                                          w * b.w - x * b.x - y * b.y - z * b.z); }
+
+    // 
+    // this^p normalized; same as rotating by this p times.
+    Quat PowNormalized(T p) const
+    {
+        Vector3<T> v;
+        T          a;
+        GetAxisAngle(&v, &a);
+        return Quat(v, a * p);
+    }
+
+    // Normalized linear interpolation of quaternions
+    Quat Nlerp(const Quat& other, T a)
+    {
+        T sign = (Dot(other) >= 0) ? 1 : -1;
+        return (*this * sign * a + other * (1-a)).Normalized();
+    }
+    
+    // Rotate transforms vector in a manner that matches Matrix rotations (counter-clockwise,
+    // assuming negative direction of the axis). Standard formula: q(t) * V * q(t)^-1. 
+    Vector3<T> Rotate(const Vector3<T>& v) const
+    {
+        return ((*this * Quat<T>(v.x, v.y, v.z, T(0))) * Inverted()).Imag();
+    }
+    
+    // Inversed quaternion rotates in the opposite direction.
+    Quat        Inverted() const
+    {
+        return Quat(-x, -y, -z, w);
+    }
+
+    // Sets this quaternion to the one rotates in the opposite direction.
+    void        Invert()
+    {
+        *this = Quat(-x, -y, -z, w);
+    }
+    
+    // GetEulerAngles extracts Euler angles from the quaternion, in the specified order of
+    // axis rotations and the specified coordinate system. Right-handed coordinate system
+    // is the default, with CCW rotations while looking in the negative axis direction.
+    // Here a,b,c, are the Yaw/Pitch/Roll angles to be returned.
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A3
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+	template <Axis A1, Axis A2, Axis A3, RotateDirection D, HandedSystem S>
+    void GetEulerAngles(T *a, T *b, T *c) const 
+    {
+        OVR_COMPILER_ASSERT((A1 != A2) && (A2 != A3) && (A1 != A3));
+
+        T Q[3] = { x, y, z };  //Quaternion components x,y,z
+
+        T ww  = w*w;
+        T Q11 = Q[A1]*Q[A1];
+        T Q22 = Q[A2]*Q[A2];
+        T Q33 = Q[A3]*Q[A3];
+
+        T psign = T(-1);
+        // Determine whether even permutation
+        if (((A1 + 1) % 3 == A2) && ((A2 + 1) % 3 == A3))
+            psign = T(1);
+        
+        T s2 = psign * T(2) * (psign*w*Q[A2] + Q[A1]*Q[A3]);
+
+        if (s2 < T(-1) + ((T)MATH_DOUBLE_SINGULARITYRADIUS))
+        { // South pole singularity
+            *a = T(0);
+            *b = -S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2(T(2)*(psign*Q[A1]*Q[A2] + w*Q[A3]),
+		                   ww + Q22 - Q11 - Q33 );
+        }
+        else if (s2 > T(1) - ((T)MATH_DOUBLE_SINGULARITYRADIUS))
+        {  // North pole singularity
+            *a = T(0);
+            *b = S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2(T(2)*(psign*Q[A1]*Q[A2] + w*Q[A3]),
+		                   ww + Q22 - Q11 - Q33);
+        }
+        else
+        {
+            *a = -S*D*atan2(T(-2)*(w*Q[A1] - psign*Q[A2]*Q[A3]),
+		                    ww + Q33 - Q11 - Q22);
+            *b = S*D*asin(s2);
+            *c = S*D*atan2(T(2)*(w*Q[A3] - psign*Q[A1]*Q[A2]),
+		                   ww + Q11 - Q22 - Q33);
+        }      
+        return;
+    }
+
+    template <Axis A1, Axis A2, Axis A3, RotateDirection D>
+    void GetEulerAngles(T *a, T *b, T *c) const
+    { GetEulerAngles<A1, A2, A3, D, Handed_R>(a, b, c); }
+
+    template <Axis A1, Axis A2, Axis A3>
+    void GetEulerAngles(T *a, T *b, T *c) const
+    { GetEulerAngles<A1, A2, A3, Rotate_CCW, Handed_R>(a, b, c); }
+
+    // GetEulerAnglesABA extracts Euler angles from the quaternion, in the specified order of
+    // axis rotations and the specified coordinate system. Right-handed coordinate system
+    // is the default, with CCW rotations while looking in the negative axis direction.
+    // Here a,b,c, are the Yaw/Pitch/Roll angles to be returned.
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A1
+    // Rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, RotateDirection D, HandedSystem S>
+    void GetEulerAnglesABA(T *a, T *b, T *c) const
+    {
+        OVR_COMPILER_ASSERT(A1 != A2);
+
+        T Q[3] = {x, y, z}; // Quaternion components
+
+        // Determine the missing axis that was not supplied
+        int m = 3 - A1 - A2;
+
+        T ww = w*w;
+        T Q11 = Q[A1]*Q[A1];
+        T Q22 = Q[A2]*Q[A2];
+        T Qmm = Q[m]*Q[m];
+
+        T psign = T(-1);
+        if ((A1 + 1) % 3 == A2) // Determine whether even permutation
+        {
+            psign = T(1);
+        }
+
+        T c2 = ww + Q11 - Q22 - Qmm;
+        if (c2 < T(-1) + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = T(0);
+            *b = S*D*((T)MATH_DOUBLE_PI);
+            *c = S*D*atan2( T(2)*(w*Q[A1] - psign*Q[A2]*Q[m]),
+		                    ww + Q22 - Q11 - Qmm);
+        }
+        else if (c2 > T(1) - Math<T>::SingularityRadius)
+        {  // North pole singularity
+            *a = T(0);
+            *b = T(0);
+            *c = S*D*atan2( T(2)*(w*Q[A1] - psign*Q[A2]*Q[m]),
+		                   ww + Q22 - Q11 - Qmm);
+        }
+        else
+        {
+            *a = S*D*atan2( psign*w*Q[m] + Q[A1]*Q[A2],
+		                   w*Q[A2] -psign*Q[A1]*Q[m]);
+            *b = S*D*acos(c2);
+            *c = S*D*atan2( -psign*w*Q[m] + Q[A1]*Q[A2],
+		                   w*Q[A2] + psign*Q[A1]*Q[m]);
+        }
+        return;
+    }
+};
+
+typedef Quat<float>  Quatf;
+typedef Quat<double> Quatd;
+
+//-------------------------------------------------------------------------------------
+// ***** Pose
+
+// Position and orientation combined.
+
+template<class T>
+class Pose
+{
+public:
+    typedef typename CompatibleTypes<Pose<T> >::Type CompatibleType;
+
+    Pose() { }
+    Pose(const Quat<T>& orientation, const Vector3<T>& pos)
+        : Rotation(orientation), Translation(pos) {  }
+    Pose(const Pose& s)
+        : Rotation(s.Rotation), Translation(s.Translation) {  }
+    Pose(const CompatibleType& s)
+        : Rotation(s.Orientation), Translation(s.Position) {  }
+    explicit Pose(const Pose<typename Math<T>::OtherFloatType> &s)
+        : Rotation(s.Rotation), Translation(s.Translation) {  }
+
+    operator typename CompatibleTypes<Pose<T> >::Type () const
+    {
+        typename CompatibleTypes<Pose<T> >::Type result;
+        result.Orientation = Rotation;
+        result.Position = Translation;
+        return result;
+    }
+
+    Quat<T>    Rotation;
+    Vector3<T> Translation;
+
+    Vector3<T> Rotate(const Vector3<T>& v) const
+    {
+        return Rotation.Rotate(v);
+    }
+
+    Vector3<T> Translate(const Vector3<T>& v) const
+    {
+        return v + Translation;
+    }
+
+    Vector3<T> Apply(const Vector3<T>& v) const
+    {
+        return Translate(Rotate(v));
+    }
+
+    Pose operator*(const Pose& other) const   
+    {
+        return Pose(Rotation * other.Rotation, Apply(other.Translation));
+    }
+
+    Pose Inverted() const   
+    {
+        Quat<T> inv = Rotation.Inverted();
+        return Pose(inv, inv.Rotate(-Translation));
+    }
+};
+
+typedef Pose<float>  Posef;
+typedef Pose<double> Posed;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Matrix4
+//
+// Matrix4 is a 4x4 matrix used for 3d transformations and projections.
+// Translation stored in the last column.
+// The matrix is stored in row-major order in memory, meaning that values
+// of the first row are stored before the next one.
+//
+// The arrangement of the matrix is chosen to be in Right-Handed 
+// coordinate system and counterclockwise rotations when looking down
+// the axis
+//
+// Transformation Order:
+//   - Transformations are applied from right to left, so the expression
+//     M1 * M2 * M3 * V means that the vector V is transformed by M3 first,
+//     followed by M2 and M1. 
+//
+// Coordinate system: Right Handed
+//
+// Rotations: Counterclockwise when looking down the axis. All angles are in radians.
+//    
+//  | sx   01   02   tx |    // First column  (sx, 10, 20): Axis X basis vector.
+//  | 10   sy   12   ty |    // Second column (01, sy, 21): Axis Y basis vector.
+//  | 20   21   sz   tz |    // Third columnt (02, 12, sz): Axis Z basis vector.
+//  | 30   31   32   33 |
+//
+//  The basis vectors are first three columns.
+
+template<class T>
+class Matrix4
+{
+    static const Matrix4 IdentityValue;
+
+public:
+    T M[4][4];    
+
+    enum NoInitType { NoInit };
+
+    // Construct with no memory initialization.
+    Matrix4(NoInitType) { }
+
+    // By default, we construct identity matrix.
+    Matrix4()
+    {
+        SetIdentity();        
+    }
+
+    Matrix4(T m11, T m12, T m13, T m14,
+            T m21, T m22, T m23, T m24,
+            T m31, T m32, T m33, T m34,
+            T m41, T m42, T m43, T m44)
+    {
+        M[0][0] = m11; M[0][1] = m12; M[0][2] = m13; M[0][3] = m14;
+        M[1][0] = m21; M[1][1] = m22; M[1][2] = m23; M[1][3] = m24;
+        M[2][0] = m31; M[2][1] = m32; M[2][2] = m33; M[2][3] = m34;
+        M[3][0] = m41; M[3][1] = m42; M[3][2] = m43; M[3][3] = m44;
+    }
+
+    Matrix4(T m11, T m12, T m13,
+            T m21, T m22, T m23,
+            T m31, T m32, T m33)
+    {
+        M[0][0] = m11; M[0][1] = m12; M[0][2] = m13; M[0][3] = 0;
+        M[1][0] = m21; M[1][1] = m22; M[1][2] = m23; M[1][3] = 0;
+        M[2][0] = m31; M[2][1] = m32; M[2][2] = m33; M[2][3] = 0;
+        M[3][0] = 0;   M[3][1] = 0;   M[3][2] = 0;   M[3][3] = 1;
+    }
+
+    explicit Matrix4(const Quat<T>& q)
+    {
+        T ww = q.w*q.w;
+        T xx = q.x*q.x;
+        T yy = q.y*q.y;
+        T zz = q.z*q.z;
+
+        M[0][0] = ww + xx - yy - zz;       M[0][1] = 2 * (q.x*q.y - q.w*q.z); M[0][2] = 2 * (q.x*q.z + q.w*q.y); M[0][3] = 0;
+        M[1][0] = 2 * (q.x*q.y + q.w*q.z); M[1][1] = ww - xx + yy - zz;       M[1][2] = 2 * (q.y*q.z - q.w*q.x); M[1][3] = 0;
+        M[2][0] = 2 * (q.x*q.z - q.w*q.y); M[2][1] = 2 * (q.y*q.z + q.w*q.x); M[2][2] = ww - xx - yy + zz;       M[2][3] = 0;
+        M[3][0] = 0;                       M[3][1] = 0;                       M[3][2] = 0;                       M[3][3] = 1;
+    }
+
+    explicit Matrix4(const Pose<T>& p)
+    {
+        Matrix4 result(p.Rotation);
+        result.SetTranslation(p.Translation);
+        *this = result;
+    }
+
+    // C-interop support
+    explicit Matrix4(const Matrix4<typename Math<T>::OtherFloatType> &src)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] = (T)src.M[i][j];
+    }
+
+    // C-interop support.
+    Matrix4(const typename CompatibleTypes<Matrix4<T> >::Type& s) 
+    {
+        OVR_COMPILER_ASSERT(sizeof(s) == sizeof(Matrix4));
+        memcpy(M, s.M, sizeof(M));
+    }
+
+    operator typename CompatibleTypes<Matrix4<T> >::Type () const
+    {
+        typename CompatibleTypes<Matrix4<T> >::Type result;
+        OVR_COMPILER_ASSERT(sizeof(result) == sizeof(Matrix4));
+        memcpy(result.M, M, sizeof(M));
+        return result;
+    }
+
+    void ToString(char* dest, size_t destsize) const
+    {
+        size_t pos = 0;
+        for (int r=0; r<4; r++)
+            for (int c=0; c<4; c++)
+                pos += OVR_sprintf(dest+pos, destsize-pos, "%g ", M[r][c]);
+    }
+
+    static Matrix4 FromString(const char* src)
+    {
+        Matrix4 result;
+		if (src)
+		{
+        for (int r=0; r<4; r++)
+			{
+            for (int c=0; c<4; c++)
+            {
+                result.M[r][c] = (T)atof(src);
+                while (src && *src != ' ')
+					{
+                    src++;
+					}
+                while (src && *src == ' ')
+					{
+                    src++;
+            }
+				}
+			}
+		}
+        return result;
+    }
+
+    static const Matrix4& Identity()  { return IdentityValue; }
+
+    void SetIdentity()
+    {
+        M[0][0] = M[1][1] = M[2][2] = M[3][3] = 1;
+        M[0][1] = M[1][0] = M[2][3] = M[3][1] = 0;
+        M[0][2] = M[1][2] = M[2][0] = M[3][2] = 0;
+        M[0][3] = M[1][3] = M[2][1] = M[3][0] = 0;
+    }
+
+	void SetXBasis(const Vector3f & v)
+	{
+		M[0][0] = v.x;
+		M[1][0] = v.y;
+		M[2][0] = v.z;
+	}
+	Vector3f GetXBasis() const
+	{
+		return Vector3f(M[0][0], M[1][0], M[2][0]);
+	}
+
+	void SetYBasis(const Vector3f & v)
+	{
+		M[0][1] = v.x;
+		M[1][1] = v.y;
+		M[2][1] = v.z;
+	}
+	Vector3f GetYBasis() const
+	{
+		return Vector3f(M[0][1], M[1][1], M[2][1]);
+	}
+
+	void SetZBasis(const Vector3f & v)
+	{
+		M[0][2] = v.x;
+		M[1][2] = v.y;
+		M[2][2] = v.z;
+	}
+	Vector3f GetZBasis() const
+	{
+		return Vector3f(M[0][2], M[1][2], M[2][2]);
+	}
+
+	bool operator== (const Matrix4& b) const
+	{
+		bool isEqual = true;
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                isEqual &= (M[i][j] == b.M[i][j]);
+
+		return isEqual;
+	}
+
+    Matrix4 operator+ (const Matrix4& b) const
+    {
+        Matrix4 result(*this);
+        result += b;
+        return result;
+    }
+
+    Matrix4& operator+= (const Matrix4& b)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] += b.M[i][j];
+        return *this;
+    }
+
+    Matrix4 operator- (const Matrix4& b) const
+    {
+        Matrix4 result(*this);
+        result -= b;
+        return result;
+    }
+
+    Matrix4& operator-= (const Matrix4& b)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] -= b.M[i][j];
+        return *this;
+    }
+
+    // Multiplies two matrices into destination with minimum copying.
+    static Matrix4& Multiply(Matrix4* d, const Matrix4& a, const Matrix4& b)
+    {
+        OVR_ASSERT((d != &a) && (d != &b));
+        int i = 0;
+        do {
+            d->M[i][0] = a.M[i][0] * b.M[0][0] + a.M[i][1] * b.M[1][0] + a.M[i][2] * b.M[2][0] + a.M[i][3] * b.M[3][0];
+            d->M[i][1] = a.M[i][0] * b.M[0][1] + a.M[i][1] * b.M[1][1] + a.M[i][2] * b.M[2][1] + a.M[i][3] * b.M[3][1];
+            d->M[i][2] = a.M[i][0] * b.M[0][2] + a.M[i][1] * b.M[1][2] + a.M[i][2] * b.M[2][2] + a.M[i][3] * b.M[3][2];
+            d->M[i][3] = a.M[i][0] * b.M[0][3] + a.M[i][1] * b.M[1][3] + a.M[i][2] * b.M[2][3] + a.M[i][3] * b.M[3][3];
+        } while((++i) < 4);
+
+        return *d;
+    }
+
+    Matrix4 operator* (const Matrix4& b) const
+    {
+        Matrix4 result(Matrix4::NoInit);
+        Multiply(&result, *this, b);
+        return result;
+    }
+
+    Matrix4& operator*= (const Matrix4& b)
+    {
+        return Multiply(this, Matrix4(*this), b);
+    }
+
+    Matrix4 operator* (T s) const
+    {
+        Matrix4 result(*this);
+        result *= s;
+        return result;
+    }
+
+    Matrix4& operator*= (T s)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] *= s;
+        return *this;
+    }
+
+
+    Matrix4 operator/ (T s) const
+    {
+        Matrix4 result(*this);
+        result /= s;
+        return result;
+    }
+
+    Matrix4& operator/= (T s)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] /= s;
+        return *this;
+    }
+
+    Vector3<T> Transform(const Vector3<T>& v) const
+    {
+		const T rcpW = 1.0f / (M[3][0] * v.x + M[3][1] * v.y + M[3][2] * v.z + M[3][3]);
+		return Vector3<T>((M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z + M[0][3]) * rcpW,
+						  (M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z + M[1][3]) * rcpW,
+						  (M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z + M[2][3]) * rcpW);
+	}
+
+	Vector4<T> Transform(const Vector4<T>& v) const
+	{
+		return Vector4<T>(M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z + M[0][3] * v.w,
+						  M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z + M[1][3] * v.w,
+						  M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z + M[2][3] * v.w,
+						  M[3][0] * v.x + M[3][1] * v.y + M[3][2] * v.z + M[3][3] * v.w);
+    }
+
+    Matrix4 Transposed() const
+    {
+        return Matrix4(M[0][0], M[1][0], M[2][0], M[3][0],
+                        M[0][1], M[1][1], M[2][1], M[3][1],
+                        M[0][2], M[1][2], M[2][2], M[3][2],
+                        M[0][3], M[1][3], M[2][3], M[3][3]);
+    }
+
+    void     Transpose()
+    {
+        *this = Transposed();
+    }
+
+
+    T SubDet (const size_t* rows, const size_t* cols) const
+    {
+        return M[rows[0]][cols[0]] * (M[rows[1]][cols[1]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[1]])
+             - M[rows[0]][cols[1]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[0]])
+             + M[rows[0]][cols[2]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[1]] - M[rows[1]][cols[1]] * M[rows[2]][cols[0]]);
+    }
+
+    T Cofactor(size_t I, size_t J) const
+    {
+        const size_t indices[4][3] = {{1,2,3},{0,2,3},{0,1,3},{0,1,2}};
+        return ((I+J)&1) ? -SubDet(indices[I],indices[J]) : SubDet(indices[I],indices[J]);
+    }
+
+    T    Determinant() const
+    {
+        return M[0][0] * Cofactor(0,0) + M[0][1] * Cofactor(0,1) + M[0][2] * Cofactor(0,2) + M[0][3] * Cofactor(0,3);
+    }
+
+    Matrix4 Adjugated() const
+    {
+        return Matrix4(Cofactor(0,0), Cofactor(1,0), Cofactor(2,0), Cofactor(3,0), 
+                        Cofactor(0,1), Cofactor(1,1), Cofactor(2,1), Cofactor(3,1), 
+                        Cofactor(0,2), Cofactor(1,2), Cofactor(2,2), Cofactor(3,2),
+                        Cofactor(0,3), Cofactor(1,3), Cofactor(2,3), Cofactor(3,3));
+    }
+
+    Matrix4 Inverted() const
+    {
+        T det = Determinant();
+        assert(det != 0);
+        return Adjugated() * (1.0f/det);
+    }
+
+    void Invert()
+    {
+        *this = Inverted();
+    }
+
+	// This is more efficient than general inverse, but ONLY works
+	// correctly if it is a homogeneous transform matrix (rot + trans)
+	Matrix4 InvertedHomogeneousTransform() const
+	{
+		// Make the inverse rotation matrix
+		Matrix4 rinv = this->Transposed();
+		rinv.M[3][0] = rinv.M[3][1] = rinv.M[3][2] = 0.0f;
+		// Make the inverse translation matrix
+		Vector3<T> tvinv(-M[0][3],-M[1][3],-M[2][3]);
+		Matrix4 tinv = Matrix4::Translation(tvinv);
+		return rinv * tinv;  // "untranslate", then "unrotate"
+	}
+
+	// This is more efficient than general inverse, but ONLY works
+	// correctly if it is a homogeneous transform matrix (rot + trans)
+	void InvertHomogeneousTransform()
+	{
+        *this = InvertedHomogeneousTransform();
+	}
+
+	// Matrix to Euler Angles conversion
+    // a,b,c, are the YawPitchRoll angles to be returned
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A3
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, Axis A3, RotateDirection D, HandedSystem S>
+    void ToEulerAngles(T *a, T *b, T *c) const
+    {
+        OVR_COMPILER_ASSERT((A1 != A2) && (A2 != A3) && (A1 != A3));
+
+        T psign = -1;
+        if (((A1 + 1) % 3 == A2) && ((A2 + 1) % 3 == A3)) // Determine whether even permutation
+        psign = 1;
+        
+        T pm = psign*M[A1][A3];
+        if (pm < -1.0f + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = 0;
+            *b = -S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2( psign*M[A2][A1], M[A2][A2] );
+        }
+        else if (pm > 1.0f - Math<T>::SingularityRadius)
+        { // North pole singularity
+            *a = 0;
+            *b = S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2( psign*M[A2][A1], M[A2][A2] );
+        }
+        else
+        { // Normal case (nonsingular)
+            *a = S*D*atan2( -psign*M[A2][A3], M[A3][A3] );
+            *b = S*D*asin(pm);
+            *c = S*D*atan2( -psign*M[A1][A2], M[A1][A1] );
+        }
+
+        return;
+    }
+
+	// Matrix to Euler Angles conversion
+    // a,b,c, are the YawPitchRoll angles to be returned
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A1
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, RotateDirection D, HandedSystem S>
+    void ToEulerAnglesABA(T *a, T *b, T *c) const
+    {        
+         OVR_COMPILER_ASSERT(A1 != A2);
+  
+        // Determine the axis that was not supplied
+        int m = 3 - A1 - A2;
+
+        T psign = -1;
+        if ((A1 + 1) % 3 == A2) // Determine whether even permutation
+            psign = 1.0f;
+
+        T c2 = M[A1][A1];
+        if (c2 < -1 + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = 0;
+            *b = S*D*((T)MATH_DOUBLE_PI);
+            *c = S*D*atan2( -psign*M[A2][m],M[A2][A2]);
+        }
+        else if (c2 > 1.0f - Math<T>::SingularityRadius)
+        { // North pole singularity
+            *a = 0;
+            *b = 0;
+            *c = S*D*atan2( -psign*M[A2][m],M[A2][A2]);
+        }
+        else
+        { // Normal case (nonsingular)
+            *a = S*D*atan2( M[A2][A1],-psign*M[m][A1]);
+            *b = S*D*acos(c2);
+            *c = S*D*atan2( M[A1][A2],psign*M[A1][m]);
+        }
+        return;
+    }
+  
+    // Creates a matrix that converts the vertices from one coordinate system
+    // to another.
+    static Matrix4 AxisConversion(const WorldAxes& to, const WorldAxes& from)
+    {        
+        // Holds axis values from the 'to' structure
+        int toArray[3] = { to.XAxis, to.YAxis, to.ZAxis };
+
+        // The inverse of the toArray
+        int inv[4]; 
+        inv[0] = inv[abs(to.XAxis)] = 0;
+        inv[abs(to.YAxis)] = 1;
+        inv[abs(to.ZAxis)] = 2;
+
+        Matrix4 m(0,  0,  0, 
+                  0,  0,  0,
+                  0,  0,  0);
+
+        // Only three values in the matrix need to be changed to 1 or -1.
+        m.M[inv[abs(from.XAxis)]][0] = T(from.XAxis/toArray[inv[abs(from.XAxis)]]);
+        m.M[inv[abs(from.YAxis)]][1] = T(from.YAxis/toArray[inv[abs(from.YAxis)]]);
+        m.M[inv[abs(from.ZAxis)]][2] = T(from.ZAxis/toArray[inv[abs(from.ZAxis)]]);
+        return m;
+    } 
+
+
+	// Creates a matrix for translation by vector
+    static Matrix4 Translation(const Vector3<T>& v)
+    {
+        Matrix4 t;
+        t.M[0][3] = v.x;
+        t.M[1][3] = v.y;
+        t.M[2][3] = v.z;
+        return t;
+    }
+
+	// Creates a matrix for translation by vector
+    static Matrix4 Translation(T x, T y, T z = 0.0f)
+    {
+        Matrix4 t;
+        t.M[0][3] = x;
+        t.M[1][3] = y;
+        t.M[2][3] = z;
+        return t;
+    }
+
+	// Sets the translation part
+    void SetTranslation(const Vector3<T>& v)
+    {
+        M[0][3] = v.x;
+        M[1][3] = v.y;
+        M[2][3] = v.z;
+    }
+
+    Vector3<T> GetTranslation() const
+    {
+        return Vector3<T>( M[0][3], M[1][3], M[2][3] );
+    }
+
+	// Creates a matrix for scaling by vector
+    static Matrix4 Scaling(const Vector3<T>& v)
+    {
+        Matrix4 t;
+        t.M[0][0] = v.x;
+        t.M[1][1] = v.y;
+        t.M[2][2] = v.z;
+        return t;
+    }
+
+	// Creates a matrix for scaling by vector
+    static Matrix4 Scaling(T x, T y, T z)
+    {
+        Matrix4 t;
+        t.M[0][0] = x;
+        t.M[1][1] = y;
+        t.M[2][2] = z;
+        return t;
+    }
+
+	// Creates a matrix for scaling by constant
+    static Matrix4 Scaling(T s)
+    {
+        Matrix4 t;
+        t.M[0][0] = s;
+        t.M[1][1] = s;
+        t.M[2][2] = s;
+        return t;
+    }
+
+    // Simple L1 distance in R^12
+	T Distance(const Matrix4& m2) const           
+	{ 
+		T d = fabs(M[0][0] - m2.M[0][0]) + fabs(M[0][1] - m2.M[0][1]);
+		d += fabs(M[0][2] - m2.M[0][2]) + fabs(M[0][3] - m2.M[0][3]);
+		d += fabs(M[1][0] - m2.M[1][0]) + fabs(M[1][1] - m2.M[1][1]);
+		d += fabs(M[1][2] - m2.M[1][2]) + fabs(M[1][3] - m2.M[1][3]);
+		d += fabs(M[2][0] - m2.M[2][0]) + fabs(M[2][1] - m2.M[2][1]);
+		d += fabs(M[2][2] - m2.M[2][2]) + fabs(M[2][3] - m2.M[2][3]);
+		d += fabs(M[3][0] - m2.M[3][0]) + fabs(M[3][1] - m2.M[3][1]);
+		d += fabs(M[3][2] - m2.M[3][2]) + fabs(M[3][3] - m2.M[3][3]);
+		return d; 
+	}
+
+    // Creates a rotation matrix rotating around the X axis by 'angle' radians.
+    // Just for quick testing.  Not for final API.  Need to remove case.
+    static Matrix4 RotationAxis(Axis A, T angle, RotateDirection d, HandedSystem s)
+    {
+        T sina = s * d *sin(angle);
+        T cosa = cos(angle);
+        
+        switch(A)
+        {
+        case Axis_X:
+            return Matrix4(1,  0,     0, 
+                           0,  cosa,  -sina,
+                           0,  sina,  cosa);
+        case Axis_Y:
+            return Matrix4(cosa,  0,   sina, 
+                           0,     1,   0,
+                           -sina, 0,   cosa);
+        case Axis_Z:
+            return Matrix4(cosa,  -sina,  0, 
+                           sina,  cosa,   0,
+                           0,     0,      1);
+        }
+    }
+
+
+    // Creates a rotation matrix rotating around the X axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    // RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    // LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationX(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(1,  0,     0, 
+                       0,  cosa,  -sina,
+                       0,  sina,  cosa);
+    }
+
+    // Creates a rotation matrix rotating around the Y axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    //  RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    //  LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationY(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(cosa,  0,   sina, 
+                       0,     1,   0,
+                       -sina, 0,   cosa);
+    }
+
+    // Creates a rotation matrix rotating around the Z axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    //  RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    //  LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationZ(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(cosa,  -sina,  0, 
+                       sina,  cosa,   0,
+                       0,     0,      1);
+    }
+
+    // LookAtRH creates a View transformation matrix for right-handed coordinate system.
+    // The resulting matrix points camera from 'eye' towards 'at' direction, with 'up'
+    // specifying the up vector. The resulting matrix should be used with PerspectiveRH
+    // projection.
+    static Matrix4 LookAtRH(const Vector3<T>& eye, const Vector3<T>& at, const Vector3<T>& up)
+    {
+        Vector3<T> z = (eye - at).Normalized();  // Forward
+        Vector3<T> x = up.Cross(z).Normalized(); // Right
+        Vector3<T> y = z.Cross(x);
+
+        Matrix4 m(x.x,  x.y,  x.z,  -(x.Dot(eye)),
+                  y.x,  y.y,  y.z,  -(y.Dot(eye)),
+                  z.x,  z.y,  z.z,  -(z.Dot(eye)),
+                  0,    0,    0,    1 );
+        return m;
+    }
+    
+    // LookAtLH creates a View transformation matrix for left-handed coordinate system.
+    // The resulting matrix points camera from 'eye' towards 'at' direction, with 'up'
+    // specifying the up vector. 
+    static Matrix4 LookAtLH(const Vector3<T>& eye, const Vector3<T>& at, const Vector3<T>& up)
+    {
+        Vector3<T> z = (at - eye).Normalized();  // Forward
+        Vector3<T> x = up.Cross(z).Normalized(); // Right
+        Vector3<T> y = z.Cross(x);
+
+        Matrix4 m(x.x,  x.y,  x.z,  -(x.Dot(eye)),
+                  y.x,  y.y,  y.z,  -(y.Dot(eye)),
+                  z.x,  z.y,  z.z,  -(z.Dot(eye)),
+                  0,    0,    0,    1 ); 
+        return m;
+    }
+    
+    // PerspectiveRH creates a right-handed perspective projection matrix that can be
+    // used with the Oculus sample renderer. 
+    //  yfov   - Specifies vertical field of view in radians.
+    //  aspect - Screen aspect ration, which is usually width/height for square pixels.
+    //           Note that xfov = yfov * aspect.
+    //  znear  - Absolute value of near Z clipping clipping range.
+    //  zfar   - Absolute value of far  Z clipping clipping range (larger then near).
+    // Even though RHS usually looks in the direction of negative Z, positive values
+    // are expected for znear and zfar.
+    static Matrix4 PerspectiveRH(T yfov, T aspect, T znear, T zfar)
+    {
+        Matrix4 m;
+        T tanHalfFov = tan(yfov * 0.5f);
+
+        m.M[0][0] = 1. / (aspect * tanHalfFov);
+        m.M[1][1] = 1. / tanHalfFov;
+        m.M[2][2] = zfar / (znear - zfar);
+        m.M[3][2] = -1.;
+        m.M[2][3] = (zfar * znear) / (znear - zfar);
+        m.M[3][3] = 0.;
+
+        // Note: Post-projection matrix result assumes Left-Handed coordinate system,
+        //       with Y up, X right and Z forward. This supports positive z-buffer values.
+		// This is the case even for RHS coordinate input.
+        return m;
+    }
+    
+    // PerspectiveLH creates a left-handed perspective projection matrix that can be
+    // used with the Oculus sample renderer. 
+    //  yfov   - Specifies vertical field of view in radians.
+    //  aspect - Screen aspect ration, which is usually width/height for square pixels.
+    //           Note that xfov = yfov * aspect.
+    //  znear  - Absolute value of near Z clipping clipping range.
+    //  zfar   - Absolute value of far  Z clipping clipping range (larger then near).
+    static Matrix4 PerspectiveLH(T yfov, T aspect, T znear, T zfar)
+    {
+        Matrix4 m;
+        T tanHalfFov = tan(yfov * 0.5f);
+
+        m.M[0][0] = 1. / (aspect * tanHalfFov);
+        m.M[1][1] = 1. / tanHalfFov;
+        //m.M[2][2] = zfar / (znear - zfar);
+         m.M[2][2] = zfar / (zfar - znear);
+        m.M[3][2] = -1.;
+        m.M[2][3] = (zfar * znear) / (znear - zfar);
+        m.M[3][3] = 0.;
+
+        // Note: Post-projection matrix result assumes Left-Handed coordinate system,    
+        //       with Y up, X right and Z forward. This supports positive z-buffer values.
+        // This is the case even for RHS coordinate input. 
+        return m;
+    }
+
+    static Matrix4 Ortho2D(T w, T h)
+    {
+        Matrix4 m;
+        m.M[0][0] = 2.0/w;
+        m.M[1][1] = -2.0/h;
+        m.M[0][3] = -1.0;
+        m.M[1][3] = 1.0;
+        m.M[2][2] = 0;
+        return m;
+    }
+};
+
+typedef Matrix4<float>  Matrix4f;
+typedef Matrix4<double> Matrix4d;
+
+//-------------------------------------------------------------------------------------
+// ***** Matrix3
+//
+// Matrix3 is a 3x3 matrix used for representing a rotation matrix.
+// The matrix is stored in row-major order in memory, meaning that values
+// of the first row are stored before the next one.
+//
+// The arrangement of the matrix is chosen to be in Right-Handed 
+// coordinate system and counterclockwise rotations when looking down
+// the axis
+//
+// Transformation Order:
+//   - Transformations are applied from right to left, so the expression
+//     M1 * M2 * M3 * V means that the vector V is transformed by M3 first,
+//     followed by M2 and M1. 
+//
+// Coordinate system: Right Handed
+//
+// Rotations: Counterclockwise when looking down the axis. All angles are in radians.
+
+template<typename T>
+class SymMat3;
+
+template<class T>
+class Matrix3
+{
+	static const Matrix3 IdentityValue;
+
+public:
+	T M[3][3];    
+
+	enum NoInitType { NoInit };
+
+	// Construct with no memory initialization.
+	Matrix3(NoInitType) { }
+
+	// By default, we construct identity matrix.
+	Matrix3()
+	{
+		SetIdentity();        
+	}
+
+	Matrix3(T m11, T m12, T m13,
+			T m21, T m22, T m23,
+			T m31, T m32, T m33)
+	{
+		M[0][0] = m11; M[0][1] = m12; M[0][2] = m13;
+		M[1][0] = m21; M[1][1] = m22; M[1][2] = m23;
+		M[2][0] = m31; M[2][1] = m32; M[2][2] = m33;
+	}
+	
+	/*
+	explicit Matrix3(const Quat<T>& q)
+	{
+		T ww = q.w*q.w;
+		T xx = q.x*q.x;
+		T yy = q.y*q.y;
+		T zz = q.z*q.z;
+
+		M[0][0] = ww + xx - yy - zz;       M[0][1] = 2 * (q.x*q.y - q.w*q.z); M[0][2] = 2 * (q.x*q.z + q.w*q.y);
+		M[1][0] = 2 * (q.x*q.y + q.w*q.z); M[1][1] = ww - xx + yy - zz;       M[1][2] = 2 * (q.y*q.z - q.w*q.x);
+		M[2][0] = 2 * (q.x*q.z - q.w*q.y); M[2][1] = 2 * (q.y*q.z + q.w*q.x); M[2][2] = ww - xx - yy + zz;      
+	}
+	*/
+	
+	explicit Matrix3(const Quat<T>& q)
+	{
+		const T tx  = q.x+q.x,  ty  = q.y+q.y,  tz  = q.z+q.z;
+		const T twx = q.w*tx,   twy = q.w*ty,   twz = q.w*tz;
+		const T txx = q.x*tx,   txy = q.x*ty,   txz = q.x*tz;
+		const T tyy = q.y*ty,   tyz = q.y*tz,   tzz = q.z*tz;
+		M[0][0] = T(1) - (tyy + tzz);	M[0][1] = txy - twz;			M[0][2] = txz + twy;
+		M[1][0] = txy + twz;			M[1][1] = T(1) - (txx + tzz);	M[1][2] = tyz - twx;
+		M[2][0] = txz - twy;			M[2][1] = tyz + twx;			M[2][2] = T(1) - (txx + tyy);
+	}
+	
+	inline explicit Matrix3(T s)
+    {
+        M[0][0] = M[1][1] = M[2][2] = s;
+        M[0][1] = M[0][2] = M[1][0] = M[1][2] = M[2][0] = M[2][1] = 0;
+    }
+
+	explicit Matrix3(const Pose<T>& p)
+	{
+		Matrix3 result(p.Rotation);
+		result.SetTranslation(p.Translation);
+		*this = result;
+	}
+
+	// C-interop support
+	explicit Matrix3(const Matrix4<typename Math<T>::OtherFloatType> &src)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = (T)src.M[i][j];
+	}
+
+	// C-interop support.
+	Matrix3(const typename CompatibleTypes<Matrix3<T> >::Type& s) 
+	{
+		OVR_COMPILER_ASSERT(sizeof(s) == sizeof(Matrix3));
+		memcpy(M, s.M, sizeof(M));
+	}
+
+	operator const typename CompatibleTypes<Matrix3<T> >::Type () const
+	{
+		typename CompatibleTypes<Matrix3<T> >::Type result;
+		OVR_COMPILER_ASSERT(sizeof(result) == sizeof(Matrix3));
+		memcpy(result.M, M, sizeof(M));
+		return result;
+	}
+
+	void ToString(char* dest, size_t destsize) const
+	{
+		size_t pos = 0;
+		for (int r=0; r<3; r++)
+			for (int c=0; c<3; c++)
+				pos += OVR_sprintf(dest+pos, destsize-pos, "%g ", M[r][c]);
+	}
+
+	static Matrix3 FromString(const char* src)
+	{
+		Matrix3 result;
+		for (int r=0; r<3; r++)
+			for (int c=0; c<3; c++)
+			{
+				result.M[r][c] = (T)atof(src);
+				while (src && *src != ' ')
+					src++;
+				while (src && *src == ' ')
+					src++;
+			}
+			return result;
+	}
+
+	static const Matrix3& Identity()  { return IdentityValue; }
+
+	void SetIdentity()
+	{
+		M[0][0] = M[1][1] = M[2][2] = 1;
+		M[0][1] = M[1][0] = M[2][0] = 0;
+		M[0][2] = M[1][2] = M[2][1] = 0;
+	}
+
+	bool operator== (const Matrix3& b) const
+	{
+		bool isEqual = true;
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				isEqual &= (M[i][j] == b.M[i][j]);
+
+		return isEqual;
+	}
+
+	Matrix3 operator+ (const Matrix3& b) const
+	{
+        Matrix4<T> result(*this);
+		result += b;
+		return result;
+	}
+
+	Matrix3& operator+= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] += b.M[i][j];
+		return *this;
+	}
+
+	void operator= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = b.M[i][j];
+		return;
+	}
+
+	void operator= (const SymMat3<T>& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = 0;
+
+		M[0][0] = b.v[0];
+		M[0][1] = b.v[1];
+		M[0][2] = b.v[2];
+		M[1][1] = b.v[3];
+		M[1][2] = b.v[4];
+		M[2][2] = b.v[5];
+
+		return;
+	}
+
+	Matrix3 operator- (const Matrix3& b) const
+	{
+		Matrix3 result(*this);
+		result -= b;
+		return result;
+	}
+
+	Matrix3& operator-= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] -= b.M[i][j];
+		return *this;
+	}
+
+	// Multiplies two matrices into destination with minimum copying.
+	static Matrix3& Multiply(Matrix3* d, const Matrix3& a, const Matrix3& b)
+	{
+		OVR_ASSERT((d != &a) && (d != &b));
+		int i = 0;
+		do {
+			d->M[i][0] = a.M[i][0] * b.M[0][0] + a.M[i][1] * b.M[1][0] + a.M[i][2] * b.M[2][0];
+			d->M[i][1] = a.M[i][0] * b.M[0][1] + a.M[i][1] * b.M[1][1] + a.M[i][2] * b.M[2][1];
+			d->M[i][2] = a.M[i][0] * b.M[0][2] + a.M[i][1] * b.M[1][2] + a.M[i][2] * b.M[2][2];
+		} while((++i) < 3);
+
+		return *d;
+	}
+
+	Matrix3 operator* (const Matrix3& b) const
+	{
+		Matrix3 result(Matrix3::NoInit);
+		Multiply(&result, *this, b);
+		return result;
+	}
+
+	Matrix3& operator*= (const Matrix3& b)
+	{
+		return Multiply(this, Matrix3(*this), b);
+	}
+
+	Matrix3 operator* (T s) const
+	{
+		Matrix3 result(*this);
+		result *= s;
+		return result;
+	}
+
+	Matrix3& operator*= (T s)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] *= s;
+		return *this;
+	}
+
+	Vector3<T> operator* (const Vector3<T> &b) const
+	{
+		Vector3<T> result;
+		result.x = M[0][0]*b.x + M[0][1]*b.y + M[0][2]*b.z;
+		result.y = M[1][0]*b.x + M[1][1]*b.y + M[1][2]*b.z;
+		result.z = M[2][0]*b.x + M[2][1]*b.y + M[2][2]*b.z;
+
+		return result;
+	}
+
+	Matrix3 operator/ (T s) const
+	{
+		Matrix3 result(*this);
+		result /= s;
+		return result;
+	}
+
+	Matrix3& operator/= (T s)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] /= s;
+		return *this;
+	}
+
+	Vector2<T> Transform(const Vector2<T>& v) const
+	{
+		const float rcpZ = 1.0f / (M[2][0] * v.x + M[2][1] * v.y + M[2][2]);
+		return Vector2<T>((M[0][0] * v.x + M[0][1] * v.y + M[0][2]) * rcpZ,
+						  (M[1][0] * v.x + M[1][1] * v.y + M[1][2]) * rcpZ);
+	}
+
+	Vector3<T> Transform(const Vector3<T>& v) const
+	{
+		return Vector3<T>(M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z,
+						  M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z,
+						  M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z);
+	}
+
+	Matrix3 Transposed() const
+	{
+		return Matrix3(M[0][0], M[1][0], M[2][0],
+					   M[0][1], M[1][1], M[2][1],
+					   M[0][2], M[1][2], M[2][2]);
+	}
+
+	void     Transpose()
+	{
+		*this = Transposed();
+	}
+
+
+	T SubDet (const size_t* rows, const size_t* cols) const
+	{
+		return M[rows[0]][cols[0]] * (M[rows[1]][cols[1]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[1]])
+			 - M[rows[0]][cols[1]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[0]])
+			 + M[rows[0]][cols[2]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[1]] - M[rows[1]][cols[1]] * M[rows[2]][cols[0]]);
+	}
+
+	// M += a*b.t()
+	inline void Rank1Add(const Vector3<T> &a, const Vector3<T> &b)
+	{
+		M[0][0] += a.x*b.x;		M[0][1] += a.x*b.y;		M[0][2] += a.x*b.z;
+		M[1][0] += a.y*b.x;		M[1][1] += a.y*b.y;		M[1][2] += a.y*b.z;
+		M[2][0] += a.z*b.x;		M[2][1] += a.z*b.y;		M[2][2] += a.z*b.z;
+	}
+
+	// M -= a*b.t()
+	inline void Rank1Sub(const Vector3<T> &a, const Vector3<T> &b)
+	{
+		M[0][0] -= a.x*b.x;		M[0][1] -= a.x*b.y;		M[0][2] -= a.x*b.z;
+		M[1][0] -= a.y*b.x;		M[1][1] -= a.y*b.y;		M[1][2] -= a.y*b.z;
+		M[2][0] -= a.z*b.x;		M[2][1] -= a.z*b.y;		M[2][2] -= a.z*b.z;
+	}
+
+	inline Vector3<T> Col(int c) const
+	{
+		return Vector3<T>(M[0][c], M[1][c], M[2][c]);
+	}
+
+	inline Vector3<T> Row(int r) const
+	{
+        return Vector3<T>(M[r][0], M[r][1], M[r][2]);
+	}
+
+	inline T Determinant() const
+	{
+		const Matrix3<T>& m = *this;
+		T d; 
+
+		d  = m.M[0][0] * (m.M[1][1]*m.M[2][2] - m.M[1][2] * m.M[2][1]);
+		d -= m.M[0][1] * (m.M[1][0]*m.M[2][2] - m.M[1][2] * m.M[2][0]);
+		d += m.M[0][2] * (m.M[1][0]*m.M[2][1] - m.M[1][1] * m.M[2][0]);
+
+		return d;
+	}
+	
+	inline Matrix3<T> Inverse() const
+    {
+        Matrix3<T> a;
+        const  Matrix3<T>& m = *this;
+        T d = Determinant();
+
+        assert(d != 0);
+        T s = T(1)/d;
+
+        a.M[0][0] = s * (m.M[1][1] * m.M[2][2] - m.M[1][2] * m.M[2][1]);   
+        a.M[1][0] = s * (m.M[1][2] * m.M[2][0] - m.M[1][0] * m.M[2][2]);   
+        a.M[2][0] = s * (m.M[1][0] * m.M[2][1] - m.M[1][1] * m.M[2][0]);   
+
+		a.M[0][1] = s * (m.M[0][2] * m.M[2][1] - m.M[0][1] * m.M[2][2]);   
+		a.M[1][1] = s * (m.M[0][0] * m.M[2][2] - m.M[0][2] * m.M[2][0]);   
+		a.M[2][1] = s * (m.M[0][1] * m.M[2][0] - m.M[0][0] * m.M[2][1]);   
+        
+		a.M[0][2] = s * (m.M[0][1] * m.M[1][2] - m.M[0][2] * m.M[1][1]);   
+		a.M[1][2] = s * (m.M[0][2] * m.M[1][0] - m.M[0][0] * m.M[1][2]);   
+		a.M[2][2] = s * (m.M[0][0] * m.M[1][1] - m.M[0][1] * m.M[1][0]);   
+        
+        return a;
+    }
+	
+};
+
+typedef Matrix3<float>  Matrix3f;
+typedef Matrix3<double> Matrix3d;
+
+//-------------------------------------------------------------------------------------
+
+template<typename T>
+class SymMat3
+{
+private:
+	typedef SymMat3<T> this_type;
+
+public:
+	typedef T Value_t;
+	// Upper symmetric
+	T v[6]; // _00 _01 _02 _11 _12 _22
+
+	inline SymMat3() {}
+
+	inline explicit SymMat3(T s)
+	{
+		v[0] = v[3] = v[5] = s;
+		v[1] = v[2] = v[4] = 0;
+	}
+
+	inline explicit SymMat3(T a00, T a01, T a02, T a11, T a12, T a22)
+	{
+		v[0] = a00; v[1] = a01; v[2] = a02;
+		v[3] = a11; v[4] = a12;
+		v[5] = a22;
+	}
+
+	static inline int Index(unsigned int i, unsigned int j)
+	{
+		return (i <= j) ? (3*i - i*(i+1)/2 + j) : (3*j - j*(j+1)/2 + i);
+	}
+
+	inline T operator()(int i, int j) const { return v[Index(i,j)]; }
+	
+	inline T &operator()(int i, int j) { return v[Index(i,j)]; }
+
+	template<typename U>
+	inline SymMat3<U> CastTo() const
+	{
+		return SymMat3<U>(static_cast<U>(v[0]), static_cast<U>(v[1]), static_cast<U>(v[2]),
+						  static_cast<U>(v[3]), static_cast<U>(v[4]), static_cast<U>(v[5]));
+	}
+
+	inline this_type& operator+=(const this_type& b)
+	{
+		v[0]+=b.v[0];
+		v[1]+=b.v[1];
+		v[2]+=b.v[2];
+		v[3]+=b.v[3];
+		v[4]+=b.v[4];
+		v[5]+=b.v[5];
+		return *this;
+	}
+
+	inline this_type& operator-=(const this_type& b)
+	{
+		v[0]-=b.v[0];
+		v[1]-=b.v[1];
+		v[2]-=b.v[2];
+		v[3]-=b.v[3];
+		v[4]-=b.v[4];
+		v[5]-=b.v[5];
+
+		return *this;
+	}
+
+	inline this_type& operator*=(T s)
+	{
+		v[0]*=s;
+		v[1]*=s;
+		v[2]*=s;
+		v[3]*=s;
+		v[4]*=s;
+		v[5]*=s;
+
+		return *this;
+	}
+		
+	inline SymMat3 operator*(T s) const
+	{
+		SymMat3 d;
+		d.v[0] = v[0]*s; 
+		d.v[1] = v[1]*s; 
+		d.v[2] = v[2]*s; 
+		d.v[3] = v[3]*s; 
+		d.v[4] = v[4]*s; 
+		d.v[5] = v[5]*s; 
+						
+		return d;
+	}
+
+	// Multiplies two matrices into destination with minimum copying.
+	static SymMat3& Multiply(SymMat3* d, const SymMat3& a, const SymMat3& b)
+	{		
+		// _00 _01 _02 _11 _12 _22
+
+		d->v[0] = a.v[0] * b.v[0];
+		d->v[1] = a.v[0] * b.v[1] + a.v[1] * b.v[3];
+		d->v[2] = a.v[0] * b.v[2] + a.v[1] * b.v[4];
+					
+		d->v[3] = a.v[3] * b.v[3];
+		d->v[4] = a.v[3] * b.v[4] + a.v[4] * b.v[5];
+				
+		d->v[5] = a.v[5] * b.v[5];
+	
+		return *d;
+	}
+	
+	inline T Determinant() const
+	{
+		const this_type& m = *this;
+		T d; 
+
+		d  = m(0,0) * (m(1,1)*m(2,2) - m(1,2) * m(2,1));
+		d -= m(0,1) * (m(1,0)*m(2,2) - m(1,2) * m(2,0));
+		d += m(0,2) * (m(1,0)*m(2,1) - m(1,1) * m(2,0));
+
+		return d;
+	}
+
+	inline this_type Inverse() const
+	{
+		this_type a;
+		const this_type& m = *this;
+		T d = Determinant();
+
+		assert(d != 0);
+		T s = T(1)/d;
+
+		a(0,0) = s * (m(1,1) * m(2,2) - m(1,2) * m(2,1));   
+
+		a(0,1) = s * (m(0,2) * m(2,1) - m(0,1) * m(2,2));   
+		a(1,1) = s * (m(0,0) * m(2,2) - m(0,2) * m(2,0));   
+
+		a(0,2) = s * (m(0,1) * m(1,2) - m(0,2) * m(1,1));   
+		a(1,2) = s * (m(0,2) * m(1,0) - m(0,0) * m(1,2));   
+		a(2,2) = s * (m(0,0) * m(1,1) - m(0,1) * m(1,0));   
+
+		return a;
+	}
+
+	inline T Trace() const { return v[0] + v[3] + v[5]; }
+
+	// M = a*a.t()
+	inline void Rank1(const Vector3<T> &a)
+	{
+		v[0] = a.x*a.x; v[1] = a.x*a.y; v[2] = a.x*a.z;
+		v[3] = a.y*a.y; v[4] = a.y*a.z;
+		v[5] = a.z*a.z;
+	}
+
+	// M += a*a.t()
+	inline void Rank1Add(const Vector3<T> &a)
+	{
+		v[0] += a.x*a.x; v[1] += a.x*a.y; v[2] += a.x*a.z;
+		v[3] += a.y*a.y; v[4] += a.y*a.z;
+		v[5] += a.z*a.z;
+	}
+
+	// M -= a*a.t()
+	inline void Rank1Sub(const Vector3<T> &a)
+	{
+		v[0] -= a.x*a.x; v[1] -= a.x*a.y; v[2] -= a.x*a.z;
+		v[3] -= a.y*a.y; v[4] -= a.y*a.z;
+		v[5] -= a.z*a.z;
+	}
+};
+
+typedef SymMat3<float>  SymMat3f;
+typedef SymMat3<double> SymMat3d;
+
+template<typename T>
+inline Matrix3<T> operator*(const SymMat3<T>& a, const SymMat3<T>& b)
+{
+	#define AJB_ARBC(r,c) (a(r,0)*b(0,c)+a(r,1)*b(1,c)+a(r,2)*b(2,c))
+    return Matrix3<T>(
+		AJB_ARBC(0,0), AJB_ARBC(0,1), AJB_ARBC(0,2),
+		AJB_ARBC(1,0), AJB_ARBC(1,1), AJB_ARBC(1,2),
+		AJB_ARBC(2,0), AJB_ARBC(2,1), AJB_ARBC(2,2));
+	#undef AJB_ARBC
+}
+
+template<typename T>
+inline Matrix3<T> operator*(const Matrix3<T>& a, const SymMat3<T>& b)
+{
+	#define AJB_ARBC(r,c) (a(r,0)*b(0,c)+a(r,1)*b(1,c)+a(r,2)*b(2,c))
+	return Matrix3<T>(
+		AJB_ARBC(0,0), AJB_ARBC(0,1), AJB_ARBC(0,2),
+		AJB_ARBC(1,0), AJB_ARBC(1,1), AJB_ARBC(1,2),
+		AJB_ARBC(2,0), AJB_ARBC(2,1), AJB_ARBC(2,2));
+	#undef AJB_ARBC
+}
+
+//-------------------------------------------------------------------------------------
+// ***** Angle
+
+// Cleanly representing the algebra of 2D rotations.
+// The operations maintain the angle between -Pi and Pi, the same range as atan2.
+
+template<class T>
+class Angle
+{
+public:
+	enum AngularUnits
+	{
+		Radians = 0,
+		Degrees = 1
+	};
+
+    Angle() : a(0) {}
+    
+	// Fix the range to be between -Pi and Pi
+	Angle(T a_, AngularUnits u = Radians) : a((u == Radians) ? a_ : ((T)MATH_DOUBLE_DEGREETORADFACTOR)) { FixRange(); }
+
+	T    Get(AngularUnits u = Radians) const       { return (u == Radians) ? a : a*((T)MATH_DOUBLE_RADTODEGREEFACTOR); }
+	void Set(const T& x, AngularUnits u = Radians) { a = (u == Radians) ? x : x*((T)MATH_DOUBLE_DEGREETORADFACTOR); FixRange(); }
+	int Sign() const                               { if (a == 0) return 0; else return (a > 0) ? 1 : -1; }
+	T   Abs() const                                { return (a > 0) ? a : -a; }
+
+    bool operator== (const Angle& b) const    { return a == b.a; }
+    bool operator!= (const Angle& b) const    { return a != b.a; }
+//	bool operator<  (const Angle& b) const    { return a < a.b; } 
+//	bool operator>  (const Angle& b) const    { return a > a.b; } 
+//	bool operator<= (const Angle& b) const    { return a <= a.b; } 
+//	bool operator>= (const Angle& b) const    { return a >= a.b; } 
+//	bool operator= (const T& x)               { a = x; FixRange(); }
+
+	// These operations assume a is already between -Pi and Pi.
+	Angle& operator+= (const Angle& b)        { a = a + b.a; FastFixRange(); return *this; }
+	Angle& operator+= (const T& x)            { a = a + x; FixRange(); return *this; }
+    Angle  operator+  (const Angle& b) const  { Angle res = *this; res += b; return res; }
+	Angle  operator+  (const T& x) const      { Angle res = *this; res += x; return res; }
+	Angle& operator-= (const Angle& b)        { a = a - b.a; FastFixRange(); return *this; }
+	Angle& operator-= (const T& x)            { a = a - x; FixRange(); return *this; }
+	Angle  operator-  (const Angle& b) const  { Angle res = *this; res -= b; return res; }
+	Angle  operator-  (const T& x) const      { Angle res = *this; res -= x; return res; }
+	
+	T   Distance(const Angle& b)              { T c = fabs(a - b.a); return (c <= ((T)MATH_DOUBLE_PI)) ? c : ((T)MATH_DOUBLE_TWOPI) - c; }
+
+private:
+
+	// The stored angle, which should be maintained between -Pi and Pi
+	T a;
+
+	// Fixes the angle range to [-Pi,Pi], but assumes no more than 2Pi away on either side 
+	inline void FastFixRange()
+	{
+		if (a < -((T)MATH_DOUBLE_PI))
+			a += ((T)MATH_DOUBLE_TWOPI);
+		else if (a > ((T)MATH_DOUBLE_PI))
+			a -= ((T)MATH_DOUBLE_TWOPI);
+	}
+
+	// Fixes the angle range to [-Pi,Pi] for any given range, but slower then the fast method
+	inline void FixRange()
+	{
+        // do nothing if the value is already in the correct range, since fmod call is expensive
+        if (a >= -((T)MATH_DOUBLE_PI) && a <= ((T)MATH_DOUBLE_PI))
+            return;
+		a = fmod(a,((T)MATH_DOUBLE_TWOPI));
+		if (a < -((T)MATH_DOUBLE_PI))
+			a += ((T)MATH_DOUBLE_TWOPI);
+		else if (a > ((T)MATH_DOUBLE_PI))
+			a -= ((T)MATH_DOUBLE_TWOPI);
+	}
+};
+
+
+typedef Angle<float>  Anglef;
+typedef Angle<double> Angled;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Plane
+
+// Consists of a normal vector and distance from the origin where the plane is located.
+
+template<class T>
+class Plane
+{
+public:
+    Vector3<T> N;
+    T          D;
+
+    Plane() : D(0) {}
+
+    // Normals must already be normalized
+    Plane(const Vector3<T>& n, T d) : N(n), D(d) {}
+    Plane(T x, T y, T z, T d) : N(x,y,z), D(d) {}
+
+    // construct from a point on the plane and the normal
+    Plane(const Vector3<T>& p, const Vector3<T>& n) : N(n), D(-(p * n)) {}
+
+    // Find the point to plane distance. The sign indicates what side of the plane the point is on (0 = point on plane).
+    T TestSide(const Vector3<T>& p) const
+    {
+        return (N.Dot(p)) + D;
+    }
+
+    Plane<T> Flipped() const
+    {
+        return Plane(-N, -D);
+    }
+
+    void Flip()
+    {
+        N = -N;
+        D = -D;
+    }
+
+	bool operator==(const Plane<T>& rhs) const
+	{
+		return (this->D == rhs.D && this->N == rhs.N);
+	}
+};
+
+typedef Plane<float> Planef;
+typedef Plane<double> Planed;
+
+
+} // Namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Nullptr.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Nullptr.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,150 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Nullptr.h
+Content     :   Implements C++11 nullptr for the case that the compiler doesn't.
+Created     :   June 19, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Nullptr_h
+#define OVR_Nullptr_h
+
+#pragma once
+
+#include "OVR_Types.h"
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_HAVE_std_nullptr_t
+//
+// Identifies if <cstddef.h> includes std::nullptr_t. 
+//
+#if !defined(OVR_HAVE_std_nullptr_t) && defined(OVR_CPP11_ENABLED)
+    #if defined(OVR_STDLIB_LIBCPP)
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(OVR_STDLIB_LIBSTDCPP)
+        #if (__GLIBCXX__ >= 20110325) && (__GLIBCXX__ != 20110428) && (__GLIBCXX__ != 20120702)
+            #define OVR_HAVE_std_nullptr_t 1
+        #endif
+    #elif defined(_MSC_VER) && (_MSC_VER >= 1600) // VS2010+
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(__clang__)
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(OVR_CPP_GNUC) && (OVR_CPP_VERSION >= 406) // GCC 4.6+
+        #define OVR_HAVE_std_nullptr_t 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** nullptr / std::nullptr_t
+//
+// Declares and defines nullptr and related types.
+//
+#if defined(OVR_CPP_NO_NULLPTR)
+    namespace std
+    {
+        class nullptr_t
+        {
+        public:
+            template <typename T>
+            operator T*() const
+                { return 0; }
+         
+            template <typename C, typename T>
+            operator T C::*() const
+                { return 0; }
+
+            #if OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS
+                typedef void* (nullptr_t::*bool_)() const;  // 4.12,p1. We can't portably use operator bool(){ return false; } because bool 
+                operator bool_() const                      // is convertable to int which breaks other required functionality.
+                    { return false; }
+            #else
+                operator bool() const
+                    { return false; }
+            #endif
+
+        private:
+            void operator&() const; // 5.2.10,p9
+        };
+
+        inline nullptr_t nullptr_get()
+        {
+            nullptr_t n = { };
+            return n;
+        }
+
+        #if !defined(nullptr)
+            #define nullptr nullptr_get()
+        #endif
+
+    } // namespace std
+
+
+    // 5.9,p2 p4
+    // 13.6, p13
+    template <typename T>
+    inline bool operator==(T* pT, const std::nullptr_t)
+        { return pT == 0; }
+
+    template <typename T>
+    inline bool operator==(const std::nullptr_t, T* pT)
+        { return pT == 0; }
+
+    template <typename T, typename U>
+    inline bool operator==(const std::nullptr_t, T U::* pU)
+        { return pU == 0; }
+
+    template <typename T, typename U>
+    inline bool operator==(T U::* pTU, const std::nullptr_t)
+        { return pTU == 0; }
+
+    inline bool operator==(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    inline bool operator!=(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator<(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator<=(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    inline bool operator>(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator>=(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    using std::nullptr_t;
+    using std::nullptr_get;
+
+// Some compilers natively support C++11 nullptr but the standard library being used 
+// doesn't declare std::nullptr_t, in which case we provide one ourselves.
+#elif !defined(OVR_HAVE_std_nullptr_t) && !defined(OVR_CPP_NO_DECLTYPE)
+    namespace std { typedef decltype(nullptr) nullptr_t; }
+#endif
+
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Observer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Observer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,457 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_Observer.h
+Content     :   Observer pattern
+Created     :   June 20, 2014
+Author      :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Observer_h
+#define OVR_Observer_h
+
+#include "OVR_Types.h"
+#include "OVR_Atomic.h"
+#include "OVR_RefCount.h"
+#include "OVR_Delegates.h"
+#include "OVR_Array.h"
+#include "OVR_String.h"
+#include "OVR_Hash.h"
+
+namespace OVR {
+
+template<class DelegateT> class Observer;
+template<class DelegateT> class ObserverScope;
+template<class DelegateT> class ObserverHash;
+
+
+//-----------------------------------------------------------------------------
+// Observer pattern
+
+// An Observer will observe a Subject.  The Subject can emit callbacks that get
+// serviced by the Observers.
+
+// The trickiest part of this is the shutdown code.
+// To simplify shutdown, the Observer is a reference-counted object divorced
+// from the handler that is called.  To avoid misuse, the ObserverScope object
+// is provided to ensure that the Shutdown() method is called when it goes out
+// of scope.
+
+// The Observer<> class doubles as the subject class.
+// To avoid misuse, assertions are added if a subject tries to observe, or if
+// an observer tries to be watched.
+
+/*
+    Usage example:
+
+    Say we want to invoke a handler with the signature:
+
+        void MyHandler(int i, bool b);
+
+    The corresponding delegate type is:
+
+        typedef Delegate2<void, int, bool> Handler;
+
+    Note: The return value will be ignored for the Observer pattern.
+
+    For this example there are two classes, one that emits events and another
+    that listens for events:
+*/
+
+/*
+    Event emitter example:
+
+    class MyEmitter
+    {
+        ObserverScope<Handler> TheSubject;
+
+    public:
+        void ClearAllListeners()
+        {
+            TheSubject.ReleaseAll();
+        }
+
+        void CallListeners(int x, bool y)
+        {
+            TheSubject->Call(x, y);
+        }
+
+        Observer<Handler>* GetSubject()
+        {
+            return TheSubject;
+        }
+    };
+*/
+
+/*
+    Event listener example:
+
+    class MyListener
+    {
+        ObserverScope<Handler> TheObserver;
+
+        void OnEvent(int x, bool y)
+        {
+            // Handle event here
+        }
+
+    public:
+        MyListener()
+        {
+            TheObserver.SetHandler(
+                Handler::FromMember<MyListener, &MyListener::OnEvent>(this)
+                );
+        }
+
+        void ClearListener()
+        {
+            TheObserver.ReleaseAll();
+        }
+
+        void ListenTo(Observer<Handler>* emitter)
+        {
+            TheObserver->Observe(emitter);
+        }
+    };
+*/
+
+/*
+    Usage example:
+
+    MyListener listener;
+    MyEmitter emitter;
+
+    // To listen to an emitter,
+    listener.ListenTo(emitter.GetSubject());
+
+    // To call the listeners,
+    emitter.CallListeners(22, true);
+*/
+
+template<class DelegateT>
+class Observer : public RefCountBase< Observer<DelegateT> >
+{
+	friend class ObserverScope<DelegateT>;
+	friend class ObserverHash<DelegateT>;
+
+public:
+    typedef Observer<DelegateT> ThisType;
+    typedef DelegateT Handler;
+
+protected:
+	bool                     IsShutdown; // Flag to indicate that the object went out of scope
+	mutable Lock             TheLock;    // Lock to synchronize calls and shutdown
+	Array< Ptr< ThisType > > References; // List of observed or observing objects
+	Handler                  TheHandler; // Observer-only: Handler for callbacks
+
+	Observer() :
+		IsShutdown(false)
+	{
+		TheHandler.Invalidate();
+	}
+	Observer(Handler handler) :
+		IsShutdown(false),
+		TheHandler(handler)
+	{
+	}
+	~Observer()
+	{
+		OVR_ASSERT(References.GetSizeI() == 0);
+	}
+
+public:
+	void SetHandler(Handler handler)
+	{
+		OVR_ASSERT(References.GetSizeI() == 0);
+		TheHandler = handler;
+	}
+
+	// Release references and prevent further actions
+	void Shutdown()
+	{
+		Lock::Locker locker(&TheLock);
+		IsShutdown = true;
+		References.ClearAndRelease();
+	}
+
+	// Get count of references held
+	int GetSizeI() const
+	{
+		Lock::Locker locker(&TheLock);
+		return References.GetSizeI();
+	}
+
+	// Observe a subject
+	bool Observe(ThisType *subject)
+	{
+		OVR_ASSERT(TheHandler.IsValid());
+
+		if (!subject)
+		{
+			return false;
+		}
+
+		Lock::Locker locker(&TheLock);
+
+		if (IsShutdown)
+		{
+			return false;
+		}
+
+		if (!subject->SubjectAddObserver(this))
+		{
+			return false;
+		}
+
+		References.PushBack(subject);
+		return true;
+	}
+
+protected:
+	// Subject function: AddObserver()
+	// Returns true if the observer was added
+	bool SubjectAddObserver(ThisType* observer)
+	{
+		OVR_ASSERT(!TheHandler.IsValid());
+
+		if (!observer)
+		{
+			return true;
+		}
+
+		Lock::Locker locker(&TheLock);
+
+		if (IsShutdown)
+		{
+			return false;
+		}
+
+		const int count = References.GetSizeI();
+		for (int i = 0; i < count; ++i)
+		{
+			if (References[i] == observer)
+			{
+				// Already watched
+				return true;
+			}
+		}
+
+		References.PushBack(observer);
+
+		return true;
+	}
+
+public:
+    // Subject function: Call()
+#define OVR_OBSERVER_CALL_BODY(params) \
+    bool callSuccess = false; \
+	Lock::Locker locker(&TheLock); \
+	int count = References.GetSizeI(); \
+	for (int i = 0; i < count; ++i) \
+	{ \
+		if (!References[i]->IsShutdown) \
+		{ \
+			OVR_ASSERT(References[i]->TheHandler.IsValid()); \
+			References[i]->TheHandler params; \
+            callSuccess = true; \
+		} \
+		if (References[i]->IsShutdown) \
+		{ \
+			References.RemoveAt(i); \
+			--i; --count; \
+		} \
+	} \
+    return callSuccess;
+
+	// Call: Various parameter counts
+    // Returns true if a call was made
+	bool Call()
+	{
+		OVR_OBSERVER_CALL_BODY(());
+	}
+	template<class Param1>
+    bool Call(Param1& p1)
+	{
+		OVR_OBSERVER_CALL_BODY((p1));
+	}
+	template<class Param1>
+    bool Call(Param1* p1)
+	{
+		OVR_OBSERVER_CALL_BODY((p1));
+	}
+	template<class Param1, class Param2>
+    bool Call(Param1& p1, Param2& p2)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2));
+	}
+	template<class Param1, class Param2>
+    bool Call(Param1* p1, Param2* p2)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2));
+	}
+	template<class Param1, class Param2, class Param3>
+    bool Call(Param1& p1, Param2& p2, Param3& p3)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2, p3));
+	}
+	template<class Param1, class Param2, class Param3>
+    bool Call(Param1* p1, Param2* p2, Param3* p3)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2, p3));
+	}
+
+#undef OVR_OBSERVER_CALL_BODY
+};
+
+
+//-----------------------------------------------------------------------------
+// ObserverScope
+
+// Scoped shutdown of the Observer object
+template<class DelegateT>
+class ObserverScope : public NewOverrideBase
+{
+	Ptr< Observer<DelegateT> > TheObserver;
+	DelegateT TheHandler;
+
+	void Shutdown()
+	{
+		if (TheObserver)
+		{
+			TheObserver->Shutdown();
+			TheObserver.Clear();
+		}
+	}
+
+public:
+	ObserverScope()
+	{
+		TheObserver = *new Observer<DelegateT>;
+	}
+	~ObserverScope()
+	{
+		Shutdown();
+	}
+
+	// Release all references and recreate it
+	void ReleaseAll()
+	{
+		Shutdown();
+		TheObserver = *new Observer<DelegateT>;
+		if (TheHandler.IsValid())
+		{
+			TheObserver->SetHandler(TheHandler);
+		}
+	}
+
+	void SetHandler(DelegateT handler)
+	{
+		TheHandler = handler;
+		TheObserver->SetHandler(handler);
+	}
+
+	Observer<DelegateT>* GetPtr()
+	{
+		return TheObserver.GetPtr();
+	}
+	Observer<DelegateT>* operator->()
+	{
+		return TheObserver.GetPtr();
+	}
+	const Observer<DelegateT>* operator->() const
+	{
+		return TheObserver.GetPtr();
+	}
+	operator Observer<DelegateT>*()
+	{
+		return TheObserver.GetPtr();
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// ObserverHash
+
+// A hash containing Observers
+template<class DelegateT>
+class ObserverHash : public NewOverrideBase
+{
+public:
+	ObserverHash() {}
+	~ObserverHash() {Clear();}
+	void Clear()
+	{
+		Lock::Locker locker(&TheLock);
+		typename OVR::Hash< String, Ptr<Observer<DelegateT> >, OVR::String::HashFunctor >::Iterator it = _Hash.Begin();
+		for( it = _Hash.Begin(); it != _Hash.End(); ++it )
+		{
+			Ptr<Observer<DelegateT> > o = it->Second;
+			o->Shutdown();
+		}
+	}
+
+	Ptr<Observer<DelegateT> > GetSubject(OVR::String key)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *o = _Hash.Get(key);
+		if (o)
+			return (*o);
+		return NULL;
+	}
+
+	// Add handler to new observer with implicit creation of subject.
+	void AddObserverToSubject(OVR::String key, Observer<DelegateT> *observer)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *subjectPtr = _Hash.Get(key);
+
+		if (subjectPtr==NULL)
+		{
+			Ptr<Observer<DelegateT> > subject = *new Observer<DelegateT>();
+			_Hash.Add(key, subject);
+			observer->Observe(subject);
+		}
+		else
+		{
+			observer->Observe(*subjectPtr);
+		}
+	}
+
+	void RemoveSubject(OVR::String key)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *subjectPtr = _Hash.Get(key);
+		if (subjectPtr!=NULL)
+		{
+			(*subjectPtr)->Shutdown();
+			_Hash.Remove(key);
+		}
+	}
+
+protected:
+	OVR::Hash< OVR::String, Ptr<Observer<DelegateT> >, OVR::String::HashFunctor > _Hash;
+	Lock                     TheLock;      // Lock to synchronize calls and shutdown
+};
+
+
+} // namespace OVR
+
+#endif // OVR_Observer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,111 @@
+/************************************************************************************
+
+Filename    :   OVR_RefCount.cpp
+Content     :   Reference counting implementation
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_RefCount.h"
+#include "OVR_Atomic.h"
+#include "OVR_Log.h"
+
+namespace OVR {
+
+#ifdef OVR_CC_ARM
+void* ReturnArg0(void* p)
+{
+    return p;
+}
+#endif
+
+// ***** Reference Count Base implementation
+
+RefCountImplCore::~RefCountImplCore()
+{
+    // RefCount can be either 1 or 0 here.
+    //  0 if Release() was properly called.
+    //  1 if the object was declared on stack or as an aggregate.
+    OVR_ASSERT(RefCount <= 1);
+}
+
+#ifdef OVR_BUILD_DEBUG
+void RefCountImplCore::reportInvalidDelete(void *pmem)
+{
+    OVR_DEBUG_LOG(
+        ("Invalid delete call on ref-counted object at %p. Please use Release()", pmem));
+    OVR_ASSERT(0);
+}
+#endif
+
+RefCountNTSImplCore::~RefCountNTSImplCore()
+{
+    // RefCount can be either 1 or 0 here.
+    //  0 if Release() was properly called.
+    //  1 if the object was declared on stack or as an aggregate.
+    OVR_ASSERT(RefCount <= 1);
+}
+
+#ifdef OVR_BUILD_DEBUG
+void RefCountNTSImplCore::reportInvalidDelete(void *pmem)
+{
+    OVR_DEBUG_LOG(
+        ("Invalid delete call on ref-counted object at %p. Please use Release()", pmem));
+    OVR_ASSERT(0);
+}
+#endif
+
+
+// *** Thread-Safe RefCountImpl
+
+void    RefCountImpl::AddRef()
+{
+    AtomicOps<int>::ExchangeAdd_NoSync(&RefCount, 1);
+}
+void    RefCountImpl::Release()
+{
+    if ((AtomicOps<int>::ExchangeAdd_NoSync(&RefCount, -1) - 1) == 0)
+        delete this;
+}
+
+// *** Thread-Safe RefCountVImpl w/virtual AddRef/Release
+
+void    RefCountVImpl::AddRef()
+{
+    AtomicOps<int>::ExchangeAdd_NoSync(&RefCount, 1);
+}
+void    RefCountVImpl::Release()
+{
+    if ((AtomicOps<int>::ExchangeAdd_NoSync(&RefCount, -1) - 1) == 0)
+        delete this;
+}
+
+// *** NON-Thread-Safe RefCountImpl
+
+void    RefCountNTSImpl::Release() const
+{
+    RefCount--;
+    if (RefCount == 0)
+        delete this;
+}
+
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,565 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_RefCount.h
+Content     :   Reference counting implementation headers
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_RefCount_h
+#define OVR_RefCount_h
+
+#include "OVR_Types.h"
+#include "OVR_Allocator.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Reference Counting
+
+// There are three types of reference counting base classes:
+//
+//  RefCountBase     - Provides thread-safe reference counting (Default).
+//  RefCountBaseNTS  - Non Thread Safe version of reference counting.
+
+
+// ***** Declared classes
+
+template<class C>
+class   RefCountBase;
+template<class C>
+class   RefCountBaseNTS;
+
+class   RefCountImpl;
+class   RefCountNTSImpl;
+
+
+//-----------------------------------------------------------------------------------
+// ***** Implementation For Reference Counting
+
+// RefCountImplCore holds RefCount value and defines a few utility
+// functions shared by all implementations.
+
+class RefCountImplCore
+{
+protected:
+   volatile int RefCount;
+
+public:
+    // RefCountImpl constructor always initializes RefCount to 1 by default.
+    OVR_FORCE_INLINE RefCountImplCore() : RefCount(1) { }
+
+    // Need virtual destructor
+    // This:    1. Makes sure the right destructor's called.
+    //          2. Makes us have VTable, necessary if we are going to have format needed by InitNewMem()
+    virtual ~RefCountImplCore();
+
+    // Debug method only.
+    int GetRefCount() const { return RefCount;  }
+
+    // This logic is used to detect invalid 'delete' calls of reference counted
+    // objects. Direct delete calls are not allowed on them unless they come in
+    // internally from Release.
+#ifdef OVR_BUILD_DEBUG    
+    static void   OVR_CDECL  reportInvalidDelete(void *pmem);
+    inline static void checkInvalidDelete(RefCountImplCore *pmem)
+    {
+        if (pmem->RefCount != 0)
+            reportInvalidDelete(pmem);
+    }
+#else
+    inline static void checkInvalidDelete(RefCountImplCore *) { }
+#endif
+
+    // Base class ref-count content should not be copied.
+    void operator = (const RefCountImplCore &) { }  
+};
+
+class RefCountNTSImplCore
+{
+protected:
+    mutable int RefCount;
+
+public:
+    // RefCountImpl constructor always initializes RefCount to 1 by default.
+    OVR_FORCE_INLINE RefCountNTSImplCore() : RefCount(1) { }
+
+    // Need virtual destructor
+    // This:    1. Makes sure the right destructor's called.
+    //          2. Makes us have VTable, necessary if we are going to have format needed by InitNewMem()
+    virtual ~RefCountNTSImplCore();
+
+    // Debug method only.
+    int             GetRefCount() const { return RefCount;  }
+
+    // This logic is used to detect invalid 'delete' calls of reference counted
+    // objects. Direct delete calls are not allowed on them unless they come in
+    // internally from Release.
+#ifdef OVR_BUILD_DEBUG    
+    static void   OVR_CDECL  reportInvalidDelete(void *pmem);
+    OVR_FORCE_INLINE static void checkInvalidDelete(RefCountNTSImplCore *pmem)
+    {
+        if (pmem->RefCount != 0)
+            reportInvalidDelete(pmem);
+    }
+#else
+    OVR_FORCE_INLINE static void checkInvalidDelete(RefCountNTSImplCore *) { }
+#endif
+
+    // Base class ref-count content should not be copied.
+    void operator = (const RefCountNTSImplCore &) { }  
+};
+
+
+
+// RefCountImpl provides Thread-Safe implementation of reference counting, so
+// it should be used by default in most places.
+
+class RefCountImpl : public RefCountImplCore
+{
+public:
+    // Thread-Safe Ref-Count Implementation.
+    void    AddRef();
+    void    Release();   
+};
+
+// RefCountVImpl provides Thread-Safe implementation of reference counting, plus,
+// virtual AddRef and Release.
+
+class RefCountVImpl : virtual public RefCountImplCore
+{
+public:
+    // Thread-Safe Ref-Count Implementation.
+    virtual void      AddRef();
+    virtual void      Release();   
+};
+
+
+// RefCountImplNTS provides Non-Thread-Safe implementation of reference counting,
+// which is slightly more efficient since it doesn't use atomics.
+
+class RefCountNTSImpl : public RefCountNTSImplCore
+{
+public:
+    OVR_FORCE_INLINE void    AddRef() const { RefCount++; }
+    void    Release() const;   
+};
+
+
+
+// RefCountBaseStatImpl<> is a common class that adds new/delete override with Stat tracking
+// to the reference counting implementation. Base must be one of the RefCountImpl classes.
+
+template<class Base>
+class RefCountBaseStatImpl : public Base
+{
+public:
+    RefCountBaseStatImpl() { }
+     
+    // *** Override New and Delete
+
+    // DOM-IGNORE-BEGIN
+    // Undef new temporarily if it is being redefined
+#ifdef OVR_DEFINE_NEW
+#undef new
+#endif
+
+#ifdef OVR_BUILD_DEBUG
+    // Custom check used to detect incorrect calls of 'delete' on ref-counted objects.
+    #define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)   \
+        do {if (p) Base::checkInvalidDelete((class_name*)p); } while(0)
+#else
+    #define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)
+#endif
+
+    // Redefine all new & delete operators.
+    OVR_MEMORY_REDEFINE_NEW_IMPL(Base, OVR_REFCOUNTALLOC_CHECK_DELETE)
+
+#undef OVR_REFCOUNTALLOC_CHECK_DELETE
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+        // OVR_BUILD_DEFINE_NEW
+        // DOM-IGNORE-END
+};
+
+
+template<class Base>
+class RefCountBaseStatVImpl : virtual public Base
+{
+public:
+	RefCountBaseStatVImpl() { }
+
+	// *** Override New and Delete
+
+	// DOM-IGNORE-BEGIN
+	// Undef new temporarily if it is being redefined
+#ifdef OVR_DEFINE_NEW
+#undef new
+#endif
+
+#define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)
+
+	// Redefine all new & delete operators.
+	OVR_MEMORY_REDEFINE_NEW_IMPL(Base, OVR_REFCOUNTALLOC_CHECK_DELETE)
+
+#undef OVR_REFCOUNTALLOC_CHECK_DELETE
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+		// OVR_BUILD_DEFINE_NEW
+		// DOM-IGNORE-END
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// *** End user RefCountBase<> classes
+
+
+// RefCountBase is a base class for classes that require thread-safe reference
+// counting; it also overrides the new and delete operators to use MemoryHeap.
+//
+// Reference counted objects start out with RefCount value of 1. Further lifetime
+// management is done through the AddRef() and Release() methods, typically
+// hidden by Ptr<>.
+
+template<class C>
+class RefCountBase : public RefCountBaseStatImpl<RefCountImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBase() : RefCountBaseStatImpl<RefCountImpl>() { }    
+};
+
+// RefCountBaseV is the same as RefCountBase but with virtual AddRef/Release
+
+template<class C>
+class RefCountBaseV : virtual public RefCountBaseStatVImpl<RefCountVImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBaseV() : RefCountBaseStatVImpl<RefCountVImpl>() { }    
+};
+
+
+// RefCountBaseNTS is a base class for classes that require Non-Thread-Safe reference
+// counting; it also overrides the new and delete operators to use MemoryHeap.
+// This class should only be used if all pointers to it are known to be assigned,
+// destroyed and manipulated within one thread.
+//
+// Reference counted objects start out with RefCount value of 1. Further lifetime
+// management is done through the AddRef() and Release() methods, typically
+// hidden by Ptr<>.
+
+template<class C>
+class RefCountBaseNTS : public RefCountBaseStatImpl<RefCountNTSImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBaseNTS() : RefCountBaseStatImpl<RefCountNTSImpl>() { }    
+};
+
+//-----------------------------------------------------------------------------------
+// ***** Pickable template pointer
+enum PickType { PickValue };
+
+template <typename T>
+class Pickable
+{
+public:
+    Pickable() : pV(NULL) {}
+    explicit Pickable(T* p) : pV(p) {}
+    Pickable(T* p, PickType) : pV(p) 
+    {
+        OVR_ASSERT(pV);
+        if (pV)
+            pV->AddRef();
+    }
+    template <typename OT>
+    Pickable(const Pickable<OT>& other) : pV(other.GetPtr()) {}
+
+public:
+    Pickable& operator =(const Pickable& other)
+    {
+        OVR_ASSERT(pV == NULL);
+        pV = other.pV;
+        // Extra check.
+        //other.pV = NULL;
+        return *this;
+    }
+
+public:
+    T* GetPtr() const { return pV; }
+    T* operator->() const
+    {
+        return pV;
+    }
+    T& operator*() const
+    {
+        OVR_ASSERT(pV);
+        return *pV;
+    }
+
+private:
+    T* pV;
+};
+
+template <typename T>
+OVR_FORCE_INLINE
+Pickable<T> MakePickable(T* p)
+{
+    return Pickable<T>(p);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Ref-Counted template pointer
+
+// Automatically AddRefs and Releases interfaces
+
+void* ReturnArg0(void* p);
+
+template<class C>
+class Ptr
+{
+#ifdef OVR_CC_ARM
+    static C* ReturnArg(void* p) { return (C*)ReturnArg0(p); }
+#endif
+
+protected:
+    C   *pObject;
+
+public:
+
+    // Constructors
+    OVR_FORCE_INLINE Ptr() : pObject(0)
+    { }
+#ifdef OVR_CC_ARM
+    OVR_FORCE_INLINE Ptr(C &robj) : pObject(ReturnArg(&robj))
+#else
+    OVR_FORCE_INLINE Ptr(C &robj) : pObject(&robj)
+#endif
+    { }
+    OVR_FORCE_INLINE Ptr(Pickable<C> v) : pObject(v.GetPtr())
+    {
+        // No AddRef() on purpose.
+    }
+    OVR_FORCE_INLINE Ptr(Ptr<C>& other, PickType) : pObject(other.pObject)
+    {
+        other.pObject = NULL;
+        // No AddRef() on purpose.
+    }
+    OVR_FORCE_INLINE Ptr(C *pobj)
+    {
+        if (pobj) pobj->AddRef();   
+        pObject = pobj;
+    }
+    OVR_FORCE_INLINE Ptr(const Ptr<C> &src)
+    {
+        if (src.pObject) src.pObject->AddRef();     
+        pObject = src.pObject;
+    }
+
+    template<class R>
+    OVR_FORCE_INLINE Ptr(Ptr<R> &src)
+    {
+        if (src) src->AddRef();
+        pObject = src;
+    }
+    template<class R>
+    OVR_FORCE_INLINE Ptr(Pickable<R> v) : pObject(v.GetPtr())
+    {
+        // No AddRef() on purpose.
+    }
+
+    // Destructor
+    OVR_FORCE_INLINE ~Ptr()
+    {
+        if (pObject) pObject->Release();        
+    }
+
+    // Compares
+    OVR_FORCE_INLINE bool operator == (const Ptr &other) const       { return pObject == other.pObject; }
+    OVR_FORCE_INLINE bool operator != (const Ptr &other) const       { return pObject != other.pObject; }
+
+    OVR_FORCE_INLINE bool operator == (C *pother) const              { return pObject == pother; }
+    OVR_FORCE_INLINE bool operator != (C *pother) const              { return pObject != pother; }
+
+
+    OVR_FORCE_INLINE bool operator < (const Ptr &other) const       { return pObject < other.pObject; }
+
+    // Assignment
+    template<class R>
+    OVR_FORCE_INLINE const Ptr<C>& operator = (const Ptr<R> &src)
+    {
+        // By design we don't check for src == pObject, as we don't expect that to be the case the large majority of the time.
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = src;
+        return *this;
+    }   
+    // Specialization
+    OVR_FORCE_INLINE const Ptr<C>& operator = (const Ptr<C> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = src;
+        return *this;
+    }   
+    
+    OVR_FORCE_INLINE const Ptr<C>& operator = (C *psrc)
+    {
+        if (psrc) psrc->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = psrc;
+        return *this;
+    }   
+    OVR_FORCE_INLINE const Ptr<C>& operator = (C &src)
+    {       
+        if (pObject) pObject->Release();        
+        pObject = &src;
+        return *this;
+    }
+    OVR_FORCE_INLINE Ptr<C>& operator = (Pickable<C> src)
+    {
+        return Pick(src);
+    }
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& operator = (Pickable<R> src)
+    {
+        return Pick(src);
+    }
+    
+    // Set Assignment
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(const Ptr<R> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();
+        pObject = src;
+        return *this;
+    }
+    // Specialization
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(const Ptr<C> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();
+        pObject = src;
+        return *this;
+    }   
+    
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(C *psrc)
+    {
+        if (psrc) psrc->AddRef();
+        if (pObject) pObject->Release();
+        pObject = psrc;
+        return *this;
+    }   
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(C &src)
+    {       
+        if (pObject) pObject->Release();
+        pObject = &src;
+        return *this;
+    }
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(Pickable<C> src)
+    {       
+        return Pick(src);
+    }
+
+    // Nulls ref-counted pointer without decrement
+    OVR_FORCE_INLINE void    NullWithoutRelease()    
+    { 
+        pObject = 0;    
+    }
+
+    // Clears the pointer to the object
+    OVR_FORCE_INLINE void    Clear()
+    {
+        if (pObject) pObject->Release();
+        pObject = 0;
+    }
+
+    // Obtain pointer reference directly, for D3D interfaces
+    OVR_FORCE_INLINE C*& GetRawRef()                 { return pObject; }
+
+    // Access Operators
+    OVR_FORCE_INLINE C* GetPtr() const               { return pObject; }
+    OVR_FORCE_INLINE C& operator * () const          { return *pObject; }
+    OVR_FORCE_INLINE C* operator -> ()  const        { return pObject; }
+    // Conversion                   
+    OVR_FORCE_INLINE operator C* () const            { return pObject; }
+
+    // Pickers.
+
+    // Pick a value.
+    OVR_FORCE_INLINE Ptr<C>& Pick(Ptr<C>& other)
+    {
+        if (&other != this)
+        {
+            if (pObject) pObject->Release();
+            pObject = other.pObject;
+            other.pObject = 0;
+        }
+
+        return *this;
+    }
+
+    OVR_FORCE_INLINE Ptr<C>& Pick(Pickable<C> v)
+    {
+        if (v.GetPtr() != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = v.GetPtr();
+        }
+
+        return *this;
+    }
+
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& Pick(Pickable<R> v)
+    {
+        if (v.GetPtr() != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = v.GetPtr();
+        }
+
+        return *this;
+    }
+
+    OVR_FORCE_INLINE Ptr<C>& Pick(C* p)
+    {
+        if (p != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = p;
+        }
+
+        return *this;
+    }
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,693 @@
+/************************************************************************************
+
+Filename    :   OVR_SharedMemory.cpp
+Content     :   Inter-process shared memory subsystem
+Created     :   June 1, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_SharedMemory.h"
+#include "OVR_Atomic.h"
+#include "OVR_Log.h"
+#include "OVR_String.h"
+#include "OVR_Array.h"
+
+#undef new
+
+#if defined(OVR_OS_WIN32) && !defined(OVR_FAKE_SHAREDMEMORY)
+#include <Sddl.h> // ConvertStringSecurityDescriptorToSecurityDescriptor
+#endif // OVR_OS_WIN32
+
+#if (defined(OVR_OS_LINUX) || defined(OVR_OS_MAC)) && !defined(OVR_FAKE_SHAREDMEMORY)
+#include <sys/mman.h> // shm_open(), mmap()
+#include <errno.h> // error results for mmap
+#include <sys/stat.h> // mode constants
+#include <fcntl.h> // O_ constants
+#include <unistd.h> // close()
+#endif // OVR_OS_LINUX
+
+OVR_DEFINE_SINGLETON(OVR::SharedMemoryFactory);
+
+namespace OVR {
+
+
+    //// Fake version
+
+#if defined(OVR_FAKE_SHAREDMEMORY)
+
+    class FakeMemoryBlock : public RefCountBase<FakeMemoryBlock>
+    {
+        String Name;
+        char*  Data;
+        int    SizeBytes;
+        int    References;
+
+    public:
+        FakeMemoryBlock(const String& name, int size) :
+            Name(name),
+            Data(NULL),
+            SizeBytes(size),
+            References(1)
+        {
+            Data = new char[SizeBytes];
+        }
+        ~FakeMemoryBlock()
+        {
+            delete[] Data;
+        }
+
+        bool IsNamed(const String& name)
+        {
+            return Name.CompareNoCase(name) == 0;
+        }
+        void* GetData()
+        {
+            return Data;
+        }
+        int GetSizeI()
+        {
+            return SizeBytes;
+        }
+        void IncrementReferences()
+        {
+            ++References;
+        }
+        bool DecrementReferences()
+        {
+            return --References <= 0;
+        }
+    };
+
+    class SharedMemoryInternal : public NewOverrideBase
+    {
+    public:
+        void* FileView;
+        Ptr<FakeMemoryBlock> Block;
+
+        void Close();
+
+        SharedMemoryInternal(FakeMemoryBlock* block) :
+            Block(block)
+        {
+            FileView = Block->GetData();
+        }
+        ~SharedMemoryInternal()
+        {
+            Close();
+        }
+
+        static SharedMemoryInternal* CreateSharedMemory(const SharedMemory::OpenParameters& params);
+    };
+
+
+    //// FakeMemoryManager
+
+    class FakeMemoryManager : public NewOverrideBase, public SystemSingletonBase<FakeMemoryManager>
+    {
+        OVR_DECLARE_SINGLETON(FakeMemoryManager);
+
+        Lock FakeLock;
+        Array< Ptr<FakeMemoryBlock> > FakeArray;
+
+    public:
+        SharedMemoryInternal* Open(const char *name, int bytes, bool openOnly)
+        {
+            Lock::Locker locker(&FakeLock);
+
+            const int count = FakeArray.GetSizeI();
+            for (int ii = 0; ii < count; ++ii)
+            {
+                if (FakeArray[ii]->IsNamed(name))
+                {
+                    FakeArray[ii]->IncrementReferences();
+                    return new SharedMemoryInternal(FakeArray[ii]);
+                }
+            }
+
+            if (openOnly)
+            {
+                return NULL;
+            }
+
+            Ptr<FakeMemoryBlock> data = *new FakeMemoryBlock(name, bytes);
+            FakeArray.PushBack(data);
+            return new SharedMemoryInternal(data);
+        }
+
+        void Free(FakeMemoryBlock* block)
+        {
+            Lock::Locker locker(&FakeLock);
+
+            const int count = FakeArray.GetSizeI();
+            for (int ii = 0; ii < count; ++ii)
+            {
+                if (FakeArray[ii].GetPtr() == block)
+                {
+                    // If the reference count hit zero,
+                    if (FakeArray[ii]->DecrementReferences())
+                    {
+                        // Toast
+                        FakeArray.RemoveAtUnordered(ii);
+                    }
+                    break;
+                }
+            }
+        }
+    };
+
+    FakeMemoryManager::FakeMemoryManager()
+    {
+        PushDestroyCallbacks();
+    }
+
+    FakeMemoryManager::~FakeMemoryManager()
+    {
+        OVR_ASSERT(FakeArray.GetSizeI() == 0);
+    }
+
+    void FakeMemoryManager::OnSystemDestroy()
+    {
+        delete this;
+    }
+
+
+} // namespace OVR
+
+OVR_DEFINE_SINGLETON(FakeMemoryManager);
+
+namespace OVR {
+
+
+void SharedMemoryInternal::Close()
+{
+	FakeMemoryManager::GetInstance()->Free(Block);
+	Block.Clear();
+}
+
+SharedMemoryInternal* SharedMemoryInternal::CreateSharedMemory(const SharedMemory::OpenParameters& params)
+{
+	return FakeMemoryManager::GetInstance()->Open(params.globalName, params.minSizeBytes, params.openMode == SharedMemory::OpenMode_OpenOnly);
+}
+
+#endif
+
+
+//// Windows version
+
+#if defined(OVR_OS_WIN32) && !defined(OVR_FAKE_SHAREDMEMORY)
+
+#pragma comment(lib, "advapi32.lib")
+
+// Hidden implementation class for OS-specific behavior
+class SharedMemoryInternal : public NewOverrideBase
+{
+public:
+	HANDLE FileMapping;
+	void* FileView;
+
+	SharedMemoryInternal(HANDLE fileMapping, void* fileView) :
+		FileMapping(fileMapping),
+		FileView(fileView)
+	{
+	}
+
+	~SharedMemoryInternal()
+	{
+		// If file view is set,
+		if (FileView)
+		{
+			UnmapViewOfFile(FileView);
+			FileView = NULL;
+		}
+
+		// If file mapping is set,
+		if (FileMapping != NULL)
+		{
+			CloseHandle(FileMapping);
+			FileMapping = NULL;
+		}
+	}
+
+	static SharedMemoryInternal* DoFileMap(HANDLE hFileMapping, const char* fileName, bool openReadOnly, int minSize);
+	static SharedMemoryInternal* AttemptOpenSharedMemory(const char* fileName, int minSize, bool openReadOnly);
+	static SharedMemoryInternal* AttemptCreateSharedMemory(const char* fileName, int minSize, bool openReadOnly, bool allowRemoteWrite);
+	static SharedMemoryInternal* CreateSharedMemory(const SharedMemory::OpenParameters& params);
+};
+
+SharedMemoryInternal* SharedMemoryInternal::DoFileMap(HANDLE hFileMapping, const char* fileName, bool openReadOnly, int minSize)
+{
+	// Interpret the access mode as a map desired access code
+	DWORD mapDesiredAccess = openReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE;
+
+	// Map view of the file to this process
+	void* pFileView = MapViewOfFile(hFileMapping, mapDesiredAccess, 0, 0, minSize);
+
+	// If mapping could not be created,
+	if (!pFileView)
+	{
+		CloseHandle(hFileMapping);
+
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to map view of file for %s error code = %d", fileName, GetLastError()));
+        OVR_UNUSED(fileName);
+		return NULL;
+	}
+
+	// Create internal representation
+	SharedMemoryInternal* pimple = new SharedMemoryInternal(hFileMapping, pFileView);
+
+	// If memory allocation fails,
+	if (!pimple)
+	{
+		UnmapViewOfFile(pFileView);
+		CloseHandle(hFileMapping);
+
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Out of memory"));
+		return NULL;
+	}
+
+	return pimple;
+}
+
+SharedMemoryInternal* SharedMemoryInternal::AttemptOpenSharedMemory(const char* fileName, int minSize, bool openReadOnly)
+{
+	// Interpret the access mode as a map desired access code
+	DWORD mapDesiredAccess = openReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE;
+
+	// Open file mapping
+	HANDLE hFileMapping = OpenFileMappingA(mapDesiredAccess, TRUE, fileName);
+
+	// If file was mapped unsuccessfully,
+	if (NULL == hFileMapping)
+	{
+		OVR_DEBUG_LOG(("[SharedMemory] WARNING: Unable to open file mapping for %s error code = %d (not necessarily bad)", fileName, GetLastError()));
+		return NULL;
+	}
+
+	// Map the file
+	return DoFileMap(hFileMapping, fileName, openReadOnly, minSize);
+}
+
+SharedMemoryInternal* SharedMemoryInternal::AttemptCreateSharedMemory(const char* fileName, int minSize, bool openReadOnly, bool allowRemoteWrite)
+{
+	// Prepare a SECURITY_ATTRIBUTES object
+	SECURITY_ATTRIBUTES security;
+	ZeroMemory(&security, sizeof(security));
+	security.nLength = sizeof(security);
+
+	// Security descriptor by DACL strings:
+	// ACE strings grant Allow(A), Object/Contains Inheritance (OICI) of:
+	// + Grant All (GA) to System (SY)
+	// + Grant All (GA) to Built-in Administrators (BA)
+	// + Grant Read-Only (GR) or Read-Write (GWGR) to Interactive Users (IU) - ie. games
+	static const char* DACLString_ReadOnly = "D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GR;;;IU)";
+	static const char* DACLString_ReadWrite = "D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GWGR;;;IU)";
+
+	// Select the remote process access mode
+	const char* remoteAccessString =
+		allowRemoteWrite ? DACLString_ReadWrite : DACLString_ReadOnly;
+
+	// Attempt to convert access string to security attributes
+	// Note: This will allocate the security descriptor with LocalAlloc() and must be freed later
+	BOOL bConvertOkay = ConvertStringSecurityDescriptorToSecurityDescriptorA(
+		remoteAccessString, SDDL_REVISION_1, &security.lpSecurityDescriptor, NULL);
+
+	// If conversion fails,
+	if (!bConvertOkay)
+	{
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to convert access string, error code = %d", GetLastError()));
+		return NULL;
+	}
+
+	// Interpret the access mode as a page protection code
+	int pageProtectCode = openReadOnly ? PAGE_READONLY : PAGE_READWRITE;
+
+	// Attempt to create a file mapping
+	HANDLE hFileMapping = CreateFileMappingA(INVALID_HANDLE_VALUE,	// From page file
+											 &security,				// Security attributes
+											 pageProtectCode,		// Read-only?
+											 0,						// High word for size = 0
+											 minSize,				// Low word for size
+											 fileName);				// Name of global shared memory file
+
+	// Free the security descriptor buffer
+	LocalFree(security.lpSecurityDescriptor);
+
+	// If mapping could not be created,
+	if (NULL == hFileMapping)
+	{
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to create file mapping for %s error code = %d", fileName, GetLastError()));
+		return NULL;
+	}
+
+#ifndef OVR_ALLOW_CREATE_FILE_MAPPING_IF_EXISTS
+	// If the file mapping already exists,
+	if (GetLastError() == ERROR_ALREADY_EXISTS)
+	{
+		CloseHandle(hFileMapping);
+
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: File mapping at %s already exists", fileName));
+		return NULL;
+	}
+#endif
+
+	// Map the file
+	return DoFileMap(hFileMapping, fileName, openReadOnly, minSize);
+}
+
+SharedMemoryInternal* SharedMemoryInternal::CreateSharedMemory(const SharedMemory::OpenParameters& params)
+{
+	SharedMemoryInternal* retval = NULL;
+
+	// Construct the file mapping name in a Windows-specific way
+	OVR::String fileMappingName = params.globalName;
+	const char *fileName = fileMappingName.ToCStr();
+
+	// Is being opened read-only?
+	const bool openReadOnly = (params.accessMode == SharedMemory::AccessMode_ReadOnly);
+
+	// Try up to 3 times to reduce low-probability failures:
+	static const int ATTEMPTS_MAX = 3;
+	for (int attempts = 0; attempts < ATTEMPTS_MAX; ++attempts)
+	{
+		// If opening should be attempted first,
+		if (params.openMode != SharedMemory::OpenMode_CreateOnly)
+		{
+			// Attempt to open a shared memory map
+			retval = AttemptOpenSharedMemory(fileName, params.minSizeBytes, openReadOnly);
+
+			// If successful,
+			if (retval)
+			{
+				// Done!
+				break;
+			}
+		}
+
+		// If creating the shared memory is also acceptable,
+		if (params.openMode != SharedMemory::OpenMode_OpenOnly)
+		{
+			// Interpret create mode
+			const bool allowRemoteWrite = (params.remoteMode == SharedMemory::RemoteMode_ReadWrite);
+
+			// Attempt to create a shared memory map
+			retval = AttemptCreateSharedMemory(fileName, params.minSizeBytes, openReadOnly, allowRemoteWrite);
+
+			// If successful,
+			if (retval)
+			{
+				// Done!
+				break;
+			}
+		}
+	} // Re-attempt create/open
+
+	// Note: On Windows the initial contents of the region are guaranteed to be zero.
+	return retval;
+}
+
+#endif // OVR_OS_WIN32
+
+
+#if (defined(OVR_OS_LINUX) || defined(OVR_OS_MAC)) && !defined(OVR_FAKE_SHAREDMEMORY)
+
+// Hidden implementation class for OS-specific behavior
+class SharedMemoryInternal
+{
+public:
+	int   FileMapping;
+	void* FileView;
+    int   FileSize;
+
+	SharedMemoryInternal(int fileMapping, void* fileView, int fileSize) :
+		FileMapping(fileMapping),
+		FileView(fileView),
+        FileSize(fileSize)
+	{
+	}
+
+	~SharedMemoryInternal()
+	{
+		// If file view is set,
+		if (FileView)
+		{
+            munmap(FileView, FileSize);
+			FileView = MAP_FAILED;
+		}
+
+		// If file mapping is set,
+		if (FileMapping >= 0)
+		{
+            close(FileMapping);
+			FileMapping = -1;
+		}
+	}
+
+	static SharedMemoryInternal* DoFileMap(int hFileMapping, const char* fileName, bool openReadOnly, int minSize);
+	static SharedMemoryInternal* AttemptOpenSharedMemory(const char* fileName, int minSize, bool openReadOnly);
+	static SharedMemoryInternal* AttemptCreateSharedMemory(const char* fileName, int minSize, bool openReadOnly, bool allowRemoteWrite);
+	static SharedMemoryInternal* CreateSharedMemory(const SharedMemory::OpenParameters& params);
+};
+
+SharedMemoryInternal* SharedMemoryInternal::DoFileMap(int hFileMapping, const char* fileName, bool openReadOnly, int minSize)
+{
+    // Calculate the required flags based on read/write mode
+    int prot = openReadOnly ? PROT_READ : (PROT_READ|PROT_WRITE);
+
+    // Map the file view
+    void* pFileView = mmap(NULL, minSize, prot, MAP_SHARED, hFileMapping, 0);
+
+    if (pFileView == MAP_FAILED)
+    {
+        close(hFileMapping);
+
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to map view of file for %s error code = %d", fileName, errno));
+        OVR_UNUSED(fileName);
+		return NULL;
+    }
+
+	// Create internal representation
+	SharedMemoryInternal* pimple = new SharedMemoryInternal(hFileMapping, pFileView, minSize);
+
+	// If memory allocation fails,
+	if (!pimple)
+	{
+        munmap(pFileView, minSize);
+        close(hFileMapping);
+
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Out of memory"));
+		return NULL;
+	}
+
+	return pimple;
+}
+
+SharedMemoryInternal* SharedMemoryInternal::AttemptOpenSharedMemory(const char* fileName, int minSize, bool openReadOnly)
+{
+    // Calculate permissions and flags based on read/write mode
+    int flags = openReadOnly ? O_RDONLY : O_RDWR;
+    int perms = openReadOnly ? S_IRUSR : (S_IRUSR | S_IWUSR);
+
+    // Attempt to open the shared memory file
+    int hFileMapping = shm_open(fileName, flags, perms);
+
+    // If file was not opened successfully,
+    if (hFileMapping < 0)
+    {
+		OVR_DEBUG_LOG(("[SharedMemory] WARNING: Unable to open file mapping for %s error code = %d (not necessarily bad)", fileName, errno));
+		return NULL;
+    }
+
+	// Map the file
+	return DoFileMap(hFileMapping, fileName, openReadOnly, minSize);
+}
+
+SharedMemoryInternal* SharedMemoryInternal::AttemptCreateSharedMemory(const char* fileName, int minSize, bool openReadOnly, bool allowRemoteWrite)
+{
+    // Create mode
+    // Note: Cannot create the shared memory file read-only because then ftruncate() will fail.
+    int flags = O_CREAT | O_RDWR;
+
+#ifndef OVR_ALLOW_CREATE_FILE_MAPPING_IF_EXISTS
+    // Require exclusive access when creating (seems like a good idea without trying it yet..)
+    if (shm_unlink(fileName) < 0)
+    {
+		OVR_DEBUG_LOG(("[SharedMemory] WARNING: Unable to unlink shared memory file %s error code = %d", fileName, errno));
+    }
+    flags |= O_EXCL;
+#endif
+
+    // Set own read/write permissions
+    int perms = openReadOnly ? S_IRUSR : (S_IRUSR|S_IWUSR);
+
+    // Allow other users to read/write the shared memory file
+    perms |= allowRemoteWrite ? (S_IWGRP|S_IWOTH|S_IRGRP|S_IROTH) : (S_IRGRP|S_IROTH);
+
+    // Attempt to open the shared memory file
+    int hFileMapping = shm_open(fileName, flags, perms);
+
+    // If file was not opened successfully,
+    if (hFileMapping < 0)
+    {
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to create file mapping for %s error code = %d", fileName, errno));
+		return NULL;
+    }
+
+    int truncRes = ftruncate(hFileMapping, minSize);
+
+    // If file was not opened successfully,
+    if (truncRes < 0)
+    {
+        close(hFileMapping);
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Unable to truncate file for %s to %d error code = %d", fileName, minSize, errno));
+		return NULL;
+    }
+
+	// Map the file
+	return DoFileMap(hFileMapping, fileName, openReadOnly, minSize);
+}
+
+SharedMemoryInternal* SharedMemoryInternal::CreateSharedMemory(const SharedMemory::OpenParameters& params)
+{
+	SharedMemoryInternal* retval = NULL;
+
+	// Construct the file mapping name in a Linux-specific way
+	OVR::String fileMappingName = "/";
+	fileMappingName += params.globalName;
+	const char *fileName = fileMappingName.ToCStr();
+
+	// Is being opened read-only?
+	const bool openReadOnly = (params.accessMode == SharedMemory::AccessMode_ReadOnly);
+
+	// Try up to 3 times to reduce low-probability failures:
+	static const int ATTEMPTS_MAX = 3;
+	for (int attempts = 0; attempts < ATTEMPTS_MAX; ++attempts)
+	{
+		// If opening should be attempted first,
+		if (params.openMode != SharedMemory::OpenMode_CreateOnly)
+		{
+			// Attempt to open a shared memory map
+			retval = AttemptOpenSharedMemory(fileName, params.minSizeBytes, openReadOnly);
+
+			// If successful,
+			if (retval)
+			{
+				// Done!
+				break;
+			}
+		}
+
+		// If creating the shared memory is also acceptable,
+		if (params.openMode != SharedMemory::OpenMode_OpenOnly)
+		{
+            // Interpret create mode
+            const bool allowRemoteWrite = (params.remoteMode == SharedMemory::RemoteMode_ReadWrite);
+
+            // Attempt to create a shared memory map
+            retval = AttemptCreateSharedMemory(fileName, params.minSizeBytes, openReadOnly, allowRemoteWrite);
+
+            // If successful,
+            if (retval)
+            {
+                // Done!
+                break;
+            }
+		}
+	} // Re-attempt create/open
+
+	// Note: On Windows the initial contents of the region are guaranteed to be zero.
+	return retval;
+}
+
+#endif // OVR_OS_LINUX
+
+
+//// SharedMemory
+
+SharedMemory::SharedMemory(int size, void* data, SharedMemoryInternal* pInternal) :
+	Size(size),
+	Data(data),
+	Internal(pInternal)
+{
+}
+// Call close when it goes out of scope
+SharedMemory::~SharedMemory()
+{
+	Close();
+    delete Internal;
+}
+
+void SharedMemory::Close()
+{
+	if (Internal)
+	{
+		delete Internal;
+		Internal = NULL;
+	}
+}
+
+
+//// SharedMemoryFactory
+
+Ptr<SharedMemory> SharedMemoryFactory::Open(const SharedMemory::OpenParameters& params)
+{
+	Ptr<SharedMemory> retval;
+
+	// If no name specified or no size requested,
+	if (!params.globalName || (params.minSizeBytes <= 0))
+	{
+		OVR_DEBUG_LOG(("[SharedMemory] FAILURE: Invalid parameters to Create()"));
+		return NULL;
+	}
+
+	OVR_DEBUG_LOG(("[SharedMemory] Creating shared memory region: %s > %d bytes",
+		params.globalName, params.minSizeBytes));
+
+	// Attempt to create a shared memory region from the parameters
+	SharedMemoryInternal* pInternal = SharedMemoryInternal::CreateSharedMemory(params);
+
+	if (pInternal)
+	{
+		// Create the wrapper object
+		retval = *new SharedMemory(params.minSizeBytes, pInternal->FileView, pInternal);
+	}
+
+	return retval;
+}
+
+SharedMemoryFactory::SharedMemoryFactory()
+{
+	OVR_DEBUG_LOG(("[SharedMemory] Creating factory"));
+
+    PushDestroyCallbacks();
+}
+
+SharedMemoryFactory::~SharedMemoryFactory()
+{
+	OVR_DEBUG_LOG(("[SharedMemory] Destroying factory"));
+}
+
+void SharedMemoryFactory::OnSystemDestroy()
+{
+    delete this;
+}
+
+
+} // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,237 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_SharedMemory.h
+Content     :   Inter-process shared memory subsystem
+Created     :   June 1, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SharedMemory_h
+#define OVR_SharedMemory_h
+
+#include "OVR_Types.h"
+#include "OVR_RefCount.h"
+#include "OVR_Allocator.h"
+#include "OVR_System.h"
+
+#ifdef OVR_SINGLE_PROCESS /* Everything running in one process usually for debugging */
+#define OVR_FAKE_SHAREDMEMORY /* Single-process version to avoid admin privs */
+#endif
+
+namespace OVR {
+
+class SharedMemoryInternal; // Opaque
+
+
+// SharedMemory
+// Note: Safe when used between 32-bit and 64-bit processes
+class SharedMemory : public RefCountBase<SharedMemory>
+{
+	friend class SharedMemoryFactory;
+
+	SharedMemory(SharedMemory&) {}
+	void operator=(SharedMemory&) {}
+
+public:
+	// Only constructed by the SharedMemory Factory
+    SharedMemory(int size, void* data, SharedMemoryInternal* pInternal);
+	// Call close when it goes out of scope
+    ~SharedMemory();
+
+	// Modes for opening a new shared memory region
+	enum OpenMode
+	{
+		// Note: On Windows, Create* requires Administrator priviledges or running as a Service.
+		OpenMode_CreateOnly,		// Must not already exist
+		OpenMode_OpenOnly,			// Must already exist
+		OpenMode_CreateOrOpen		// May exist or not
+	};
+
+	// Local access restrictions
+	enum AccessMode
+	{
+		AccessMode_ReadOnly,		// Acquire read-only access
+		AccessMode_ReadWrite,		// Acquire read or write access
+	};
+
+	// Remote access restrictions
+	enum RemoteMode
+	{
+		RemoteMode_ReadOnly,		// Other processes will need to open in read-only mode
+		RemoteMode_ReadWrite		// Other processes can open in read-write mode
+	};
+
+	// Modes for opening a new shared memory region
+	struct OpenParameters
+	{
+		OpenParameters() :
+			globalName(NULL),
+			minSizeBytes(0),
+			openMode(SharedMemory::OpenMode_CreateOrOpen),
+			remoteMode(SharedMemory::RemoteMode_ReadWrite),
+			accessMode(SharedMemory::AccessMode_ReadWrite)
+		{
+		}
+
+		// Creation parameters
+		const char*					globalName;		// Name of the shared memory region
+		int							minSizeBytes;	// Minimum number of bytes to request
+		SharedMemory::OpenMode		openMode;		// Creating the file or opening the file?
+		SharedMemory::RemoteMode	remoteMode;		// When creating, what access should other processes get?
+		SharedMemory::AccessMode	accessMode;		// When opening/creating, what access should this process get?
+	};
+
+public:
+	// Returns the size of the shared memory region
+	int GetSizeI() const
+	{
+		return Size;
+	}
+
+	// Returns the process-local pointer to the shared memory region
+	// Note: This may be different on different processes
+	void* GetData() const
+	{
+		return Data;
+	}
+
+protected:
+	int Size;		// How many shared bytes are shared at the pointer address?
+	void* Data;		// Pointer to the shared memory region.
+
+	// Hidden implementation class for OS-specific behavior
+	SharedMemoryInternal* Internal;
+
+	// Close and cleanup the shared memory region
+	// Note: This is called on destruction
+	void Close();
+};
+
+
+// SharedMemoryFactory
+class SharedMemoryFactory : public NewOverrideBase, public SystemSingletonBase<SharedMemoryFactory>
+{
+    OVR_DECLARE_SINGLETON(SharedMemoryFactory);
+
+public:
+    // Construct a SharedMemory object.
+	// Note: The new object is reference-counted so it should be stored with Ptr<>.  Initial reference count is 1.
+	Ptr<SharedMemory> Open(const SharedMemory::OpenParameters&);
+};
+
+
+// A shared object
+// Its constructor will be called when creating a writer
+// Its destructor will not be called
+template<class SharedType>
+class ISharedObject : public NewOverrideBase
+{
+public:
+	static const int RegionSize = (int)sizeof(SharedType);
+
+protected:
+	Ptr<SharedMemory> pSharedMemory;
+
+	bool Open(const char* name, bool readOnly)
+	{
+		// Configure open parameters based on read-only mode
+		SharedMemory::OpenParameters params;
+		params.globalName = name;
+		// FIXME: This is a hack.  We currently need to open this for read-write even when just reading from
+		// it because the LocklessUpdater class technically writes to it (increments by 0).
+		//params.accessMode = readOnly ? SharedMemory::AccessMode_ReadOnly : SharedMemory::AccessMode_ReadWrite;
+		//params.remoteMode = SharedMemory::RemoteMode_ReadOnly;
+		params.accessMode = SharedMemory::AccessMode_ReadWrite;
+		params.remoteMode = SharedMemory::RemoteMode_ReadWrite;
+		params.minSizeBytes = RegionSize;
+		params.openMode = readOnly ? SharedMemory::OpenMode_OpenOnly : SharedMemory::OpenMode_CreateOrOpen;
+
+		// Attempt to open the shared memory file
+		pSharedMemory = SharedMemoryFactory::GetInstance()->Open(params);
+
+		// If it was not able to be opened,
+		if (pSharedMemory && pSharedMemory->GetSizeI() >= RegionSize && pSharedMemory->GetData())
+		{
+			// If writing,
+			if (!readOnly)
+			{
+				// Construct the object also
+				Construct<SharedType>(pSharedMemory->GetData());
+			}
+
+			return true;
+		}
+
+		return false;
+	}
+
+	SharedType* Get() const
+	{
+		if (!pSharedMemory)
+		{
+			return NULL;
+		}
+
+		void* data = pSharedMemory->GetData();
+		if (!data)
+		{
+			return NULL;
+		}
+
+		return reinterpret_cast<SharedType*>(data);
+	}
+};
+
+// Writer specialized shared object: Ctor will be called on Open()
+template<class SharedType>
+class SharedObjectWriter : public ISharedObject<SharedType>
+{
+public:
+	OVR_FORCE_INLINE bool Open(const char* name)
+	{
+		return ISharedObject<SharedType>::Open(name, false);
+	}
+	OVR_FORCE_INLINE SharedType* Get()
+	{
+		return ISharedObject<SharedType>::Get();
+	}
+};
+
+// Reader specialized shared object: Ctor will not be called
+template<class SharedType>
+class SharedObjectReader : public ISharedObject<SharedType>
+{
+public:
+	OVR_FORCE_INLINE bool Open(const char* name)
+	{
+		return ISharedObject<SharedType>::Open(name, true);
+	}
+	OVR_FORCE_INLINE const SharedType* Get() const
+	{
+		return ISharedObject<SharedType>::Get();
+	}
+};
+
+
+} // namespace OVR
+
+#endif // OVR_SharedMemory_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1036 @@
+/************************************************************************************
+
+Filename    :   OVR_Std.cpp
+Content     :   Standard C function implementation
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+// localeconv() call in OVR_strtod()
+#include <locale.h>
+
+namespace OVR {
+
+// Source for functions not available on all platforms is included here.
+
+// Case insensitive compare implemented in platform-specific way.
+int OVR_CDECL OVR_stricmp(const char* a, const char* b)
+{
+#if defined(OVR_OS_WIN32) 
+    #if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+        return ::_stricmp(a, b);
+    #else
+        return ::stricmp(a, b);
+    #endif
+
+#else
+    return strcasecmp(a, b);
+#endif
+}
+
+int OVR_CDECL OVR_strnicmp(const char* a, const char* b, size_t count)
+{
+#if defined(OVR_OS_WIN32) 
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+    return ::_strnicmp(a, b, count);
+#else
+    return ::strnicmp(a, b, count);
+#endif
+
+#else
+    return strncasecmp(a, b, count);
+#endif
+}
+
+wchar_t* OVR_CDECL OVR_wcscpy(wchar_t* dest, size_t destsize, const wchar_t* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    wcscpy_s(dest, destsize, src);
+    return dest;
+#elif defined(OVR_OS_WIN32)
+    OVR_UNUSED(destsize);
+    wcscpy(dest, src);
+    return dest;
+#else
+    size_t l = OVR_wcslen(src) + 1; // incl term null
+    l = (l < destsize) ? l : destsize;
+    memcpy(dest, src, l * sizeof(wchar_t));
+    return dest;
+#endif
+}
+
+wchar_t* OVR_CDECL OVR_wcsncpy(wchar_t* dest, size_t destsize, const wchar_t* src, size_t count)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    wcsncpy_s(dest, destsize, src, count);
+    return dest;
+#else
+    size_t srclen = OVR_wcslen(src);
+    size_t l = Alg::Min(srclen, count);
+    l = (l < destsize) ? l : destsize;
+    memcpy(dest, src, l * sizeof(wchar_t));
+    if (count > srclen)
+    {
+        size_t remLen = Alg::Min(destsize - l, (count - srclen));
+        memset(&dest[l], 0, sizeof(wchar_t)*remLen);
+    }
+    else if (l < destsize)
+        dest[l] = 0;
+    return dest;
+#endif
+}
+
+
+wchar_t* OVR_CDECL OVR_wcscat(wchar_t* dest, size_t destsize, const wchar_t* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    wcscat_s(dest, destsize, src);
+    return dest;
+#elif defined(OVR_OS_WIN32)
+    OVR_UNUSED(destsize);
+    wcscat(dest, src);
+    return dest;
+#else
+    size_t dstlen = OVR_wcslen(dest); // do not incl term null
+    size_t srclen = OVR_wcslen(src) + 1; // incl term null
+    size_t copylen = (dstlen + srclen < destsize) ? srclen : destsize - dstlen;
+    memcpy(dest + dstlen, src, copylen * sizeof(wchar_t));
+    return dest;
+#endif
+}
+
+size_t  OVR_CDECL OVR_wcslen(const wchar_t* str)
+{
+#if defined(OVR_OS_WIN32) 
+    return wcslen(str);
+#else
+    size_t i = 0;
+    while(str[i] != '\0')
+        ++i;
+    return i;
+#endif
+}
+
+int OVR_CDECL OVR_wcscmp(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32)  || defined(OVR_OS_LINUX)
+    return wcscmp(a, b);
+#else
+    // not supported, use custom implementation
+    const wchar_t *pa = a, *pb = b;
+    while (*pa && *pb)
+    {
+        wchar_t ca = *pa;
+        wchar_t cb = *pb;
+        if (ca < cb)
+            return -1;
+        else if (ca > cb)
+            return 1;
+        pa++;
+        pb++;
+    }
+    if (*pa)
+        return 1;
+    else if (*pb)
+        return -1;
+    else
+        return 0;
+#endif
+}
+
+int OVR_CDECL OVR_wcsicmp(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32) 
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+    return ::_wcsicmp(a, b);
+#else
+    return ::wcsicmp(a, b);
+#endif
+#elif defined(OVR_OS_MAC) || defined(__CYGWIN__) || defined(OVR_OS_ANDROID) || defined(OVR_OS_IPHONE)
+    // not supported, use custom implementation
+    const wchar_t *pa = a, *pb = b;
+    while (*pa && *pb)
+    {
+        wchar_t ca = OVR_towlower(*pa);
+        wchar_t cb = OVR_towlower(*pb);
+        if (ca < cb)
+            return -1;
+        else if (ca > cb)
+            return 1;
+        pa++;
+        pb++;
+    }
+    if (*pa)
+        return 1;
+    else if (*pb)
+        return -1;
+    else
+        return 0;
+#else
+    return wcscasecmp(a, b);
+#endif
+}
+
+// This function is not inline because of dependency on <locale.h>
+double OVR_CDECL OVR_strtod(const char* string, char** tailptr)
+{
+#if !defined(OVR_OS_ANDROID)
+    const char s = *localeconv()->decimal_point;
+
+    if (s != '.')
+    {
+        char buffer[347 + 1];
+
+        OVR_strcpy(buffer, sizeof(buffer), string);
+
+        for (char* c = buffer; *c != '\0'; ++c)
+        {
+            if (*c == '.')
+            {
+                *c = s;
+                break;
+            }
+        }
+
+        return strtod(buffer, tailptr);
+    }
+#endif
+
+    return strtod(string, tailptr);
+}
+
+
+#ifndef OVR_NO_WCTYPE
+
+//// Use this class to generate Unicode bitsets. For example:
+////
+//// UnicodeBitSet bitSet;
+//// for(unsigned i = 0; i < 65536; ++i)
+//// {
+////     if (iswalpha(i))
+////         bitSet.Set(i);
+//// }
+//// bitSet.Dump();
+////
+////---------------------------------------------------------------
+//class UnicodeBitSet
+//{
+//public:
+//    UnicodeBitSet()
+//    {
+//        memset(Offsets, 0, sizeof(Offsets));
+//        memset(Bits,    0, sizeof(Bits));
+//    }
+//
+//    void Set(unsigned bit) { Bits[bit >> 8][(bit >> 4) & 15] |= 1 << (bit & 15); }
+//
+//    void Dump()
+//    {
+//        unsigned i, j;
+//        unsigned offsetCount = 0;
+//        for(i = 0; i < 256; ++i)
+//        {
+//            if (isNull(i)) Offsets[i] = 0;
+//            else
+//            if (isFull(i)) Offsets[i] = 1;
+//            else           Offsets[i] = uint16_t(offsetCount++ * 16 + 256);
+//        }
+//        for(i = 0; i < 16; ++i)
+//        {
+//            for(j = 0; j < 16; ++j)
+//            {
+//                printf("%5u,", Offsets[i*16+j]);
+//            }
+//            printf("\n");
+//        }
+//        for(i = 0; i < 256; ++i)
+//        {
+//            if (Offsets[i] > 255)
+//            {
+//                for(j = 0; j < 16; j++)
+//                {
+//                    printf("%5u,", Bits[i][j]);
+//                }
+//                printf("\n");
+//            }
+//        }
+//    }
+//
+//private:
+//    bool isNull(unsigned n) const
+//    {
+//        const uint16_t* p = Bits[n];
+//        for(unsigned i = 0; i < 16; ++i)
+//            if (p[i] != 0) return false;
+//        return true;
+//    }
+//
+//    bool isFull(unsigned n) const
+//    {
+//        const uint16_t* p = Bits[n];
+//        for(unsigned i = 0; i < 16; ++i)
+//            if (p[i] != 0xFFFF) return false;
+//        return true;
+//    }
+//
+//    uint16_t Offsets[256];
+//    uint16_t Bits[256][16];
+//};
+
+
+const uint16_t UnicodeAlnumBits[] = {
+  256,    1,  272,  288,  304,  320,  336,  352,    0,  368,  384,  400,  416,  432,  448,  464,
+  480,  496,  512,  528,  544,    1,  560,  576,  592,    0,    0,    0,    0,    0,  608,  624,
+  640,  656,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  672,  688,    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  704,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  720,
+    1,    1,    1,    1,  736,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,  752,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,  768,  784,    1,  800,  816,  832,
+    0,    0,    0, 1023,65534, 2047,65534, 2047,    0,    0,    0,  524,65535,65407,65535,65407,
+65535,65535,65532,   15,    0,65535,65535,65535,65535,65535,16383,63999,    3,    0,16415,    0,
+    0,    0,    0,    0,   32,    0,    0, 1024,55104,65535,65531,65535,32767,64767,65535,   15,
+65535,65535,65535,65535,65535,65535,65535,65535,61443,65535,65535,65535, 6559,65535,65535,  831,
+    0,    0,    0,65534,65535,  639,65534,65535,  255,    0,    0,    0,    0,65535, 2047,    7,
+    0,    0,65534, 2047,65534,   63, 1023,65535,65535,65535,65535,65535,65535, 8175, 8702, 8191,
+    0,65535, 8191,65535,    0,    0,    0,    0,65535,65535,65535,    1,    0,    0,    0,    0,
+65518,65535,65535,58367, 8191,65281,65487,    0,40942,65529,65023,50117, 6559,45184,65487,    3,
+34788,65529,65023,50029, 6535,24064,65472,   31,45038,65531,65023,58349, 7103,    1,65473,    0,
+40942,65529,65023,58317, 6543,45248,65475,    0,51180,54845,50968,50111, 7623,  128,65408,    0,
+57326,65533,65023,50159, 7647,   96,65475,    0,57324,65533,65023,50159, 7647,16480,65475,    0,
+57324,65533,65023,50175, 7631,  128,65475,    0,65516,64639,65535,12283,32895,65375,    0,   12,
+65534,65535,65535, 2047,32767, 1023,    0,    0, 9622,65264,60590,15359, 8223,13311,    0,    0,
+    1,    0, 1023,    0,65279,65535, 2047,65534, 3843,65279,65535, 8191,    0,    0,    0,    0,
+65535,65535,63227,  327, 1023, 1023,    0,    0,    0,    0,65535,65535,   63,65535,65535,  127,
+65535,65535,65535,65535,65535,33791,65535,65535,65535,65535,65287,65535,65535,65535,65535, 1023,
+65407,65535,65535,65535,15743,15743,65535,65535,15743,65535,32767,32573,32573,65407,32767,65535,
+32767,32573,65535,65535,65407, 2047,65024,    3,    0,    0,65535,65535,65535,65535,65535,   31,
+65534,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,
+65535,65535,65535,65535,65535,65535,40959,  127,65534, 2047,65535,65535,65535,65535, 2047,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,65535,65535,  511,    0, 1023,    0,
+    0, 1023,65535,65535,65527,65535,65535,  255,65535,65535, 1023,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535, 4095,65535,65535,65535,65535,65535, 1023,
+65535,16191,65535,65535,16191,43775,65535,16383,65535,65535,65535,24543, 8156, 4047, 8191, 8156,
+    0,    0,    0,    0,    0,    0,    0,32768,    0,    0,    0,    0,    0,    0,    0,    0,
+64644,15919,48464, 1019,    0,    0,65535,65535,   15,    0,    0,    0,    0,    0,    0,    0,
+  192,    0, 1022, 1792,65534,65535,65535,65535,65535,   31,65534,65535,65535,65535,65535, 2047,
+65504,65535, 8191,65534,65535,65535,65535,65535,32767,    0,65535,  255,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535, 8191,    0,    0,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   15,    0,    0,    0,    0,    0,
+65535,65535,16383,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  127,41208,65023,24447,65499,65535,65535,65535,65535,65535,65535,    3,    0,65528,65535,65535,
+65535,65535,65535,16383,    0,65535,65535,65535,65535,65532,65535,65535,  255,    0,    0, 4095,
+    0,    0,    0,    0,    0,    0,    0,65495,65535,65535,65535,65535,65535,65535,65535, 8191,
+    0, 1023,65534, 2047,65534, 2047,65472,65534,65535,16383,65535,32767,64764, 7420,    0,    0};
+
+const uint16_t UnicodeAlphaBits[] = {
+  256,    1,  272,  288,  304,  320,  336,  352,    0,  368,  384,  400,  416,  432,  448,  464,
+  480,  496,  512,  528,  544,    1,  560,  576,  592,    0,    0,    0,    0,    0,  608,  624,
+  640,  656,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  672,  688,    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  704,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  720,
+    1,    1,    1,    1,  736,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,  752,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,  768,  784,    1,  800,  816,  832,
+    0,    0,    0,    0,65534, 2047,65534, 2047,    0,    0,    0,    0,65535,65407,65535,65407,
+65535,65535,65532,   15,    0,65535,65535,65535,65535,65535,16383,63999,    3,    0,16415,    0,
+    0,    0,    0,    0,   32,    0,    0, 1024,55104,65535,65531,65535,32767,64767,65535,   15,
+65535,65535,65535,65535,65535,65535,65535,65535,61443,65535,65535,65535, 6559,65535,65535,  831,
+    0,    0,    0,65534,65535,  639,65534,65535,  255,    0,    0,    0,    0,65535, 2047,    7,
+    0,    0,65534, 2047,65534,   63,    0,65535,65535,65535,65535,65535,65535, 8175, 8702, 7168,
+    0,65535, 8191,65535,    0,    0,    0,    0,65535,65535,65535,    1,    0,    0,    0,    0,
+65518,65535,65535,58367, 8191,65281,   15,    0,40942,65529,65023,50117, 6559,45184,   15,    3,
+34788,65529,65023,50029, 6535,24064,    0,   31,45038,65531,65023,58349, 7103,    1,    1,    0,
+40942,65529,65023,58317, 6543,45248,    3,    0,51180,54845,50968,50111, 7623,  128,    0,    0,
+57326,65533,65023,50159, 7647,   96,    3,    0,57324,65533,65023,50159, 7647,16480,    3,    0,
+57324,65533,65023,50175, 7631,  128,    3,    0,65516,64639,65535,12283,32895,65375,    0,   12,
+65534,65535,65535, 2047,32767,    0,    0,    0, 9622,65264,60590,15359, 8223,12288,    0,    0,
+    1,    0,    0,    0,65279,65535, 2047,65534, 3843,65279,65535, 8191,    0,    0,    0,    0,
+65535,65535,63227,  327,    0, 1023,    0,    0,    0,    0,65535,65535,   63,65535,65535,  127,
+65535,65535,65535,65535,65535,33791,65535,65535,65535,65535,65287,65535,65535,65535,65535, 1023,
+65407,65535,65535,65535,15743,15743,65535,65535,15743,65535,32767,32573,32573,65407,32767,65535,
+32767,32573,65535,65535,65407, 2047,    0,    0,    0,    0,65535,65535,65535,65535,65535,   31,
+65534,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,
+65535,65535,65535,65535,65535,65535,40959,  127,65534, 2047,65535,65535,65535,65535, 2047,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,65535,65535,  511,    0,    0,    0,
+    0,    0,65535,65535,65527,65535,65535,  255,65535,65535, 1023,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535, 4095,65535,65535,65535,65535,65535, 1023,
+65535,16191,65535,65535,16191,43775,65535,16383,65535,65535,65535,24543, 8156, 4047, 8191, 8156,
+    0,    0,    0,    0,    0,    0,    0,32768,    0,    0,    0,    0,    0,    0,    0,    0,
+64644,15919,48464, 1019,    0,    0,65535,65535,   15,    0,    0,    0,    0,    0,    0,    0,
+  192,    0, 1022, 1792,65534,65535,65535,65535,65535,   31,65534,65535,65535,65535,65535, 2047,
+65504,65535, 8191,65534,65535,65535,65535,65535,32767,    0,65535,  255,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535, 8191,    0,    0,    0,    0,    0,    0,    0,
+65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   15,    0,    0,    0,    0,    0,
+65535,65535,16383,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  127,41208,65023,24447,65499,65535,65535,65535,65535,65535,65535,    3,    0,65528,65535,65535,
+65535,65535,65535,16383,    0,65535,65535,65535,65535,65532,65535,65535,  255,    0,    0, 4095,
+    0,    0,    0,    0,    0,    0,    0,65495,65535,65535,65535,65535,65535,65535,65535, 8191,
+    0,    0,65534, 2047,65534, 2047,65472,65534,65535,16383,65535,32767,64764, 7420,    0,    0};
+
+const uint16_t UnicodeDigitBits[] = {
+  256,    0,    0,    0,    0,    0,  272,    0,    0,  288,  304,  320,  336,  352,  368,  384,
+  400,    0,    0,  416,    0,    0,    0,  432,  448,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  464,
+    0,    0,    0, 1023,    0,    0,    0,    0,    0,    0,    0,  524,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, 1023,    0,    0,    0,    0,    0,    0,    0,    0, 1023,
+    0,    0,    0,    0,    0,    0,65472,    0,    0,    0,    0,    0,    0,    0,65472,    0,
+    0,    0,    0,    0,    0,    0,65472,    0,    0,    0,    0,    0,    0,    0,65472,    0,
+    0,    0,    0,    0,    0,    0,65472,    0,    0,    0,    0,    0,    0,    0,65408,    0,
+    0,    0,    0,    0,    0,    0,65472,    0,    0,    0,    0,    0,    0,    0,65472,    0,
+    0,    0,    0,    0,    0,    0,65472,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, 1023,    0,    0,    0,    0,    0,    0,    0, 1023,    0,    0,
+    0,    0, 1023,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0, 1023,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,65024,    3,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 1023,    0,
+    0, 1023,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 1023,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+const uint16_t UnicodeSpaceBits[] = {
+  256,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  272,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  288,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  304,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+15872,    0,    1,    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,
+ 4095,    0,33536,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+const uint16_t UnicodeXDigitBits[] = {
+  256,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  272,
+    0,    0,    0, 1023,  126,    0,  126,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 1023,  126,    0,  126,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+// Uncomment if necessary
+//const uint16_t UnicodeCntrlBits[] = {
+//  256,    0,    0,    0,    0,    0,    0,  272,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,  288,    0,    0,    0,    0,    0,    0,    0,
+//  304,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  320,  336,
+//65535,65535,    0,    0,    0,    0,    0,32768,65535,65535,    0,    0,    0,    0,    0,    0,
+//32768,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//30720,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//61440,    0,31744,    0,    0,    0,64512,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,32768,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 3584};
+//
+//const uint16_t UnicodeGraphBits[] = {
+//  256,    1,  272,  288,  304,  320,  336,  352,    0,  368,  384,  400,  416,  432,  448,  464,
+//  480,  496,  512,  528,  544,    1,  560,  576,  592,    0,    0,    0,    0,    0,  608,  624,
+//  640,  656,    0,  672,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  688,  704,    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  720,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  736,
+//    1,    1,    1,    1,  752,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,  768,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,  784,  800,    1,  816,  832,  848,
+//    0,    0,65534,65535,65535,65535,65535,32767,    0,    0,65534,65535,65535,65535,65535,65535,
+//65535,65535,65532,   15,    0,65535,65535,65535,65535,65535,16383,63999,    3,    0,16415,    0,
+//    0,    0,    0,    0,   32,    0,    0,17408,55232,65535,65531,65535,32767,64767,65535,   15,
+//65535,65535,65535,65535,65535,65535,65535,65535,61443,65535,65535,65535, 6559,65535,65535,  831,
+//    0,    0,    0,65534,65535,65151,65534,65535, 1791,    0,    0,16384,    9,65535, 2047,   31,
+// 4096,34816,65534, 2047,65534,   63,16383,65535,65535,65535,65535,65535,65535, 8191, 8702, 8191,
+//16383,65535, 8191,65535,    0,    0,    0,    0,65535,65535,65535,    1,    0,    0,    0,    0,
+//65518,65535,65535,58367, 8191,65281,65535,    1,40942,65529,65023,50117, 6559,45184,65487,    3,
+//34788,65529,65023,50029, 6535,24064,65472,   31,45038,65531,65023,58349, 7103,    1,65473,    0,
+//40942,65529,65023,58317, 6543,45248,65475,    0,51180,54845,50968,50111, 7623,  128,65408,    0,
+//57326,65533,65023,50159, 7647,   96,65475,    0,57324,65533,65023,50159, 7647,16480,65475,    0,
+//57324,65533,65023,50175, 7631,  128,65475,    0,65516,64639,65535,12283,32895,65375,    0,   28,
+//65534,65535,65535, 2047,65535, 4095,    0,    0, 9622,65264,60590,15359, 8223,13311,    0,    0,
+//65521,    7, 1023,15360,65279,65535, 2047,65534, 3875,65279,65535, 8191,    0,    0,    0,    0,
+//65535,65535,63227,  327,65535, 1023,    0,    0,    0,    0,65535,65535,   63,65535,65535, 2175,
+//65535,65535,65535,65535,65535,33791,65535,65535,65535,65535,65287,65535,65535,65535,65535, 1023,
+//65407,65535,65535,65535,15743,15743,65535,65535,15743,65535,32767,32573,32573,65407,32767,65535,
+//32767,32573,65535,65535,65407, 2047,65534,    3,    0,    0,65535,65535,65535,65535,65535,   31,
+//65534,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,
+//65535,65535,65535,65535,65535,65535,65535,  127,65534, 8191,65535,65535,65535,65535,16383,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,65535,65535,  511, 6128, 1023,    0,
+// 2047, 1023,65535,65535,65527,65535,65535,  255,65535,65535, 1023,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535, 4095,65535,65535,65535,65535,65535, 1023,
+//65535,16191,65535,65535,16191,43775,65535,16383,65535,65535,65535,24543, 8156, 4047, 8191, 8156,
+//    0,65535,  255,65535,16239,    0,    0,57344,24576,    0,    0,    0,    0,    0,    0,    0,
+//64644,15919,48464, 1019,    0,    0,65535,65535,   15,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0, 1536,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//65486,65523, 1022, 1793,65534,65535,65535,65535,65535,   31,65534,65535,65535,65535,65535, 4095,
+//65504,65535, 8191,65534,65535,65535,65535,65535,32767,    0,65535,  255,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535, 8191,    0,    0,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   15,    0,    0,    0,    0,    0,
+//65535,65535,16383,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  127,41208,65023,24447,65499,65535,65535,65535,65535,65535,65535,    3,    0,65528,65535,65535,
+//65535,65535,65535,65535,    0,65535,65535,65535,65535,65532,65535,65535,  255,    0,    0, 4095,
+//    0,    0,    0,65535,65055,65527, 3339,65495,65535,65535,65535,65535,65535,65535,65535, 8191,
+//63470,36863,65535,49151,65534,12287,65534,65534,65535,16383,65535,32767,64764, 7420,    0,    0};
+//
+//const uint16_t UnicodePrintBits[] = {
+//  256,    1,  272,  288,  304,  320,  336,  352,    0,  368,  384,  400,  416,  432,  448,  464,
+//  480,  496,  512,  528,  544,    1,  560,  576,  592,    0,    0,    0,    0,    0,  608,  624,
+//  640,  656,    0,  672,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  688,  704,    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  720,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,  736,
+//    1,    1,    1,    1,  752,    0,    0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+//    1,    1,    1,    1,    1,    1,    1,  768,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,  784,  800,    1,  816,  832,  848,
+//  512,    0,65535,65535,65535,65535,65535,32767,    0,    0,65535,65535,65535,65535,65535,65535,
+//65535,65535,65532,   15,    0,65535,65535,65535,65535,65535,16383,63999,    3,    0,16415,    0,
+//    0,    0,    0,    0,   32,    0,    0,17408,55232,65535,65531,65535,32767,64767,65535,   15,
+//65535,65535,65535,65535,65535,65535,65535,65535,61443,65535,65535,65535, 6559,65535,65535,  831,
+//    0,    0,    0,65534,65535,65151,65534,65535, 1791,    0,    0,16384,    9,65535, 2047,   31,
+// 4096,34816,65534, 2047,65534,   63,16383,65535,65535,65535,65535,65535,65535, 8191, 8702, 8191,
+//16383,65535, 8191,65535,    0,    0,    0,    0,65535,65535,65535,    1,    0,    0,    0,    0,
+//65518,65535,65535,58367, 8191,65281,65535,    1,40942,65529,65023,50117, 6559,45184,65487,    3,
+//34788,65529,65023,50029, 6535,24064,65472,   31,45038,65531,65023,58349, 7103,    1,65473,    0,
+//40942,65529,65023,58317, 6543,45248,65475,    0,51180,54845,50968,50111, 7623,  128,65408,    0,
+//57326,65533,65023,50159, 7647,   96,65475,    0,57324,65533,65023,50159, 7647,16480,65475,    0,
+//57324,65533,65023,50175, 7631,  128,65475,    0,65516,64639,65535,12283,32895,65375,    0,   28,
+//65534,65535,65535, 2047,65535, 4095,    0,    0, 9622,65264,60590,15359, 8223,13311,    0,    0,
+//65521,    7, 1023,15360,65279,65535, 2047,65534, 3875,65279,65535, 8191,    0,    0,    0,    0,
+//65535,65535,63227,  327,65535, 1023,    0,    0,    0,    0,65535,65535,   63,65535,65535, 2175,
+//65535,65535,65535,65535,65535,33791,65535,65535,65535,65535,65287,65535,65535,65535,65535, 1023,
+//65407,65535,65535,65535,15743,15743,65535,65535,15743,65535,32767,32573,32573,65407,32767,65535,
+//32767,32573,65535,65535,65407, 2047,65534,    3,    0,    0,65535,65535,65535,65535,65535,   31,
+//65534,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,
+//65535,65535,65535,65535,65535,65535,65535,  127,65534, 8191,65535,65535,65535,65535,16383,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,65535,65535,  511, 6128, 1023,    0,
+// 2047, 1023,65535,65535,65527,65535,65535,  255,65535,65535, 1023,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535, 4095,65535,65535,65535,65535,65535, 1023,
+//65535,16191,65535,65535,16191,43775,65535,16383,65535,65535,65535,24543, 8156, 4047, 8191, 8156,
+//    0,65535,  255,65535,16239,    0,    0,57344,24576,    0,    0,    0,    0,    0,    0,    0,
+//64644,15919,48464, 1019,    0,    0,65535,65535,   15,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0, 1536,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//65487,65523, 1022, 1793,65534,65535,65535,65535,65535,   31,65534,65535,65535,65535,65535, 4095,
+//65504,65535, 8191,65534,65535,65535,65535,65535,32767,    0,65535,  255,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   63,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535, 8191,    0,    0,    0,    0,    0,    0,    0,
+//65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,   15,    0,    0,    0,    0,    0,
+//65535,65535,16383,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  127,41208,65023,24447,65499,65535,65535,65535,65535,65535,65535,    3,    0,65528,65535,65535,
+//65535,65535,65535,65535,    0,65535,65535,65535,65535,65532,65535,65535,  255,    0,    0, 4095,
+//    0,    0,    0,65535,65055,65527, 3339,65495,65535,65535,65535,65535,65535,65535,65535,40959,
+//63470,36863,65535,49151,65534,12287,65534,65534,65535,16383,65535,32767,64764, 7420,    0,    0};
+//
+//const uint16_t UnicodePunctBits[] = {
+//  256,    0,    0,  272,    0,  288,  304,  320,    0,  336,    0,    0,    0,  352,  368,  384,
+//  400,    0,    0,  416,    0,    0,  432,  448,  464,    0,    0,    0,    0,    0,    0,    0,
+//  480,    0,    0,  496,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  512,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  528,  544,  560,
+//    0,    0,65534,64512,    1,63488,    1,30720,    0,    0,65534,65535,    0,  128,    0,  128,
+//    0,    0,    0,    0,    0,    0,    0,16384,  128,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,64512,    0,    0, 1536,    0,    0,16384,    9,    0,    0,   24,
+// 4096,34816,    0,    0,    0,    0,15360,    0,    0,    0,    0,    0,    0,   16,    0,    0,
+//16383,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,   48,    1,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   16,
+//    0,    0,    0,    0,32768, 3072,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//65520,    7,    0,15360,    0,    0,    0,    0,   32,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,64512,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 2048,
+//    0,    0,    0,    0,    0,    0,  510,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,24576,    0,    0, 6144,    0,    0,    0,    0,14336,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 6128,    0,    0,
+// 2047,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,65535,  255,65535,16239,    0,    0,24576,24576,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0, 1536,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//65294,65523,    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 2048,
+//    0,    0,    0,49152,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,65535,65055,65527, 3339,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//63470,35840,    1,47104,    0,10240,   62,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+//
+//const uint16_t UnicodeLowerBits[] = {
+//  256,  272,  288,  304,  320,  336,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  352,  368,
+//  384,  400,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  416,    0,    0,    0,  432,
+//    0,    0,    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,32768,65535,65407,
+//43690,43690,43690,21930,43861,43690,43690,54442,12585,20004,11562,58961,23392,46421,43690,43565,
+//43690,43690,43688,   10,    0,65535,65535,65535,65535,65535,16383,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,61440,65535,32767,43235,43690,   15,
+//    0,    0,    0,65535,65535,65535,43690,43690,40962,43690,43690,43690, 4372,43690,43690,  554,
+//    0,    0,    0,    0,    0,    0,65534,65535,  255,    0,    0,    0,    0,    0,    0,    0,
+//43690,43690,43690,43690,43690,43690,43690,43690,43690, 4074,43690,43690,43690,43690,43690,  682,
+//  255,   63,  255,  255,   63,  255,  255,16383,65535,65535,65535,20703, 4316,  207,  255, 4316,
+//    0,    0,    0,    0,    0,    0,    0,32768,    0,    0,    0,    0,    0,    0,    0,    0,
+//50176,    8,32768,  528,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  127,  248,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+//
+//const uint16_t UnicodeUpperBits[] = {
+//  256,  272,  288,  304,  320,  336,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//  352,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  368,  384,
+//    0,  400,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  416,
+//    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,65535,32639,    0,    0,
+//21845,21845,21845,43605,21674,21845,21845,11093,52950,45531,53973, 4526,44464,19114,21845,21974,
+//21845,21845,21844,    5,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,55104,65534, 4091,    0,    0,21532,21845,    0,
+//65535,65535,65535,    0,    0,    0,21845,21845,20481,21845,21845,21845, 2187,21845,21845,  277,
+//    0,    0,    0,65534,65535,  127,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,   63,    0,    0,    0,
+//21845,21845,21845,21845,21845,21845,21845,21845,21845,   21,21845,21845,21845,21845,21845,  341,
+//65280,16128,65280,65280,16128,43520,65280,    0,65280,65280,65280, 7936, 7936, 3840, 7936, 7936,
+//14468,15911,15696,   11,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+//    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+
+// MA: March 19, 2010
+// Modified ToUpper and ToLower tables to match values expected by AS3 tests.
+// ToLower modifications:
+//    304 ->  105
+//   1024 -> 1104 *
+//   1037 -> 1117 * 
+// UoUpper modifications:
+//    255 ->  376
+//    305 ->   73
+//    383 ->   83
+//   1104 -> 1024 *
+//   1117 -> 1037 *
+// Entries marked with a '*' don't make complete sense based on Unicode manual, although
+// they match AS3.
+
+
+static const uint16_t UnicodeToUpperBits[] = {
+  256,  272,  288,  304,  320,  336,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  352,  368,
+    0,  384,    0,    0,  400,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  416,
+    0,    0,    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,65535,65407,
+43690,43690,43690,21674,43349,43690,43690,54442, 4392,  516, 8490, 8785,21056,46421,43690,43048, // MA: Modified for AS3.
+43690,  170,    0,    0,    0, 2776,33545,   36, 3336,    4,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,61440,65534,32767,    0,43688,    0,
+    0,    0,    0,65535,65535,65535,43690,43690,    2,43690,43690,43690, 4372,43690,35498,  554, // MA: Modified for AS3.
+    0,    0,    0,    0,    0,    0,65534,65535,  127,    0,    0,    0,    0,    0,    0,    0,
+43690,43690,43690,43690,43690,43690,43690,43690,43690,   42,43690,43690,43690,43690,43690,  682,
+  255,   63,  255,  255,   63,  170,  255,16383,    0,    0,    0,    3,    0,    3,   35,    0,
+    0,    0,    0,    0,    0,    0,    0,65535,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,65535, 1023,    0,
+    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+static const uint16_t UnicodeToLowerBits[] = {
+  256,  272,  288,  304,  320,  336,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  352,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  368,  384,
+    0,  400,    0,    0,  416,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  432,
+    0,    0,    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,65535,32639,    0,    0,
+21845,21845,21845,43605,21674,21845,21845,11093,52950,45531,53909, 4526,42128,19114,21845,21522,// MA: Modidied for AS3.
+21845,   85,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,55104,65534, 4091,    0,    0,    0,21844,    0,
+65535,65535,65535,    0,    0,    0,21845,21845,    1,21845,21845,21845, 2186,21845,17749,  277,
+    0,    0,    0,65534,65535,  127,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,65535,65535,   63,    0,    0,    0,
+21845,21845,21845,21845,21845,21845,21845,21845,21845,   21,21845,21845,21845,21845,21845,  341,
+65280,16128,65280,65280,16128,43520,65280,    0,    0,    0,    0, 3840, 3840, 3840, 7936, 3840,
+    0,    0,    0,    0,    0,    0,65535,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,65472,65535,    0,    0,    0,
+    0,    0,65534, 2047,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0};
+
+struct GUnicodePairType
+{
+    uint16_t Key, Value;
+};
+
+static inline bool CmpUnicodeKey(const GUnicodePairType& a, uint16_t key)
+{
+    return a.Key < key;
+}
+
+static const GUnicodePairType UnicodeToUpperTable[] = {
+{   97,   65}, {   98,   66}, {   99,   67}, {  100,   68}, {  101,   69}, {  102,   70}, {  103,   71},
+{  104,   72}, {  105,   73}, {  106,   74}, {  107,   75}, {  108,   76}, {  109,   77}, {  110,   78},
+{  111,   79}, {  112,   80}, {  113,   81}, {  114,   82}, {  115,   83}, {  116,   84}, {  117,   85},
+{  118,   86}, {  119,   87}, {  120,   88}, {  121,   89}, {  122,   90}, {  224,  192}, {  225,  193},
+{  226,  194}, {  227,  195}, {  228,  196}, {  229,  197}, {  230,  198}, {  231,  199}, {  232,  200},
+{  233,  201}, {  234,  202}, {  235,  203}, {  236,  204}, {  237,  205}, {  238,  206}, {  239,  207},
+{  240,  208}, {  241,  209}, {  242,  210}, {  243,  211}, {  244,  212}, {  245,  213}, {  246,  214},
+{  248,  216}, {  249,  217}, {  250,  218}, {  251,  219}, {  252,  220}, {  253,  221}, {  254,  222},
+{  255,  376}, {  257,  256}, {  259,  258}, {  261,  260}, {  263,  262}, {  265,  264}, {  267,  266},
+{  269,  268}, {  271,  270}, {  273,  272}, {  275,  274}, {  277,  276}, {  279,  278}, {  281,  280},
+{  283,  282}, {  285,  284}, {  287,  286}, {  289,  288}, {  291,  290}, {  293,  292}, {  295,  294},
+{  297,  296}, {  299,  298}, {  301,  300}, {  303,  302}, {  305,   73}, {  307,  306}, {  309,  308}, {  311,  310},
+{  314,  313}, {  316,  315}, {  318,  317}, {  320,  319}, {  322,  321}, {  324,  323}, {  326,  325},
+{  328,  327}, {  331,  330}, {  333,  332}, {  335,  334}, {  337,  336}, {  339,  338}, {  341,  340},
+{  343,  342}, {  345,  344}, {  347,  346}, {  349,  348}, {  351,  350}, {  353,  352}, {  355,  354},
+{  357,  356}, {  359,  358}, {  361,  360}, {  363,  362}, {  365,  364}, {  367,  366}, {  369,  368},
+{  371,  370}, {  373,  372}, {  375,  374}, {  378,  377}, {  380,  379}, {  382,  381}, {  383,   83}, {  387,  386},
+{  389,  388}, {  392,  391}, {  396,  395}, {  402,  401}, {  409,  408}, {  417,  416}, {  419,  418},
+{  421,  420}, {  424,  423}, {  429,  428}, {  432,  431}, {  436,  435}, {  438,  437}, {  441,  440},
+{  445,  444}, {  454,  452}, {  457,  455}, {  460,  458}, {  462,  461}, {  464,  463}, {  466,  465},
+{  468,  467}, {  470,  469}, {  472,  471}, {  474,  473}, {  476,  475}, {  477,  398}, {  479,  478},
+{  481,  480}, {  483,  482}, {  485,  484}, {  487,  486}, {  489,  488}, {  491,  490}, {  493,  492},
+{  495,  494}, {  499,  497}, {  501,  500}, {  507,  506}, {  509,  508}, {  511,  510}, {  513,  512},
+{  515,  514}, {  517,  516}, {  519,  518}, {  521,  520}, {  523,  522}, {  525,  524}, {  527,  526},
+{  529,  528}, {  531,  530}, {  533,  532}, {  535,  534}, {  595,  385}, {  596,  390}, {  598,  393},
+{  599,  394}, {  601,  399}, {  603,  400}, {  608,  403}, {  611,  404}, {  616,  407}, {  617,  406},
+{  623,  412}, {  626,  413}, {  629,  415}, {  643,  425}, {  648,  430}, {  650,  433}, {  651,  434},
+{  658,  439}, {  940,  902}, {  941,  904}, {  942,  905}, {  943,  906}, {  945,  913}, {  946,  914},
+{  947,  915}, {  948,  916}, {  949,  917}, {  950,  918}, {  951,  919}, {  952,  920}, {  953,  921},
+{  954,  922}, {  955,  923}, {  956,  924}, {  957,  925}, {  958,  926}, {  959,  927}, {  960,  928},
+{  961,  929}, {  962,  931}, {  963,  931}, {  964,  932}, {  965,  933}, {  966,  934}, {  967,  935},
+{  968,  936}, {  969,  937}, {  970,  938}, {  971,  939}, {  972,  908}, {  973,  910}, {  974,  911},
+{  995,  994}, {  997,  996}, {  999,  998}, { 1001, 1000}, { 1003, 1002}, { 1005, 1004}, { 1007, 1006},
+{ 1072, 1040}, { 1073, 1041}, { 1074, 1042}, { 1075, 1043}, { 1076, 1044}, { 1077, 1045}, { 1078, 1046},
+{ 1079, 1047}, { 1080, 1048}, { 1081, 1049}, { 1082, 1050}, { 1083, 1051}, { 1084, 1052}, { 1085, 1053},
+{ 1086, 1054}, { 1087, 1055}, { 1088, 1056}, { 1089, 1057}, { 1090, 1058}, { 1091, 1059}, { 1092, 1060},
+{ 1093, 1061}, { 1094, 1062}, { 1095, 1063}, { 1096, 1064}, { 1097, 1065}, { 1098, 1066}, { 1099, 1067},
+{ 1100, 1068}, { 1101, 1069}, { 1102, 1070}, { 1103, 1071}, { 1104, 1024}, { 1105, 1025}, { 1106, 1026}, { 1107, 1027},
+{ 1108, 1028}, { 1109, 1029}, { 1110, 1030}, { 1111, 1031}, { 1112, 1032}, { 1113, 1033}, { 1114, 1034},
+{ 1115, 1035}, { 1116, 1036}, { 1117, 1037}, { 1118, 1038}, { 1119, 1039}, { 1121, 1120}, { 1123, 1122}, { 1125, 1124},
+{ 1127, 1126}, { 1129, 1128}, { 1131, 1130}, { 1133, 1132}, { 1135, 1134}, { 1137, 1136}, { 1139, 1138},
+{ 1141, 1140}, { 1143, 1142}, { 1145, 1144}, { 1147, 1146}, { 1149, 1148}, { 1151, 1150}, { 1153, 1152},
+{ 1169, 1168}, { 1171, 1170}, { 1173, 1172}, { 1175, 1174}, { 1177, 1176}, { 1179, 1178}, { 1181, 1180},
+{ 1183, 1182}, { 1185, 1184}, { 1187, 1186}, { 1189, 1188}, { 1191, 1190}, { 1193, 1192}, { 1195, 1194},
+{ 1197, 1196}, { 1199, 1198}, { 1201, 1200}, { 1203, 1202}, { 1205, 1204}, { 1207, 1206}, { 1209, 1208},
+{ 1211, 1210}, { 1213, 1212}, { 1215, 1214}, { 1218, 1217}, { 1220, 1219}, { 1224, 1223}, { 1228, 1227},
+{ 1233, 1232}, { 1235, 1234}, { 1237, 1236}, { 1239, 1238}, { 1241, 1240}, { 1243, 1242}, { 1245, 1244},
+{ 1247, 1246}, { 1249, 1248}, { 1251, 1250}, { 1253, 1252}, { 1255, 1254}, { 1257, 1256}, { 1259, 1258},
+{ 1263, 1262}, { 1265, 1264}, { 1267, 1266}, { 1269, 1268}, { 1273, 1272}, { 1377, 1329}, { 1378, 1330},
+{ 1379, 1331}, { 1380, 1332}, { 1381, 1333}, { 1382, 1334}, { 1383, 1335}, { 1384, 1336}, { 1385, 1337},
+{ 1386, 1338}, { 1387, 1339}, { 1388, 1340}, { 1389, 1341}, { 1390, 1342}, { 1391, 1343}, { 1392, 1344},
+{ 1393, 1345}, { 1394, 1346}, { 1395, 1347}, { 1396, 1348}, { 1397, 1349}, { 1398, 1350}, { 1399, 1351},
+{ 1400, 1352}, { 1401, 1353}, { 1402, 1354}, { 1403, 1355}, { 1404, 1356}, { 1405, 1357}, { 1406, 1358},
+{ 1407, 1359}, { 1408, 1360}, { 1409, 1361}, { 1410, 1362}, { 1411, 1363}, { 1412, 1364}, { 1413, 1365},
+{ 1414, 1366}, { 7681, 7680}, { 7683, 7682}, { 7685, 7684}, { 7687, 7686}, { 7689, 7688}, { 7691, 7690},
+{ 7693, 7692}, { 7695, 7694}, { 7697, 7696}, { 7699, 7698}, { 7701, 7700}, { 7703, 7702}, { 7705, 7704},
+{ 7707, 7706}, { 7709, 7708}, { 7711, 7710}, { 7713, 7712}, { 7715, 7714}, { 7717, 7716}, { 7719, 7718},
+{ 7721, 7720}, { 7723, 7722}, { 7725, 7724}, { 7727, 7726}, { 7729, 7728}, { 7731, 7730}, { 7733, 7732},
+{ 7735, 7734}, { 7737, 7736}, { 7739, 7738}, { 7741, 7740}, { 7743, 7742}, { 7745, 7744}, { 7747, 7746},
+{ 7749, 7748}, { 7751, 7750}, { 7753, 7752}, { 7755, 7754}, { 7757, 7756}, { 7759, 7758}, { 7761, 7760},
+{ 7763, 7762}, { 7765, 7764}, { 7767, 7766}, { 7769, 7768}, { 7771, 7770}, { 7773, 7772}, { 7775, 7774},
+{ 7777, 7776}, { 7779, 7778}, { 7781, 7780}, { 7783, 7782}, { 7785, 7784}, { 7787, 7786}, { 7789, 7788},
+{ 7791, 7790}, { 7793, 7792}, { 7795, 7794}, { 7797, 7796}, { 7799, 7798}, { 7801, 7800}, { 7803, 7802},
+{ 7805, 7804}, { 7807, 7806}, { 7809, 7808}, { 7811, 7810}, { 7813, 7812}, { 7815, 7814}, { 7817, 7816},
+{ 7819, 7818}, { 7821, 7820}, { 7823, 7822}, { 7825, 7824}, { 7827, 7826}, { 7829, 7828}, { 7841, 7840},
+{ 7843, 7842}, { 7845, 7844}, { 7847, 7846}, { 7849, 7848}, { 7851, 7850}, { 7853, 7852}, { 7855, 7854},
+{ 7857, 7856}, { 7859, 7858}, { 7861, 7860}, { 7863, 7862}, { 7865, 7864}, { 7867, 7866}, { 7869, 7868},
+{ 7871, 7870}, { 7873, 7872}, { 7875, 7874}, { 7877, 7876}, { 7879, 7878}, { 7881, 7880}, { 7883, 7882},
+{ 7885, 7884}, { 7887, 7886}, { 7889, 7888}, { 7891, 7890}, { 7893, 7892}, { 7895, 7894}, { 7897, 7896},
+{ 7899, 7898}, { 7901, 7900}, { 7903, 7902}, { 7905, 7904}, { 7907, 7906}, { 7909, 7908}, { 7911, 7910},
+{ 7913, 7912}, { 7915, 7914}, { 7917, 7916}, { 7919, 7918}, { 7921, 7920}, { 7923, 7922}, { 7925, 7924},
+{ 7927, 7926}, { 7929, 7928}, { 7936, 7944}, { 7937, 7945}, { 7938, 7946}, { 7939, 7947}, { 7940, 7948},
+{ 7941, 7949}, { 7942, 7950}, { 7943, 7951}, { 7952, 7960}, { 7953, 7961}, { 7954, 7962}, { 7955, 7963},
+{ 7956, 7964}, { 7957, 7965}, { 7968, 7976}, { 7969, 7977}, { 7970, 7978}, { 7971, 7979}, { 7972, 7980},
+{ 7973, 7981}, { 7974, 7982}, { 7975, 7983}, { 7984, 7992}, { 7985, 7993}, { 7986, 7994}, { 7987, 7995},
+{ 7988, 7996}, { 7989, 7997}, { 7990, 7998}, { 7991, 7999}, { 8000, 8008}, { 8001, 8009}, { 8002, 8010},
+{ 8003, 8011}, { 8004, 8012}, { 8005, 8013}, { 8017, 8025}, { 8019, 8027}, { 8021, 8029}, { 8023, 8031},
+{ 8032, 8040}, { 8033, 8041}, { 8034, 8042}, { 8035, 8043}, { 8036, 8044}, { 8037, 8045}, { 8038, 8046},
+{ 8039, 8047}, { 8048, 8122}, { 8049, 8123}, { 8050, 8136}, { 8051, 8137}, { 8052, 8138}, { 8053, 8139},
+{ 8054, 8154}, { 8055, 8155}, { 8056, 8184}, { 8057, 8185}, { 8058, 8170}, { 8059, 8171}, { 8060, 8186},
+{ 8061, 8187}, { 8112, 8120}, { 8113, 8121}, { 8144, 8152}, { 8145, 8153}, { 8160, 8168}, { 8161, 8169},
+{ 8165, 8172}, { 8560, 8544}, { 8561, 8545}, { 8562, 8546}, { 8563, 8547}, { 8564, 8548}, { 8565, 8549},
+{ 8566, 8550}, { 8567, 8551}, { 8568, 8552}, { 8569, 8553}, { 8570, 8554}, { 8571, 8555}, { 8572, 8556},
+{ 8573, 8557}, { 8574, 8558}, { 8575, 8559}, { 9424, 9398}, { 9425, 9399}, { 9426, 9400}, { 9427, 9401},
+{ 9428, 9402}, { 9429, 9403}, { 9430, 9404}, { 9431, 9405}, { 9432, 9406}, { 9433, 9407}, { 9434, 9408},
+{ 9435, 9409}, { 9436, 9410}, { 9437, 9411}, { 9438, 9412}, { 9439, 9413}, { 9440, 9414}, { 9441, 9415},
+{ 9442, 9416}, { 9443, 9417}, { 9444, 9418}, { 9445, 9419}, { 9446, 9420}, { 9447, 9421}, { 9448, 9422},
+{ 9449, 9423}, {65345,65313}, {65346,65314}, {65347,65315}, {65348,65316}, {65349,65317}, {65350,65318},
+{65351,65319}, {65352,65320}, {65353,65321}, {65354,65322}, {65355,65323}, {65356,65324}, {65357,65325},
+{65358,65326}, {65359,65327}, {65360,65328}, {65361,65329}, {65362,65330}, {65363,65331}, {65364,65332},
+{65365,65333}, {65366,65334}, {65367,65335}, {65368,65336}, {65369,65337}, {65370,65338}, {65535,    0}};
+
+static const GUnicodePairType UnicodeToLowerTable[] = {
+{   65,   97}, {   66,   98}, {   67,   99}, {   68,  100}, {   69,  101}, {   70,  102}, {   71,  103},
+{   72,  104}, {   73,  105}, {   74,  106}, {   75,  107}, {   76,  108}, {   77,  109}, {   78,  110},
+{   79,  111}, {   80,  112}, {   81,  113}, {   82,  114}, {   83,  115}, {   84,  116}, {   85,  117},
+{   86,  118}, {   87,  119}, {   88,  120}, {   89,  121}, {   90,  122}, {  192,  224}, {  193,  225},
+{  194,  226}, {  195,  227}, {  196,  228}, {  197,  229}, {  198,  230}, {  199,  231}, {  200,  232},
+{  201,  233}, {  202,  234}, {  203,  235}, {  204,  236}, {  205,  237}, {  206,  238}, {  207,  239},
+{  208,  240}, {  209,  241}, {  210,  242}, {  211,  243}, {  212,  244}, {  213,  245}, {  214,  246},
+{  216,  248}, {  217,  249}, {  218,  250}, {  219,  251}, {  220,  252}, {  221,  253}, {  222,  254},
+{  256,  257}, {  258,  259}, {  260,  261}, {  262,  263}, {  264,  265}, {  266,  267}, {  268,  269},
+{  270,  271}, {  272,  273}, {  274,  275}, {  276,  277}, {  278,  279}, {  280,  281}, {  282,  283},
+{  284,  285}, {  286,  287}, {  288,  289}, {  290,  291}, {  292,  293}, {  294,  295}, {  296,  297},
+{  298,  299}, {  300,  301}, {  302,  303}, {  304,  105}, {  306,  307}, {  308,  309}, {  310,  311}, {  313,  314},
+{  315,  316}, {  317,  318}, {  319,  320}, {  321,  322}, {  323,  324}, {  325,  326}, {  327,  328},
+{  330,  331}, {  332,  333}, {  334,  335}, {  336,  337}, {  338,  339}, {  340,  341}, {  342,  343},
+{  344,  345}, {  346,  347}, {  348,  349}, {  350,  351}, {  352,  353}, {  354,  355}, {  356,  357},
+{  358,  359}, {  360,  361}, {  362,  363}, {  364,  365}, {  366,  367}, {  368,  369}, {  370,  371},
+{  372,  373}, {  374,  375}, {  376,  255}, {  377,  378}, {  379,  380}, {  381,  382}, {  385,  595},
+{  386,  387}, {  388,  389}, {  390,  596}, {  391,  392}, {  393,  598}, {  394,  599}, {  395,  396},
+{  398,  477}, {  399,  601}, {  400,  603}, {  401,  402}, {  403,  608}, {  404,  611}, {  406,  617},
+{  407,  616}, {  408,  409}, {  412,  623}, {  413,  626}, {  415,  629}, {  416,  417}, {  418,  419},
+{  420,  421}, {  423,  424}, {  425,  643}, {  428,  429}, {  430,  648}, {  431,  432}, {  433,  650},
+{  434,  651}, {  435,  436}, {  437,  438}, {  439,  658}, {  440,  441}, {  444,  445}, {  452,  454},
+{  455,  457}, {  458,  460}, {  461,  462}, {  463,  464}, {  465,  466}, {  467,  468}, {  469,  470},
+{  471,  472}, {  473,  474}, {  475,  476}, {  478,  479}, {  480,  481}, {  482,  483}, {  484,  485},
+{  486,  487}, {  488,  489}, {  490,  491}, {  492,  493}, {  494,  495}, {  497,  499}, {  500,  501},
+{  506,  507}, {  508,  509}, {  510,  511}, {  512,  513}, {  514,  515}, {  516,  517}, {  518,  519},
+{  520,  521}, {  522,  523}, {  524,  525}, {  526,  527}, {  528,  529}, {  530,  531}, {  532,  533},
+{  534,  535}, {  902,  940}, {  904,  941}, {  905,  942}, {  906,  943}, {  908,  972}, {  910,  973},
+{  911,  974}, {  913,  945}, {  914,  946}, {  915,  947}, {  916,  948}, {  917,  949}, {  918,  950},
+{  919,  951}, {  920,  952}, {  921,  953}, {  922,  954}, {  923,  955}, {  924,  956}, {  925,  957},
+{  926,  958}, {  927,  959}, {  928,  960}, {  929,  961}, {  931,  963}, {  932,  964}, {  933,  965},
+{  934,  966}, {  935,  967}, {  936,  968}, {  937,  969}, {  938,  970}, {  939,  971}, {  994,  995},
+{  996,  997}, {  998,  999}, { 1000, 1001}, { 1002, 1003}, { 1004, 1005}, { 1006, 1007}, { 1024, 1104}, { 1025, 1105},
+{ 1026, 1106}, { 1027, 1107}, { 1028, 1108}, { 1029, 1109}, { 1030, 1110}, { 1031, 1111}, { 1032, 1112},
+{ 1033, 1113}, { 1034, 1114}, { 1035, 1115}, { 1036, 1116}, { 1037, 1117}, { 1038, 1118}, { 1039, 1119}, { 1040, 1072},
+{ 1041, 1073}, { 1042, 1074}, { 1043, 1075}, { 1044, 1076}, { 1045, 1077}, { 1046, 1078}, { 1047, 1079},
+{ 1048, 1080}, { 1049, 1081}, { 1050, 1082}, { 1051, 1083}, { 1052, 1084}, { 1053, 1085}, { 1054, 1086},
+{ 1055, 1087}, { 1056, 1088}, { 1057, 1089}, { 1058, 1090}, { 1059, 1091}, { 1060, 1092}, { 1061, 1093},
+{ 1062, 1094}, { 1063, 1095}, { 1064, 1096}, { 1065, 1097}, { 1066, 1098}, { 1067, 1099}, { 1068, 1100},
+{ 1069, 1101}, { 1070, 1102}, { 1071, 1103}, { 1120, 1121}, { 1122, 1123}, { 1124, 1125}, { 1126, 1127},
+{ 1128, 1129}, { 1130, 1131}, { 1132, 1133}, { 1134, 1135}, { 1136, 1137}, { 1138, 1139}, { 1140, 1141},
+{ 1142, 1143}, { 1144, 1145}, { 1146, 1147}, { 1148, 1149}, { 1150, 1151}, { 1152, 1153}, { 1168, 1169},
+{ 1170, 1171}, { 1172, 1173}, { 1174, 1175}, { 1176, 1177}, { 1178, 1179}, { 1180, 1181}, { 1182, 1183},
+{ 1184, 1185}, { 1186, 1187}, { 1188, 1189}, { 1190, 1191}, { 1192, 1193}, { 1194, 1195}, { 1196, 1197},
+{ 1198, 1199}, { 1200, 1201}, { 1202, 1203}, { 1204, 1205}, { 1206, 1207}, { 1208, 1209}, { 1210, 1211},
+{ 1212, 1213}, { 1214, 1215}, { 1217, 1218}, { 1219, 1220}, { 1223, 1224}, { 1227, 1228}, { 1232, 1233},
+{ 1234, 1235}, { 1236, 1237}, { 1238, 1239}, { 1240, 1241}, { 1242, 1243}, { 1244, 1245}, { 1246, 1247},
+{ 1248, 1249}, { 1250, 1251}, { 1252, 1253}, { 1254, 1255}, { 1256, 1257}, { 1258, 1259}, { 1262, 1263},
+{ 1264, 1265}, { 1266, 1267}, { 1268, 1269}, { 1272, 1273}, { 1329, 1377}, { 1330, 1378}, { 1331, 1379},
+{ 1332, 1380}, { 1333, 1381}, { 1334, 1382}, { 1335, 1383}, { 1336, 1384}, { 1337, 1385}, { 1338, 1386},
+{ 1339, 1387}, { 1340, 1388}, { 1341, 1389}, { 1342, 1390}, { 1343, 1391}, { 1344, 1392}, { 1345, 1393},
+{ 1346, 1394}, { 1347, 1395}, { 1348, 1396}, { 1349, 1397}, { 1350, 1398}, { 1351, 1399}, { 1352, 1400},
+{ 1353, 1401}, { 1354, 1402}, { 1355, 1403}, { 1356, 1404}, { 1357, 1405}, { 1358, 1406}, { 1359, 1407},
+{ 1360, 1408}, { 1361, 1409}, { 1362, 1410}, { 1363, 1411}, { 1364, 1412}, { 1365, 1413}, { 1366, 1414},
+{ 4256, 4304}, { 4257, 4305}, { 4258, 4306}, { 4259, 4307}, { 4260, 4308}, { 4261, 4309}, { 4262, 4310},
+{ 4263, 4311}, { 4264, 4312}, { 4265, 4313}, { 4266, 4314}, { 4267, 4315}, { 4268, 4316}, { 4269, 4317},
+{ 4270, 4318}, { 4271, 4319}, { 4272, 4320}, { 4273, 4321}, { 4274, 4322}, { 4275, 4323}, { 4276, 4324},
+{ 4277, 4325}, { 4278, 4326}, { 4279, 4327}, { 4280, 4328}, { 4281, 4329}, { 4282, 4330}, { 4283, 4331},
+{ 4284, 4332}, { 4285, 4333}, { 4286, 4334}, { 4287, 4335}, { 4288, 4336}, { 4289, 4337}, { 4290, 4338},
+{ 4291, 4339}, { 4292, 4340}, { 4293, 4341}, { 7680, 7681}, { 7682, 7683}, { 7684, 7685}, { 7686, 7687},
+{ 7688, 7689}, { 7690, 7691}, { 7692, 7693}, { 7694, 7695}, { 7696, 7697}, { 7698, 7699}, { 7700, 7701},
+{ 7702, 7703}, { 7704, 7705}, { 7706, 7707}, { 7708, 7709}, { 7710, 7711}, { 7712, 7713}, { 7714, 7715},
+{ 7716, 7717}, { 7718, 7719}, { 7720, 7721}, { 7722, 7723}, { 7724, 7725}, { 7726, 7727}, { 7728, 7729},
+{ 7730, 7731}, { 7732, 7733}, { 7734, 7735}, { 7736, 7737}, { 7738, 7739}, { 7740, 7741}, { 7742, 7743},
+{ 7744, 7745}, { 7746, 7747}, { 7748, 7749}, { 7750, 7751}, { 7752, 7753}, { 7754, 7755}, { 7756, 7757},
+{ 7758, 7759}, { 7760, 7761}, { 7762, 7763}, { 7764, 7765}, { 7766, 7767}, { 7768, 7769}, { 7770, 7771},
+{ 7772, 7773}, { 7774, 7775}, { 7776, 7777}, { 7778, 7779}, { 7780, 7781}, { 7782, 7783}, { 7784, 7785},
+{ 7786, 7787}, { 7788, 7789}, { 7790, 7791}, { 7792, 7793}, { 7794, 7795}, { 7796, 7797}, { 7798, 7799},
+{ 7800, 7801}, { 7802, 7803}, { 7804, 7805}, { 7806, 7807}, { 7808, 7809}, { 7810, 7811}, { 7812, 7813},
+{ 7814, 7815}, { 7816, 7817}, { 7818, 7819}, { 7820, 7821}, { 7822, 7823}, { 7824, 7825}, { 7826, 7827},
+{ 7828, 7829}, { 7840, 7841}, { 7842, 7843}, { 7844, 7845}, { 7846, 7847}, { 7848, 7849}, { 7850, 7851},
+{ 7852, 7853}, { 7854, 7855}, { 7856, 7857}, { 7858, 7859}, { 7860, 7861}, { 7862, 7863}, { 7864, 7865},
+{ 7866, 7867}, { 7868, 7869}, { 7870, 7871}, { 7872, 7873}, { 7874, 7875}, { 7876, 7877}, { 7878, 7879},
+{ 7880, 7881}, { 7882, 7883}, { 7884, 7885}, { 7886, 7887}, { 7888, 7889}, { 7890, 7891}, { 7892, 7893},
+{ 7894, 7895}, { 7896, 7897}, { 7898, 7899}, { 7900, 7901}, { 7902, 7903}, { 7904, 7905}, { 7906, 7907},
+{ 7908, 7909}, { 7910, 7911}, { 7912, 7913}, { 7914, 7915}, { 7916, 7917}, { 7918, 7919}, { 7920, 7921},
+{ 7922, 7923}, { 7924, 7925}, { 7926, 7927}, { 7928, 7929}, { 7944, 7936}, { 7945, 7937}, { 7946, 7938},
+{ 7947, 7939}, { 7948, 7940}, { 7949, 7941}, { 7950, 7942}, { 7951, 7943}, { 7960, 7952}, { 7961, 7953},
+{ 7962, 7954}, { 7963, 7955}, { 7964, 7956}, { 7965, 7957}, { 7976, 7968}, { 7977, 7969}, { 7978, 7970},
+{ 7979, 7971}, { 7980, 7972}, { 7981, 7973}, { 7982, 7974}, { 7983, 7975}, { 7992, 7984}, { 7993, 7985},
+{ 7994, 7986}, { 7995, 7987}, { 7996, 7988}, { 7997, 7989}, { 7998, 7990}, { 7999, 7991}, { 8008, 8000},
+{ 8009, 8001}, { 8010, 8002}, { 8011, 8003}, { 8012, 8004}, { 8013, 8005}, { 8025, 8017}, { 8027, 8019},
+{ 8029, 8021}, { 8031, 8023}, { 8040, 8032}, { 8041, 8033}, { 8042, 8034}, { 8043, 8035}, { 8044, 8036},
+{ 8045, 8037}, { 8046, 8038}, { 8047, 8039}, { 8120, 8112}, { 8121, 8113}, { 8122, 8048}, { 8123, 8049},
+{ 8136, 8050}, { 8137, 8051}, { 8138, 8052}, { 8139, 8053}, { 8152, 8144}, { 8153, 8145}, { 8154, 8054},
+{ 8155, 8055}, { 8168, 8160}, { 8169, 8161}, { 8170, 8058}, { 8171, 8059}, { 8172, 8165}, { 8184, 8056},
+{ 8185, 8057}, { 8186, 8060}, { 8187, 8061}, { 8544, 8560}, { 8545, 8561}, { 8546, 8562}, { 8547, 8563},
+{ 8548, 8564}, { 8549, 8565}, { 8550, 8566}, { 8551, 8567}, { 8552, 8568}, { 8553, 8569}, { 8554, 8570},
+{ 8555, 8571}, { 8556, 8572}, { 8557, 8573}, { 8558, 8574}, { 8559, 8575}, { 9398, 9424}, { 9399, 9425},
+{ 9400, 9426}, { 9401, 9427}, { 9402, 9428}, { 9403, 9429}, { 9404, 9430}, { 9405, 9431}, { 9406, 9432},
+{ 9407, 9433}, { 9408, 9434}, { 9409, 9435}, { 9410, 9436}, { 9411, 9437}, { 9412, 9438}, { 9413, 9439},
+{ 9414, 9440}, { 9415, 9441}, { 9416, 9442}, { 9417, 9443}, { 9418, 9444}, { 9419, 9445}, { 9420, 9446},
+{ 9421, 9447}, { 9422, 9448}, { 9423, 9449}, {65313,65345}, {65314,65346}, {65315,65347}, {65316,65348},
+{65317,65349}, {65318,65350}, {65319,65351}, {65320,65352}, {65321,65353}, {65322,65354}, {65323,65355},
+{65324,65356}, {65325,65357}, {65326,65358}, {65327,65359}, {65328,65360}, {65329,65361}, {65330,65362},
+{65331,65363}, {65332,65364}, {65333,65365}, {65334,65366}, {65335,65367}, {65336,65368}, {65337,65369},
+{65338,65370}, {65535,    0}};
+
+int OVR_CDECL OVR_towupper(wchar_t charCode)
+{
+    // Don't use UnicodeUpperBits! It differs from UnicodeToUpperBits.
+    if (UnicodeCharIs(UnicodeToUpperBits, charCode))
+    {
+        // To protect from memory overrun in case the character is not found
+        // we use one extra fake element in the table {65536, 0}.
+        size_t idx = Alg::LowerBoundSliced(
+            UnicodeToUpperTable,
+            0,
+            sizeof(UnicodeToUpperTable) / sizeof(UnicodeToUpperTable[0]) - 1,
+            (uint16_t)charCode,
+            CmpUnicodeKey);
+        return UnicodeToUpperTable[idx].Value;
+    }
+    return charCode;
+}
+
+int OVR_CDECL OVR_towlower(wchar_t charCode)
+{
+    // Don't use UnicodeLowerBits! It differs from UnicodeToLowerBits.
+    if (UnicodeCharIs(UnicodeToLowerBits, charCode))
+    {
+        // To protect from memory overrun in case the character is not found
+        // we use one extra fake element in the table {65536, 0}.
+        size_t idx = Alg::LowerBoundSliced(
+            UnicodeToLowerTable,
+            0,
+            sizeof(UnicodeToLowerTable) / sizeof(UnicodeToLowerTable[0]) - 1,
+            (uint16_t)charCode,
+            CmpUnicodeKey);
+        return UnicodeToLowerTable[idx].Value;
+    }
+    return charCode;
+}
+
+#endif //OVR_NO_WCTYPE
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,514 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Std.h
+Content     :   Standard C function interface
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Std_h
+#define OVR_Std_h
+
+#include "OVR_Types.h"
+#include <stdarg.h> // for va_list args
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if !defined(OVR_OS_WINCE) && defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+#define OVR_MSVC_SAFESTRING
+#include <errno.h>
+#endif
+
+// Wide-char funcs
+#include <wchar.h>
+#include <wctype.h>
+
+namespace OVR {
+
+#if defined(OVR_OS_WIN32) 
+inline char* OVR_CDECL OVR_itoa(int val, char *dest, size_t destsize, int radix)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    _itoa_s(val, dest, destsize, radix);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return itoa(val, dest, radix);
+#endif
+}
+#else // OVR_OS_WIN32
+inline char* OVR_itoa(int val, char* dest, unsigned int len, int radix)
+{
+    if (val == 0)
+    {
+        if (len > 1)
+        {
+            dest[0] = '0';
+            dest[1] = '\0';  
+        }
+        return dest;
+    }
+
+    int cur = val;
+    unsigned int i    = 0; 
+    unsigned int sign = 0;
+
+    if (val < 0)
+    {
+        val = -val;
+        sign = 1;
+    }
+
+    while ((val != 0) && (i < (len - 1 - sign)))        
+    {
+        cur    = val % radix;
+        val   /= radix;
+
+        if (radix == 16)
+        {
+            switch(cur)
+            {
+            case 10:
+                dest[i] = 'a';
+                break;
+            case 11:
+                dest[i] = 'b';
+                break;
+            case 12:
+                dest[i] = 'c';
+                break;
+            case 13:
+                dest[i] = 'd';
+                break;
+            case 14:
+                dest[i] = 'e';
+                break;
+            case 15:
+                dest[i] = 'f';
+                break;
+            default:
+                dest[i] = (char)('0' + cur);
+                break;
+            }
+        } 
+        else
+        {
+            dest[i] = (char)('0' + cur);
+        }
+        ++i;
+    }
+
+    if (sign)
+    {
+        dest[i++] = '-';
+    }
+
+    for (unsigned int j = 0; j < i / 2; ++j)
+    {
+        char tmp        = dest[j];
+        dest[j]         = dest[i - 1 - j];
+        dest[i - 1 - j] = tmp;
+    }
+    dest[i] = '\0';
+
+    return dest;
+}
+
+#endif
+
+
+// String functions
+
+inline size_t OVR_CDECL OVR_strlen(const char* str)
+{
+    return strlen(str);
+}
+
+inline char* OVR_CDECL OVR_strcpy(char* dest, size_t destsize, const char* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strcpy_s(dest, destsize, src);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strcpy(dest, src);
+#endif
+}
+
+inline char* OVR_CDECL OVR_strncpy(char* dest, size_t destsize, const char* src, size_t count)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strncpy_s(dest, destsize, src, count);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strncpy(dest, src, count);
+#endif
+}
+
+inline char * OVR_CDECL OVR_strcat(char* dest, size_t destsize, const char* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strcat_s(dest, destsize, src);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strcat(dest, src);
+#endif
+}
+
+inline int OVR_CDECL OVR_strcmp(const char* dest, const char* src)
+{
+    return strcmp(dest, src);
+}
+
+inline const char* OVR_CDECL OVR_strchr(const char* str, char c)
+{
+    return strchr(str, c);
+}
+
+inline char* OVR_CDECL OVR_strchr(char* str, char c)
+{
+    return strchr(str, c);
+}
+
+inline const char* OVR_strrchr(const char* str, char c)
+{
+    size_t len = OVR_strlen(str);
+    for (size_t i=len; i>0; i--)     
+        if (str[i]==c) 
+            return str+i;
+    return 0;
+}
+
+inline const uint8_t* OVR_CDECL OVR_memrchr(const uint8_t* str, size_t size, uint8_t c)
+{
+    for (intptr_t i = (intptr_t)size - 1; i >= 0; i--)     
+    {
+        if (str[i] == c) 
+            return str + i;
+    }
+    return 0;
+}
+
+inline char* OVR_CDECL OVR_strrchr(char* str, char c)
+{
+    size_t len = OVR_strlen(str);
+    for (size_t i=len; i>0; i--)     
+        if (str[i]==c) 
+            return str+i;
+    return 0;
+}
+
+
+double OVR_CDECL OVR_strtod(const char* string, char** tailptr);
+
+inline long OVR_CDECL OVR_strtol(const char* string, char** tailptr, int radix)
+{
+    return strtol(string, tailptr, radix);
+}
+
+inline long OVR_CDECL OVR_strtoul(const char* string, char** tailptr, int radix)
+{
+    return strtoul(string, tailptr, radix);
+}
+
+inline int OVR_CDECL OVR_strncmp(const char* ws1, const char* ws2, size_t size)
+{
+    return strncmp(ws1, ws2, size);
+}
+
+inline uint64_t OVR_CDECL OVR_strtouq(const char *nptr, char **endptr, int base)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _strtoui64(nptr, endptr, base);
+#else
+    return strtoull(nptr, endptr, base);
+#endif
+}
+
+inline int64_t OVR_CDECL OVR_strtoq(const char *nptr, char **endptr, int base)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _strtoi64(nptr, endptr, base);
+#else
+    return strtoll(nptr, endptr, base);
+#endif
+}
+
+
+inline int64_t OVR_CDECL OVR_atoq(const char* string)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _atoi64(string);
+#else
+    return atoll(string);
+#endif
+}
+
+inline uint64_t OVR_CDECL OVR_atouq(const char* string)
+{
+  return OVR_strtouq(string, NULL, 10);
+}
+
+
+// Implemented in GStd.cpp in platform-specific manner.
+int OVR_CDECL OVR_stricmp(const char* dest, const char* src);
+int OVR_CDECL OVR_strnicmp(const char* dest, const char* src, size_t count);
+
+inline size_t OVR_CDECL OVR_sprintf(char *dest, size_t destsize, const char* format, ...)
+{
+    va_list argList;
+    va_start(argList,format);
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    #if defined(OVR_MSVC_SAFESTRING)
+        ret = _vsnprintf_s(dest, destsize, _TRUNCATE, format, argList);
+        OVR_ASSERT(ret != -1);
+    #else
+        OVR_UNUSED(destsize);
+        ret = _vsnprintf(dest, destsize - 1, format, argList); // -1 for space for the null character
+        OVR_ASSERT(ret != -1);
+        dest[destsize-1] = 0;
+    #endif
+#else
+    OVR_UNUSED(destsize);
+    ret = vsprintf(dest, format, argList);
+    OVR_ASSERT(ret < destsize);
+#endif
+    va_end(argList);
+    return ret;
+}
+
+inline size_t OVR_CDECL OVR_vsprintf(char *dest, size_t destsize, const char * format, va_list argList)
+{
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    #if defined(OVR_MSVC_SAFESTRING)
+        dest[0] = '\0';
+        int rv = vsnprintf_s(dest, destsize, _TRUNCATE, format, argList);
+        if (rv == -1)
+        {
+            dest[destsize - 1] = '\0';
+            ret = destsize - 1;
+        }
+        else
+            ret = (size_t)rv;
+    #else
+        OVR_UNUSED(destsize);
+        int rv = _vsnprintf(dest, destsize - 1, format, argList);
+        OVR_ASSERT(rv != -1);
+        ret = (size_t)rv;
+        dest[destsize-1] = 0;
+    #endif
+#else
+    OVR_UNUSED(destsize);
+    ret = (size_t)vsprintf(dest, format, argList);
+    OVR_ASSERT(ret < destsize);
+#endif
+    return ret;
+}
+
+// Returns the number of characters in the formatted string.
+inline size_t OVR_CDECL OVR_vscprintf(const char * format, va_list argList)
+{
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    ret = (size_t) _vscprintf(format, argList);
+#else    
+    ret = (size_t) vsnprintf(NULL, 0, format, argList);
+#endif
+    return ret;       
+}
+
+
+wchar_t* OVR_CDECL OVR_wcscpy(wchar_t* dest, size_t destsize, const wchar_t* src);
+wchar_t* OVR_CDECL OVR_wcsncpy(wchar_t* dest, size_t destsize, const wchar_t* src, size_t count);
+wchar_t* OVR_CDECL OVR_wcscat(wchar_t* dest, size_t destsize, const wchar_t* src);
+size_t   OVR_CDECL OVR_wcslen(const wchar_t* str);
+int      OVR_CDECL OVR_wcscmp(const wchar_t* a, const wchar_t* b);
+int      OVR_CDECL OVR_wcsicmp(const wchar_t* a, const wchar_t* b);
+
+inline int OVR_CDECL OVR_wcsicoll(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32) 
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+    return ::_wcsicoll(a, b);
+#else
+    return ::wcsicoll(a, b);
+#endif
+#else
+    // not supported, use regular wcsicmp
+    return OVR_wcsicmp(a, b);
+#endif
+}
+
+inline int OVR_CDECL OVR_wcscoll(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32)  || defined(OVR_OS_LINUX)
+    return wcscoll(a, b);
+#else
+    // not supported, use regular wcscmp
+    return OVR_wcscmp(a, b);
+#endif
+}
+
+#ifndef OVR_NO_WCTYPE
+
+inline int OVR_CDECL UnicodeCharIs(const uint16_t* table, wchar_t charCode)
+{
+    unsigned offset = table[charCode >> 8];
+    if (offset == 0) return 0;
+    if (offset == 1) return 1;
+    return (table[offset + ((charCode >> 4) & 15)] & (1 << (charCode & 15))) != 0;
+}
+
+extern const uint16_t UnicodeAlnumBits[];
+extern const uint16_t UnicodeAlphaBits[];
+extern const uint16_t UnicodeDigitBits[];
+extern const uint16_t UnicodeSpaceBits[];
+extern const uint16_t UnicodeXDigitBits[];
+
+// Uncomment if necessary
+//extern const uint16_t UnicodeCntrlBits[];
+//extern const uint16_t UnicodeGraphBits[];
+//extern const uint16_t UnicodeLowerBits[];
+//extern const uint16_t UnicodePrintBits[];
+//extern const uint16_t UnicodePunctBits[];
+//extern const uint16_t UnicodeUpperBits[];
+
+inline int OVR_CDECL OVR_iswalnum (wchar_t charCode) { return UnicodeCharIs(UnicodeAlnumBits,  charCode); }
+inline int OVR_CDECL OVR_iswalpha (wchar_t charCode) { return UnicodeCharIs(UnicodeAlphaBits,  charCode); }
+inline int OVR_CDECL OVR_iswdigit (wchar_t charCode) { return UnicodeCharIs(UnicodeDigitBits,  charCode); }
+inline int OVR_CDECL OVR_iswspace (wchar_t charCode) { return UnicodeCharIs(UnicodeSpaceBits,  charCode); }
+inline int OVR_CDECL OVR_iswxdigit(wchar_t charCode) { return UnicodeCharIs(UnicodeXDigitBits, charCode); }
+
+// Uncomment if necessary
+//inline int OVR_CDECL OVR_iswcntrl (wchar_t charCode) { return UnicodeCharIs(UnicodeCntrlBits,  charCode); }
+//inline int OVR_CDECL OVR_iswgraph (wchar_t charCode) { return UnicodeCharIs(UnicodeGraphBits,  charCode); }
+//inline int OVR_CDECL OVR_iswlower (wchar_t charCode) { return UnicodeCharIs(UnicodeLowerBits,  charCode); }
+//inline int OVR_CDECL OVR_iswprint (wchar_t charCode) { return UnicodeCharIs(UnicodePrintBits,  charCode); }
+//inline int OVR_CDECL OVR_iswpunct (wchar_t charCode) { return UnicodeCharIs(UnicodePunctBits,  charCode); }
+//inline int OVR_CDECL OVR_iswupper (wchar_t charCode) { return UnicodeCharIs(UnicodeUpperBits,  charCode); }
+
+int OVR_CDECL OVR_towupper(wchar_t charCode);
+int OVR_CDECL OVR_towlower(wchar_t charCode);
+
+#else // OVR_NO_WCTYPE
+
+inline int OVR_CDECL OVR_iswspace(wchar_t c)
+{
+    return iswspace(c);
+}
+
+inline int OVR_CDECL OVR_iswdigit(wchar_t c)
+{
+    return iswdigit(c);
+}
+
+inline int OVR_CDECL OVR_iswxdigit(wchar_t c)
+{
+    return iswxdigit(c);
+}
+
+inline int OVR_CDECL OVR_iswalpha(wchar_t c)
+{
+    return iswalpha(c);
+}
+
+inline int OVR_CDECL OVR_iswalnum(wchar_t c)
+{
+    return iswalnum(c);
+}
+
+inline wchar_t OVR_CDECL OVR_towlower(wchar_t c)
+{
+    return (wchar_t)towlower(c);
+}
+
+inline wchar_t OVR_towupper(wchar_t c)
+{
+    return (wchar_t)towupper(c);
+}
+
+#endif // OVR_NO_WCTYPE
+
+// ASCII versions of tolower and toupper. Don't use "char"
+inline int OVR_CDECL OVR_tolower(int c)
+{
+    return (c >= 'A' && c <= 'Z') ? c - 'A' + 'a' : c;
+}
+
+inline int OVR_CDECL OVR_toupper(int c)
+{
+    return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c;
+}
+
+
+
+inline double OVR_CDECL OVR_wcstod(const wchar_t* string, wchar_t** tailptr)
+{
+#if defined(OVR_OS_OTHER)
+    OVR_UNUSED(tailptr);
+    char buffer[64];
+    char* tp = NULL;
+    size_t max = OVR_wcslen(string);
+    if (max > 63) max = 63;
+    unsigned char c = 0;
+    for (size_t i=0; i < max; i++)
+    {
+        c = (unsigned char)string[i];
+        buffer[i] = ((c) < 128 ? (char)c : '!');
+    }
+    buffer[max] = 0;
+    return OVR_strtod(buffer, &tp);
+#else
+    return wcstod(string, tailptr);
+#endif
+}
+
+inline long OVR_CDECL OVR_wcstol(const wchar_t* string, wchar_t** tailptr, int radix)
+{
+#if defined(OVR_OS_OTHER)
+    OVR_UNUSED(tailptr);
+    char buffer[64];
+    char* tp = NULL;
+    size_t max = OVR_wcslen(string);
+    if (max > 63) max = 63;
+    unsigned char c = 0;
+    for (size_t i=0; i < max; i++)
+    {
+        c = (unsigned char)string[i];
+        buffer[i] = ((c) < 128 ? (char)c : '!');
+    }
+    buffer[max] = 0;
+    return strtol(buffer, &tp, radix);
+#else
+    return wcstol(string, tailptr, radix);
+#endif
+}
+
+} // OVR
+
+#endif // OVR_Std_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,768 @@
+/************************************************************************************
+
+Filename    :   OVR_String.cpp
+Content     :   String UTF8 string implementation with copy-on-write semantics
+                (thread-safe for assignment but not modification).
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_String.h"
+
+#include <stdlib.h>
+#include <ctype.h>
+
+#ifdef OVR_OS_QNX
+# include <strings.h>
+#endif
+
+namespace OVR {
+
+#define String_LengthIsSize (size_t(1) << String::Flag_LengthIsSizeShift)
+
+String::DataDesc String::NullData = {String_LengthIsSize, 1, {0} };
+
+
+String::String()
+{
+    pData = &NullData;
+    pData->AddRef();
+};
+
+String::String(const char* pdata)
+{
+    // Obtain length in bytes; it doesn't matter if _data is UTF8.
+    size_t size = pdata ? OVR_strlen(pdata) : 0; 
+    pData = AllocDataCopy1(size, 0, pdata, size);
+};
+
+String::String(const char* pdata1, const char* pdata2, const char* pdata3)
+{
+    // Obtain length in bytes; it doesn't matter if _data is UTF8.
+    size_t size1 = pdata1 ? OVR_strlen(pdata1) : 0; 
+    size_t size2 = pdata2 ? OVR_strlen(pdata2) : 0; 
+    size_t size3 = pdata3 ? OVR_strlen(pdata3) : 0; 
+
+    DataDesc *pdataDesc = AllocDataCopy2(size1 + size2 + size3, 0,
+                                         pdata1, size1, pdata2, size2);
+    memcpy(pdataDesc->Data + size1 + size2, pdata3, size3);   
+    pData = pdataDesc;    
+}
+
+String::String(const char* pdata, size_t size)
+{
+    OVR_ASSERT((size == 0) || (pdata != 0));
+    pData = AllocDataCopy1(size, 0, pdata, size);
+};
+
+
+String::String(const InitStruct& src, size_t size)
+{
+    pData = AllocData(size, 0);
+    src.InitString(GetData()->Data, size);
+}
+
+String::String(const String& src)
+{    
+    pData = src.GetData();
+    pData->AddRef();
+}
+
+String::String(const StringBuffer& src)
+{
+    pData = AllocDataCopy1(src.GetSize(), 0, src.ToCStr(), src.GetSize());
+}
+
+String::String(const wchar_t* data)
+{
+    pData = &NullData;
+    pData->AddRef();
+    // Simplified logic for wchar_t constructor.
+    if (data)    
+        *this = data;    
+}
+
+
+String::DataDesc* String::AllocData(size_t size, size_t lengthIsSize)
+{
+    String::DataDesc* pdesc;
+
+    if (size == 0)
+    {
+        pdesc = &NullData;
+        pdesc->AddRef();
+        return pdesc;
+    }
+
+    pdesc = (DataDesc*)OVR_ALLOC(sizeof(DataDesc)+ size);
+    pdesc->Data[size] = 0;
+    pdesc->RefCount = 1;
+    pdesc->Size     = size | lengthIsSize;  
+    return pdesc;
+}
+
+
+String::DataDesc* String::AllocDataCopy1(size_t size, size_t lengthIsSize,
+                                         const char* pdata, size_t copySize)
+{
+    String::DataDesc* pdesc = AllocData(size, lengthIsSize);
+    memcpy(pdesc->Data, pdata, copySize);
+    return pdesc;
+}
+
+String::DataDesc* String::AllocDataCopy2(size_t size, size_t lengthIsSize,
+                                         const char* pdata1, size_t copySize1,
+                                         const char* pdata2, size_t copySize2)
+{
+    String::DataDesc* pdesc = AllocData(size, lengthIsSize);
+    memcpy(pdesc->Data, pdata1, copySize1);
+    memcpy(pdesc->Data + copySize1, pdata2, copySize2);
+    return pdesc;
+}
+
+
+size_t String::GetLength() const 
+{
+    // Optimize length accesses for non-UTF8 character strings. 
+    DataDesc* pdata = GetData();
+    size_t    length, size = pdata->GetSize();
+    
+    if (pdata->LengthIsSize())
+        return size;    
+    
+    length = (size_t)UTF8Util::GetLength(pdata->Data, (size_t)size);
+    
+    if (length == size)
+        pdata->Size |= String_LengthIsSize;
+    
+    return length;
+}
+
+
+//static uint32_t String_CharSearch(const char* buf, )
+
+
+uint32_t String::GetCharAt(size_t index) const 
+{  
+    intptr_t    i = (intptr_t) index;
+    DataDesc*   pdata = GetData();
+    const char* buf = pdata->Data;
+    uint32_t    c;
+    
+    if (pdata->LengthIsSize())
+    {
+        OVR_ASSERT(index < pdata->GetSize());
+        buf += i;
+        return UTF8Util::DecodeNextChar_Advance0(&buf);
+    }
+
+    c = UTF8Util::GetCharAt(index, buf, pdata->GetSize());
+    return c;
+}
+
+uint32_t String::GetFirstCharAt(size_t index, const char** offset) const
+{
+    DataDesc*   pdata = GetData();
+    intptr_t    i = (intptr_t) index;
+    const char* buf = pdata->Data;
+    const char* end = buf + pdata->GetSize();
+    uint32_t    c;
+
+    do 
+    {
+        c = UTF8Util::DecodeNextChar_Advance0(&buf);
+        i--;
+
+        if (buf >= end)
+        {
+            // We've hit the end of the string; don't go further.
+            OVR_ASSERT(i == 0);
+            return c;
+        }
+    } while (i >= 0);
+
+    *offset = buf;
+
+    return c;
+}
+
+uint32_t String::GetNextChar(const char** offset) const
+{
+    return UTF8Util::DecodeNextChar(offset);
+}
+
+
+
+void String::AppendChar(uint32_t ch)
+{
+    DataDesc*   pdata = GetData();
+    size_t      size = pdata->GetSize();
+    char        buff[8];
+    intptr_t    encodeSize = 0;
+
+    // Converts ch into UTF8 string and fills it into buff.   
+    UTF8Util::EncodeChar(buff, &encodeSize, ch);
+    OVR_ASSERT(encodeSize >= 0);
+
+    SetData(AllocDataCopy2(size + (size_t)encodeSize, 0,
+                           pdata->Data, size, buff, (size_t)encodeSize));
+    pdata->Release();
+}
+
+
+void String::AppendString(const wchar_t* pstr, intptr_t len)
+{
+    if (!pstr)
+        return;
+
+    DataDesc*   pdata = GetData();
+    size_t      oldSize = pdata->GetSize();    
+    size_t      encodeSize = (size_t)UTF8Util::GetEncodeStringSize(pstr, len);
+
+    DataDesc*   pnewData = AllocDataCopy1(oldSize + (size_t)encodeSize, 0,
+                                          pdata->Data, oldSize);
+    UTF8Util::EncodeString(pnewData->Data + oldSize,  pstr, len);
+
+    SetData(pnewData);
+    pdata->Release();
+}
+
+
+void String::AppendString(const char* putf8str, intptr_t utf8StrSz)
+{
+    if (!putf8str || !utf8StrSz)
+        return;
+    if (utf8StrSz == -1)
+        utf8StrSz = (intptr_t)OVR_strlen(putf8str);
+
+    DataDesc*   pdata = GetData();
+    size_t      oldSize = pdata->GetSize();
+
+    SetData(AllocDataCopy2(oldSize + (size_t)utf8StrSz, 0,
+                           pdata->Data, oldSize, putf8str, (size_t)utf8StrSz));
+    pdata->Release();
+}
+
+void    String::AssignString(const InitStruct& src, size_t size)
+{
+    DataDesc*   poldData = GetData();
+    DataDesc*   pnewData = AllocData(size, 0);
+    src.InitString(pnewData->Data, size);
+    SetData(pnewData);
+    poldData->Release();
+}
+
+void    String::AssignString(const char* putf8str, size_t size)
+{
+    DataDesc* poldData = GetData();
+    SetData(AllocDataCopy1(size, 0, putf8str, size));
+    poldData->Release();
+}
+
+void    String::operator = (const char* pstr)
+{
+    AssignString(pstr, pstr ? OVR_strlen(pstr) : 0);
+}
+
+void    String::operator = (const wchar_t* pwstr)
+{
+    DataDesc*   poldData = GetData();
+    size_t      size = pwstr ? (size_t)UTF8Util::GetEncodeStringSize(pwstr) : 0;
+
+    DataDesc*   pnewData = AllocData(size, 0);
+    UTF8Util::EncodeString(pnewData->Data, pwstr);
+    SetData(pnewData);
+    poldData->Release();
+}
+
+
+void    String::operator = (const String& src)
+{     
+    DataDesc*    psdata = src.GetData();
+    DataDesc*    pdata = GetData();    
+
+    SetData(psdata);
+    psdata->AddRef();
+    pdata->Release();
+}
+
+
+void    String::operator = (const StringBuffer& src)
+{ 
+    DataDesc* polddata = GetData();    
+    SetData(AllocDataCopy1(src.GetSize(), 0, src.ToCStr(), src.GetSize()));
+    polddata->Release();
+}
+
+void    String::operator += (const String& src)
+{
+    DataDesc   *pourData = GetData(),
+               *psrcData = src.GetData();
+    size_t      ourSize  = pourData->GetSize(),
+                srcSize  = psrcData->GetSize();
+    size_t      lflag    = pourData->GetLengthFlag() & psrcData->GetLengthFlag();
+
+    SetData(AllocDataCopy2(ourSize + srcSize, lflag,
+                           pourData->Data, ourSize, psrcData->Data, srcSize));
+    pourData->Release();
+}
+
+
+String   String::operator + (const char* str) const
+{   
+    String tmp1(*this);
+    tmp1 += (str ? str : "");
+    return tmp1;
+}
+
+String   String::operator + (const String& src) const
+{ 
+    String tmp1(*this);
+    tmp1 += src;
+    return tmp1;
+}
+
+void    String::Remove(size_t posAt, intptr_t removeLength)
+{
+    DataDesc*   pdata = GetData();
+    size_t      oldSize = pdata->GetSize();    
+    // Length indicates the number of characters to remove. 
+    size_t      length = GetLength();
+
+    // If index is past the string, nothing to remove.
+    if (posAt >= length)
+        return;
+    // Otherwise, cap removeLength to the length of the string.
+    if ((posAt + removeLength) > length)
+        removeLength = length - posAt;
+
+    // Get the byte position of the UTF8 char at position posAt.
+    intptr_t bytePos    = UTF8Util::GetByteIndex(posAt, pdata->Data, oldSize);
+    intptr_t removeSize = UTF8Util::GetByteIndex(removeLength, pdata->Data + bytePos, oldSize-bytePos);
+
+    SetData(AllocDataCopy2(oldSize - removeSize, pdata->GetLengthFlag(),
+                           pdata->Data, bytePos,
+                           pData->Data + bytePos + removeSize, (oldSize - bytePos - removeSize)));
+    pdata->Release();
+}
+
+
+String   String::Substring(size_t start, size_t end) const
+{
+    size_t length = GetLength();
+    if ((start >= length) || (start >= end))
+        return String();   
+
+    DataDesc* pdata = GetData();
+    
+    // If size matches, we know the exact index range.
+    if (pdata->LengthIsSize())
+        return String(pdata->Data + start, end - start);
+    
+    // Get position of starting character.
+    intptr_t byteStart = UTF8Util::GetByteIndex(start, pdata->Data, pdata->GetSize());
+    intptr_t byteSize  = UTF8Util::GetByteIndex(end - start, pdata->Data + byteStart, pdata->GetSize()-byteStart);
+    return String(pdata->Data + byteStart, (size_t)byteSize);
+}
+
+void String::Clear()
+{   
+    NullData.AddRef();
+    GetData()->Release();
+    SetData(&NullData);
+}
+
+
+String   String::ToUpper() const 
+{       
+    uint32_t    c;
+    const char* psource = GetData()->Data;
+    const char* pend = psource + GetData()->GetSize();
+    String      str;
+    intptr_t    bufferOffset = 0;
+    char        buffer[512];
+    
+    while(psource < pend)
+    {
+        do {            
+            c = UTF8Util::DecodeNextChar_Advance0(&psource);
+            UTF8Util::EncodeChar(buffer, &bufferOffset, OVR_towupper(wchar_t(c)));
+        } while ((psource < pend) && (bufferOffset < intptr_t(sizeof(buffer)-8)));
+
+        // Append string a piece at a time.
+        str.AppendString(buffer, bufferOffset);
+        bufferOffset = 0;
+    }
+
+    return str;
+}
+
+String   String::ToLower() const 
+{
+    uint32_t    c;
+    const char* psource = GetData()->Data;
+    const char* pend = psource + GetData()->GetSize();
+    String      str;
+    intptr_t    bufferOffset = 0;
+    char        buffer[512];
+
+    while(psource < pend)
+    {
+        do {
+            c = UTF8Util::DecodeNextChar_Advance0(&psource);
+            UTF8Util::EncodeChar(buffer, &bufferOffset, OVR_towlower(wchar_t(c)));
+        } while ((psource < pend) && (bufferOffset < intptr_t(sizeof(buffer)-8)));
+
+        // Append string a piece at a time.
+        str.AppendString(buffer, bufferOffset);
+        bufferOffset = 0;
+    }
+
+    return str;
+}
+
+
+
+String& String::Insert(const char* substr, size_t posAt, intptr_t strSize)
+{
+    DataDesc* poldData   = GetData();
+    size_t    oldSize    = poldData->GetSize();
+    size_t    insertSize = (strSize < 0) ? OVR_strlen(substr) : (size_t)strSize;    
+    size_t    byteIndex  =  (poldData->LengthIsSize()) ?
+                            posAt : (size_t)UTF8Util::GetByteIndex(posAt, poldData->Data, oldSize);
+
+    OVR_ASSERT(byteIndex <= oldSize);
+    
+    DataDesc* pnewData = AllocDataCopy2(oldSize + insertSize, 0,
+                                        poldData->Data, byteIndex, substr, insertSize);
+    memcpy(pnewData->Data + byteIndex + insertSize,
+           poldData->Data + byteIndex, oldSize - byteIndex);
+    SetData(pnewData);
+    poldData->Release();
+    return *this;
+}
+
+/*
+String& String::Insert(const uint32_t* substr, size_t posAt, intptr_t len)
+{
+    for (intptr_t i = 0; i < len; ++i)
+    {
+        size_t charw = InsertCharAt(substr[i], posAt);
+        posAt += charw;
+    }
+    return *this;
+}
+*/
+
+size_t String::InsertCharAt(uint32_t c, size_t posAt)
+{
+    char      buf[8];
+    intptr_t  index = 0;
+    UTF8Util::EncodeChar(buf, &index, c);
+    OVR_ASSERT(index >= 0);
+    buf[(size_t)index] = 0;
+
+    Insert(buf, posAt, index);
+    return (size_t)index;
+}
+
+
+int String::CompareNoCase(const char* a, const char* b)
+{
+    return OVR_stricmp(a, b);
+}
+
+int String::CompareNoCase(const char* a, const char* b, intptr_t len)
+{
+    if (len)
+    {
+        intptr_t f,l;
+        intptr_t slen = len;
+        const char *s = b;
+        do {
+            f = (intptr_t)OVR_tolower((int)(*(a++)));
+            l = (intptr_t)OVR_tolower((int)(*(b++)));
+        } while (--len && f && (f == l) && *b != 0);
+
+        if (f == l && (len != 0 || *b != 0))
+        {
+            f = (intptr_t)slen;
+            l = (intptr_t)OVR_strlen(s);
+            return int(f - l);
+        }
+
+        return int(f - l);
+    }
+    else
+        return (0-(int)OVR_strlen(b));
+}
+
+// ***** Implement hash static functions
+
+// Hash function
+size_t String::BernsteinHashFunction(const void* pdataIn, size_t size, size_t seed)
+{
+    const uint8_t*    pdata   = (const uint8_t*) pdataIn;
+    size_t          h       = seed;
+    while (size > 0)
+    {
+        size--;
+        h = ((h << 5) + h) ^ (unsigned) pdata[size];
+    }
+
+    return h;
+}
+
+// Hash function, case-insensitive
+size_t String::BernsteinHashFunctionCIS(const void* pdataIn, size_t size, size_t seed)
+{
+    const uint8_t*    pdata = (const uint8_t*) pdataIn;
+    size_t          h = seed;
+    while (size > 0)
+    {
+        size--;
+        h = ((h << 5) + h) ^ OVR_tolower(pdata[size]);
+    }
+
+    // Alternative: "sdbm" hash function, suggested at same web page above.
+    // h = 0;
+    // for bytes { h = (h << 16) + (h << 6) - hash + *p; }
+    return h;
+}
+
+
+
+// ***** String Buffer used for Building Strings
+
+
+#define OVR_SBUFF_DEFAULT_GROW_SIZE 512
+// Constructors / Destructor.
+StringBuffer::StringBuffer()
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+}
+
+StringBuffer::StringBuffer(size_t growSize)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    SetGrowSize(growSize);
+}
+
+StringBuffer::StringBuffer(const char* data)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    AppendString(data);
+}
+
+StringBuffer::StringBuffer(const char* data, size_t dataSize)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    AppendString(data, dataSize);
+}
+
+StringBuffer::StringBuffer(const String& src)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    AppendString(src.ToCStr(), src.GetSize());
+}
+
+StringBuffer::StringBuffer(const StringBuffer& src)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    AppendString(src.ToCStr(), src.GetSize());
+}
+
+StringBuffer::StringBuffer(const wchar_t* data)
+    : pData(NULL), Size(0), BufferSize(0), GrowSize(OVR_SBUFF_DEFAULT_GROW_SIZE), LengthIsSize(false)
+{
+    *this = data;
+}
+
+StringBuffer::~StringBuffer()
+{
+    if (pData)
+        OVR_FREE(pData);
+}
+void StringBuffer::SetGrowSize(size_t growSize) 
+{ 
+    if (growSize <= 16)
+        GrowSize = 16;
+    else
+    {
+        uint8_t bits = Alg::UpperBit(uint32_t(growSize-1));
+		size_t size = (size_t)1 << bits;
+        GrowSize = size == growSize ? growSize : size;
+    }
+}
+
+size_t StringBuffer::GetLength() const
+{
+    size_t length, size = GetSize();
+    if (LengthIsSize)
+        return size;
+
+    length = (size_t)UTF8Util::GetLength(pData, (size_t)GetSize());
+
+    if (length == GetSize())
+        LengthIsSize = true;
+    return length;
+}
+
+void    StringBuffer::Reserve(size_t _size)
+{
+    if (_size >= BufferSize) // >= because of trailing zero! (!AB)
+    {
+        BufferSize = (_size + 1 + GrowSize - 1)& ~(GrowSize-1);
+        if (!pData)
+            pData = (char*)OVR_ALLOC(BufferSize);
+        else 
+            pData = (char*)OVR_REALLOC(pData, BufferSize);
+    }
+}
+void    StringBuffer::Resize(size_t _size)
+{
+    Reserve(_size);
+    LengthIsSize = false;
+    Size = _size;
+    if (pData)
+        pData[Size] = 0;
+}
+
+void StringBuffer::Clear()
+{
+    Resize(0);
+    /*
+    if (pData != pEmptyNullData)
+    {
+        OVR_FREE(pHeap, pData);
+        pData = pEmptyNullData;
+        Size = BufferSize = 0;
+        LengthIsSize = false;
+    }
+    */
+}
+// Appends a character
+void     StringBuffer::AppendChar(uint32_t ch)
+{
+    char    buff[8];
+    size_t  origSize = GetSize();
+
+    // Converts ch into UTF8 string and fills it into buff. Also increments index according to the number of bytes
+    // in the UTF8 string.
+    intptr_t   srcSize = 0;
+    UTF8Util::EncodeChar(buff, &srcSize, ch);
+    OVR_ASSERT(srcSize >= 0);
+    
+    size_t size = origSize + srcSize;
+    Resize(size);
+    memcpy(pData + origSize, buff, srcSize);
+}
+
+// Append a string
+void     StringBuffer::AppendString(const wchar_t* pstr, intptr_t len)
+{
+    if (!pstr)
+        return;
+
+    intptr_t srcSize  = UTF8Util::GetEncodeStringSize(pstr, len);
+    size_t   origSize = GetSize();
+    size_t   size     = srcSize + origSize;
+
+    Resize(size);
+    UTF8Util::EncodeString(pData + origSize,  pstr, len);
+}
+
+void      StringBuffer::AppendString(const char* putf8str, intptr_t utf8StrSz)
+{
+    if (!putf8str || !utf8StrSz)
+        return;
+    if (utf8StrSz == -1)
+        utf8StrSz = (intptr_t)OVR_strlen(putf8str);
+
+    size_t  origSize = GetSize();
+    size_t  size     = utf8StrSz + origSize;
+
+    Resize(size);
+    memcpy(pData + origSize, putf8str, utf8StrSz);
+}
+
+
+void      StringBuffer::operator = (const char* pstr)
+{
+    pstr = pstr ? pstr : "";
+    size_t size = OVR_strlen(pstr);
+    Resize(size);
+    memcpy(pData, pstr, size);
+}
+
+void      StringBuffer::operator = (const wchar_t* pstr)
+{
+    pstr = pstr ? pstr : L"";
+    size_t size = (size_t)UTF8Util::GetEncodeStringSize(pstr);
+    Resize(size);
+    UTF8Util::EncodeString(pData, pstr);
+}
+
+void      StringBuffer::operator = (const String& src)
+{
+    Resize(src.GetSize());
+    memcpy(pData, src.ToCStr(), src.GetSize());
+}
+
+void      StringBuffer::operator = (const StringBuffer& src)
+{
+	Clear();
+	AppendString(src.ToCStr(), src.GetSize());
+}
+
+
+// Inserts substr at posAt
+void      StringBuffer::Insert(const char* substr, size_t posAt, intptr_t len)
+{
+    size_t    oldSize    = Size;
+    size_t    insertSize = (len < 0) ? OVR_strlen(substr) : (size_t)len;    
+    size_t    byteIndex  = LengthIsSize ? posAt : 
+                           (size_t)UTF8Util::GetByteIndex(posAt, pData, (intptr_t)Size);
+
+    OVR_ASSERT(byteIndex <= oldSize);
+    Reserve(oldSize + insertSize);
+
+    memmove(pData + byteIndex + insertSize, pData + byteIndex, oldSize - byteIndex + 1);
+    memcpy (pData + byteIndex, substr, insertSize);
+    LengthIsSize = false;
+    Size = oldSize + insertSize;
+    pData[Size] = 0;
+}
+
+// Inserts character at posAt
+size_t    StringBuffer::InsertCharAt(uint32_t c, size_t posAt)
+{
+    char    buf[8];
+    intptr_t   len = 0;
+    UTF8Util::EncodeChar(buf, &len, c);
+    OVR_ASSERT(len >= 0);
+    buf[(size_t)len] = 0;
+
+    Insert(buf, posAt, len);
+    return (size_t)len;
+}
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,657 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_String.h
+Content     :   String UTF8 string implementation with copy-on-write semantics
+                (thread-safe for assignment but not modification).
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_String_h
+#define OVR_String_h
+
+#include "OVR_Types.h"
+#include "OVR_Allocator.h"
+#include "OVR_UTF8Util.h"
+#include "OVR_Atomic.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+namespace OVR {
+
+// ***** Classes
+
+class String;
+class StringBuffer;
+
+
+//-----------------------------------------------------------------------------------
+// ***** String Class 
+
+// String is UTF8 based string class with copy-on-write implementation
+// for assignment.
+
+class String
+{
+protected:
+
+    enum FlagConstants
+    {
+        //Flag_GetLength      = 0x7FFFFFFF,
+        // This flag is set if GetLength() == GetSize() for a string.
+        // Avoid extra scanning is Substring and indexing logic.
+        Flag_LengthIsSizeShift   = (sizeof(size_t)*8 - 1)
+    };
+
+
+    // Internal structure to hold string data
+    struct DataDesc
+    {
+        // Number of bytes. Will be the same as the number of chars if the characters
+        // are ascii, may not be equal to number of chars in case string data is UTF8.
+        size_t  Size;       
+        volatile int32_t RefCount;
+        char    Data[1];
+
+        void    AddRef()
+        {
+            AtomicOps<int32_t>::ExchangeAdd_NoSync(&RefCount, 1);
+        }
+        // Decrement ref count. This needs to be thread-safe, since
+        // a different thread could have also decremented the ref count.
+        // For example, if u start off with a ref count = 2. Now if u
+        // decrement the ref count and check against 0 in different
+        // statements, a different thread can also decrement the ref count
+        // in between our decrement and checking against 0 and will find
+        // the ref count = 0 and delete the object. This will lead to a crash
+        // when context switches to our thread and we'll be trying to delete
+        // an already deleted object. Hence decrementing the ref count and
+        // checking against 0 needs to made an atomic operation.
+        void    Release()
+        {
+            if ((AtomicOps<int32_t>::ExchangeAdd_NoSync(&RefCount, -1) - 1) == 0)
+                OVR_FREE(this);
+        }
+
+        static size_t GetLengthFlagBit()     { return size_t(1) << Flag_LengthIsSizeShift; }
+        size_t      GetSize() const         { return Size & ~GetLengthFlagBit() ; }
+        size_t      GetLengthFlag()  const  { return Size & GetLengthFlagBit(); }
+        bool        LengthIsSize() const    { return GetLengthFlag() != 0; }
+    };
+
+    // Heap type of the string is encoded in the lower bits.
+    enum HeapType
+    {
+        HT_Global   = 0,    // Heap is global.
+        HT_Local    = 1,    // SF::String_loc: Heap is determined based on string's address.
+        HT_Dynamic  = 2,    // SF::String_temp: Heap is stored as a part of the class.
+        HT_Mask     = 3
+    };
+
+    union {
+        DataDesc* pData;
+        size_t    HeapTypeBits;
+    };
+    typedef union {
+        DataDesc* pData;
+        size_t    HeapTypeBits;
+    } DataDescUnion;
+
+    inline HeapType    GetHeapType() const { return (HeapType) (HeapTypeBits & HT_Mask); }
+
+    inline DataDesc*   GetData() const
+    {
+        DataDescUnion u;
+        u.pData    = pData;
+        u.HeapTypeBits = (u.HeapTypeBits & ~(size_t)HT_Mask);
+        return u.pData;
+    }
+    
+    inline void        SetData(DataDesc* pdesc)
+    {
+        HeapType ht = GetHeapType();
+        pData = pdesc;
+        OVR_ASSERT((HeapTypeBits & HT_Mask) == 0);
+        HeapTypeBits |= ht;        
+    }
+
+    
+    DataDesc*   AllocData(size_t size, size_t lengthIsSize);
+    DataDesc*   AllocDataCopy1(size_t size, size_t lengthIsSize,
+                               const char* pdata, size_t copySize);
+    DataDesc*   AllocDataCopy2(size_t size, size_t lengthIsSize,
+                               const char* pdata1, size_t copySize1,
+                               const char* pdata2, size_t copySize2);
+
+    // Special constructor to avoid data initalization when used in derived class.
+    struct NoConstructor { };
+    String(const NoConstructor&) { }
+
+public:
+
+    // For initializing string with dynamic buffer
+    struct InitStruct
+    {
+        virtual ~InitStruct() { }
+        virtual void InitString(char* pbuffer, size_t size) const = 0;
+    };
+
+
+    // Constructors / Destructors.
+    String();
+    String(const char* data);
+    String(const char* data1, const char* pdata2, const char* pdata3 = 0);
+    String(const char* data, size_t buflen);
+    String(const String& src);
+    String(const StringBuffer& src);
+    String(const InitStruct& src, size_t size);
+    explicit String(const wchar_t* data);      
+
+    // Destructor (Captain Obvious guarantees!)
+    ~String()
+    {
+        GetData()->Release();
+    }
+
+    // Declaration of NullString
+    static DataDesc NullData;
+
+
+    // *** General Functions
+
+    void        Clear();
+
+    // For casting to a pointer to char.
+    operator const char*() const        { return GetData()->Data; }
+    // Pointer to raw buffer.
+    const char* ToCStr() const          { return GetData()->Data; }
+
+    // Returns number of bytes
+    size_t      GetSize() const         { return GetData()->GetSize() ; }
+    // Tells whether or not the string is empty
+    bool        IsEmpty() const         { return GetSize() == 0; }
+
+    // Returns  number of characters
+    size_t      GetLength() const;
+
+    // Returns  character at the specified index
+    uint32_t    GetCharAt(size_t index) const;
+    uint32_t    GetFirstCharAt(size_t index, const char** offset) const;
+    uint32_t    GetNextChar(const char** offset) const;
+
+    // Appends a character
+    void        AppendChar(uint32_t ch);
+
+    // Append a string
+    void        AppendString(const wchar_t* pstr, intptr_t len = -1);
+    void        AppendString(const char* putf8str, intptr_t utf8StrSz = -1);
+
+    // Assigned a string with dynamic data (copied through initializer).
+    void        AssignString(const InitStruct& src, size_t size);
+    // Assigns string with known size.
+    void        AssignString(const char* putf8str, size_t size);
+
+    //  Resize the string to the new size
+//  void        Resize(size_t _size);
+
+    // Removes the character at posAt
+    void        Remove(size_t posAt, intptr_t len = 1);
+
+    // Returns a String that's a substring of this.
+    //  -start is the index of the first UTF8 character you want to include.
+    //  -end is the index one past the last UTF8 character you want to include.
+    String   Substring(size_t start, size_t end) const;
+
+    // Case-conversion
+    String   ToUpper() const;
+    String   ToLower() const;
+
+    // Inserts substr at posAt
+    String&    Insert (const char* substr, size_t posAt, intptr_t len = -1);
+
+    // Inserts character at posAt
+    size_t      InsertCharAt(uint32_t c, size_t posAt);
+
+    // Inserts substr at posAt, which is an index of a character (not byte).
+    // Of size is specified, it is in bytes.
+//  String&    Insert(const uint32_t* substr, size_t posAt, intptr_t size = -1);
+
+    // Get Byte index of the character at position = index
+    size_t      GetByteIndex(size_t index) const { return (size_t)UTF8Util::GetByteIndex(index, GetData()->Data); }
+
+    // Utility: case-insensitive string compare.  stricmp() & strnicmp() are not
+    // ANSI or POSIX, do not seem to appear in Linux.
+    static int OVR_STDCALL   CompareNoCase(const char* a, const char* b);
+    static int OVR_STDCALL   CompareNoCase(const char* a, const char* b, intptr_t len);
+
+    // Hash function, case-insensitive
+    static size_t OVR_STDCALL BernsteinHashFunctionCIS(const void* pdataIn, size_t size, size_t seed = 5381);
+
+    // Hash function, case-sensitive
+    static size_t OVR_STDCALL BernsteinHashFunction(const void* pdataIn, size_t size, size_t seed = 5381);
+
+
+    // ***** File path parsing helper functions.
+    // Implemented in OVR_String_FilePath.cpp.
+
+    // Absolute paths can star with:
+    //  - protocols:        'file://', 'http://'
+    //  - windows drive:    'c:\'
+    //  - UNC share name:   '\\share'
+    //  - unix root         '/'
+    static bool HasAbsolutePath(const char* path);
+    static bool HasExtension(const char* path);
+    static bool HasProtocol(const char* path);
+
+    bool    HasAbsolutePath() const { return HasAbsolutePath(ToCStr()); }
+    bool    HasExtension() const    { return HasExtension(ToCStr()); }
+    bool    HasProtocol() const     { return HasProtocol(ToCStr()); }
+
+    String  GetProtocol() const;    // Returns protocol, if any, with trailing '://'.
+    String  GetPath() const;        // Returns path with trailing '/'.
+    String  GetFilename() const;    // Returns filename, including extension.
+    String  GetExtension() const;   // Returns extension with a dot.
+
+    void    StripProtocol();        // Strips front protocol, if any, from the string.
+    void    StripExtension();       // Strips off trailing extension.
+    
+
+    // Operators
+    // Assignment
+    void        operator =  (const char* str);
+    void        operator =  (const wchar_t* str);
+    void        operator =  (const String& src);
+    void        operator =  (const StringBuffer& src);
+
+    // Addition
+    void        operator += (const String& src);
+    void        operator += (const char* psrc)       { AppendString(psrc); }
+    void        operator += (const wchar_t* psrc)    { AppendString(psrc); }
+    void        operator += (char  ch)               { AppendChar(ch); }
+    String      operator +  (const char* str) const;
+    String      operator +  (const String& src)  const;
+
+    // Comparison
+    bool        operator == (const String& str) const
+    {
+        return (OVR_strcmp(GetData()->Data, str.GetData()->Data)== 0);
+    }
+
+    bool        operator != (const String& str) const
+    {
+        return !operator == (str);
+    }
+
+    bool        operator == (const char* str) const
+    {
+        return OVR_strcmp(GetData()->Data, str) == 0;
+    }
+
+    bool        operator != (const char* str) const
+    {
+        return !operator == (str);
+    }
+
+    bool        operator <  (const char* pstr) const
+    {
+        return OVR_strcmp(GetData()->Data, pstr) < 0;
+    }
+
+    bool        operator <  (const String& str) const
+    {
+        return *this < str.GetData()->Data;
+    }
+
+    bool        operator >  (const char* pstr) const
+    {
+        return OVR_strcmp(GetData()->Data, pstr) > 0;
+    }
+
+    bool        operator >  (const String& str) const
+    {
+        return *this > str.GetData()->Data;
+    }
+
+    int CompareNoCase(const char* pstr) const
+    {
+        return CompareNoCase(GetData()->Data, pstr);
+    }
+    int CompareNoCase(const String& str) const
+    {
+        return CompareNoCase(GetData()->Data, str.ToCStr());
+    }
+
+    // Accesses raw bytes
+    const char&     operator [] (int index) const
+    {
+        OVR_ASSERT(index >= 0 && (size_t)index < GetSize());
+        return GetData()->Data[index];
+    }
+    const char&     operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < GetSize());
+        return GetData()->Data[index];
+    }
+
+
+    // Case insensitive keys are used to look up insensitive string in hash tables
+    // for SWF files with version before SWF 7.
+    struct NoCaseKey
+    {   
+        const String* pStr;
+        NoCaseKey(const String &str) : pStr(&str){};
+    };
+
+    bool    operator == (const NoCaseKey& strKey) const
+    {
+        return (CompareNoCase(ToCStr(), strKey.pStr->ToCStr()) == 0);
+    }
+    bool    operator != (const NoCaseKey& strKey) const
+    {
+        return !(CompareNoCase(ToCStr(), strKey.pStr->ToCStr()) == 0);
+    }
+
+    // Hash functor used for strings.
+    struct HashFunctor
+    {    
+        size_t operator()(const String& data) const
+        {
+            size_t size = data.GetSize();
+            return String::BernsteinHashFunction((const char*)data, size);
+        }        
+    };
+    // Case-insensitive hash functor used for strings. Supports additional
+    // lookup based on NoCaseKey.
+    struct NoCaseHashFunctor
+    {    
+        size_t operator()(const String& data) const
+        {
+            size_t size = data.GetSize();
+            return String::BernsteinHashFunctionCIS((const char*)data, size);
+        }
+        size_t operator()(const NoCaseKey& data) const
+        {       
+            size_t size = data.pStr->GetSize();
+            return String::BernsteinHashFunctionCIS((const char*)data.pStr->ToCStr(), size);
+        }
+    };
+
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** String Buffer used for Building Strings
+
+class StringBuffer
+{
+    char*           pData;
+    size_t          Size;
+    size_t          BufferSize;
+    size_t          GrowSize;    
+    mutable bool    LengthIsSize;    
+
+public:
+
+    // Constructors / Destructor.    
+    StringBuffer();
+    explicit StringBuffer(size_t growSize);
+    StringBuffer(const char* data);
+    StringBuffer(const char* data, size_t buflen);
+    StringBuffer(const String& src);
+    StringBuffer(const StringBuffer& src);
+    explicit StringBuffer(const wchar_t* data);
+    ~StringBuffer();
+    
+
+    // Modify grow size used for growing/shrinking the buffer.
+    size_t      GetGrowSize() const         { return GrowSize; }
+    void        SetGrowSize(size_t growSize);
+    
+
+    // *** General Functions
+    // Does not release memory, just sets Size to 0
+    void        Clear();
+
+    // For casting to a pointer to char.
+    operator const char*() const        { return (pData) ? pData : ""; }
+    // Pointer to raw buffer.
+    const char* ToCStr() const          { return (pData) ? pData : ""; }
+
+    // Returns number of bytes.
+    size_t      GetSize() const         { return Size ; }
+    // Tells whether or not the string is empty.
+    bool        IsEmpty() const         { return GetSize() == 0; }
+
+    // Returns  number of characters
+    size_t      GetLength() const;
+
+    // Returns  character at the specified index
+    uint32_t    GetCharAt(size_t index) const;
+    uint32_t    GetFirstCharAt(size_t index, const char** offset) const;
+    uint32_t    GetNextChar(const char** offset) const;
+
+
+    //  Resize the string to the new size
+    void        Resize(size_t _size);
+    void        Reserve(size_t _size);
+
+    // Appends a character
+    void        AppendChar(uint32_t ch);
+
+    // Append a string
+    void        AppendString(const wchar_t* pstr, intptr_t len = -1);
+    void        AppendString(const char* putf8str, intptr_t utf8StrSz = -1);
+    void        AppendFormat(const char* format, ...);
+
+    // Assigned a string with dynamic data (copied through initializer).
+    //void        AssignString(const InitStruct& src, size_t size);
+
+    // Inserts substr at posAt
+    void        Insert (const char* substr, size_t posAt, intptr_t len = -1);
+    // Inserts character at posAt
+    size_t      InsertCharAt(uint32_t c, size_t posAt);
+
+    // Assignment
+    void        operator =  (const char* str);
+    void        operator =  (const wchar_t* str);
+    void        operator =  (const String& src);
+    void        operator =  (const StringBuffer& src);
+
+    // Addition
+    void        operator += (const String& src)      { AppendString(src.ToCStr(),src.GetSize()); }
+    void        operator += (const char* psrc)       { AppendString(psrc); }
+    void        operator += (const wchar_t* psrc)    { AppendString(psrc); }
+    void        operator += (char  ch)               { AppendChar(ch); }
+    //String   operator +  (const char* str) const ;
+    //String   operator +  (const String& src)  const ;
+
+    // Accesses raw bytes
+    char&       operator [] (int index)
+    {
+        OVR_ASSERT(((size_t)index) < GetSize());
+        return pData[index];
+    }
+    char&       operator [] (size_t index)
+    {
+        OVR_ASSERT(index < GetSize());
+        return pData[index];
+    }
+
+    const char&     operator [] (int index) const 
+    {
+        OVR_ASSERT(((size_t)index) < GetSize());
+        return pData[index];
+    }
+    const char&     operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < GetSize());
+        return pData[index];
+    }
+};
+
+
+//
+// Wrapper for string data. The data must have a guaranteed 
+// lifespan throughout the usage of the wrapper. Not intended for 
+// cached usage. Not thread safe.
+//
+class StringDataPtr
+{
+public:
+    StringDataPtr() : pStr(NULL), Size(0) {}
+    StringDataPtr(const StringDataPtr& p)
+        : pStr(p.pStr), Size(p.Size) {}
+    StringDataPtr(const char* pstr, size_t sz)
+        : pStr(pstr), Size(sz) {}
+    StringDataPtr(const char* pstr)
+        : pStr(pstr), Size((pstr != NULL) ? OVR_strlen(pstr) : 0) {}
+    explicit StringDataPtr(const String& str)
+        : pStr(str.ToCStr()), Size(str.GetSize()) {}
+    template <typename T, int N> 
+    StringDataPtr(const T (&v)[N])
+        : pStr(v), Size(N) {}
+
+public:
+    const char* ToCStr() const { return pStr; }
+    size_t      GetSize() const { return Size; }
+    bool        IsEmpty() const { return GetSize() == 0; }
+
+    // value is a prefix of this string
+    // Character's values are not compared.
+    bool        IsPrefix(const StringDataPtr& value) const
+    {
+        return ToCStr() == value.ToCStr() && GetSize() >= value.GetSize();
+    }
+    // value is a suffix of this string
+    // Character's values are not compared.
+    bool        IsSuffix(const StringDataPtr& value) const
+    {
+        return ToCStr() <= value.ToCStr() && (End()) == (value.End());
+    }
+
+    // Find first character.
+    // init_ind - initial index.
+    intptr_t    FindChar(char c, size_t init_ind = 0) const 
+    {
+        for (size_t i = init_ind; i < GetSize(); ++i)
+            if (pStr[i] == c)
+                return static_cast<intptr_t>(i);
+
+        return -1; 
+    }
+
+    // Find last character.
+    // init_ind - initial index.
+    intptr_t    FindLastChar(char c, size_t init_ind = ~0) const 
+    {
+        if (init_ind == (size_t)~0 || init_ind > GetSize())
+            init_ind = GetSize();
+        else
+            ++init_ind;
+
+        for (size_t i = init_ind; i > 0; --i)
+            if (pStr[i - 1] == c)
+                return static_cast<intptr_t>(i - 1);
+
+        return -1; 
+    }
+
+    // Create new object and trim size bytes from the left.
+    StringDataPtr  GetTrimLeft(size_t size) const
+    {
+        // Limit trim size to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+
+        return StringDataPtr(ToCStr() + size, GetSize() - size);
+    }
+    // Create new object and trim size bytes from the right.
+    StringDataPtr  GetTrimRight(size_t size) const
+    {
+        // Limit trim to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+
+        return StringDataPtr(ToCStr(), GetSize() - size);
+    }
+
+    // Create new object, which contains next token.
+    // Useful for parsing.
+    StringDataPtr GetNextToken(char separator = ':') const
+    {
+        size_t cur_pos = 0;
+        const char* cur_str = ToCStr();
+
+        for (; cur_pos < GetSize() && cur_str[cur_pos]; ++cur_pos)
+        {
+            if (cur_str[cur_pos] == separator)
+            {
+                break;
+            }
+        }
+
+        return StringDataPtr(ToCStr(), cur_pos);
+    }
+
+    // Trim size bytes from the left.
+    StringDataPtr& TrimLeft(size_t size)
+    {
+        // Limit trim size to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+        pStr += size;
+        Size -= size;
+
+        return *this;
+    }
+    // Trim size bytes from the right.
+    StringDataPtr& TrimRight(size_t size)
+    {
+        // Limit trim to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+        Size -= size;
+
+        return *this;
+    }
+
+    const char* Begin() const { return ToCStr(); }
+    const char* End() const { return ToCStr() + GetSize(); }
+
+    // Hash functor used string data pointers
+    struct HashFunctor
+    {    
+        size_t operator()(const StringDataPtr& data) const
+        {
+            return String::BernsteinHashFunction(data.ToCStr(), data.GetSize());
+        }        
+    };
+
+    bool operator== (const StringDataPtr& data) const 
+    {
+        return (OVR_strncmp(pStr, data.pStr, data.Size) == 0);
+    }
+
+protected:
+    const char* pStr;
+    size_t      Size;
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String_FormatUtil.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String_FormatUtil.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,53 @@
+/************************************************************************************
+
+Filename    :   OVR_String_FormatUtil.cpp
+Content     :   String format functions.
+Created     :   February 27, 2013
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_String.h"
+#include "OVR_Log.h"
+
+namespace OVR {
+
+void StringBuffer::AppendFormat(const char* format, ...)
+{       
+    va_list argList;
+
+    va_start(argList, format);
+    size_t size = OVR_vscprintf(format, argList);
+    va_end(argList);
+
+    char* buffer = (char*) OVR_ALLOC(sizeof(char) * (size+1));
+
+    va_start(argList, format);
+    size_t result = OVR_vsprintf(buffer, size+1, format, argList);
+    OVR_UNUSED1(result);
+    va_end(argList);
+    OVR_ASSERT_LOG(result == size, ("Error in OVR_vsprintf"));
+
+    AppendString(buffer);
+
+    OVR_FREE(buffer);
+}
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String_PathUtil.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String_PathUtil.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,211 @@
+/************************************************************************************
+
+Filename    :   OVR_String_PathUtil.cpp
+Content     :   String filename/url helper function
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_String.h"
+#include "OVR_UTF8Util.h"
+
+namespace OVR {
+
+//--------------------------------------------------------------------
+// ***** Path-Scanner helper function 
+
+// Scans file path finding filename start and extension start, fills in their addess.
+void ScanFilePath(const char* url, const char** pfilename, const char** pext)
+{ 
+    const char* urlStart = url;
+    const char *filename = 0;
+    const char *lastDot = 0;
+
+    uint32_t charVal = UTF8Util::DecodeNextChar(&url);
+
+    while (charVal != 0)
+    {
+        if ((charVal == '/') || (charVal == '\\'))
+        {
+            filename = url;
+            lastDot  = 0;
+        }
+        else if (charVal == '.')
+        {
+            lastDot = url - 1;
+        }
+        
+        charVal = UTF8Util::DecodeNextChar(&url);
+    }
+
+    if (pfilename)
+    {
+        // It was a naked filename
+        if (urlStart && (*urlStart != '.') && *urlStart)
+            *pfilename = urlStart;
+        else
+            *pfilename = filename;
+    }
+
+    if (pext)
+    {
+        *pext = lastDot;
+    }
+}
+
+// Scans till the end of protocol. Returns first character past protocol,
+// 0 if not found.
+//  - protocol: 'file://', 'http://'
+const char* ScanPathProtocol(const char* url)
+{    
+    uint32_t charVal = UTF8Util::DecodeNextChar(&url);
+    uint32_t charVal2;
+   
+    while (charVal != 0)
+    {
+        // Treat a colon followed by a slash as absolute.
+        if (charVal == ':')
+        {
+            charVal2 = UTF8Util::DecodeNextChar(&url);
+            charVal  = UTF8Util::DecodeNextChar(&url);
+            if ((charVal == '/') && (charVal2 == '\\'))
+                return url;
+        }
+        charVal = UTF8Util::DecodeNextChar(&url);
+    }
+    return 0;
+}
+
+
+//--------------------------------------------------------------------
+// ***** String Path API implementation
+
+bool String::HasAbsolutePath(const char* url)
+{
+    // Absolute paths can star with:
+    //  - protocols:        'file://', 'http://'
+    //  - windows drive:    'c:\'
+    //  - UNC share name:   '\\share'
+    //  - unix root         '/'
+
+    // On the other hand, relative paths are:
+    //  - directory:        'directory/file'
+    //  - this directory:   './file'
+    //  - parent directory: '../file'
+    // 
+    // For now, we don't parse '.' or '..' out, but instead let it be concatenated
+    // to string and let the OS figure it out. This, however, is not good for file
+    // name matching in library/etc, so it should be improved.
+
+    if (!url || !*url)
+        return true; // Treat empty strings as absolute.    
+
+    uint32_t charVal = UTF8Util::DecodeNextChar(&url);
+
+    // Fist character of '/' or '\\' means absolute url.
+    if ((charVal == '/') || (charVal == '\\'))
+        return true;
+
+    while (charVal != 0)
+    {
+        // Treat a colon followed by a slash as absolute.
+        if (charVal == ':')
+        {
+            charVal = UTF8Util::DecodeNextChar(&url);
+            // Protocol or windows drive. Absolute.
+            if ((charVal == '/') || (charVal == '\\'))
+                return true;
+        }
+        else if ((charVal == '/') || (charVal == '\\'))
+        {
+            // Not a first character (else 'if' above the loop would have caught it).
+            // Must be a relative url.
+            break;
+        }
+
+        charVal = UTF8Util::DecodeNextChar(&url);
+    }
+
+    // We get here for relative paths.
+    return false;    
+}
+
+
+bool String::HasExtension(const char* path)
+{
+    const char* ext = 0;
+    ScanFilePath(path, 0, &ext);
+    return ext != 0;
+}
+bool String::HasProtocol(const char* path)
+{
+    return ScanPathProtocol(path) != 0;
+}
+
+
+String  String::GetPath() const
+{
+    const char* filename = 0;
+    ScanFilePath(ToCStr(), &filename, 0);
+
+    // Technically we can have extra logic somewhere for paths,
+    // such as enforcing protocol and '/' only based on flags,
+    // but we keep it simple for now.
+    return String(ToCStr(), filename ? (filename-ToCStr()) : GetSize());
+}
+
+String  String::GetProtocol() const
+{
+    const char* protocolEnd = ScanPathProtocol(ToCStr());
+    return String(ToCStr(), protocolEnd ? (protocolEnd-ToCStr()) : 0);
+}
+
+String  String::GetFilename() const
+{
+    const char* filename = 0;
+    ScanFilePath(ToCStr(), &filename, 0);
+    return String(filename);
+}
+String  String::GetExtension() const
+{
+    const char* ext = 0;
+    ScanFilePath(ToCStr(), 0, &ext);
+    return String(ext);
+}
+
+void    String::StripExtension()
+{
+    const char* ext = 0;
+    ScanFilePath(ToCStr(), 0, &ext);    
+    if (ext)
+    {
+        *this = String(ToCStr(), ext-ToCStr());
+    }
+}
+
+void    String::StripProtocol()
+{
+    const char* protocol = ScanPathProtocol(ToCStr());
+    if (protocol)
+        AssignString(protocol, OVR_strlen(protocol));
+}
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_StringHash.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_StringHash.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,100 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_StringHash.h
+Content     :   String hash table used when optional case-insensitive
+                lookup is required.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_StringHash_h
+#define OVR_StringHash_h
+
+#include "OVR_String.h"
+#include "OVR_Hash.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// *** StringHash
+
+// This is a custom string hash table that supports case-insensitive
+// searches through special functions such as GetCaseInsensitive, etc.
+// This class is used for Flash labels, exports and other case-insensitive tables.
+
+template<class U, class Allocator = ContainerAllocator<U> >
+class StringHash : public Hash<String, U, String::NoCaseHashFunctor, Allocator>
+{
+public:
+    typedef U                                                        ValueType;
+    typedef StringHash<U, Allocator>                                 SelfType;
+    typedef Hash<String, U, String::NoCaseHashFunctor, Allocator>    BaseType;
+
+public:    
+
+    void    operator = (const SelfType& src) { BaseType::operator = (src); }
+
+    bool    GetCaseInsensitive(const String& key, U* pvalue) const
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey, pvalue);
+    }
+    // Pointer-returning get variety.
+    const U* GetCaseInsensitive(const String& key) const   
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey);
+    }
+    U*  GetCaseInsensitive(const String& key)
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey);
+    }
+
+    
+    typedef typename BaseType::Iterator base_iterator;
+
+    base_iterator    FindCaseInsensitive(const String& key)
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::FindAlt(ikey);
+    }
+
+    // Set just uses a find and assigns value if found. The key is not modified;
+    // this behavior is identical to Flash string variable assignment.    
+    void    SetCaseInsensitive(const String& key, const U& value)
+    {
+        base_iterator it = FindCaseInsensitive(key);
+        if (it != BaseType::End())
+        {
+            it->Second = value;
+        }
+        else
+        {
+            BaseType::Add(key, value);
+        }
+    } 
+};
+
+} // OVR 
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,138 @@
+/**************************************************************************
+
+Filename    :   OVR_SysFile.cpp
+Content     :   File wrapper class implementation (Win32)
+
+Created     :   April 5, 1999
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+**************************************************************************/
+
+#define  GFILE_CXX
+
+// Standard C library (Captain Obvious guarantees!)
+#include <stdio.h>
+
+#include "OVR_SysFile.h"
+#include "OVR_Log.h"
+
+namespace OVR {
+
+// This is - a dummy file that fails on all calls.
+
+class UnopenedFile : public File
+{
+public:
+    UnopenedFile()  { }
+    ~UnopenedFile() { }
+
+    virtual const char* GetFilePath()               { return 0; }
+
+    // ** File Information
+    virtual bool        IsValid()                   { return 0; }
+    virtual bool        IsWritable()                { return 0; }
+
+    // Return position / file size
+    virtual int         Tell()                      { return 0; }
+    virtual int64_t     LTell()                     { return 0; }
+    virtual int         GetLength()                 { return 0; }
+    virtual int64_t     LGetLength()                { return 0; }
+
+//  virtual bool        Stat(FileStats *pfs)        { return 0; }
+    virtual int         GetErrorCode()              { return Error_FileNotFound; }
+
+    // ** Stream implementation & I/O
+    virtual int         Write(const uint8_t *pbuffer, int numBytes)     { return -1; OVR_UNUSED2(pbuffer, numBytes); }
+    virtual int         Read(uint8_t *pbuffer, int numBytes)            { return -1; OVR_UNUSED2(pbuffer, numBytes); }
+    virtual int         SkipBytes(int numBytes)                       { return 0;  OVR_UNUSED(numBytes); }
+    virtual int         BytesAvailable()                              { return 0; }
+    virtual bool        Flush()                                       { return 0; }
+    virtual int         Seek(int offset, int origin)                  { return -1; OVR_UNUSED2(offset, origin); }
+    virtual int64_t     LSeek(int64_t offset, int origin)              { return -1; OVR_UNUSED2(offset, origin); }
+    
+    virtual int         CopyFromStream(File *pstream, int byteSize)   { return -1; OVR_UNUSED2(pstream, byteSize); }
+    virtual bool        Close()                                       { return 0; }    
+};
+
+
+
+// ***** System File
+
+// System file is created to access objects on file system directly
+// This file can refer directly to path
+
+// ** Constructor
+SysFile::SysFile() : DelegatedFile(0)
+{
+    pFile = *new UnopenedFile;
+}
+
+Ptr<File> FileFILEOpen(const String& path, int flags, int mode);
+
+// Opens a file
+SysFile::SysFile(const String& path, int flags, int mode) : DelegatedFile(0)
+{
+    Open(path, flags, mode);
+}
+
+
+// ** Open & management
+// Will fail if file's already open
+bool SysFile::Open(const String& path, int flags, int mode)
+{
+    pFile = FileFILEOpen(path, flags, mode);
+    if ((!pFile) || (!pFile->IsValid()))
+    {
+        pFile = *new UnopenedFile;
+        OVR_DEBUG_LOG(("Failed to open file: %s", path.ToCStr()));
+        return 0;
+    }
+    //pFile = *OVR_NEW DelegatedFile(pFile); // MA Testing
+    if (flags & Open_Buffered)
+        pFile = *new BufferedFile(pFile);
+    return 1;
+}
+
+
+// ** Overrides
+
+int SysFile::GetErrorCode()
+{
+    return pFile ? pFile->GetErrorCode() : Error_FileNotFound;
+}
+
+
+// Overrides to provide re-open support
+bool SysFile::IsValid()
+{
+    return pFile && pFile->IsValid();
+}
+bool SysFile::Close()
+{
+    if (IsValid())
+    {
+        DelegatedFile::Close();
+        pFile = *new UnopenedFile;
+        return 1;
+    }
+    return 0;
+}
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,104 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_SysFile.h
+Content     :   Header for all internal file management - functions and structures
+                to be inherited by OS specific subclasses.
+Created     :   September 19, 2012
+Notes       : 
+
+Notes       :   errno may not be preserved across use of GBaseFile member functions
+            :   Directories cannot be deleted while files opened from them are in use
+                (For the GetFullName function)
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SysFile_h
+#define OVR_SysFile_h
+
+#include "OVR_File.h"
+
+namespace OVR {
+
+// ***** Declared classes
+class   SysFile;
+
+//-----------------------------------------------------------------------------------
+// *** File Statistics
+
+// This class contents are similar to _stat, providing
+// creation, modify and other information about the file.
+struct FileStat
+{
+    // No change or create time because they are not available on most systems
+    int64_t ModifyTime;
+    int64_t AccessTime;
+    int64_t FileSize;
+
+    bool operator== (const FileStat& stat) const
+    {
+        return ( (ModifyTime == stat.ModifyTime) &&
+                 (AccessTime == stat.AccessTime) &&
+                 (FileSize == stat.FileSize) );
+    }
+};
+
+//-----------------------------------------------------------------------------------
+// *** System File
+
+// System file is created to access objects on file system directly
+// This file can refer directly to path.
+// System file can be open & closed several times; however, such use is not recommended
+// This class is realy a wrapper around an implementation of File interface for a 
+// particular platform.
+
+class SysFile : public DelegatedFile
+{
+protected:
+  SysFile(const SysFile &source) : DelegatedFile () { OVR_UNUSED(source); }
+public:
+
+    // ** Constructor
+    SysFile();
+    // Opens a file
+    SysFile(const String& path, int flags = Open_Read|Open_Buffered, int mode = Mode_ReadWrite); 
+
+    // ** Open & management 
+    bool  Open(const String& path, int flags = Open_Read|Open_Buffered, int mode = Mode_ReadWrite);
+        
+    OVR_FORCE_INLINE bool  Create(const String& path, int mode = Mode_ReadWrite)
+    { return Open(path, Open_ReadWrite|Open_Create, mode); }
+
+    // Helper function: obtain file statistics information. In OVR, this is used to detect file changes.
+    // Return 0 if function failed, most likely because the file doesn't exist.
+    static bool OVR_CDECL GetFileStat(FileStat* pfileStats, const String& path);
+    
+    // ** Overrides
+    // Overridden to provide re-open support
+    virtual int   GetErrorCode();
+
+    virtual bool  IsValid();
+
+    virtual bool  Close();    
+};
+
+} // Namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,141 @@
+/************************************************************************************
+
+Filename    :   OVR_System.cpp
+Content     :   General kernel initialization/cleanup, including that
+                of the memory allocator.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_System.h"
+#include "OVR_Threads.h"
+#include "OVR_Timer.h"
+#include "../Displays/OVR_Display.h"
+#ifdef OVR_OS_WIN32
+#include "../Displays/OVR_Win32_ShimFunctions.h"
+#endif
+
+namespace OVR {
+
+extern bool anyRiftsInExtendedMode();
+
+// Stack of destroy listeners (push/pop semantics)
+static SystemSingletonInternal *SystemShutdownListenerStack = 0;
+static Lock stackLock;
+
+void SystemSingletonInternal::PushDestroyCallbacks()
+{
+    Lock::Locker locker(&stackLock);
+
+    // Push listener onto the stack
+    NextSingleton = SystemShutdownListenerStack;
+    SystemShutdownListenerStack = this;
+}
+
+void System::DirectDisplayInitialize()
+{    
+#ifdef OVR_OS_WIN32
+	// Set up display code for Windows
+	Win32::DisplayShim::GetInstance();
+
+		// This code will look for the first display. If it's a display
+		// that's extending the destkop, the code will assume we're in
+		// compatibility mode. Compatibility mode prevents shim loading
+		// and renders only to extended Rifts.
+		// If we find a display and it's application exclusive,
+		// we load the shim so we can render to it.
+		// If no display is available, we revert to whatever the
+		// driver tells us we're in
+
+	bool anyExtendedRifts = anyRiftsInExtendedMode() || Display::InCompatibilityMode( false );
+	
+	Win32::DisplayShim::GetInstance().Initialize(anyExtendedRifts);
+#endif
+        }
+
+// Initializes System core, installing allocator.
+void System::Init(Log* log, Allocator *palloc)
+{    
+    if (!Allocator::GetInstance())
+    {
+        Log::SetGlobalLog(log);
+        Timer::initializeTimerSystem();
+        Allocator::setInstance(palloc);
+		Display::Initialize();
+		DirectDisplayInitialize();
+    }
+    else
+    {
+        OVR_DEBUG_LOG(("System::Init failed - duplicate call."));
+    }
+}
+
+void System::Destroy()
+{    
+    if (Allocator::GetInstance())
+    {
+#ifdef OVR_OS_WIN32
+		Win32::DisplayShim::GetInstance().Shutdown();
+#endif
+
+		// Invoke all of the post-finish callbacks (normal case)
+        for (SystemSingletonInternal *listener = SystemShutdownListenerStack; listener; listener = listener->NextSingleton)
+		{
+			listener->OnThreadDestroy();
+		}
+
+#ifdef OVR_ENABLE_THREADS
+		// Wait for all threads to finish; this must be done so that memory
+		// allocator and all destructors finalize correctly.
+		Thread::FinishAllThreads();
+#endif
+
+		// Invoke all of the post-finish callbacks (normal case)
+        for (SystemSingletonInternal *next, *listener = SystemShutdownListenerStack; listener; listener = next)
+		{
+            next = listener->NextSingleton;
+
+			listener->OnSystemDestroy();
+		}
+
+        SystemShutdownListenerStack = 0;
+
+		// Shutdown heap and destroy SysAlloc singleton, if any.
+        Allocator::GetInstance()->onSystemShutdown();
+        Allocator::setInstance(0);
+
+        Timer::shutdownTimerSystem();
+        Log::SetGlobalLog(Log::GetDefaultLog());
+    }
+    else
+    {
+        OVR_DEBUG_LOG(("System::Destroy failed - System not initialized."));
+    }
+}
+
+// Returns 'true' if system was properly initialized.
+bool System::IsInitialized()
+{
+    return Allocator::GetInstance() != 0;
+}
+
+
+} // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,172 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_System.h
+Content     :   General kernel initialization/cleanup, including that
+                of the memory allocator.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_System_h
+#define OVR_System_h
+
+#include "OVR_Allocator.h"
+#include "OVR_Log.h"
+#include "OVR_Atomic.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// SystemSingleton
+
+// Subsystems are implemented using the Singleton pattern.
+// To avoid code duplication in all the places where Singletons are defined,
+// The pattern is defined once here and used everywhere.
+
+class SystemSingletonInternal
+{
+    friend class System;
+
+    SystemSingletonInternal* NextSingleton;
+
+    // No copying allowed
+    SystemSingletonInternal(const SystemSingletonInternal&) {}
+    void operator=(const SystemSingletonInternal&) {}
+
+protected:
+    SystemSingletonInternal() :
+        NextSingleton(0)
+    {
+    }
+
+    // Call this to register the destroy events
+    // Destroy callbacks will be called in the reverse order they were registered
+    // Note: As a rule of thumb, call this at the end of the singleton class constructor.
+    void PushDestroyCallbacks();
+
+    // Required: Invoked when the System object is shutting down
+    // Called after threads are stopped
+    // Called before Log, Allocator, and Timer subsystems are stopped
+    // Listeners are called in the opposite order they were registered
+    virtual void OnSystemDestroy() = 0;
+
+    // Called just before waiting for threads to die
+    // Listeners are called in the opposite order they were registered
+    // Useful to start terminating threads at the right time
+    // Note: The singleton must not delete itself here.
+    virtual void OnThreadDestroy() {}
+};
+
+// Singletons derive from this class
+template<class T>
+class SystemSingletonBase : public SystemSingletonInternal
+{
+    static AtomicPtr<T> SingletonInstance;
+    static T* SlowGetInstance();
+
+protected:
+    ~SystemSingletonBase()
+    {
+        // Make sure the instance gets set to zero on dtor
+        if (SingletonInstance == this)
+            SingletonInstance = 0;
+    }
+
+public:
+    static OVR_FORCE_INLINE T* GetInstance()
+    {
+        // Fast version
+        // Note: The singleton instance is stored in an AtomicPtr<> to allow it to be accessed
+        // atomically from multiple threads without locks.
+        T* instance = SingletonInstance;
+        return instance ? instance : SlowGetInstance();
+    }
+};
+
+// For reference, see N3337 14.5.1.3 (Static data members of class templates):
+template<class T> OVR::AtomicPtr<T> OVR::SystemSingletonBase<T>::SingletonInstance;
+
+// Place this in the singleton class in the header file
+#define OVR_DECLARE_SINGLETON(T) \
+    friend class OVR::SystemSingletonBase<T>; \
+private: \
+    T(); \
+    ~T(); \
+    virtual void OnSystemDestroy();
+
+// Place this in the singleton class source file
+#define OVR_DEFINE_SINGLETON(T) \
+    namespace OVR { \
+    template<> T* SystemSingletonBase<T>::SlowGetInstance() \
+    { \
+        static OVR::Lock lock; \
+        OVR::Lock::Locker locker(&lock); \
+        if (!SingletonInstance) SingletonInstance = new T; \
+        return SingletonInstance; \
+    } \
+    }
+
+
+// ***** System Core Initialization class
+
+// System initialization must take place before any other OVR_Kernel objects are used;
+// this is done my calling System::Init(). Among other things, this is necessary to
+// initialize the memory allocator. Similarly, System::Destroy must be
+// called before program exist for proper cleanup. Both of these tasks can be achieved by
+// simply creating System object first, allowing its constructor/destructor do the work.
+
+// TBD: Require additional System class for Oculus Rift API?
+
+class System
+{
+public:
+    // System constructor expects allocator to be specified, if it is being substituted.
+    System(Log* log = Log::ConfigureDefaultLog(LogMask_Debug),
+           Allocator* palloc = DefaultAllocator::InitSystemSingleton())
+    {
+        Init(log, palloc);
+    }
+    ~System()
+    {
+        Destroy();
+    }
+
+	static void OVR_CDECL DirectDisplayInitialize();
+
+    // Returns 'true' if system was properly initialized.
+    static bool OVR_CDECL IsInitialized();
+
+    // Initializes System core.  Users can override memory implementation by passing
+    // a different Allocator here.
+    static void OVR_CDECL Init(Log* log = Log::ConfigureDefaultLog(LogMask_Debug),
+                               Allocator *palloc = DefaultAllocator::InitSystemSingleton());
+
+	// De-initializes System more, finalizing the threading system and destroying
+    // the global memory allocator.
+    static void OVR_CDECL Destroy();
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,401 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_ThreadCommandQueue.cpp
+Content     :   Command queue for operations executed on a thread
+Created     :   October 29, 2012
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_ThreadCommandQueue.h"
+
+namespace OVR {
+
+
+//------------------------------------------------------------------------
+// ***** CircularBuffer
+
+// CircularBuffer is a FIFO buffer implemented in a single block of memory,
+// which allows writing and reading variable-size data chucks. Write fails
+// if buffer is full.
+
+class CircularBuffer
+{
+    enum {
+        AlignSize = 16,
+        AlignMask = AlignSize - 1
+    };
+
+    uint8_t*  pBuffer;
+    size_t  Size;
+    size_t  Tail;   // Byte offset of next item to be popped.
+    size_t  Head;   // Byte offset of where next push will take place.
+    size_t  End;    // When Head < Tail, this is used instead of Size.    
+
+    inline size_t roundUpSize(size_t size)
+    { return (size + AlignMask) & ~(size_t)AlignMask; }
+
+public:
+
+    CircularBuffer(size_t size)
+        : Size(size), Tail(0), Head(0), End(0)
+    {
+        pBuffer = (uint8_t*)OVR_ALLOC_ALIGNED(roundUpSize(size), AlignSize);
+    }
+    ~CircularBuffer()
+    {
+        // For ThreadCommands, we must consume everything before shutdown.
+        OVR_ASSERT(IsEmpty());
+        OVR_FREE_ALIGNED(pBuffer);
+    }
+
+    bool    IsEmpty() const { return (Head == Tail); }
+
+    // Allocates a state block of specified size and advances pointers,
+    // returning 0 if buffer is full.
+    uint8_t*  Write(size_t size);
+
+    // Returns a pointer to next available data block; 0 if none available.
+    uint8_t*  ReadBegin()
+    { return (Head != Tail) ? (pBuffer + Tail) : 0; }
+    // Consumes data of specified size; this must match size passed to Write.
+    void    ReadEnd(size_t size);
+};
+
+
+// Allocates a state block of specified size and advances pointers,
+// returning 0 if buffer is full.
+uint8_t* CircularBuffer::Write(size_t size)
+{
+    uint8_t* p = 0;
+
+    size = roundUpSize(size);
+    // Since this is circular buffer, always allow at least one item.
+    OVR_ASSERT(size < Size/2);
+
+    if (Head >= Tail)
+    {
+        OVR_ASSERT(End == 0);
+        
+        if (size <= (Size - Head))
+        {
+            p    = pBuffer + Head;
+            Head += size;
+        }
+        else if (size < Tail)
+        {
+            p    = pBuffer;
+            End  = Head;
+            Head = size;
+            OVR_ASSERT(Head != Tail);
+        }
+    }
+    else
+    {
+        OVR_ASSERT(End != 0);
+
+        if ((Tail - Head) > size)
+        {
+            p    = pBuffer + Head;
+            Head += size;
+            OVR_ASSERT(Head != Tail);
+        }
+    }
+
+    return p;
+}
+
+void CircularBuffer::ReadEnd(size_t size)
+{
+    OVR_ASSERT(Head != Tail);
+    size = roundUpSize(size);
+    
+    Tail += size;        
+    if (Tail == End)
+    {
+        Tail = End = 0;
+    }
+    else if (Tail == Head)
+    {        
+        OVR_ASSERT(End == 0);
+        Tail = Head = 0;
+    }
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadCommand
+
+ThreadCommand::PopBuffer::~PopBuffer()
+{
+	if (Size) {
+		Destruct<ThreadCommand>(toCommand());
+	}
+}
+
+void ThreadCommand::PopBuffer::InitFromBuffer(void* data)
+{
+    ThreadCommand* cmd = (ThreadCommand*)data;
+    OVR_ASSERT(cmd->Size <= MaxSize);
+
+	if (Size) {
+		Destruct<ThreadCommand>(toCommand());
+	}
+    Size = cmd->Size;    
+    memcpy(Buffer, (void*)cmd, Size);
+}
+
+void ThreadCommand::PopBuffer::Execute()
+{
+    ThreadCommand* command = toCommand();
+    OVR_ASSERT(command);
+    command->Execute();
+	if (NeedsWait()) {
+		GetEvent()->PulseEvent();
+	}
+}
+
+//-------------------------------------------------------------------------------------
+
+class ThreadCommandQueueImpl : public NewOverrideBase
+{
+    typedef ThreadCommand::NotifyEvent NotifyEvent;
+    friend class ThreadCommandQueue;
+    
+public:
+
+    ThreadCommandQueueImpl(ThreadCommandQueue* queue) :
+		pQueue(queue),
+		ExitEnqueued(false),
+		ExitProcessed(false),
+		CommandBuffer(2048),
+		PullThreadId(0)
+    {
+    }
+    ~ThreadCommandQueueImpl();
+
+
+    bool PushCommand(const ThreadCommand& command);
+    bool PopCommand(ThreadCommand::PopBuffer* popBuffer);
+
+
+    // ExitCommand is used by notify us that Thread is shutting down.
+    struct ExitCommand : public ThreadCommand
+    {
+        ThreadCommandQueueImpl* pImpl;
+        
+        ExitCommand(ThreadCommandQueueImpl* impl, bool wait)
+            : ThreadCommand(sizeof(ExitCommand), wait, true), pImpl(impl) { }
+
+        virtual void Execute() const
+        {
+            Lock::Locker lock(&pImpl->QueueLock);
+            pImpl->ExitProcessed = true;
+        }
+        virtual ThreadCommand* CopyConstruct(void* p) const 
+        { return Construct<ExitCommand>(p, *this); }
+    };
+
+
+    NotifyEvent* AllocNotifyEvent_NTS()
+    {
+        NotifyEvent* p = AvailableEvents.GetFirst();
+
+        if (!AvailableEvents.IsNull(p))
+            p->RemoveNode();        
+        else
+            p = new NotifyEvent;
+        return p;
+    }
+
+    void         FreeNotifyEvent_NTS(NotifyEvent* p)
+    {
+        AvailableEvents.PushBack(p);
+    }
+
+    void        FreeNotifyEvents_NTS()
+    {
+        while(!AvailableEvents.IsEmpty())
+        {
+            NotifyEvent* p = AvailableEvents.GetFirst();
+            p->RemoveNode();
+            delete p;
+        }
+    }
+
+    ThreadCommandQueue* pQueue;
+    Lock                QueueLock;
+    volatile bool       ExitEnqueued;
+    volatile bool       ExitProcessed;
+    List<NotifyEvent>   AvailableEvents;
+    List<NotifyEvent>   BlockedProducers;
+    CircularBuffer      CommandBuffer;
+
+	// The pull thread id is set to the last thread that pulled commands.
+	// Since this thread command queue is designed for a single thread,
+	// reentrant behavior that would cause a dead-lock for messages that
+	// wait for completion can be avoided by simply comparing the
+	// thread id of the last pull.
+	OVR::ThreadId		PullThreadId;
+};
+
+ThreadCommandQueueImpl::~ThreadCommandQueueImpl()
+{
+    Lock::Locker lock(&QueueLock);
+    OVR_ASSERT(BlockedProducers.IsEmpty());
+    FreeNotifyEvents_NTS();
+}
+
+bool ThreadCommandQueueImpl::PushCommand(const ThreadCommand& command)
+{
+	if (command.NeedsWait() && PullThreadId == OVR::GetCurrentThreadId())
+	{
+		command.Execute();
+		return true;
+	}
+
+    ThreadCommand::NotifyEvent* completeEvent = 0;
+    ThreadCommand::NotifyEvent* queueAvailableEvent = 0;
+
+    // Repeat  writing command into buffer until it is available.    
+	for (;;) {
+        { // Lock Scope
+            Lock::Locker lock(&QueueLock);
+
+            if (queueAvailableEvent) {
+                FreeNotifyEvent_NTS(queueAvailableEvent);
+                queueAvailableEvent = 0;
+            }
+
+            // Don't allow any commands after PushExitCommand() is called.
+			if (ExitEnqueued && !command.ExitFlag) {
+				return false;
+			}
+
+            bool bufferWasEmpty = CommandBuffer.IsEmpty();
+            uint8_t* buffer = CommandBuffer.Write(command.GetSize());
+
+			if (buffer) {
+                ThreadCommand* c = command.CopyConstruct(buffer);
+
+				if (c->NeedsWait()) {
+					completeEvent = c->pEvent = AllocNotifyEvent_NTS();
+				}
+
+				// Signal-waker consumer when we add data to buffer.
+				if (bufferWasEmpty) {
+					pQueue->OnPushNonEmpty_Locked();
+				}
+
+				break;
+            }
+
+            queueAvailableEvent = AllocNotifyEvent_NTS();
+            BlockedProducers.PushBack(queueAvailableEvent);
+        } // Lock Scope
+
+        queueAvailableEvent->Wait();
+    } // Intentional infinite loop
+
+    // Command was enqueued, wait if necessary.
+    if (completeEvent) {
+        completeEvent->Wait();
+        Lock::Locker lock(&QueueLock);
+        FreeNotifyEvent_NTS(completeEvent);
+    }
+
+    return true;
+}
+
+
+// Pops the next command from the thread queue, if any is available.
+bool ThreadCommandQueueImpl::PopCommand(ThreadCommand::PopBuffer* popBuffer)
+{    
+	PullThreadId = OVR::GetCurrentThreadId();
+
+	Lock::Locker lock(&QueueLock);
+
+    uint8_t* buffer = CommandBuffer.ReadBegin();
+    if (!buffer)
+    {
+        // Notify thread while in lock scope, enabling initialization of wait.
+        pQueue->OnPopEmpty_Locked();
+        return false;
+    }
+
+    popBuffer->InitFromBuffer(buffer);
+    CommandBuffer.ReadEnd(popBuffer->GetSize());
+
+    if (!BlockedProducers.IsEmpty())
+    {
+        ThreadCommand::NotifyEvent* queueAvailableEvent = BlockedProducers.GetFirst();
+        queueAvailableEvent->RemoveNode();
+        queueAvailableEvent->PulseEvent();
+        // Event is freed later by waiter.
+    }    
+    return true;
+}
+
+
+//-------------------------------------------------------------------------------------
+
+ThreadCommandQueue::ThreadCommandQueue()
+{
+    pImpl = new ThreadCommandQueueImpl(this);
+}
+ThreadCommandQueue::~ThreadCommandQueue()
+{
+    delete pImpl;
+}
+
+bool ThreadCommandQueue::PushCommand(const ThreadCommand& command)
+{
+    return pImpl->PushCommand(command);
+}
+
+bool ThreadCommandQueue::PopCommand(ThreadCommand::PopBuffer* popBuffer)
+{    
+    return pImpl->PopCommand(popBuffer);
+}
+
+void ThreadCommandQueue::PushExitCommand(bool wait)
+{
+    // Exit is processed in two stages:
+    //  - First, ExitEnqueued flag is set to block further commands from queuing up.
+    //  - Second, the actual exit call is processed on the consumer thread, flushing
+    //    any prior commands.
+    //    IsExiting() only returns true after exit has flushed.
+    {
+        Lock::Locker lock(&pImpl->QueueLock);
+        if (pImpl->ExitEnqueued)
+            return;
+        pImpl->ExitEnqueued = true;
+    }
+
+    PushCommand(ThreadCommandQueueImpl::ExitCommand(pImpl, wait));
+}
+
+bool ThreadCommandQueue::IsExiting() const
+{
+    return pImpl->ExitProcessed;
+}
+
+
+} // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,318 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_ThreadCommandQueue.h
+Content     :   Command queue for operations executed on a thread
+Created     :   October 29, 2012
+Author      :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_ThreadCommandQueue_h
+#define OVR_ThreadCommandQueue_h
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_List.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_Threads.h"
+
+namespace OVR {
+
+class ThreadCommand;
+class ThreadCommandQueue;
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadCommand
+
+// ThreadCommand is a base class implementation for commands stored in ThreadCommandQueue.
+class ThreadCommand
+{
+public:    
+    // NotifyEvent is used by ThreadCommandQueue::PushCallAndWait to notify the
+    // calling (producer)  thread when command is completed or queue slot is available.
+    class NotifyEvent : public ListNode<NotifyEvent>, public NewOverrideBase
+    {
+        Event E;
+    public:   
+        NotifyEvent() { }
+
+        void Wait()        { E.Wait(); }
+        void PulseEvent()  { E.PulseEvent(); }
+    };
+
+    // ThreadCommand::PopBuffer is temporary storage for a command popped off
+    // by ThreadCommandQueue::PopCommand. 
+    class PopBuffer
+    {
+        enum { MaxSize = 256 };
+
+        size_t Size;
+        union {            
+            uint8_t Buffer[MaxSize];
+            size_t Align;
+        };
+
+        ThreadCommand* toCommand() const { return (ThreadCommand*)Buffer; }
+
+    public:
+        PopBuffer() : Size(0) { }
+        ~PopBuffer();
+
+        void        InitFromBuffer(void* data);
+
+        bool        HasCommand() const  { return Size != 0; }
+        size_t      GetSize() const     { return Size; }
+        bool        NeedsWait() const   { return toCommand()->NeedsWait(); }
+        NotifyEvent* GetEvent() const   { return toCommand()->pEvent; }
+
+        // Execute the command and also notifies caller to finish waiting,
+        // if necessary.
+        void        Execute();
+    };
+    
+    uint16_t     Size;
+    bool         WaitFlag; 
+    bool         ExitFlag; // Marks the last exit command. 
+    NotifyEvent* pEvent;
+
+    ThreadCommand(size_t size, bool waitFlag, bool exitFlag = false)
+        : Size((uint16_t)size), WaitFlag(waitFlag), ExitFlag(exitFlag), pEvent(0) { }
+    virtual ~ThreadCommand() { }
+
+    bool          NeedsWait() const { return WaitFlag; }
+    size_t        GetSize() const   { return Size; }
+
+    virtual void            Execute() const = 0;
+    // Copy constructor used for serializing this to memory buffer.
+    virtual ThreadCommand*  CopyConstruct(void* p) const = 0;
+};
+
+
+//-------------------------------------------------------------------------------------
+
+// CleanType is a template that strips 'const' and '&' modifiers from the argument type;
+// for example, typename CleanType<A&>::Type is equivalent to A.
+template<class T> struct CleanType           { typedef T Type; };
+template<class T> struct CleanType<T&>       { typedef T Type; };
+template<class T> struct CleanType<const T>  { typedef T Type; };
+template<class T> struct CleanType<const T&> { typedef T Type; };
+
+// SelfType is a template that yields the argument type. This helps avoid conflicts with
+// automatic template argument deduction for function calls when identical argument
+// is already defined.
+template<class T> struct SelfType { typedef T Type; };
+
+
+
+//-------------------------------------------------------------------------------------
+// ThreadCommand specializations for member functions with different number of
+// arguments and argument types.
+
+// Used to return nothing from a ThreadCommand, to avoid problems with 'void'.
+struct Void
+{
+    Void() {}
+    Void(int) {}
+};
+
+// ThreadCommand for member function with 0 arguments.
+template<class C, class R>
+class ThreadCommandMF0 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)();
+    C*      pClass;
+    FnPtr   pFn;
+    R*      pRet;
+
+    void executeImpl() const
+    {
+        pRet ? (void)(*pRet = (pClass->*pFn)()) :
+	           (void)(pClass->*pFn)();
+    }
+
+public:    
+    ThreadCommandMF0(C* pclass, FnPtr fn, R* ret, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF0), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret) { }
+
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const
+    { return Construct<ThreadCommandMF0>(p, *this); }
+};
+
+
+// ThreadCommand for member function with 1 argument.
+template<class C, class R, class A0>
+class ThreadCommandMF1 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)(A0);
+    C*                           pClass;
+    FnPtr                        pFn;
+    R*                           pRet;
+    typename CleanType<A0>::Type AVal0;
+
+    void executeImpl() const
+    {
+      pRet ? (void)(*pRet = (pClass->*pFn)(AVal0)) :
+	         (void)(pClass->*pFn)(AVal0);
+    }
+
+public:    
+    ThreadCommandMF1(C* pclass, FnPtr fn, R* ret, A0 a0, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF1), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret), AVal0(a0) { }
+
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const
+    { return Construct<ThreadCommandMF1>(p, *this); }
+};
+
+// ThreadCommand for member function with 2 arguments.
+template<class C, class R, class A0, class A1>
+class ThreadCommandMF2 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)(A0, A1);
+    C*                            pClass;
+    FnPtr                         pFn;
+    R*                            pRet;
+    typename CleanType<A0>::Type  AVal0;
+    typename CleanType<A1>::Type  AVal1;
+
+    void executeImpl() const
+    {
+        pRet ? (void)(*pRet = (pClass->*pFn)(AVal0, AVal1)) :
+	           (void)(pClass->*pFn)(AVal0, AVal1);
+    }
+
+public:    
+    ThreadCommandMF2(C* pclass, FnPtr fn, R* ret, A0 a0, A1 a1, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF2), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret), AVal0(a0), AVal1(a1) { }
+    
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const 
+    { return Construct<ThreadCommandMF2>(p, *this); }
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadCommandQueue
+
+// ThreadCommandQueue is a queue of executable function-call commands intended to be
+// serviced by a single consumer thread. Commands are added to the queue with PushCall
+// and removed with PopCall; they are processed in FIFO order. Multiple producer threads
+// are supported and will be blocked if internal data buffer is full.
+
+class ThreadCommandQueue
+{
+public:
+
+    ThreadCommandQueue();
+    virtual ~ThreadCommandQueue();
+
+
+    // Pops the next command from the thread queue, if any is available.
+    // The command should be executed by calling popBuffer->Execute().
+    // Returns 'false' if no command is available at the time of the call.
+    bool PopCommand(ThreadCommand::PopBuffer* popBuffer);
+
+    // Generic implementaion of PushCommand; enqueues a command for execution.
+    // Returns 'false' if push failed, usually indicating thread shutdown.
+    bool PushCommand(const ThreadCommand& command);
+
+    // 
+    void PushExitCommand(bool wait);
+
+    // Returns 'true' once ExitCommand has been processed, so the thread can shut down.
+    bool IsExiting() const;
+
+
+    // These two virtual functions serve as notifications for derived
+    // thread waiting.    
+    virtual void OnPushNonEmpty_Locked() { }
+    virtual void OnPopEmpty_Locked()     { }
+
+
+    // *** PushCall with no result
+    
+    // Enqueue a member function of 'this' class to be called on consumer thread.
+    // By default the function returns immediately; set 'wait' argument to 'true' to
+    // wait for completion.
+    template<class C, class R>
+    bool PushCall(R (C::*fn)(), bool wait = false)
+    { return PushCommand(ThreadCommandMF0<C,R>(static_cast<C*>(this), fn, 0, wait)); }       
+    template<class C, class R, class A0>
+    bool PushCall(R (C::*fn)(A0), typename SelfType<A0>::Type a0, bool wait = false)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(static_cast<C*>(this), fn, 0, a0, wait)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCall(R (C::*fn)(A0, A1),
+                  typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1, bool wait = false)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(static_cast<C*>(this), fn, 0, a0, a1, wait)); }
+    // Enqueue a specified member function call of class C.
+    // By default the function returns immediately; set 'wait' argument to 'true' to
+    // wait for completion.
+    template<class C, class R>
+    bool PushCall(C* p, R (C::*fn)(), bool wait = false)
+    { return PushCommand(ThreadCommandMF0<C,R>(p, fn, 0, wait)); }
+    template<class C, class R, class A0>
+    bool PushCall(C* p, R (C::*fn)(A0), typename SelfType<A0>::Type a0, bool wait = false)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(p, fn, 0, a0, wait)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCall(C* p, R (C::*fn)(A0, A1),
+                  typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1, bool wait = false)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(p, fn, 0, a0, a1, wait)); }
+    
+    
+    // *** PushCall with Result
+
+    // Enqueue a member function of 'this' class call and wait for call to complete
+    // on consumer thread before returning.
+    template<class C, class R>
+    bool PushCallAndWaitResult(R (C::*fn)(), R* ret)
+    { return PushCommand(ThreadCommandMF0<C,R>(static_cast<C*>(this), fn, ret, true)); }       
+    template<class C, class R, class A0>
+    bool PushCallAndWaitResult(R (C::*fn)(A0), R* ret, typename SelfType<A0>::Type a0)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(static_cast<C*>(this), fn, ret, a0, true)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCallAndWaitResult(R (C::*fn)(A0, A1), R* ret,
+                               typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(static_cast<C*>(this), fn, ret, a0, a1, true)); }
+    // Enqueue a member function call for class C and wait for the call to complete
+    // on consumer thread before returning.
+    template<class C, class R>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(), R* ret)
+    { return PushCommand(ThreadCommandMF0<C,R>(p, fn, ret, true)); }
+    template<class C, class R, class A0>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(A0), R* ret, typename SelfType<A0>::Type a0)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(p, fn, ret, a0, true)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(A0, A1), R* ret,
+                               typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(p, fn, ret, a0, a1, true)); }
+
+private:
+    class ThreadCommandQueueImpl* pImpl;
+};
+
+
+} // namespace OVR
+
+#endif // OVR_ThreadCommandQueue_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Threads.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Threads.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,406 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Threads.h
+Content     :   Contains thread-related (safe) functionality
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_Threads_h
+#define OVR_Threads_h
+
+#include "OVR_Types.h"
+#include "OVR_Atomic.h"
+#include "OVR_RefCount.h"
+#include "OVR_Array.h"
+
+// Defines the infinite wait delay timeout
+#define OVR_WAIT_INFINITE 0xFFFFFFFF
+
+// To be defined in the project configuration options
+#ifdef OVR_ENABLE_THREADS
+
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ****** Declared classes
+
+// Declared with thread support only
+class   Mutex;
+class   WaitCondition;
+class   Event;
+// Implementation forward declarations
+class MutexImpl;
+class WaitConditionImpl;
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Mutex
+
+// Mutex class represents a system Mutex synchronization object that provides access 
+// serialization between different threads, allowing one thread mutually exclusive access 
+// to a resource. Mutex is more heavy-weight then Lock, but supports WaitCondition.
+
+class Mutex
+{
+    friend class WaitConditionImpl;    
+    friend class MutexImpl;
+
+    MutexImpl  *pImpl; 
+
+public:
+    // Constructor/destructor
+    Mutex(bool recursive = 1);
+    ~Mutex();
+
+    // Locking functions
+    void  DoLock();
+    bool  TryLock();
+    void  Unlock();
+
+    // Returns 1 if the mutes is currently locked by another thread
+    // Returns 0 if the mutex is not locked by another thread, and can therefore be acquired. 
+    bool  IsLockedByAnotherThread();
+    
+    // Locker class; Used for automatic locking of a mutex withing scope    
+    class Locker
+    {
+    public:
+        Mutex *pMutex;
+        Locker(Mutex *pmutex)
+            { pMutex = pmutex; pMutex->DoLock(); }
+        ~Locker()
+            { pMutex->Unlock(); }
+    };
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** WaitCondition
+
+/*
+    WaitCondition is a synchronization primitive that can be used to implement what is known as a monitor.
+    Dependent threads wait on a wait condition by calling Wait(), and get woken up by other threads that
+    call Notify() or NotifyAll().
+
+    The unique feature of this class is that it provides an atomic way of first releasing a Mutex, and then 
+    starting a wait on a wait condition. If both the mutex and the wait condition are associated with the same
+    resource, this ensures that any condition checked for while the mutex was locked does not change before
+    the wait on the condition is actually initiated.
+*/
+
+class WaitCondition
+{
+    friend class WaitConditionImpl;
+    // Internal implementation structure
+    WaitConditionImpl *pImpl;
+
+public:
+    // Constructor/destructor
+    WaitCondition();
+    ~WaitCondition();
+
+    // Release mutex and wait for condition. The mutex is re-aquired after the wait.
+    // Delay is specified in milliseconds (1/1000 of a second).
+    bool    Wait(Mutex *pmutex, unsigned delay = OVR_WAIT_INFINITE);
+
+    // Notify a condition, releasing at one object waiting
+    void    Notify();
+    // Notify a condition, releasing all objects waiting
+    void    NotifyAll();
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Event
+
+// Event is a wait-able synchronization object similar to Windows event.
+// Event can be waited on until it's signaled by another thread calling
+// either SetEvent or PulseEvent.
+
+class Event
+{
+    // Event state, its mutex and the wait condition
+    volatile bool   State;
+    volatile bool   Temporary;  
+    mutable Mutex   StateMutex;
+    WaitCondition   StateWaitCondition;
+
+    void updateState(bool newState, bool newTemp, bool mustNotify);
+
+public:    
+    Event(bool setInitially = 0) : State(setInitially), Temporary(false) { }
+    ~Event() { }
+
+    // Wait on an event condition until it is set
+    // Delay is specified in milliseconds (1/1000 of a second).
+    bool  Wait(unsigned delay = OVR_WAIT_INFINITE);
+    
+    // Set an event, releasing objects waiting on it
+    void  SetEvent()
+    { updateState(true, false, true); }
+
+    // Reset an event, un-signaling it
+    void  ResetEvent()
+    { updateState(false, false, false); }
+
+    // Set and then reset an event once a waiter is released.
+    // If threads are already waiting, they will be notified and released
+    // If threads are not waiting, the event is set until the first thread comes in
+    void  PulseEvent()
+    { updateState(true, true, true); }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Thread class
+
+// ThreadId uniquely identifies a thread; returned by GetCurrentThreadId() and
+// Thread::GetThreadId.
+typedef void* ThreadId;
+
+
+// *** Thread flags
+
+// Indicates that the thread is has been started, i.e. Start method has been called, and threads
+// OnExit() method has not yet been called/returned.
+#define OVR_THREAD_STARTED               0x01
+// This flag is set once the thread has ran, and finished.
+#define OVR_THREAD_FINISHED              0x02
+// This flag is set temporarily if this thread was started suspended. It is used internally.
+#define OVR_THREAD_START_SUSPENDED       0x08
+// This flag is used to ask a thread to exit. Message driven threads will usually check this flag
+// and finish once it is set.
+#define OVR_THREAD_EXIT                  0x10
+
+
+class Thread : public RefCountBase<Thread>
+{ // NOTE: Waitable must be the first base since it implements RefCountImpl.    
+public:
+    // *** Callback functions, can be used instead of overriding Run
+
+    // Run function prototypes.    
+    // Thread function and user handle passed to it, executed by the default
+    // Thread::Run implementation if not null.
+    typedef int (*ThreadFn)(Thread *pthread, void* h);
+    
+    // Thread ThreadFunction1 is executed if not 0, otherwise ThreadFunction2 is tried
+    ThreadFn    ThreadFunction;    
+    // User handle passes to a thread
+    void*       UserHandle;
+
+    // Thread state to start a thread with
+    enum ThreadState
+    {
+        NotRunning  = 0,
+        Running     = 1,
+        Suspended   = 2
+    };
+
+    // Thread priority
+    enum ThreadPriority
+    {
+        CriticalPriority,
+        HighestPriority,
+        AboveNormalPriority,
+        NormalPriority,
+        BelowNormalPriority,
+        LowestPriority,
+        IdlePriority,
+    };
+
+    // Thread constructor parameters
+    struct CreateParams
+    {
+        CreateParams(ThreadFn func = 0, void* hand = 0, size_t ssize = 128 * 1024, 
+                     int proc = -1, ThreadState state = NotRunning, ThreadPriority prior = NormalPriority)
+                     : threadFunction(func), userHandle(hand), stackSize(ssize), 
+                       processor(proc), initialState(state), priority(prior) {}
+        ThreadFn       threadFunction;   // Thread function
+        void*          userHandle;       // User handle passes to a thread
+        size_t         stackSize;        // Thread stack size
+        int            processor;        // Thread hardware processor
+        ThreadState    initialState;     // 
+        ThreadPriority priority;         // Thread priority
+    };
+
+
+    // *** Constructors
+
+    // A default constructor always creates a thread in NotRunning state, because
+    // the derived class has not yet been initialized. The derived class can call Start explicitly.
+    // "processor" parameter specifies which hardware processor this thread will be run on. 
+    // -1 means OS decides this. Implemented only on Win32
+    Thread(size_t stackSize = 128 * 1024, int processor = -1);
+    // Constructors that initialize the thread with a pointer to function.
+    // An option to start a thread is available, but it should not be used if classes are derived from Thread.
+    // "processor" parameter specifies which hardware processor this thread will be run on. 
+    // -1 means OS decides this. Implemented only on Win32
+    Thread(ThreadFn threadFunction, void*  userHandle = 0, size_t stackSize = 128 * 1024,
+           int processor = -1, ThreadState initialState = NotRunning);
+    // Constructors that initialize the thread with a create parameters structure.
+    explicit Thread(const CreateParams& params);
+
+    // Destructor.
+    virtual ~Thread();
+
+    // Waits for all Threads to finish; should be called only from the root
+    // application thread. Once this function returns, we know that all other
+    // thread's references to Thread object have been released.
+    static  void OVR_CDECL FinishAllThreads();
+
+
+    // *** Overridable Run function for thread processing
+
+    // - returning from this method will end the execution of the thread
+    // - return value is usually 0 for success 
+    virtual int   Run();
+    // Called after return/exit function
+    virtual void  OnExit();
+
+
+    // *** Thread management
+
+    // Starts the thread if its not already running
+    // - internally sets up the threading and calls Run()
+    // - initial state can either be Running or Suspended, NotRunning will just fail and do nothing
+    // - returns the exit code
+    virtual bool  Start(ThreadState initialState = Running);
+
+    // Quits with an exit code
+    virtual void  Exit(int exitCode=0);
+
+    // Suspend the thread until resumed
+    // Returns 1 for success, 0 for failure.
+    bool  Suspend();
+    // Resumes currently suspended thread
+    // Returns 1 for success, 0 for failure.
+    bool  Resume();
+
+    // Static function to return a pointer to the current thread
+    //static Thread* GetThread();
+
+
+    // *** Thread status query functions
+
+    bool          GetExitFlag() const;
+    void          SetExitFlag(bool exitFlag);
+
+    // Determines whether the thread was running and is now finished
+    bool          IsFinished() const;
+    // Determines if the thread is currently suspended
+    bool          IsSuspended() const;
+    // Returns current thread state
+    ThreadState   GetThreadState() const;
+
+    // Wait for thread to finish for a maxmimum number of milliseconds
+    // For maxWaitMs = 0 it simply polls and then returns if the thread is not finished
+    // For maxWaitMs < 0 it will wait forever
+    bool          Join(int maxWaitMs = -1) const;
+
+    // Returns the number of available CPUs on the system 
+    static int    GetCPUCount();
+
+    // Returns the thread exit code. Exit code is initialized to 0,
+    // and set to the return value if Run function after the thread is finished.
+    inline int    GetExitCode() const { return ExitCode; }
+    // Returns an OS handle 
+#if defined(OVR_OS_WIN32) 
+    void*          GetOSHandle() const { return ThreadHandle; }
+#else
+    pthread_t      GetOSHandle() const { return ThreadHandle; }
+#endif
+
+#if defined(OVR_OS_WIN32) 
+    ThreadId       GetThreadId() const { return IdValue; }
+#else
+    ThreadId       GetThreadId() const { return (ThreadId)GetOSHandle(); }
+#endif
+
+    static int      GetOSPriority(ThreadPriority);
+    // *** Sleep
+
+    // Sleep secs seconds
+    static bool    Sleep(unsigned secs);
+    // Sleep msecs milliseconds
+    static bool    MSleep(unsigned msecs);
+
+
+    // *** Debugging functionality
+    virtual void    SetThreadName( const char* name );
+
+private:
+#if defined(OVR_OS_WIN32)
+    friend unsigned WINAPI Thread_Win32StartFn(void *phandle);
+#else
+    friend void *Thread_PthreadStartFn(void * phandle);
+
+    static int            InitAttr;
+    static pthread_attr_t Attr;
+#endif
+
+protected:    
+    // Thread state flags
+    AtomicInt<uint32_t>   ThreadFlags;
+    AtomicInt<int32_t>   SuspendCount;
+    size_t              StackSize;
+
+    // Hardware processor which this thread is running on.
+    int            Processor;
+    ThreadPriority Priority;
+
+#if defined(OVR_OS_WIN32) 
+    void*               ThreadHandle;
+    volatile ThreadId   IdValue;
+
+    // System-specific cleanup function called from destructor
+    void                CleanupSystemThread();
+
+#else
+    pthread_t           ThreadHandle;
+#endif
+
+    // Exit code of the thread, as returned by Run.
+    int                 ExitCode;
+
+    // Internal run function.
+    int                 PRun();    
+    // Finishes the thread and releases internal reference to it.
+    void                FinishAndRelease();
+
+    void                Init(const CreateParams& params);
+
+    // Protected copy constructor
+    Thread(const Thread &source) : RefCountBase<Thread>() { OVR_UNUSED(source); }
+
+};
+
+// Returns the unique Id of a thread it is called on, intended for
+// comparison purposes.
+ThreadId GetCurrentThreadId();
+
+
+} // OVR
+
+#endif // OVR_ENABLE_THREADS
+#endif // OVR_Threads_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadsWinAPI.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadsWinAPI.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1041 @@
+/************************************************************************************
+
+Filename    :   OVR_ThreadsWinAPI.cpp
+Platform    :   WinAPI
+Content     :   Windows specific thread-related (safe) functionality
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Threads.h"
+#include "OVR_Hash.h"
+#include "OVR_Log.h"
+#include "OVR_Timer.h"
+
+#ifdef OVR_ENABLE_THREADS
+
+// For _beginthreadex / _endtheadex
+#include <process.h>
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------------
+// *** Internal Mutex implementation class
+
+class MutexImpl : public NewOverrideBase
+{
+    // System mutex or semaphore
+    HANDLE            hMutexOrSemaphore;
+    bool              Recursive;
+    volatile unsigned LockCount;
+    
+    friend class WaitConditionImpl;
+
+public:
+    // Constructor/destructor
+    MutexImpl(bool recursive = 1);
+    ~MutexImpl();
+
+    // Locking functions
+    void                DoLock();
+    bool                TryLock();
+    void                Unlock(Mutex* pmutex);
+    // Returns 1 if the mutes is currently locked
+    bool                IsLockedByAnotherThread(Mutex* pmutex);
+};
+
+// *** Constructor/destructor
+MutexImpl::MutexImpl(bool recursive)
+{    
+    Recursive                   = recursive;
+    LockCount                   = 0;
+    hMutexOrSemaphore           = Recursive ? CreateMutex(NULL, 0, NULL) : CreateSemaphore(NULL, 1, 1, NULL);
+}
+MutexImpl::~MutexImpl()
+{
+    CloseHandle(hMutexOrSemaphore);
+}
+
+
+// Lock and try lock
+void MutexImpl::DoLock()
+{
+    if (::WaitForSingleObject(hMutexOrSemaphore, INFINITE) != WAIT_OBJECT_0)
+        return;
+    LockCount++;
+}
+
+bool MutexImpl::TryLock()
+{
+    DWORD ret;
+    if ((ret=::WaitForSingleObject(hMutexOrSemaphore, 0)) != WAIT_OBJECT_0)
+        return 0;
+    LockCount++;
+    return 1;
+}
+
+void MutexImpl::Unlock(Mutex* pmutex)
+{
+    OVR_UNUSED(pmutex);
+
+    unsigned lockCount;
+    LockCount--;
+    lockCount = LockCount;
+
+    // Release mutex
+    if ((Recursive ? ReleaseMutex(hMutexOrSemaphore) :
+                     ReleaseSemaphore(hMutexOrSemaphore, 1, NULL))  != 0)
+    {
+        // This used to call Wait handlers if lockCount == 0.
+    }
+}
+
+bool MutexImpl::IsLockedByAnotherThread(Mutex* pmutex)
+{
+    // There could be multiple interpretations of IsLocked with respect to current thread
+    if (LockCount == 0)
+        return 0;
+    if (!TryLock())
+        return 1;
+    Unlock(pmutex);
+    return 0;
+}
+
+/*
+bool    MutexImpl::IsSignaled() const
+{
+    // An mutex is signaled if it is not locked ANYWHERE
+    // Note that this is different from IsLockedByAnotherThread function,
+    // that takes current thread into account
+    return LockCount == 0;
+}
+*/
+
+
+// *** Actual Mutex class implementation
+
+Mutex::Mutex(bool recursive)
+{    
+    pImpl = new MutexImpl(recursive);
+}
+Mutex::~Mutex()
+{
+    delete pImpl;
+}
+
+// Lock and try lock
+void Mutex::DoLock()
+{
+    pImpl->DoLock();
+}
+bool Mutex::TryLock()
+{
+    return pImpl->TryLock();
+}
+void Mutex::Unlock()
+{
+    pImpl->Unlock(this);
+}
+bool Mutex::IsLockedByAnotherThread()
+{
+    return pImpl->IsLockedByAnotherThread(this);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Event
+
+bool Event::Wait(unsigned delay)
+{
+    Mutex::Locker lock(&StateMutex);
+
+    // Do the correct amount of waiting
+    if (delay == OVR_WAIT_INFINITE)
+    {
+        while(!State)
+            StateWaitCondition.Wait(&StateMutex);
+    }
+    else if (delay)
+    {
+        if (!State)
+            StateWaitCondition.Wait(&StateMutex, delay);
+    }
+
+    bool state = State;
+    // Take care of temporary 'pulsing' of a state
+    if (Temporary)
+    {
+        Temporary   = false;
+        State       = false;
+    }
+    return state;
+}
+
+void Event::updateState(bool newState, bool newTemp, bool mustNotify)
+{
+    Mutex::Locker lock(&StateMutex);
+    State       = newState;
+    Temporary   = newTemp;
+    if (mustNotify)
+        StateWaitCondition.NotifyAll();    
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** Win32 Wait Condition Implementation
+
+// Internal implementation class
+class WaitConditionImpl : public NewOverrideBase
+{   
+    // Event pool entries for extra events
+    struct EventPoolEntry  : public NewOverrideBase
+    {
+        HANDLE          hEvent;
+        EventPoolEntry  *pNext;
+        EventPoolEntry  *pPrev;
+    };
+    
+    Lock                WaitQueueLoc;
+    // Stores free events that can be used later
+    EventPoolEntry  *   pFreeEventList;
+    
+    // A queue of waiting objects to be signaled    
+    EventPoolEntry*     pQueueHead;
+    EventPoolEntry*     pQueueTail;
+
+    // Allocation functions for free events
+    EventPoolEntry*     GetNewEvent();
+    void                ReleaseEvent(EventPoolEntry* pevent);
+
+    // Queue operations
+    void                QueuePush(EventPoolEntry* pentry);
+    EventPoolEntry*     QueuePop();
+    void                QueueFindAndRemove(EventPoolEntry* pentry);
+
+public:
+
+    // Constructor/destructor
+    WaitConditionImpl();
+    ~WaitConditionImpl();
+
+    // Release mutex and wait for condition. The mutex is re-acqured after the wait.
+    bool    Wait(Mutex *pmutex, unsigned delay = OVR_WAIT_INFINITE);
+
+    // Notify a condition, releasing at one object waiting
+    void    Notify();
+    // Notify a condition, releasing all objects waiting
+    void    NotifyAll();
+};
+
+
+
+WaitConditionImpl::WaitConditionImpl()
+{
+    pFreeEventList  = 0;
+    pQueueHead      =
+    pQueueTail      = 0;
+}
+
+WaitConditionImpl::~WaitConditionImpl()
+{
+    // Free all the resources
+    EventPoolEntry* p       = pFreeEventList;
+    EventPoolEntry* pentry;
+
+    while(p)
+    {
+        // Move to next
+        pentry = p;
+        p = p->pNext;
+        // Delete old
+        ::CloseHandle(pentry->hEvent);
+        delete pentry;  
+    }   
+    // Shouldn't we also consider the queue?
+
+    // To be safe
+    pFreeEventList  = 0;
+    pQueueHead      =
+    pQueueTail      = 0;
+}
+
+
+// Allocation functions for free events
+WaitConditionImpl::EventPoolEntry* WaitConditionImpl::GetNewEvent()
+{
+    EventPoolEntry* pentry;
+
+    // If there are any free nodes, use them
+    if (pFreeEventList)
+    {
+        pentry          = pFreeEventList;
+        pFreeEventList  = pFreeEventList->pNext;        
+    }
+    else
+    {
+        // Allocate a new node
+        pentry          = new EventPoolEntry;
+        pentry->pNext   = 0;
+        pentry->pPrev   = 0;
+        // Non-signaled manual event
+        pentry->hEvent  = ::CreateEvent(NULL, TRUE, 0, NULL);
+    }
+    
+    return pentry;
+}
+
+void WaitConditionImpl::ReleaseEvent(EventPoolEntry* pevent)
+{
+    // Mark event as non-signaled
+    ::ResetEvent(pevent->hEvent);
+    // And add it to free pool
+    pevent->pNext   = pFreeEventList;
+    pevent->pPrev   = 0;
+    pFreeEventList  = pevent;
+}
+
+// Queue operations
+void WaitConditionImpl::QueuePush(EventPoolEntry* pentry)
+{
+    // Items already exist? Just add to tail
+    if (pQueueTail)
+    {
+        pentry->pPrev       = pQueueTail;
+        pQueueTail->pNext   = pentry;
+        pentry->pNext       = 0;        
+        pQueueTail          = pentry;       
+    }
+    else
+    {
+        // No items in queue
+        pentry->pNext   = 
+        pentry->pPrev   = 0;
+        pQueueHead      =
+        pQueueTail      = pentry;
+    }
+}
+
+WaitConditionImpl::EventPoolEntry* WaitConditionImpl::QueuePop()
+{
+    EventPoolEntry* pentry = pQueueHead;
+
+    // No items, null pointer
+    if (pentry)
+    {
+        // More items after this one? just grab the first item
+        if (pQueueHead->pNext)
+        {       
+            pQueueHead  = pentry->pNext;
+            pQueueHead->pPrev = 0;      
+        }
+        else
+        {
+            // Last item left
+            pQueueTail =
+            pQueueHead = 0;
+        }
+    }   
+    return pentry;
+}
+
+void WaitConditionImpl::QueueFindAndRemove(EventPoolEntry* pentry)
+{
+    // Do an exhaustive search looking for an entry
+    EventPoolEntry* p = pQueueHead;
+
+    while(p)
+    {
+        // Entry found? Remove.
+        if (p == pentry)
+        {
+            
+            // Remove the node form the list
+            // Prev link
+            if (pentry->pPrev)
+                pentry->pPrev->pNext = pentry->pNext;
+            else
+                pQueueHead = pentry->pNext;
+            // Next link
+            if (pentry->pNext)
+                pentry->pNext->pPrev = pentry->pPrev;
+            else
+                pQueueTail = pentry->pPrev;
+            // Done
+            return;
+        }
+
+        // Move to next item
+        p = p->pNext;
+    }
+}
+    
+
+bool WaitConditionImpl::Wait(Mutex *pmutex, unsigned delay)
+{
+    bool            result = 0;
+    unsigned        i;
+    unsigned        lockCount = pmutex->pImpl->LockCount;
+    EventPoolEntry* pentry;
+
+    // Mutex must have been locked
+    if (lockCount == 0)
+        return 0;
+    
+    // Add an object to the wait queue
+    WaitQueueLoc.DoLock();
+    QueuePush(pentry = GetNewEvent());
+    WaitQueueLoc.Unlock();
+
+    // Finally, release a mutex or semaphore
+    if (pmutex->pImpl->Recursive)
+    {
+        // Release the recursive mutex N times
+        pmutex->pImpl->LockCount = 0;
+        for(i=0; i<lockCount; i++)
+            ::ReleaseMutex(pmutex->pImpl->hMutexOrSemaphore);
+    }
+    else
+    {
+        pmutex->pImpl->LockCount = 0;
+        ::ReleaseSemaphore(pmutex->pImpl->hMutexOrSemaphore, 1, NULL);
+    }
+
+    // Note that there is a gap here between mutex.Unlock() and Wait(). However,
+    // if notify() comes in at this point in the other thread it will set our
+    // corresponding event so wait will just fall through, as expected.
+
+    // Block and wait on the event
+    DWORD waitResult = ::WaitForSingleObject(pentry->hEvent,
+                            (delay == OVR_WAIT_INFINITE) ? INFINITE : delay);
+    /*
+repeat_wait:
+    DWORD waitResult =
+
+    ::MsgWaitForMultipleObjects(1, &pentry->hEvent, FALSE,
+                                (delay == OVR_WAIT_INFINITE) ? INFINITE : delay,
+                                QS_ALLINPUT);
+    */
+
+    WaitQueueLoc.DoLock();
+    switch(waitResult)
+    {
+        case WAIT_ABANDONED:
+        case WAIT_OBJECT_0: 
+            result = 1;
+            // Wait was successful, therefore the event entry should already be removed
+            // So just add entry back to a free list
+            ReleaseEvent(pentry);
+            break;
+            /*
+        case WAIT_OBJECT_0 + 1:
+            // Messages in WINDOWS queue
+            {
+                MSG msg;
+                PeekMessage(&msg, NULL, 0U, 0U, PM_NOREMOVE);             
+                WaitQueueLoc.Unlock();
+                goto repeat_wait;
+            }
+            break; */
+        default:
+            // Timeout, our entry should still be in a queue
+            QueueFindAndRemove(pentry);
+            ReleaseEvent(pentry);
+    }
+    WaitQueueLoc.Unlock();
+
+    // Re-aquire the mutex
+    for(i=0; i<lockCount; i++)
+        pmutex->DoLock(); 
+
+    // Return the result
+    return result;
+}
+
+// Notify a condition, releasing the least object in a queue
+void WaitConditionImpl::Notify()
+{
+    Lock::Locker   lock(&WaitQueueLoc);
+    
+    // Pop last entry & signal it
+    EventPoolEntry* pentry = QueuePop();    
+    if (pentry)
+        ::SetEvent(pentry->hEvent); 
+}
+
+// Notify a condition, releasing all objects waiting
+void WaitConditionImpl::NotifyAll()
+{
+    Lock::Locker   lock(&WaitQueueLoc);
+
+    // Pop and signal all events
+    // NOTE : There is no need to release the events, it's the waiters job to do so 
+    EventPoolEntry* pentry = QueuePop();
+    while (pentry)
+    {
+        ::SetEvent(pentry->hEvent);
+        pentry = QueuePop();
+    }
+}
+
+
+
+// *** Actual implementation of WaitCondition
+
+WaitCondition::WaitCondition()
+{
+    pImpl = new WaitConditionImpl;
+}
+WaitCondition::~WaitCondition()
+{
+    delete pImpl;
+}
+    
+// Wait without a mutex
+bool    WaitCondition::Wait(Mutex *pmutex, unsigned delay)
+{
+    return pImpl->Wait(pmutex, delay);
+}
+// Notification
+void    WaitCondition::Notify()
+{
+    pImpl->Notify();
+}
+void    WaitCondition::NotifyAll()
+{
+    pImpl->NotifyAll();
+}
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Thread Class
+
+//  Per-thread variable
+//  MA: Don't use TLS for now - portability issues with DLLs, etc.
+/*
+#if !defined(OVR_CC_MSVC) || (OVR_CC_MSVC < 1300)
+__declspec(thread)  Thread*    pCurrentThread      = 0;
+#else
+#pragma data_seg(".tls$")
+__declspec(thread)  Thread*    pCurrentThread      = 0;
+#pragma data_seg(".rwdata")
+#endif
+*/
+
+// *** Thread constructors.
+
+Thread::Thread(size_t stackSize, int processor)
+{    
+    CreateParams params;
+    params.stackSize = stackSize;
+    params.processor = processor;
+    Init(params);
+}
+
+Thread::Thread(Thread::ThreadFn threadFunction, void*  userHandle, size_t stackSize, 
+                 int processor, Thread::ThreadState initialState)
+{
+    CreateParams params(threadFunction, userHandle, stackSize, processor, initialState);
+    Init(params);
+}
+
+Thread::Thread(const CreateParams& params)
+{
+    Init(params);
+}
+void Thread::Init(const CreateParams& params)
+{
+    // Clear the variables    
+    ThreadFlags     = 0;
+    ThreadHandle    = 0;
+    IdValue         = 0;
+    ExitCode        = 0;
+    SuspendCount    = 0;
+    StackSize       = params.stackSize;
+    Processor       = params.processor;
+    Priority        = params.priority;
+
+    // Clear Function pointers
+    ThreadFunction  = params.threadFunction;
+    UserHandle      = params.userHandle;
+    if (params.initialState != NotRunning)
+        Start(params.initialState);
+
+}
+
+Thread::~Thread()
+{
+    // Thread should not running while object is being destroyed,
+    // this would indicate ref-counting issue.
+    //OVR_ASSERT(IsRunning() == 0);
+  
+    // Clean up thread.    
+    CleanupSystemThread();
+    ThreadHandle = 0;
+}
+
+
+// *** Overridable User functions.
+
+// Default Run implementation
+int Thread::Run()
+{
+	if (!ThreadFunction)
+		return 0;
+
+	int ret = ThreadFunction(this, UserHandle);
+
+	return ret;
+}
+
+void Thread::OnExit()
+{   
+}
+
+// Finishes the thread and releases internal reference to it.
+void Thread::FinishAndRelease()
+{
+    // Note: thread must be US.
+    ThreadFlags &= (uint32_t)~(OVR_THREAD_STARTED);
+    ThreadFlags |= OVR_THREAD_FINISHED;
+
+    // Release our reference; this is equivalent to 'delete this'
+    // from the point of view of our thread.
+    Release();
+}
+
+
+// *** ThreadList - used to tack all created threads
+
+class ThreadList : public NewOverrideBase
+{
+    //------------------------------------------------------------------------
+    struct ThreadHashOp
+    {
+        size_t operator()(const Thread* ptr)
+        {
+            return (((size_t)ptr) >> 6) ^ (size_t)ptr;
+        }
+    };
+
+    HashSet<Thread*, ThreadHashOp>  ThreadSet;
+    Mutex                           ThreadMutex;
+    WaitCondition                   ThreadsEmpty;
+    // Track the root thread that created us.
+    ThreadId                        RootThreadId;
+
+    static ThreadList* volatile pRunningThreads;
+
+    void addThread(Thread *pthread)
+    {
+         Mutex::Locker lock(&ThreadMutex);
+         ThreadSet.Add(pthread);
+    }
+
+    void removeThread(Thread *pthread)
+    {
+        Mutex::Locker lock(&ThreadMutex);
+        ThreadSet.Remove(pthread);
+        if (ThreadSet.GetSize() == 0)
+            ThreadsEmpty.Notify();
+    }
+
+    void finishAllThreads()
+    {
+        // Only original root thread can call this.
+        OVR_ASSERT(GetCurrentThreadId() == RootThreadId);
+
+        Mutex::Locker lock(&ThreadMutex);
+        while (ThreadSet.GetSize() != 0)
+            ThreadsEmpty.Wait(&ThreadMutex);
+    }
+
+public:
+
+    ThreadList()
+    {
+        RootThreadId = GetCurrentThreadId();
+    }
+    ~ThreadList() { }
+
+
+    static void AddRunningThread(Thread *pthread)
+    {
+        // Non-atomic creation ok since only the root thread
+        if (!pRunningThreads)
+        {
+            pRunningThreads = new ThreadList;
+            OVR_ASSERT(pRunningThreads);
+        }
+        pRunningThreads->addThread(pthread);
+    }
+
+    // NOTE: 'pthread' might be a dead pointer when this is
+    // called so it should not be accessed; it is only used
+    // for removal.
+    static void RemoveRunningThread(Thread *pthread)
+    {
+        OVR_ASSERT(pRunningThreads);        
+        pRunningThreads->removeThread(pthread);
+    }
+
+    static void FinishAllThreads()
+    {
+        // This is ok because only root thread can wait for other thread finish.
+        if (pRunningThreads)
+        {           
+            pRunningThreads->finishAllThreads();
+            delete pRunningThreads;
+            pRunningThreads = 0;
+        }        
+    }
+};
+
+// By default, we have no thread list.
+ThreadList* volatile ThreadList::pRunningThreads = 0;
+
+
+// FinishAllThreads - exposed publicly in Thread.
+void Thread::FinishAllThreads()
+{
+    ThreadList::FinishAllThreads();
+}
+
+
+// *** Run override
+
+int Thread::PRun()
+{
+    // Suspend us on start, if requested
+    if (ThreadFlags & OVR_THREAD_START_SUSPENDED)
+    {
+        Suspend();
+        ThreadFlags &= (uint32_t)~OVR_THREAD_START_SUSPENDED;
+    }
+
+    // Call the virtual run function
+    ExitCode = Run();    
+
+    return ExitCode;
+}
+
+
+
+/* MA: Don't use TLS for now.
+
+// Static function to return a pointer to the current thread
+void    Thread::InitCurrentThread(Thread *pthread)
+{
+    pCurrentThread = pthread;
+}
+
+// Static function to return a pointer to the current thread
+Thread*    Thread::GetThread()
+{
+    return pCurrentThread;
+}
+*/
+
+
+// *** User overridables
+
+bool    Thread::GetExitFlag() const
+{
+    return (ThreadFlags & OVR_THREAD_EXIT) != 0;
+}       
+
+void    Thread::SetExitFlag(bool exitFlag)
+{
+    // The below is atomic since ThreadFlags is AtomicInt.
+    if (exitFlag)
+        ThreadFlags |= OVR_THREAD_EXIT;
+    else
+        ThreadFlags &= (uint32_t) ~OVR_THREAD_EXIT;
+}
+
+
+// Determines whether the thread was running and is now finished
+bool    Thread::IsFinished() const
+{
+    return (ThreadFlags & OVR_THREAD_FINISHED) != 0;
+}
+// Determines whether the thread is suspended
+bool    Thread::IsSuspended() const
+{   
+    return SuspendCount > 0;
+}
+// Returns current thread state
+Thread::ThreadState Thread::GetThreadState() const
+{
+    if (IsSuspended())
+        return Suspended;
+    if (ThreadFlags & OVR_THREAD_STARTED)
+        return Running;
+    return NotRunning;
+}
+// Join thread
+bool Thread::Join(int maxWaitMs) const
+{
+    // If polling,
+    if (maxWaitMs == 0)
+    {
+        // Just return if finished
+        return IsFinished();
+    }
+    // If waiting forever,
+    else if (maxWaitMs > 0)
+    {
+        // Try waiting once
+        WaitForSingleObject(ThreadHandle, maxWaitMs);
+
+        // Return if the wait succeeded
+        return IsFinished();
+    }
+
+    // While not finished,
+    while (!IsFinished())
+    {
+        // Wait for the thread handle to signal
+        WaitForSingleObject(ThreadHandle, INFINITE);
+    }
+
+    return true;
+}
+
+
+// ***** Thread management
+/* static */
+int Thread::GetOSPriority(ThreadPriority p)
+{
+    switch(p)
+    {
+    case Thread::CriticalPriority:      return THREAD_PRIORITY_TIME_CRITICAL;
+    case Thread::HighestPriority:       return THREAD_PRIORITY_HIGHEST;
+    case Thread::AboveNormalPriority:   return THREAD_PRIORITY_ABOVE_NORMAL;
+    case Thread::NormalPriority:        return THREAD_PRIORITY_NORMAL;
+    case Thread::BelowNormalPriority:   return THREAD_PRIORITY_BELOW_NORMAL;
+    case Thread::LowestPriority:        return THREAD_PRIORITY_LOWEST;
+    case Thread::IdlePriority:          return THREAD_PRIORITY_IDLE;
+    }
+    return THREAD_PRIORITY_NORMAL;
+}
+
+// The actual first function called on thread start
+unsigned WINAPI Thread_Win32StartFn(void * phandle)
+{
+    Thread *   pthread = (Thread*)phandle;
+    if (pthread->Processor != -1)
+    {
+        DWORD_PTR ret = SetThreadAffinityMask(GetCurrentThread(), (DWORD)pthread->Processor);
+        if (ret == 0)
+            OVR_DEBUG_LOG(("Could not set hardware processor for the thread"));
+    }
+    BOOL ret = ::SetThreadPriority(GetCurrentThread(), Thread::GetOSPriority(pthread->Priority));
+    if (ret == 0)
+        OVR_DEBUG_LOG(("Could not set thread priority"));
+    OVR_UNUSED(ret);
+
+    // Ensure that ThreadId is assigned once thread is running, in case
+    // beginthread hasn't filled it in yet.
+    pthread->IdValue = (ThreadId)::GetCurrentThreadId();
+
+    DWORD       result = pthread->PRun();
+    // Signal the thread as done and release it atomically.
+    pthread->FinishAndRelease();
+    // At this point Thread object might be dead; however we can still pass
+    // it to RemoveRunningThread since it is only used as a key there.    
+    ThreadList::RemoveRunningThread(pthread);
+    return (unsigned) result;
+}
+
+bool Thread::Start(ThreadState initialState)
+{
+    if (initialState == NotRunning)
+        return 0;
+    if (GetThreadState() != NotRunning)
+    {
+        OVR_DEBUG_LOG(("Thread::Start failed - thread %p already running", this));
+        return 0;
+    }
+
+    // Free old thread handle before creating the new one
+    CleanupSystemThread();
+
+    // AddRef to us until the thread is finished.
+    AddRef();
+    ThreadList::AddRunningThread(this);
+    
+    ExitCode        = 0;
+    SuspendCount    = 0;
+    ThreadFlags     = (initialState == Running) ? 0 : OVR_THREAD_START_SUSPENDED;
+
+    ThreadHandle = (HANDLE) _beginthreadex(0, (unsigned)StackSize,
+                   Thread_Win32StartFn, this, 0, (unsigned*)&IdValue);
+
+    // Failed? Fail the function
+    if (ThreadHandle == 0)
+    {
+        ThreadFlags = 0;
+        Release();
+        ThreadList::RemoveRunningThread(this);
+        return 0;
+    }
+    return 1;
+}
+
+
+// Suspend the thread until resumed
+bool Thread::Suspend()
+{
+    // Can't suspend a thread that wasn't started
+    if (!(ThreadFlags & OVR_THREAD_STARTED))
+        return 0;
+
+    if (::SuspendThread(ThreadHandle) != 0xFFFFFFFF)
+    {        
+        SuspendCount++;        
+        return 1;
+    }
+    return 0;
+}
+
+// Resumes currently suspended thread
+bool Thread::Resume()
+{
+    // Can't suspend a thread that wasn't started
+    if (!(ThreadFlags & OVR_THREAD_STARTED))
+        return 0;
+
+    // Decrement count, and resume thread if it is 0
+    int32_t oldCount = SuspendCount.ExchangeAdd_Acquire(-1);
+    if (oldCount >= 1)
+    {
+        if (oldCount == 1)
+        {
+            if (::ResumeThread(ThreadHandle) != 0xFFFFFFFF)
+            {
+                return 1;
+            }
+        }
+        else
+        {
+            return 1;
+        }
+    }   
+    return 0;
+}
+
+
+// Quits with an exit code  
+void Thread::Exit(int exitCode)
+{
+    // Can only exist the current thread.
+    // MA: Don't use TLS for now.
+    //if (GetThread() != this)
+    //    return;
+
+    // Call the virtual OnExit function.
+    OnExit();   
+
+    // Signal this thread object as done and release it's references.
+    FinishAndRelease();
+    ThreadList::RemoveRunningThread(this);
+
+    // Call the exit function.
+    _endthreadex((unsigned)exitCode);
+}
+
+
+void Thread::CleanupSystemThread()
+{
+    if (ThreadHandle != 0)
+    {
+        ::CloseHandle(ThreadHandle);
+        ThreadHandle = 0;
+    }
+}
+
+// *** Sleep functions
+// static
+bool Thread::Sleep(unsigned secs)
+{
+    ::Sleep(secs*1000);
+    return 1;
+}
+
+// static
+bool Thread::MSleep(unsigned msecs)
+{
+    ::Sleep(msecs);
+    return 1;
+}
+
+void Thread::SetThreadName( const char* name )
+{
+#if !defined(OVR_BUILD_SHIPPING) || defined(OVR_BUILD_PROFILING)
+    // Looks ugly, but it is the recommended way to name a thread.
+    typedef struct tagTHREADNAME_INFO {
+        DWORD dwType;     // Must be 0x1000
+        LPCSTR szName;    // Pointer to name (in user address space)
+        DWORD dwThreadID; // Thread ID (-1 for caller thread)
+        DWORD dwFlags;    // Reserved for future use; must be zero
+    } THREADNAME_INFO;
+
+    THREADNAME_INFO info;
+
+    info.dwType = 0x1000;
+    info.szName = name;
+    info.dwThreadID = reinterpret_cast<DWORD>(GetThreadId());
+    info.dwFlags = 0;
+
+    __try
+    {
+#ifdef _WIN64
+        RaiseException( 0x406D1388, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR *)&info );
+#else
+        RaiseException( 0x406D1388, 0, sizeof(info)/sizeof(DWORD), (DWORD *)&info );
+#endif
+    }
+    __except( GetExceptionCode()==0x406D1388 ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_EXECUTE_HANDLER )
+    {
+        return;
+    }
+#endif // OVR_BUILD_SHIPPING
+}
+
+// static
+int  Thread::GetCPUCount()
+{
+    SYSTEM_INFO sysInfo;
+    GetSystemInfo(&sysInfo);
+    return (int) sysInfo.dwNumberOfProcessors;
+}
+
+// Returns the unique Id of a thread it is called on, intended for
+// comparison purposes.
+ThreadId GetCurrentThreadId()
+{
+    return (ThreadId)::GetCurrentThreadId();
+}
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,321 @@
+/************************************************************************************
+
+Filename    :   OVR_Timer.cpp
+Content     :   Provides static functions for precise timing
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Timer.h"
+#include "OVR_Log.h"
+
+#if defined (OVR_OS_WIN32) 
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <MMSystem.h>
+#elif defined(OVR_OS_ANDROID)
+#include <time.h>
+#include <android/log.h>
+
+#else
+#include <sys/time.h>
+#endif
+
+namespace OVR {
+
+// For recorded data playback
+bool   Timer::useFakeSeconds  = false; 
+double Timer::FakeSeconds     = 0;
+
+
+//------------------------------------------------------------------------
+// *** Timer - Platform Independent functions
+
+// Returns global high-resolution application timer in seconds.
+double Timer::GetSeconds()
+{
+	if(useFakeSeconds)
+		return FakeSeconds;
+
+    return double(Timer::GetTicksNanos()) * 0.000000001;
+}
+
+
+#if !defined(OVR_OS_WIN32)
+
+// Unused on OSs other then Win32.
+void Timer::initializeTimerSystem()
+{
+}
+void Timer::shutdownTimerSystem()
+{
+}
+
+#endif
+
+
+
+//------------------------------------------------------------------------
+// *** Android Specific Timer
+
+#if defined(OVR_OS_ANDROID)
+
+uint64_t Timer::GetTicksNanos()
+{
+    if (useFakeSeconds)
+        return (uint64_t) (FakeSeconds * NanosPerSecond);
+
+    // Choreographer vsync timestamp is based on.
+    struct timespec tp;
+    const int       status = clock_gettime(CLOCK_MONOTONIC, &tp);
+
+    if (status != 0)
+    {
+        OVR_DEBUG_LOG(("clock_gettime status=%i", status ));
+    }
+    const uint64_t result = (uint64_t)tp.tv_sec * (uint64_t)(1000 * 1000 * 1000) + uint64_t(tp.tv_nsec);
+    return result;
+}
+
+
+//------------------------------------------------------------------------
+// *** Win32 Specific Timer
+
+#elif defined (OVR_OS_WIN32) 
+
+
+// This helper class implements high-resolution wrapper that combines timeGetTime() output
+// with QueryPerformanceCounter.  timeGetTime() is lower precision but drives the high bits,
+// as it's tied to the system clock.
+struct PerformanceTimer
+{
+    PerformanceTimer()
+        : OldMMTimeMs(0), MMTimeWrapCounter(0), PrefFrequency(0),
+          LastResultNanos(0), PerfMinusTicksDeltaNanos(0)
+    { }
+    
+    enum {
+        MMTimerResolutionNanos = 1000000
+    };
+   
+    void    Initialize();
+    void    Shutdown();
+
+    uint64_t  GetTimeNanos();
+
+
+    UINT64 getFrequency()
+    {
+        if (PrefFrequency == 0)
+        {
+            LARGE_INTEGER freq;
+            QueryPerformanceFrequency(&freq);
+            PrefFrequency = freq.QuadPart;
+        }        
+        return PrefFrequency;
+    }
+    
+	bool            UsingVista;
+
+    CRITICAL_SECTION TimeCS;
+    // timeGetTime() support with wrap.
+    uint32_t        OldMMTimeMs;
+    uint32_t        MMTimeWrapCounter;
+    // Cached performance frequency result.
+    uint64_t        PrefFrequency;
+    
+    // Computed as (perfCounterNanos - ticksCounterNanos) initially,
+    // and used to adjust timing.
+    uint64_t        PerfMinusTicksDeltaNanos;
+    // Last returned value in nanoseconds, to ensure we don't back-step in time.
+    uint64_t        LastResultNanos;
+};
+
+PerformanceTimer Win32_PerfTimer;
+
+
+void PerformanceTimer::Initialize()
+{
+
+    MMRESULT mmr = timeBeginPeriod(1);
+    OVR_ASSERT(TIMERR_NOERROR == mmr);
+    OVR_UNUSED(mmr);
+
+    InitializeCriticalSection(&TimeCS);
+    MMTimeWrapCounter = 0;
+    getFrequency();
+
+	// Set Vista flag.  On Vista, we can just use QPC() without all the extra work
+	UsingVista = false;
+	OSVERSIONINFOA vi;
+	vi.dwOSVersionInfoSize = sizeof(vi);
+	if (GetVersionExA(&vi))
+	{
+		UsingVista = vi.dwMajorVersion >= 6;
+	}
+
+	OVR_DEBUG_LOG(("Performance timer Vista flag = %d", (int)UsingVista));
+}
+
+void PerformanceTimer::Shutdown()
+{
+    DeleteCriticalSection(&TimeCS);
+
+    MMRESULT mmr = timeEndPeriod(1);
+    OVR_ASSERT(TIMERR_NOERROR == mmr);
+    OVR_UNUSED(mmr);
+}
+
+uint64_t PerformanceTimer::GetTimeNanos()
+{
+    uint64_t        resultNanos;
+    LARGE_INTEGER   li;
+
+	// If on Vista,
+	if (UsingVista)
+	{
+		// Then we can use QPC() directly without all that extra work
+		QueryPerformanceCounter(&li);
+
+		uint64_t  frequency = getFrequency();
+		uint64_t  perfCounterSeconds = (uint64_t)li.QuadPart / frequency;
+		uint64_t  perfRemainderNanos = (((uint64_t)li.QuadPart - perfCounterSeconds * frequency) *
+									  Timer::NanosPerSecond) / frequency;
+		resultNanos = perfCounterSeconds * Timer::NanosPerSecond + perfRemainderNanos;
+	}
+	else
+	{
+
+    // On Win32 QueryPerformanceFrequency is unreliable due to SMP and
+    // performance levels, so use this logic to detect wrapping and track
+    // high bits.
+    ::EnterCriticalSection(&TimeCS);
+
+    // Get raw value and perf counter "At the same time".
+    QueryPerformanceCounter(&li);
+    DWORD mmTimeMs = timeGetTime();
+    if (OldMMTimeMs > mmTimeMs)
+        MMTimeWrapCounter++;
+    OldMMTimeMs = mmTimeMs;
+
+    // Normalize to nanoseconds.
+    uint64_t  frequency          = getFrequency();
+    uint64_t  perfCounterSeconds = uint64_t(li.QuadPart) / frequency;
+    uint64_t  perfRemainderNanos = ( (uint64_t(li.QuadPart) - perfCounterSeconds * frequency) *
+                                   Timer::NanosPerSecond ) / frequency;
+    uint64_t  perfCounterNanos   = perfCounterSeconds * Timer::NanosPerSecond + perfRemainderNanos;
+
+    uint64_t  mmCounterNanos     = ((uint64_t(MMTimeWrapCounter) << 32) | mmTimeMs) * 1000000;
+    if (PerfMinusTicksDeltaNanos == 0)
+        PerfMinusTicksDeltaNanos = perfCounterNanos - mmCounterNanos;
+ 
+    // Compute result before snapping. 
+    //
+    // On first call, this evaluates to:
+    //          resultNanos = mmCounterNanos.    
+    // Next call, assuming no wrap:
+    //          resultNanos = prev_mmCounterNanos + (perfCounterNanos - prev_perfCounterNanos).        
+    // After wrap, this would be:
+    //          resultNanos = snapped(prev_mmCounterNanos +/- 1ms) + (perfCounterNanos - prev_perfCounterNanos).
+    //
+    resultNanos = perfCounterNanos - PerfMinusTicksDeltaNanos;    
+
+    // Snap the range so that resultNanos never moves further apart then its target resolution.
+    // It's better to allow more slack on the high side as timeGetTime() may be updated at sporadically 
+    // larger then 1 ms intervals even when 1 ms resolution is requested.
+    if (resultNanos > (mmCounterNanos + MMTimerResolutionNanos*2))
+    {
+        resultNanos = mmCounterNanos + MMTimerResolutionNanos*2;
+        if (resultNanos < LastResultNanos)
+            resultNanos = LastResultNanos;
+        PerfMinusTicksDeltaNanos = perfCounterNanos - resultNanos;
+    }
+    else if (resultNanos < (mmCounterNanos - MMTimerResolutionNanos))
+    {
+        resultNanos = mmCounterNanos - MMTimerResolutionNanos;
+        if (resultNanos < LastResultNanos)
+            resultNanos = LastResultNanos;
+        PerfMinusTicksDeltaNanos = perfCounterNanos - resultNanos;
+    }
+
+    LastResultNanos = resultNanos;
+    ::LeaveCriticalSection(&TimeCS);
+	}
+
+	//Tom's addition, to keep precision
+	//static uint64_t    initial_time = 0;
+	//if (!initial_time) initial_time = resultNanos;
+	//resultNanos -= initial_time;
+	// FIXME: This cannot be used for cross-process timestamps
+
+    return resultNanos;
+}
+
+
+// Delegate to PerformanceTimer.
+uint64_t Timer::GetTicksNanos()
+{
+    if (useFakeSeconds)
+        return (uint64_t) (FakeSeconds * NanosPerSecond);
+
+    return Win32_PerfTimer.GetTimeNanos();
+}
+void Timer::initializeTimerSystem()
+{
+    Win32_PerfTimer.Initialize();
+
+}
+void Timer::shutdownTimerSystem()
+{
+    Win32_PerfTimer.Shutdown();
+}
+
+#else   // !OVR_OS_WIN32 && !OVR_OS_ANDROID
+
+
+//------------------------------------------------------------------------
+// *** Standard OS Timer     
+
+uint64_t Timer::GetTicksNanos()
+{
+    if (useFakeSeconds)
+        return (uint64_t) (FakeSeconds * NanosPerSecond);
+
+    // TODO: prefer rdtsc when available?
+	uint64_t result;
+
+    // Return microseconds.
+    struct timeval tv;
+
+    gettimeofday(&tv, 0);
+
+    result = (uint64_t)tv.tv_sec * 1000000;
+    result += tv.tv_usec;
+
+    return result * 1000;
+}
+
+#endif  // OS-specific
+
+
+
+} // OVR
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,88 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_Timer.h
+Content     :   Provides static functions for precise timing
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Timer_h
+#define OVR_Timer_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+    
+//-----------------------------------------------------------------------------------
+// ***** Timer
+
+// Timer class defines a family of static functions used for application
+// timing and profiling.
+
+class Timer
+{
+public:
+    enum {
+        MsPerSecond     = 1000, // Milliseconds in one second.
+        NanosPerSecond  = MsPerSecond * 1000 * 1000,
+        MksPerSecond    = MsPerSecond * 1000
+    };
+
+    // ***** Timing APIs for Application    
+
+    // These APIs should be used to guide animation and other program functions
+    // that require precision.
+
+    // Returns global high-resolution application timer in seconds.
+    static double  OVR_STDCALL GetSeconds();    
+
+    // Returns time in Nanoseconds, using highest possible system resolution.
+    static uint64_t  OVR_STDCALL GetTicksNanos();
+
+    // Kept for compatibility.
+    // Returns ticks in milliseconds, as a 32-bit number. May wrap around every 49.2 days.
+    // Use either time difference of two values of GetTicks to avoid wrap-around.
+    static uint32_t  OVR_STDCALL GetTicksMs()
+    { return  uint32_t(GetTicksNanos() / 1000000); }
+
+    // for recorded data playback
+    static void SetFakeSeconds(double fakeSeconds) 
+    { 
+        FakeSeconds = fakeSeconds; 
+        useFakeSeconds = true; 
+    }
+
+private:
+    friend class System;
+    // System called during program startup/shutdown.
+    static void initializeTimerSystem();
+    static void shutdownTimerSystem();
+
+    // for recorded data playback
+    static double FakeSeconds;
+    static bool   useFakeSeconds; 
+};
+
+
+} // OVR::Timer
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Types.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Types.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,724 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Types.h
+Content     :   Standard library defines and simple types
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Types_H
+#define OVR_Types_H
+
+#include "OVR_Compiler.h"
+
+// Unsupported compiler configurations
+#if _MSC_VER == 0x1600
+#  if _MSC_FULL_VER < 160040219
+#     error "Oculus does not support VS2010 without SP1 installed: It will crash in Release mode"
+#  endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ****** Operating System
+//
+// Type definitions exist for the following operating systems: (OVR_OS_x)
+//
+//    WIN32    - Win32 (Windows 95/98/ME and Windows NT/2000/XP)
+//    DARWIN   - Darwin OS (Mac OS X)
+//    LINUX    - Linux
+//    ANDROID  - Android
+//    IPHONE   - iPhone
+
+#if (defined(__APPLE__) && (defined(__GNUC__) ||\
+     defined(__xlC__) || defined(__xlc__))) || defined(__MACOS__)
+#  if (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) || defined(__IPHONE_OS_VERSION_MIN_REQUIRED))
+#    define OVR_OS_IPHONE
+#  else
+#    define OVR_OS_DARWIN
+#    define OVR_OS_MAC
+#  endif
+#elif (defined(WIN64) || defined(_WIN64) || defined(__WIN64__))
+#  define OVR_OS_WIN32
+#elif (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))
+#  define OVR_OS_WIN32
+#elif defined(__linux__) || defined(__linux)
+#  define OVR_OS_LINUX
+#else
+#  define OVR_OS_OTHER
+#endif
+
+#if defined(ANDROID)
+#  define OVR_OS_ANDROID
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** CPU Architecture
+//
+// The following CPUs are defined: (OVR_CPU_x)
+//
+//    X86        - x86 (IA-32)
+//    X86_64     - x86_64 (amd64)
+//    PPC        - PowerPC
+//    PPC64      - PowerPC64
+//    MIPS       - MIPS
+//    OTHER      - CPU for which no special support is present or needed
+
+
+#if defined(__x86_64__) || defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
+#  define OVR_CPU_X86_64
+#  define OVR_64BIT_POINTERS
+#elif defined(__i386__) || defined(OVR_OS_WIN32)
+#  define OVR_CPU_X86
+#elif defined(__powerpc64__)
+#  define OVR_CPU_PPC64
+#elif defined(__ppc__)
+#  define OVR_CPU_PPC
+#elif defined(__mips__) || defined(__MIPSEL__)
+#  define OVR_CPU_MIPS
+#elif defined(__arm__)
+#  define OVR_CPU_ARM
+#else
+#  define OVR_CPU_OTHER
+#endif
+
+//-----------------------------------------------------------------------------------
+// ***** Co-Processor Architecture
+//
+// The following co-processors are defined: (OVR_CPU_x)
+//
+//    SSE        - Available on all modern x86 processors.
+//    Altivec    - Available on all modern ppc processors.
+//    Neon       - Available on some armv7+ processors.
+
+#if defined(__SSE__) || defined(OVR_OS_WIN32)
+#  define  OVR_CPU_SSE
+#endif // __SSE__
+
+#if defined( __ALTIVEC__ )
+#  define OVR_CPU_ALTIVEC
+#endif // __ALTIVEC__
+
+#if defined(__ARM_NEON__)
+#  define OVR_CPU_ARM_NEON
+#endif // __ARM_NEON__
+
+
+//-----------------------------------------------------------------------------------
+// ***** Compiler Warnings
+
+// Disable MSVC warnings
+#if defined(OVR_CC_MSVC)
+#  pragma warning(disable : 4127)    // Inconsistent dll linkage
+#  pragma warning(disable : 4530)    // Exception handling
+#  if (OVR_CC_MSVC<1300)
+#    pragma warning(disable : 4514)  // Unreferenced inline function has been removed
+#    pragma warning(disable : 4710)  // Function not inlined
+#    pragma warning(disable : 4714)  // _force_inline not inlined
+#    pragma warning(disable : 4786)  // Debug variable name longer than 255 chars
+#  endif // (OVR_CC_MSVC<1300)
+#endif // (OVR_CC_MSVC)
+
+
+
+// *** Linux Unicode - must come before Standard Includes
+
+#ifdef OVR_OS_LINUX
+// Use glibc unicode functions on linux.
+#  ifndef  _GNU_SOURCE
+#    define _GNU_SOURCE
+#  endif
+#endif
+
+//-----------------------------------------------------------------------------------
+// ***** Standard Includes
+//
+#include    <stddef.h>
+#include    <limits.h>
+#include    <float.h>
+
+
+// MSVC Based Memory Leak checking - for now
+#if defined(OVR_CC_MSVC) && defined(OVR_BUILD_DEBUG)
+#  define _CRTDBG_MAP_ALLOC
+#  include <stdlib.h>
+#  include <crtdbg.h>
+
+#if 0
+// Uncomment this to help debug memory leaks under Visual Studio in OVR apps only.
+// This shouldn't be defined in customer releases.
+#  ifndef OVR_DEFINE_NEW
+#    define OVR_DEFINE_NEW new(__FILE__, __LINE__)
+#    define new OVR_DEFINE_NEW
+#  endif
+#endif
+
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** int8_t, int16_t, etc.
+
+#if defined(OVR_CC_MSVC) && (OVR_CC_VER <= 1500) // VS2008 and earlier
+    typedef signed char        int8_t; 
+    typedef unsigned char     uint8_t;
+    typedef signed short      int16_t;
+    typedef unsigned short   uint16_t;
+    typedef signed int        int32_t;
+    typedef unsigned int     uint32_t;
+    typedef signed __int64    int64_t;
+    typedef unsigned __int64 uint64_t;
+#else
+    #include <stdint.h>
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Type definitions for Common Systems
+
+namespace OVR {
+
+typedef char            Char;
+
+// Pointer-sized integer
+typedef size_t          UPInt;
+typedef ptrdiff_t       SPInt;
+
+
+#if defined(OVR_OS_WIN32) 
+
+typedef char            SByte;  // 8 bit Integer (Byte)
+typedef unsigned char   UByte;
+typedef short           SInt16; // 16 bit Integer (Word)
+typedef unsigned short  UInt16;
+typedef long            SInt32; // 32 bit Integer
+typedef unsigned long   UInt32;
+typedef __int64         SInt64; // 64 bit Integer (QWord)
+typedef unsigned __int64 UInt64;
+
+ 
+#elif defined(OVR_OS_MAC) || defined(OVR_OS_IPHONE) || defined(OVR_CC_GNU)
+
+typedef int             SByte  __attribute__((__mode__ (__QI__)));
+typedef unsigned int    UByte  __attribute__((__mode__ (__QI__)));
+typedef int             SInt16 __attribute__((__mode__ (__HI__)));
+typedef unsigned int    UInt16 __attribute__((__mode__ (__HI__)));
+typedef int             SInt32 __attribute__((__mode__ (__SI__)));
+typedef unsigned int    UInt32 __attribute__((__mode__ (__SI__)));
+typedef int             SInt64 __attribute__((__mode__ (__DI__)));
+typedef unsigned int    UInt64 __attribute__((__mode__ (__DI__)));
+
+#else
+
+#include <sys/types.h>
+typedef int8_t          SByte;
+typedef uint8_t         UByte;
+typedef int16_t         SInt16;
+typedef uint16_t        UInt16;
+typedef int32_t         SInt32;
+typedef uint32_t        UInt32;
+typedef int64_t         SInt64;
+typedef uint64_t        UInt64;
+
+#endif
+
+struct OVR_GUID
+{
+	uint32_t Data1;
+	uint16_t Data2;
+	uint16_t Data3;
+	uint8_t  Data4[8];
+};
+
+
+
+} // OVR
+
+
+
+//-----------------------------------------------------------------------------------
+// ****** Standard C/C++ Library
+//
+// Identifies which standard library is currently being used. 
+//
+//    LIBSTDCPP   - GNU libstdc++, used by GCC.
+//    LIBCPP      - LLVM libc++, typically used by clang and GCC.
+//    DINKUMWARE  - Used by Microsoft and various non-Microsoft compilers (e.g. Sony clang).
+
+#if !defined(OVR_STDLIB_LIBSTDCPP)
+    #if defined(__GLIBCXX__)
+        #define OVR_STDLIB_LIBSTDCPP 1
+    #endif
+#endif
+
+#if !defined(OVR_STDLIB_LIBCPP)
+    #if defined(__clang__)
+        #if defined(__cplusplus) && __has_include(<__config>)
+            #define OVR_STDLIB_LIBCPP 1
+        #endif
+    #endif 
+#endif
+
+#if !defined(OVR_STDLIB_DINKUMWARE)
+    #if defined(_YVALS) // Dinkumware globally #defines _YVALS from the #includes above.
+        #define OVR_STDLIB_DINKUMWARE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Macro Definitions
+//
+// We define the following:
+//
+//  OVR_BYTE_ORDER      - Defined to either OVR_LITTLE_ENDIAN or OVR_BIG_ENDIAN
+//  OVR_FORCE_INLINE    - Forces inline expansion of function
+//  OVR_ASM             - Assembly language prefix
+//  OVR_STR             - Prefixes string with L"" if building unicode
+// 
+//  OVR_STDCALL         - Use stdcall calling convention (Pascal arg order)
+//  OVR_CDECL           - Use cdecl calling convention (C argument order)
+//  OVR_FASTCALL        - Use fastcall calling convention (registers)
+//
+
+// Byte order constants, OVR_BYTE_ORDER is defined to be one of these.
+#define OVR_LITTLE_ENDIAN       1
+#define OVR_BIG_ENDIAN          2
+
+
+#if defined(OVR_OS_WIN32) 
+    
+    // ***** Win32
+
+    // Byte order
+    #define OVR_BYTE_ORDER    OVR_LITTLE_ENDIAN
+
+    // Calling convention - goes after function return type but before function name
+    #ifdef __cplusplus_cli
+    #  define OVR_FASTCALL      __stdcall
+    #else
+    #  define OVR_FASTCALL      __fastcall
+    #endif
+
+    #define OVR_STDCALL         __stdcall
+    #define OVR_CDECL           __cdecl
+
+
+    // Assembly macros
+    #if defined(OVR_CC_MSVC)
+    #  define OVR_ASM           _asm
+    #else
+    #  define OVR_ASM           asm
+    #endif // (OVR_CC_MSVC)
+
+    #ifdef UNICODE
+    #  define OVR_STR(str)      L##str
+    #else
+    #  define OVR_STR(str)      str
+    #endif // UNICODE
+
+#else
+
+    // **** Standard systems
+
+    #if (defined(BYTE_ORDER) && (BYTE_ORDER == BIG_ENDIAN))|| \
+        (defined(_BYTE_ORDER) && (_BYTE_ORDER == _BIG_ENDIAN))
+    #  define OVR_BYTE_ORDER    OVR_BIG_ENDIAN
+    #elif (defined(__ARMEB__) || defined(OVR_CPU_PPC) || defined(OVR_CPU_PPC64))
+    #  define OVR_BYTE_ORDER    OVR_BIG_ENDIAN
+    #else
+    #  define OVR_BYTE_ORDER    OVR_LITTLE_ENDIAN
+    #endif
+    
+    // Assembly macros
+    #define OVR_ASM                  __asm__
+    #define OVR_ASM_PROC(procname)   OVR_ASM
+    #define OVR_ASM_END              OVR_ASM
+    
+    // Calling convention - goes after function return type but before function name
+    #define OVR_FASTCALL
+    #define OVR_STDCALL
+    #define OVR_CDECL
+
+#endif // defined(OVR_OS_WIN32)
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_PTR_SIZE
+// 
+// Specifies the byte size of pointers (same as sizeof void*).
+
+#if !defined(OVR_PTR_SIZE)
+    #if defined(__WORDSIZE)
+        #define OVR_PTR_SIZE ((__WORDSIZE) / 8)
+    #elif defined(_WIN64) || defined(__LP64__) || defined(_LP64) || defined(_M_IA64) || defined(__ia64__) || defined(__arch64__) || defined(__64BIT__) || defined(__Ptr_Is_64)
+        #define OVR_PTR_SIZE 8
+    #elif defined(__CC_ARM) && (__sizeof_ptr == 8)
+        #define OVR_PTR_SIZE 8
+    #else
+        #define OVR_PTR_SIZE 4
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_WORD_SIZE
+// 
+// Specifies the byte size of a machine word/register. Not necessarily the same as
+// the size of pointers, but usually >= the size of pointers.
+
+#if !defined(OVR_WORD_SIZE)
+   #define OVR_WORD_SIZE OVR_PTR_SIZE // For our currently supported platforms these are equal.
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_FORCE_INLINE
+//
+// Force inline substitute - goes before function declaration
+// Example usage:
+//     OVR_FORCE_INLINE void Test();
+
+#if !defined(OVR_FORCE_INLINE)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_FORCE_INLINE  __forceinline
+    #elif defined(OVR_CC_GNU)
+        #define OVR_FORCE_INLINE  __attribute__((always_inline)) inline
+    #else
+        #define OVR_FORCE_INLINE  inline
+    #endif  // OVR_CC_MSVC
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_NO_INLINE
+//
+// Cannot be used with inline or OVR_FORCE_INLINE.
+// Example usage:
+//     OVR_NO_INLINE void Test();
+
+#if !defined(OVR_NO_INLINE)
+    #if defined(OVR_CC_MSVC) && (_MSC_VER >= 1500) // VS2008+
+        #define OVR_NO_INLINE __declspec(noinline)
+    #elif !defined(OVR_CC_MSVC)
+        #define OVR_NO_INLINE __attribute__((noinline))
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_STRINGIZE
+//
+// Converts a preprocessor symbol to a string.
+//
+// Example usage:
+//     printf("Line: %s", OVR_STRINGIZE(__LINE__));
+//
+#if !defined(OVR_STRINGIFY)
+    #define OVR_STRINGIZEIMPL(x) #x
+    #define OVR_STRINGIZE(x)     OVR_STRINGIZEIMPL(x)
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_JOIN
+//
+// Joins two preprocessing symbols together. Supports the case when either or the
+// the symbols are macros themselves.
+//
+// Example usage:
+//    char OVR_JOIN(unique_, __LINE__);  // Results in (e.g.) char unique_123;
+//
+#if !defined(OVR_JOIN)
+    #define OVR_JOIN(a, b)  OVR_JOIN1(a, b)
+    #define OVR_JOIN1(a, b) OVR_JOIN2(a, b)
+    #define OVR_JOIN2(a, b) a##b
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_OFFSETOF
+// 
+// Portable implementation of offsetof for structs and classes. offsetof and GCC's 
+// __builtin_offsetof work only with POD types (standard-layout types under C++11), 
+// despite that it can safely work with a number of types that aren't POD. This 
+// version works with more types without generating compiler warnings or errors.
+// Returns the offset as a size_t, as per offsetof.
+//
+// Example usage:
+//     struct Test{ int i; float f; };
+//     size_t fPos = OVR_OFFSETOF(Test, f);
+
+#if defined(OVR_CC_GNU)
+    #define OVR_OFFSETOF(class_, member_) ((size_t)(((uintptr_t)&reinterpret_cast<const volatile char&>((((class_*)65536)->member_))) - 65536))
+#else
+    #define OVR_OFFSETOF(class_, member_) offsetof(class_, member_)
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_SIZEOF_MEMBER
+//
+// Implements a portable way to determine the size of struct or class data member. 
+// C++11 allows this directly via sizeof (see OVR_CPP_NO_EXTENDED_SIZEOF), and this 
+// macro exists to handle pre-C++11 compilers.
+// Returns the offset as a size_t, as per sizeof.
+//
+// Example usage:
+//     struct Test{ int i; float f; };
+//     size_t fSize = OVR_SIZEOF_MEMBER(Test, f);
+//
+#if defined(OVR_CPP_NO_EXTENDED_SIZEOF)
+    #define OVR_SIZEOF_MEMBER(class_, member_) (sizeof(((class_*)0)->member_))
+#else
+    #define OVR_SIZEOF_MEMBER(class_, member_) (sizeof(class_::member_))
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_DEBUG_BREAK, OVR_ASSERT
+//
+// If not in debug build, macros do nothing
+#ifndef OVR_BUILD_DEBUG
+
+#  define OVR_DEBUG_CODE(c)
+#  define OVR_DEBUG_BREAK  ((void)0)
+#  define OVR_ASSERT(p)    ((void)0)
+
+#else 
+
+// Microsoft Win32 specific debugging support
+#if defined(OVR_OS_WIN32) 
+#  ifdef OVR_CPU_X86
+#    if defined(__cplusplus_cli)
+#      define OVR_DEBUG_BREAK   do { __debugbreak(); } while(0)
+#    elif defined(OVR_CC_GNU)
+#      define OVR_DEBUG_BREAK   do { OVR_ASM("int $3\n\t"); } while(0)
+#    else
+#      define OVR_DEBUG_BREAK   do { OVR_ASM int 3 } while (0)
+#    endif
+#  else
+#    define OVR_DEBUG_BREAK     do { __debugbreak(); } while(0)
+#  endif
+// Unix specific debugging support
+#elif defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64)
+#  define OVR_DEBUG_BREAK       do { OVR_ASM("int $3\n\t"); } while(0)
+#else
+#  define OVR_DEBUG_BREAK       do { *((int *) 0) = 1; } while(0)
+#endif
+
+#define OVR_DEBUG_CODE(c) c
+
+// This will cause compiler breakpoint
+#define OVR_ASSERT(p)           do { if (!(p))  { OVR_DEBUG_BREAK; } } while(0)
+
+#endif // OVR_BUILD_DEBUG
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_COMPILER_ASSERT
+//
+// Compile-time assert; produces compiler error if condition is false.
+// The expression must be a compile-time constant expression.
+// 
+// Example usage:
+//     OVR_COMPILER_ASSERT(sizeof(int32_t == 4));
+
+#if OVR_CPP_NO_STATIC_ASSERT
+    #define OVR_COMPILER_ASSERT(x)  { int zero = 0; switch(zero) {case 0: case x:;} }
+#else
+    #define OVR_COMPILER_ASSERT(x)  static_assert((x), #x)
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** static_assert
+//
+// Portable support for C++11 static_assert.
+// Acts as if the following were declared:
+//     void static_assert(bool const_expression, const char* msg);
+//
+// Example usage:
+//     static_assert(sizeof(int32_t) == 4, "int32_t expected to be 4 bytes.");
+
+#if defined(OVR_CPP_NO_STATIC_ASSERT)
+    #if defined(OVR_CC_GNU) || defined(OVR_CC_CLANG)
+        #define OVR_SA_UNUSED __attribute__((unused))
+    #else
+        #define OVR_SA_UNUSED
+    #endif
+    #define OVR_SA_PASTE(a,b) a##b
+    #define OVR_SA_HELP(a,b)  OVR_SA_PASTE(a,b)
+
+    #if defined(__COUNTER__)
+        #define static_assert(expression, msg) typedef char OVR_SA_HELP(compileTimeAssert, __COUNTER__) [((expression) != 0) ? 1 : -1] OVR_SA_UNUSED
+    #else
+        #define static_assert(expression, msg) typedef char OVR_SA_HELP(compileTimeAssert, __LINE__) [((expression) != 0) ? 1 : -1] OVR_SA_UNUSED
+    #endif
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_ARRAY_COUNT
+//
+// Returns the element count of a C array. 
+//
+// Example usage:
+//     float itemArray[16];
+//     for(size_t i = 0; i < OVR_ARRAY_COUNT(itemArray); i++) { ... }
+
+#if defined(OVR_CPP_NO_CONSTEXPR)
+    #ifndef OVR_ARRAY_COUNT
+        #define OVR_ARRAY_COUNT(x) (sizeof(x) / sizeof(x[0]))
+    #endif
+#else
+    // Smarter C++11 version which knows the difference between arrays and pointers. 
+    template <typename T, size_t N>
+    char (&OVRArrayCountHelper(T (&x)[N]))[N];
+    #define OVR_ARRAY_COUNT(x) (sizeof(OVRArrayCountHelper(x)))
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_CURRENT_FUNCTION
+//
+// Portable wrapper for __PRETTY_FUNCTION__, C99 __func__, __FUNCTION__.
+// This represents the most expressive version available.
+// Acts as if the following were declared:
+//     static const char OVR_CURRENT_FUNCTION[] = "function-name";
+//
+// Example usage:
+//     void Test() { printf("%s", OVR_CURRENT_FUNCTION); }
+
+#if defined(OVR_CC_GNU) || defined(OVR_CC_CLANG) || (defined(__ICC) && (__ICC >= 600)) // GCC, clang, Intel
+    #define OVR_CURRENT_FUNCTION __PRETTY_FUNCTION__
+#elif defined(__FUNCSIG__) // VC++
+    #define OVR_CURRENT_FUNCTION __FUNCSIG__
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901) // C99 compilers
+    #define OVR_CURRENT_FUNCTION __func__
+#else
+    #define OVR_CURRENT_FUNCTION __FUNCTION__
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_DEPRECATED / OVR_DEPRECATED_MSG
+// 
+// Portably annotates a function or struct as deprecated.
+// Note that clang supports __deprecated_enum_msg, which may be useful to support.
+//
+// Example usage:
+//    OVR_DEPRECATED void Test();       // Use on the function declaration, as opposed to definition.
+//
+//    struct OVR_DEPRECATED Test{ ... };
+//
+//    OVR_DEPRECATED_MSG("Test is deprecated")
+//    void Test();
+
+#if !defined(OVR_DEPRECATED)
+    #if defined(OVR_CC_MSVC) && (OVR_CC_VERSION > 1400) // VS2005+
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __declspec(deprecated(msg))
+    #elif defined(OVR_CC_CLANG) && OVR_CC_HAS_FEATURE(attribute_deprecated_with_message)
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
+    #elif defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 405)
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
+    #elif !defined(OVR_CC_MSVC)
+        #define OVR_DEPRECATED          __attribute__((deprecated))
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated))
+    #else
+        #define OVR_DEPRECATED
+        #define OVR_DEPRECATED_MSG(msg)
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_UNUSED - Unused Argument handling
+// Macro to quiet compiler warnings about unused parameters/variables.
+//
+// Example usage:
+//     void Test() {
+//         int x = SomeFunction();
+//         OVR_UNUSED(x);
+//     }
+//
+
+#if defined(OVR_CC_GNU)
+#  define   OVR_UNUSED(a)   do {__typeof__ (&a) __attribute__ ((unused)) __tmp = &a; } while(0)
+#else
+#  define   OVR_UNUSED(a)   (a)
+#endif
+
+#define     OVR_UNUSED1(a1) OVR_UNUSED(a1)
+#define     OVR_UNUSED2(a1,a2) OVR_UNUSED(a1); OVR_UNUSED(a2)
+#define     OVR_UNUSED3(a1,a2,a3) OVR_UNUSED2(a1,a2); OVR_UNUSED(a3)
+#define     OVR_UNUSED4(a1,a2,a3,a4) OVR_UNUSED3(a1,a2,a3); OVR_UNUSED(a4)
+#define     OVR_UNUSED5(a1,a2,a3,a4,a5) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED(a5)
+#define     OVR_UNUSED6(a1,a2,a3,a4,a5,a6) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED2(a5,a6)
+#define     OVR_UNUSED7(a1,a2,a3,a4,a5,a6,a7) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED3(a5,a6,a7)
+#define     OVR_UNUSED8(a1,a2,a3,a4,a5,a6,a7,a8) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED4(a5,a6,a7,a8)
+#define     OVR_UNUSED9(a1,a2,a3,a4,a5,a6,a7,a8,a9) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED5(a5,a6,a7,a8,a9)
+
+
+//-----------------------------------------------------------------------------------
+// ***** Configuration Macros
+//
+// Expands to the current build type as a const char string literal.
+// Acts as the following declaration: const char OVR_BUILD_STRING[];
+
+#ifdef OVR_BUILD_DEBUG
+#  define OVR_BUILD_STRING  "Debug"
+#else
+#  define OVR_BUILD_STRING  "Release"
+#endif
+
+
+//// Enables SF Debugging information
+//# define OVR_BUILD_DEBUG
+
+// OVR_DEBUG_STATEMENT injects a statement only in debug builds.
+// OVR_DEBUG_SELECT injects first argument in debug builds, second argument otherwise.
+#ifdef OVR_BUILD_DEBUG
+#define OVR_DEBUG_STATEMENT(s)   s
+#define OVR_DEBUG_SELECT(d, nd)  d
+#else
+#define OVR_DEBUG_STATEMENT(s)
+#define OVR_DEBUG_SELECT(d, nd)  nd
+#endif
+
+
+#define OVR_ENABLE_THREADS
+//
+// Prevents OVR from defining new within
+// type macros, so developers can override
+// new using the #define new new(...) trick
+// - used with OVR_DEFINE_NEW macro
+//# define OVR_BUILD_DEFINE_NEW
+//
+
+
+
+#endif  // OVR_Types_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,556 @@
+/**************************************************************************
+
+Filename    :   OVR_UTF8Util.cpp
+Content     :   UTF8 Unicode character encoding/decoding support
+Created     :   September 19, 2012
+Notes       : 
+Notes       :   Much useful info at "UTF-8 and Unicode FAQ"
+                http://www.cl.cam.ac.uk/~mgk25/unicode.html
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_UTF8Util.h"
+
+namespace OVR { namespace UTF8Util {
+
+intptr_t OVR_STDCALL GetLength(const char* buf, intptr_t buflen)
+{
+    const char* p = buf;
+    intptr_t length = 0;
+
+    if (buflen != -1)
+    {
+        while (p - buf < buflen)
+        {
+            // We should be able to have ASStrings with 0 in the middle.
+            UTF8Util::DecodeNextChar_Advance0(&p);
+            length++;
+        }
+    }
+    else
+    {
+        while (UTF8Util::DecodeNextChar_Advance0(&p))
+            length++;
+    }
+    
+    return length;
+}
+
+uint32_t OVR_STDCALL GetCharAt(intptr_t index, const char* putf8str, intptr_t length)
+{
+    const char* buf = putf8str;
+    uint32_t  c = 0;
+
+    if (length != -1)
+    {
+        while (buf - putf8str < length)
+        {           
+            c = UTF8Util::DecodeNextChar_Advance0(&buf);
+            if (index == 0)
+                return c;
+            index--;
+        }
+
+        return c;
+    }
+
+    do 
+    {
+        c = UTF8Util::DecodeNextChar_Advance0(&buf);
+        index--;
+
+        if (c == 0)
+        {
+            // We've hit the end of the string; don't go further.
+            OVR_ASSERT(index == 0);
+            return c;
+        }
+    } while (index >= 0);
+
+    return c;
+}
+
+intptr_t OVR_STDCALL GetByteIndex(intptr_t index, const char *putf8str, intptr_t length)
+{
+    const char* buf = putf8str;
+
+    if (length != -1)
+    {
+        while ((buf - putf8str) < length && index > 0)
+        {
+            UTF8Util::DecodeNextChar_Advance0(&buf);
+            index--;
+        }
+
+        return buf-putf8str;
+    }
+
+    while (index > 0) 
+    {
+        uint32_t c = UTF8Util::DecodeNextChar_Advance0(&buf);
+        index--;
+
+        if (c == 0)
+            return buf-putf8str;
+    };
+
+    return buf-putf8str;
+}
+
+int OVR_STDCALL GetEncodeCharSize(uint32_t ucs_character)
+{
+    if (ucs_character <= 0x7F)
+        return 1;
+    else if (ucs_character <= 0x7FF)
+        return 2;
+    else if (ucs_character <= 0xFFFF)
+        return 3;
+    else if (ucs_character <= 0x1FFFFF)
+        return 4;
+    else if (ucs_character <= 0x3FFFFFF)
+        return 5;
+    else if (ucs_character <= 0x7FFFFFFF)
+        return 6;
+    else
+        return 0;
+}
+
+uint32_t OVR_STDCALL DecodeNextChar_Advance0(const char** putf8Buffer)
+{
+    uint32_t  uc;
+    char    c;
+    
+    // Security considerations:
+    //
+    // Changed, this is now only the case for DecodeNextChar:
+    //  - If we hit a zero byte, we want to return 0 without stepping
+    //    the buffer pointer past the 0. th
+    //
+    // If we hit an "overlong sequence"; i.e. a character encoded
+    // in a longer multibyte string than is necessary, then we
+    // need to discard the character.  This is so attackers can't
+    // disguise dangerous characters or character sequences --
+    // there is only one valid encoding for each character.
+    //
+    // If we decode characters { 0xD800 .. 0xDFFF } or { 0xFFFE,
+    // 0xFFFF } then we ignore them; they are not valid in UTF-8.
+    
+    // This isn't actually an invalid character; it's a valid char that
+    // looks like an inverted question mark.
+#define INVALID_CHAR 0x0FFFD
+    
+#define FIRST_BYTE(mask, shift)     \
+    uc = (c & (mask)) << (shift);
+    
+#define NEXT_BYTE(shift) \
+    c = **putf8Buffer;   \
+    if (c == 0) return 0; /* end of buffer, do not advance */   \
+    if ((c & 0xC0) != 0x80) return INVALID_CHAR; /* standard check */  \
+    (*putf8Buffer)++;    \
+    uc |= (c & 0x3F) << shift;
+    
+    c = **putf8Buffer;
+    (*putf8Buffer)++;
+    if (c == 0)
+        return 0;   // End of buffer.
+    
+    if ((c & 0x80) == 0) return (uint32_t) c; // Conventional 7-bit ASCII.
+    
+    // Multi-byte sequences.
+    if ((c & 0xE0) == 0xC0)
+    {
+        // Two-byte sequence.
+        FIRST_BYTE(0x1F, 6);
+        NEXT_BYTE(0);
+        if (uc < 0x80) return INVALID_CHAR;  // overlong
+        return uc;
+    }
+    else if ((c & 0xF0) == 0xE0)
+    {
+        // Three-byte sequence.
+        FIRST_BYTE(0x0F, 12);
+        NEXT_BYTE(6);
+        NEXT_BYTE(0);
+        if (uc < 0x800) return INVALID_CHAR; // overlong
+        // Not valid ISO 10646, but Flash requires these to work
+        // see AS3 test e15_5_3_2_3 for String.fromCharCode().charCodeAt(0)
+        // if (uc >= 0x0D800 && uc <= 0x0DFFF) return INVALID_CHAR;
+        // if (uc == 0x0FFFE || uc == 0x0FFFF) return INVALID_CHAR; // not valid ISO 10646
+        return uc;
+    }
+    else if ((c & 0xF8) == 0xF0)
+    {
+        // Four-byte sequence.
+        FIRST_BYTE(0x07, 18);
+        NEXT_BYTE(12);
+        NEXT_BYTE(6);
+        NEXT_BYTE(0);
+        if (uc < 0x010000) return INVALID_CHAR;  // overlong
+        return uc;
+    }
+    else if ((c & 0xFC) == 0xF8)
+    {
+        // Five-byte sequence.
+        FIRST_BYTE(0x03, 24);
+        NEXT_BYTE(18);
+        NEXT_BYTE(12);
+        NEXT_BYTE(6);
+        NEXT_BYTE(0);
+        if (uc < 0x0200000) return INVALID_CHAR; // overlong
+        return uc;
+    }
+    else if ((c & 0xFE) == 0xFC)
+    {
+        // Six-byte sequence.
+        FIRST_BYTE(0x01, 30);
+        NEXT_BYTE(24);
+        NEXT_BYTE(18);
+        NEXT_BYTE(12);
+        NEXT_BYTE(6);
+        NEXT_BYTE(0);
+        if (uc < 0x04000000) return INVALID_CHAR;    // overlong
+        return uc;
+    }
+    else
+    {
+        // Invalid.
+        return INVALID_CHAR;
+    }
+}
+
+
+void OVR_STDCALL EncodeChar(char* pbuffer, intptr_t* pindex, uint32_t ucs_character)
+{
+    if (ucs_character <= 0x7F)
+    {
+        // Plain single-byte ASCII.
+        pbuffer[(*pindex)++] = (char) ucs_character;
+    }
+    else if (ucs_character <= 0x7FF)
+    {
+        // Two bytes.
+        pbuffer[(*pindex)++] = 0xC0 | (char)(ucs_character >> 6);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 0) & 0x3F);
+    }
+    else if (ucs_character <= 0xFFFF)
+    {
+        // Three bytes.
+        pbuffer[(*pindex)++] = 0xE0 | (char)(ucs_character >> 12);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 6) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 0) & 0x3F);
+    }
+    else if (ucs_character <= 0x1FFFFF)
+    {
+        // Four bytes.
+        pbuffer[(*pindex)++] = 0xF0 | (char)(ucs_character >> 18);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 12) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 6) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 0) & 0x3F);
+    }
+    else if (ucs_character <= 0x3FFFFFF)
+    {
+        // Five bytes.
+        pbuffer[(*pindex)++] = 0xF8 | (char)(ucs_character >> 24);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 18) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 12) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 6) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 0) & 0x3F);
+    }
+    else if (ucs_character <= 0x7FFFFFFF)
+    {
+        // Six bytes.
+        pbuffer[(*pindex)++] = 0xFC | (char)(ucs_character >> 30);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 24) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 18) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 12) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 6) & 0x3F);
+        pbuffer[(*pindex)++] = 0x80 | (char)((ucs_character >> 0) & 0x3F);
+    }
+    else
+    {
+        // Invalid char; don't encode anything.
+    }
+}
+
+intptr_t OVR_STDCALL GetEncodeStringSize(const wchar_t* pchar, intptr_t length)
+{
+    intptr_t len = 0;
+    if (length != -1)
+        for (int i = 0; i < length; i++)
+        {
+            len += GetEncodeCharSize(pchar[i]);
+        }
+    else
+        for (int i = 0;; i++)
+        {
+            if (pchar[i] == 0)
+                return len;
+            len += GetEncodeCharSize(pchar[i]);
+        }
+    return len;
+}
+
+void OVR_STDCALL EncodeString(char *pbuff, const wchar_t* pchar, intptr_t length)
+{
+    intptr_t ofs = 0;
+    if (length != -1)
+    {
+        for (int i = 0; i < length; i++)
+        {            
+            EncodeChar(pbuff, &ofs, pchar[i]);
+        }
+    }
+    else
+    {
+        for (int i = 0;; i++)
+        {
+            if (pchar[i] == 0)
+                break;
+            EncodeChar(pbuff, &ofs, pchar[i]);
+        }
+    }
+    pbuff[ofs] = 0;
+}
+
+size_t OVR_STDCALL DecodeString(wchar_t *pbuff, const char* putf8str, intptr_t bytesLen)
+{
+    wchar_t *pbegin = pbuff;
+    if (bytesLen == -1)
+    {
+        while (1)
+        {
+            uint32_t ch = DecodeNextChar_Advance0(&putf8str);
+            if (ch == 0)
+                break;
+            else if (ch >= 0xFFFF)
+                ch = 0xFFFD;
+            *pbuff++ = wchar_t(ch);
+        }
+    }
+    else
+    {
+        const char* p = putf8str;
+        while ((p - putf8str) < bytesLen)
+        {
+            uint32_t ch = DecodeNextChar_Advance0(&p);
+            if (ch >= 0xFFFF)
+                ch = 0xFFFD;
+            *pbuff++ = wchar_t(ch);
+        }
+    }
+
+    *pbuff = 0;
+    return pbuff - pbegin;
+}
+
+
+#ifdef UTF8_UNIT_TEST
+
+// Compile this test case with something like:
+//
+// gcc utf8.cpp -g -I.. -DUTF8_UNIT_TEST -lstdc++ -o utf8_test
+//
+//    or
+//
+// cl utf8.cpp -Zi -Od -DUTF8_UNIT_TEST -I..
+//
+// If possible, try running the test program with the first arg
+// pointing at the file:
+//
+// http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt
+// 
+// and examine the results by eye to make sure they are acceptable to
+// you.
+
+
+#include "base/utility.h"
+#include <stdio.h>
+
+
+bool    check_equal(const char* utf8_in, const uint32_t* ucs_in)
+{
+    for (;;)
+    {
+        uint32_t  next_ucs = *ucs_in++;
+        uint32_t  next_ucs_from_utf8 = utf8::decode_next_unicode_character(&utf8_in);
+        if (next_ucs != next_ucs_from_utf8)
+        {
+            return false;
+        }
+        if (next_ucs == 0)
+        {
+            OVR_ASSERT(next_ucs_from_utf8 == 0);
+            break;
+        }
+    }
+    
+    return true;
+}
+
+
+void    log_ascii(const char* line)
+{
+    for (;;)
+    {
+        unsigned char   c = (unsigned char) *line++;
+        if (c == 0)
+        {
+            // End of line.
+            return;
+        }
+        else if (c != '\n'
+            && (c < 32 || c > 127))
+        {
+            // Non-printable as plain ASCII.
+            printf("<0x%02X>", (int) c);
+        }
+        else
+        {
+            printf("%c", c);
+        }
+    }
+}
+
+
+void    log_ucs(const uint32_t* line)
+{
+    for (;;)
+    {
+        uint32_t  uc = *line++;
+        if (uc == 0)
+        {
+            // End of line.
+            return;
+        }
+        else if (uc != '\n'
+            && (uc < 32 || uc > 127))
+        {
+            // Non-printable as plain ASCII.
+            printf("<U-%04X>", uc);
+        }
+        else
+        {
+            printf("%c", (char) uc);
+        }
+    }
+}
+
+
+// Simple canned test.
+int main(int argc, const char* argv[])
+{
+    {
+        const char* test8 = "Ignacio Castao";
+        const uint32_t  test32[] =
+        {
+            0x49, 0x67, 0x6E, 0x61, 0x63,
+                0x69, 0x6F, 0x20, 0x43, 0x61,
+                0x73, 0x74, 0x61, 0xF1, 0x6F,
+                0x00
+        };
+        
+        OVR_ASSERT(check_equal(test8, test32));
+    }
+        
+        // If user passed an arg, try reading the file as UTF-8 encoded text.
+        if (argc > 1)
+        {
+            const char* filename = argv[1];
+            FILE*   fp = fopen(filename, "rb");
+            if (fp == NULL)
+            {
+                printf("Can't open file '%s'\n", filename);
+                return 1;
+            }
+            
+            // Read lines from the file, encode/decode them, and highlight discrepancies.
+            const int LINE_SIZE = 200;  // max line size
+            char    line_buffer_utf8[LINE_SIZE];
+            char    reencoded_utf8[6 * LINE_SIZE];
+            uint32_t  line_buffer_ucs[LINE_SIZE];
+            
+            int byte_counter = 0;
+            for (;;)
+            {
+                int c = fgetc(fp);
+                if (c == EOF)
+                {
+                    // Done.
+                    break;
+                }
+                line_buffer_utf8[byte_counter++] = c;
+                if (c == '\n' || byte_counter >= LINE_SIZE - 2)
+                {
+                    // End of line.  Process the line.
+                    line_buffer_utf8[byte_counter++] = 0;   // terminate.
+                    
+                    // Decode into UCS.
+                    const char* p = line_buffer_utf8;
+                    uint32_t* q = line_buffer_ucs;
+                    for (;;)
+                    {
+                        uint32_t  uc = UTF8Util::DecodeNextChar(&p);
+                        *q++ = uc;
+                        
+                        OVR_ASSERT(q < line_buffer_ucs + LINE_SIZE);
+                        OVR_ASSERT(p < line_buffer_utf8 + LINE_SIZE);
+                        
+                        if (uc == 0) break;
+                    }
+                    
+                    // Encode back into UTF-8.
+                    q = line_buffer_ucs;
+                    int index = 0;
+                    for (;;)
+                    {
+                        uint32_t  uc = *q++;
+                        OVR_ASSERT(index < LINE_SIZE * 6 - 6);
+                        int last_index = index;
+                        UTF8Util::EncodeChar(reencoded_utf8, &index, uc);
+                        OVR_ASSERT(index <= last_index + 6);
+                        if (uc == 0) break;
+                    }
+                    
+                    // This can be useful for debugging.
+#if 0
+                    // Show the UCS and the re-encoded UTF-8.
+                    log_ucs(line_buffer_ucs);
+                    log_ascii(reencoded_utf8);
+#endif // 0
+                    
+                    OVR_ASSERT(check_equal(line_buffer_utf8, line_buffer_ucs));
+                    OVR_ASSERT(check_equal(reencoded_utf8, line_buffer_ucs));
+                    
+                    // Start next line.
+                    byte_counter = 0;
+                }
+            }
+            
+            fclose(fp);
+        }
+        
+        return 0;
+}
+
+
+#endif // UTF8_UNIT_TEST
+
+}} // namespace UTF8Util::OVR
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,99 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_UTF8Util.h
+Content     :   UTF8 Unicode character encoding/decoding support
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_UTF8Util_h
+#define OVR_UTF8Util_h
+
+#include "OVR_Types.h"
+
+namespace OVR { namespace UTF8Util {
+
+//-----------------------------------------------------------------------------------
+
+// *** UTF8 string length and indexing.
+
+// Determines the length of UTF8 string in characters.
+// If source length is specified (in bytes), null 0 character is counted properly.
+intptr_t OVR_STDCALL GetLength(const char* putf8str, intptr_t length = -1);
+
+// Gets a decoded UTF8 character at index; you can access up to the index returned
+// by GetLength. 0 will be returned for out of bounds access.
+uint32_t OVR_STDCALL GetCharAt(intptr_t index, const char* putf8str, intptr_t length = -1);
+
+// Converts UTF8 character index into byte offset.
+// -1 is returned if index was out of bounds.
+intptr_t OVR_STDCALL GetByteIndex(intptr_t index, const char* putf8str, intptr_t length = -1);
+
+
+// *** 16-bit Unicode string Encoding/Decoding routines.
+
+// Determines the number of bytes necessary to encode a string.
+// Does not count the terminating 0 (null) character.
+intptr_t OVR_STDCALL GetEncodeStringSize(const wchar_t* pchar, intptr_t length = -1);
+
+// Encodes a unicode (UCS-2 only) string into a buffer. The size of buffer must be at
+// least GetEncodeStringSize() + 1.
+void     OVR_STDCALL EncodeString(char *pbuff, const wchar_t* pchar, intptr_t length = -1);
+
+// Decode UTF8 into a wchar_t buffer. Must have GetLength()+1 characters available.
+// Characters over 0xFFFF are replaced with 0xFFFD.
+// Returns the length of resulting string (number of characters)
+size_t   OVR_STDCALL DecodeString(wchar_t *pbuff, const char* putf8str, intptr_t bytesLen = -1);
+
+
+// *** Individual character Encoding/Decoding.
+
+// Determined the number of bytes necessary to encode a UCS character.
+int      OVR_STDCALL GetEncodeCharSize(uint32_t ucsCharacter);
+
+// Encodes the given UCS character into the given UTF-8 buffer.
+// Writes the data starting at buffer[offset], and 
+// increments offset by the number of bytes written.
+// May write up to 6 bytes, so make sure there's room in the buffer
+void     OVR_STDCALL EncodeChar(char* pbuffer, intptr_t* poffset, uint32_t ucsCharacter);
+
+// Return the next Unicode character in the UTF-8 encoded buffer.
+// Invalid UTF-8 sequences produce a U+FFFD character as output.
+// Advances *utf8_buffer past the character returned. Pointer advance
+// occurs even if the terminating 0 character is hit, since that allows
+// strings with middle '\0' characters to be supported.
+uint32_t OVR_STDCALL DecodeNextChar_Advance0(const char** putf8Buffer);
+
+// Safer version of DecodeNextChar, which doesn't advance pointer if
+// null character is hit.
+inline uint32_t DecodeNextChar(const char** putf8Buffer)
+{
+    uint32_t ch = DecodeNextChar_Advance0(putf8Buffer);
+    if (ch == 0)
+        (*putf8Buffer)--;
+    return ch;
+}
+
+
+}} // OVR::UTF8Util
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1149 @@
+/************************************************************************************
+
+Filename    :   OVR_BitStream.cpp
+Content     :   A generic serialization toolkit for packing data to a binary stream.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_BitStream.h"
+
+#ifdef OVR_OS_WIN32
+#include <WinSock2.h>
+#else
+#include <arpa/inet.h>
+#endif
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// BitStream
+	
+BitStream::BitStream()
+{
+	numberOfBitsUsed = 0;
+	//numberOfBitsAllocated = 32 * 8;
+	numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE * 8;
+	readOffset = 0;
+	//data = ( unsigned char* ) OVR_ALLOC( 32);
+	data = ( unsigned char* ) stackData;
+
+#ifdef _DEBUG	
+	//	OVR_ASSERT( data );
+#endif
+	//memset(data, 0, 32);
+	copyData = true;
+}
+
+BitStream::BitStream( const unsigned int initialBytesToAllocate )
+{
+	numberOfBitsUsed = 0;
+	readOffset = 0;
+	if (initialBytesToAllocate <= BITSTREAM_STACK_ALLOCATION_SIZE)
+	{
+		data = ( unsigned char* ) stackData;
+		numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE * 8;
+	}
+	else
+	{
+		data = ( unsigned char* ) OVR_ALLOC( (size_t) initialBytesToAllocate);
+		numberOfBitsAllocated = initialBytesToAllocate << 3;
+	}
+#ifdef _DEBUG
+	OVR_ASSERT( data );
+#endif
+	// memset(data, 0, initialBytesToAllocate);
+	copyData = true;
+}
+
+BitStream::BitStream( char* _data, const unsigned int lengthInBytes, bool _copyData )
+{
+	numberOfBitsUsed = lengthInBytes << 3;
+	readOffset = 0;
+	copyData = _copyData;
+	numberOfBitsAllocated = lengthInBytes << 3;
+
+	if ( copyData )
+	{
+		if ( lengthInBytes > 0 )
+		{
+			if (lengthInBytes < BITSTREAM_STACK_ALLOCATION_SIZE)
+			{
+				data = ( unsigned char* ) stackData;
+				numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE << 3;
+			}
+			else
+			{
+				data = ( unsigned char* ) OVR_ALLOC( (size_t) lengthInBytes);
+			}
+#ifdef _DEBUG
+			OVR_ASSERT( data );
+#endif
+			memcpy( data, _data, (size_t) lengthInBytes );
+		}
+		else
+			data = 0;
+	}
+	else
+		data = ( unsigned char* ) _data;
+}
+
+// Use this if you pass a pointer copy to the constructor (_copyData==false) and want to overallocate to prevent reallocation
+void BitStream::SetNumberOfBitsAllocated( const BitSize_t lengthInBits )
+{
+#ifdef _DEBUG
+	OVR_ASSERT( lengthInBits >= ( BitSize_t ) numberOfBitsAllocated );
+#endif	
+	numberOfBitsAllocated = lengthInBits;
+}
+
+BitStream::~BitStream()
+{
+	if ( copyData && numberOfBitsAllocated > (BITSTREAM_STACK_ALLOCATION_SIZE << 3))
+		OVR_FREE( data );  // Use realloc and free so we are more efficient than delete and new for resizing
+}
+
+void BitStream::Reset( void )
+{
+	// Note:  Do NOT reallocate memory because BitStream is used
+	// in places to serialize/deserialize a buffer. Reallocation
+	// is a dangerous operation (may result in leaks).
+
+	if ( numberOfBitsUsed > 0 )
+	{
+		//  memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
+	}
+
+	// Don't free memory here for speed efficiency
+	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
+	numberOfBitsUsed = 0;
+
+	//numberOfBitsAllocated=8;
+	readOffset = 0;
+
+	//data=(unsigned char*)OVR_ALLOC(1, _FILE_AND_LINE_);
+	// if (numberOfBitsAllocated>0)
+	//  memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
+}
+
+// Write an array or casted stream
+void BitStream::Write( const char* inputByteArray, const unsigned int numberOfBytes )
+{
+	if (numberOfBytes==0)
+		return;
+
+	// Optimization:
+	if ((numberOfBitsUsed & 7) == 0)
+	{
+		AddBitsAndReallocate( BYTES_TO_BITS(numberOfBytes) );
+		memcpy(data+BITS_TO_BYTES(numberOfBitsUsed), inputByteArray, (size_t) numberOfBytes);
+		numberOfBitsUsed+=BYTES_TO_BITS(numberOfBytes);
+	}
+	else
+	{
+		WriteBits( ( unsigned char* ) inputByteArray, numberOfBytes * 8, true );
+	}
+
+}
+void BitStream::Write( BitStream *bitStream)
+{
+	Write(bitStream, bitStream->GetNumberOfBitsUsed()-bitStream->GetReadOffset());
+}
+void BitStream::Write( BitStream *bitStream, BitSize_t numberOfBits )
+{
+	AddBitsAndReallocate( numberOfBits );
+	BitSize_t numberOfBitsMod8;
+
+	if ((bitStream->GetReadOffset()&7)==0 && (numberOfBitsUsed&7)==0)
+	{
+		int readOffsetBytes=bitStream->GetReadOffset()/8;
+		int numBytes=numberOfBits/8;
+		memcpy(data + (numberOfBitsUsed >> 3), bitStream->GetData()+readOffsetBytes, numBytes);
+		numberOfBits-=BYTES_TO_BITS(numBytes);
+		bitStream->SetReadOffset(BYTES_TO_BITS(numBytes+readOffsetBytes));
+		numberOfBitsUsed+=BYTES_TO_BITS(numBytes);
+	}
+
+	while (numberOfBits-->0 && bitStream->readOffset + 1 <= bitStream->numberOfBitsUsed)
+	{
+		numberOfBitsMod8 = numberOfBitsUsed & 7;
+		if ( numberOfBitsMod8 == 0 )
+		{
+			// New byte
+			if (bitStream->data[ bitStream->readOffset >> 3 ] & ( 0x80 >> ( bitStream->readOffset & 7 ) ) )
+			{
+				// Write 1
+				data[ numberOfBitsUsed >> 3 ] = 0x80;
+			}
+			else
+			{
+				// Write 0
+				data[ numberOfBitsUsed >> 3 ] = 0;
+			}
+
+		}
+		else
+		{
+			// Existing byte
+			if (bitStream->data[ bitStream->readOffset >> 3 ] & ( 0x80 >> ( bitStream->readOffset & 7 ) ) )
+				data[ numberOfBitsUsed >> 3 ] |= 0x80 >> ( numberOfBitsMod8 ); // Set the bit to 1
+			// else 0, do nothing
+		}
+
+		bitStream->readOffset++;
+		numberOfBitsUsed++;
+	}
+}
+void BitStream::Write( BitStream &bitStream, BitSize_t numberOfBits )
+{
+	Write(&bitStream, numberOfBits);
+}
+void BitStream::Write( BitStream &bitStream )
+{
+	Write(&bitStream);
+}
+bool BitStream::Read( BitStream *bitStream, BitSize_t numberOfBits )
+{
+	if (GetNumberOfUnreadBits() < numberOfBits)
+		return false;
+	bitStream->Write(this, numberOfBits);
+	return true;
+}
+bool BitStream::Read( BitStream *bitStream )
+{
+	bitStream->Write(this);
+	return true;
+}
+bool BitStream::Read( BitStream &bitStream, BitSize_t numberOfBits )
+{
+	if (GetNumberOfUnreadBits() < numberOfBits)
+		return false;
+	bitStream.Write(this, numberOfBits);
+	return true;
+}
+bool BitStream::Read( BitStream &bitStream )
+{
+	bitStream.Write(this);
+	return true;
+}
+
+// Read an array or casted stream
+bool BitStream::Read( char* outByteArray, const unsigned int numberOfBytes )
+{
+	// Optimization:
+	if ((readOffset & 7) == 0)
+	{
+		if ( readOffset + ( numberOfBytes << 3 ) > numberOfBitsUsed )
+			return false;
+
+		// Write the data
+		memcpy( outByteArray, data + ( readOffset >> 3 ), (size_t) numberOfBytes );
+
+		readOffset += numberOfBytes << 3;
+		return true;
+	}
+	else
+	{
+		return ReadBits( ( unsigned char* ) outByteArray, numberOfBytes * 8 );
+	}
+}
+
+// Sets the read pointer back to the beginning of your data.
+void BitStream::ResetReadPointer( void )
+{
+	readOffset = 0;
+}
+
+// Sets the write pointer back to the beginning of your data.
+void BitStream::ResetWritePointer( void )
+{
+	numberOfBitsUsed = 0;
+}
+
+// Write a 0
+void BitStream::Write0( void )
+{
+	AddBitsAndReallocate( 1 );
+
+	// New bytes need to be zeroed
+	if ( ( numberOfBitsUsed & 7 ) == 0 )
+		data[ numberOfBitsUsed >> 3 ] = 0;
+
+	numberOfBitsUsed++;
+}
+
+// Write a 1
+void BitStream::Write1( void )
+{
+	AddBitsAndReallocate( 1 );
+
+	BitSize_t numberOfBitsMod8 = numberOfBitsUsed & 7;
+
+	if ( numberOfBitsMod8 == 0 )
+		data[ numberOfBitsUsed >> 3 ] = 0x80;
+	else
+		data[ numberOfBitsUsed >> 3 ] |= 0x80 >> ( numberOfBitsMod8 ); // Set the bit to 1
+
+	numberOfBitsUsed++;
+}
+
+// Returns true if the next data read is a 1, false if it is a 0
+bool BitStream::ReadBit( void )
+{
+	bool result = ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset & 7 ) ) ) !=0;
+	readOffset++;
+	return result;
+}
+
+// Align the bitstream to the byte boundary and then write the specified number of bits.
+// This is faster than WriteBits but wastes the bits to do the alignment and requires you to call
+// SetReadToByteAlignment at the corresponding read position
+void BitStream::WriteAlignedBytes( const unsigned char* inByteArray, const unsigned int numberOfBytesToWrite )
+{
+	AlignWriteToByteBoundary();
+	Write((const char*) inByteArray, numberOfBytesToWrite);
+}
+void BitStream::EndianSwapBytes( int byteOffset, int length )
+{
+	if (DoEndianSwap())
+	{
+		ReverseBytesInPlace(data+byteOffset, length);
+	}
+}
+/// Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite
+void BitStream::WriteAlignedBytesSafe( const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite )
+{
+	if (inByteArray==0 || inputLength==0)
+	{
+		WriteCompressed((unsigned int)0);
+		return;
+	}
+	WriteCompressed(inputLength);
+	WriteAlignedBytes((const unsigned char*) inByteArray, inputLength < maxBytesToWrite ? inputLength : maxBytesToWrite);
+}
+
+// Read bits, starting at the next aligned bits. Note that the modulus 8 starting offset of the
+// sequence must be the same as was used with WriteBits. This will be a problem with packet coalescence
+// unless you byte align the coalesced packets.
+bool BitStream::ReadAlignedBytes( unsigned char* inOutByteArray, const unsigned int numberOfBytesToRead )
+{
+#ifdef _DEBUG
+	OVR_ASSERT( numberOfBytesToRead > 0 );
+#endif
+
+	if ( numberOfBytesToRead <= 0 )
+		return false;
+
+	// Byte align
+	AlignReadToByteBoundary();
+
+	if ( readOffset + ( numberOfBytesToRead << 3 ) > numberOfBitsUsed )
+		return false;
+
+	// Write the data
+	memcpy( inOutByteArray, data + ( readOffset >> 3 ), (size_t) numberOfBytesToRead );
+
+	readOffset += numberOfBytesToRead << 3;
+
+	return true;
+}
+bool BitStream::ReadAlignedBytesSafe( char *inOutByteArray, int &inputLength, const int maxBytesToRead )
+{
+	return ReadAlignedBytesSafe(inOutByteArray,(unsigned int&) inputLength,(unsigned int)maxBytesToRead);
+}
+bool BitStream::ReadAlignedBytesSafe( char *inOutByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead )
+{
+	if (ReadCompressed(inputLength)==false)
+		return false;
+	if (inputLength > maxBytesToRead)
+		inputLength=maxBytesToRead;
+	if (inputLength==0)
+		return true;
+	return ReadAlignedBytes((unsigned char*) inOutByteArray, inputLength);
+}
+bool BitStream::ReadAlignedBytesSafeAlloc( char **outByteArray, int &inputLength, const unsigned int maxBytesToRead )
+{
+	return ReadAlignedBytesSafeAlloc(outByteArray,(unsigned int&) inputLength, maxBytesToRead);
+}
+bool BitStream::ReadAlignedBytesSafeAlloc( char ** outByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead )
+{
+	OVR_FREE(*outByteArray);
+	*outByteArray=0;
+	if (ReadCompressed(inputLength)==false)
+		return false;
+	if (inputLength > maxBytesToRead)
+		inputLength=maxBytesToRead;
+	if (inputLength==0)
+		return true;
+	*outByteArray = (char*) OVR_ALLOC( (size_t) inputLength);
+	return ReadAlignedBytes((unsigned char*) *outByteArray, inputLength);
+}
+
+// Write numberToWrite bits from the input source
+void BitStream::WriteBits( const unsigned char* inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits )
+{
+//	if (numberOfBitsToWrite<=0)
+//		return;
+
+	AddBitsAndReallocate( numberOfBitsToWrite );
+
+	const BitSize_t numberOfBitsUsedMod8 = numberOfBitsUsed & 7;
+
+	// If currently aligned and numberOfBits is a multiple of 8, just memcpy for speed
+	if (numberOfBitsUsedMod8==0 && (numberOfBitsToWrite&7)==0)
+	{
+		memcpy( data + ( numberOfBitsUsed >> 3 ), inByteArray, numberOfBitsToWrite>>3);
+		numberOfBitsUsed+=numberOfBitsToWrite;
+		return;
+	}
+
+	unsigned char dataByte;
+	const unsigned char* inputPtr=inByteArray;
+
+	// Faster to put the while at the top surprisingly enough
+	while ( numberOfBitsToWrite > 0 )
+		//do
+	{
+		dataByte = *( inputPtr++ );
+
+		if ( numberOfBitsToWrite < 8 && rightAlignedBits )   // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)
+			dataByte <<= 8 - numberOfBitsToWrite;  // shift left to get the bits on the left, as in our internal representation
+
+		// Writing to a new byte each time
+		if ( numberOfBitsUsedMod8 == 0 )
+			* ( data + ( numberOfBitsUsed >> 3 ) ) = dataByte;
+		else
+		{
+			// Copy over the new data.
+			*( data + ( numberOfBitsUsed >> 3 ) ) |= dataByte >> ( numberOfBitsUsedMod8 ); // First half
+
+			if ( 8 - ( numberOfBitsUsedMod8 ) < 8 && 8 - ( numberOfBitsUsedMod8 ) < numberOfBitsToWrite )   // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
+			{
+				*( data + ( numberOfBitsUsed >> 3 ) + 1 ) = (unsigned char) ( dataByte << ( 8 - ( numberOfBitsUsedMod8 ) ) ); // Second half (overlaps byte boundary)
+			}
+		}
+
+		if ( numberOfBitsToWrite >= 8 )
+		{
+			numberOfBitsUsed += 8;
+			numberOfBitsToWrite -= 8;
+		}
+		else
+		{
+			numberOfBitsUsed += numberOfBitsToWrite;
+			numberOfBitsToWrite=0;
+		}
+	}
+	// } while(numberOfBitsToWrite>0);
+}
+
+// Set the stream to some initial data.  For internal use
+void BitStream::SetData( unsigned char *inByteArray )
+{
+	data=inByteArray;
+	copyData=false;
+}
+
+// Assume the input source points to a native type, compress and write it
+void BitStream::WriteCompressed( const unsigned char* inByteArray,
+								const unsigned int size, const bool unsignedData )
+{
+	BitSize_t currentByte = ( size >> 3 ) - 1; // PCs
+
+	unsigned char byteMatch;
+
+	if ( unsignedData )
+	{
+		byteMatch = 0;
+	}
+
+	else
+	{
+		byteMatch = 0xFF;
+	}
+
+	// Write upper bytes with a single 1
+	// From high byte to low byte, if high byte is a byteMatch then write a 1 bit. Otherwise write a 0 bit and then write the remaining bytes
+	while ( currentByte > 0 )
+	{
+		if ( inByteArray[ currentByte ] == byteMatch )   // If high byte is byteMatch (0 of 0xff) then it would have the same value shifted
+		{
+			bool b = true;
+			Write( b );
+		}
+		else
+		{
+			// Write the remainder of the data after writing 0
+			bool b = false;
+			Write( b );
+
+			WriteBits( inByteArray, ( currentByte + 1 ) << 3, true );
+			//  currentByte--;
+
+
+			return ;
+		}
+
+		currentByte--;
+	}
+
+	// If the upper half of the last byte is a 0 (positive) or 16 (negative) then write a 1 and the remaining 4 bits.  Otherwise write a 0 and the 8 bites.
+	if ( ( unsignedData && ( ( *( inByteArray + currentByte ) ) & 0xF0 ) == 0x00 ) ||
+		( unsignedData == false && ( ( *( inByteArray + currentByte ) ) & 0xF0 ) == 0xF0 ) )
+	{
+		bool b = true;
+		Write( b );
+		WriteBits( inByteArray + currentByte, 4, true );
+	}
+
+	else
+	{
+		bool b = false;
+		Write( b );
+		WriteBits( inByteArray + currentByte, 8, true );
+	}
+}
+
+// Read numberOfBitsToRead bits to the output source
+// alignBitsToRight should be set to true to convert internal bitstream data to userdata
+// It should be false if you used WriteBits with rightAlignedBits false
+bool BitStream::ReadBits( unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight )
+{
+#ifdef _DEBUG
+	//	OVR_ASSERT( numberOfBitsToRead > 0 );
+#endif
+	if (numberOfBitsToRead<=0)
+		return false;
+
+	if ( readOffset + numberOfBitsToRead > numberOfBitsUsed )
+		return false;
+
+
+	const BitSize_t readOffsetMod8 = readOffset & 7;
+
+	// If currently aligned and numberOfBits is a multiple of 8, just memcpy for speed
+	if (readOffsetMod8==0 && (numberOfBitsToRead&7)==0)
+	{
+		memcpy( inOutByteArray, data + ( readOffset >> 3 ), numberOfBitsToRead>>3);
+		readOffset+=numberOfBitsToRead;
+		return true;
+	}
+
+
+
+	BitSize_t offset = 0;
+
+	memset( inOutByteArray, 0, (size_t) BITS_TO_BYTES( numberOfBitsToRead ) );
+
+	while ( numberOfBitsToRead > 0 )
+	{
+		*( inOutByteArray + offset ) |= *( data + ( readOffset >> 3 ) ) << ( readOffsetMod8 ); // First half
+
+		if ( readOffsetMod8 > 0 && numberOfBitsToRead > 8 - ( readOffsetMod8 ) )   // If we have a second half, we didn't read enough bytes in the first half
+			*( inOutByteArray + offset ) |= *( data + ( readOffset >> 3 ) + 1 ) >> ( 8 - ( readOffsetMod8 ) ); // Second half (overlaps byte boundary)
+
+		if (numberOfBitsToRead>=8)
+		{
+			numberOfBitsToRead -= 8;
+			readOffset += 8;
+			offset++;
+		}
+		else
+		{
+			int neg = (int) numberOfBitsToRead - 8;
+
+			if ( neg < 0 )   // Reading a partial byte for the last byte, shift right so the data is aligned on the right
+			{
+
+				if ( alignBitsToRight )
+					* ( inOutByteArray + offset ) >>= -neg;
+
+				readOffset += 8 + neg;
+			}
+			else
+				readOffset += 8;
+
+			offset++;
+
+			numberOfBitsToRead=0;
+		}		
+	}
+
+	return true;
+}
+
+// Assume the input source points to a compressed native type. Decompress and read it
+bool BitStream::ReadCompressed( unsigned char* inOutByteArray,
+							   const unsigned int size, const bool unsignedData )
+{
+	unsigned int currentByte = ( size >> 3 ) - 1;
+
+
+	unsigned char byteMatch, halfByteMatch;
+
+	if ( unsignedData )
+	{
+		byteMatch = 0;
+		halfByteMatch = 0;
+	}
+
+	else
+	{
+		byteMatch = 0xFF;
+		halfByteMatch = 0xF0;
+	}
+
+	// Upper bytes are specified with a single 1 if they match byteMatch
+	// From high byte to low byte, if high byte is a byteMatch then write a 1 bit. Otherwise write a 0 bit and then write the remaining bytes
+	while ( currentByte > 0 )
+	{
+		// If we read a 1 then the data is byteMatch.
+
+		bool b;
+
+		if ( Read( b ) == false )
+			return false;
+
+		if ( b )   // Check that bit
+		{
+			inOutByteArray[ currentByte ] = byteMatch;
+			currentByte--;
+		}
+		else
+		{
+			// Read the rest of the bytes
+
+			if ( ReadBits( inOutByteArray, ( currentByte + 1 ) << 3 ) == false )
+				return false;
+
+			return true;
+		}
+	}
+
+	// All but the first bytes are byteMatch.  If the upper half of the last byte is a 0 (positive) or 16 (negative) then what we read will be a 1 and the remaining 4 bits.
+	// Otherwise we read a 0 and the 8 bytes
+	//OVR_ASSERT(readOffset+1 <=numberOfBitsUsed); // If this assert is hit the stream wasn't long enough to read from
+	if ( readOffset + 1 > numberOfBitsUsed )
+		return false;
+
+	bool b=false;
+
+	if ( Read( b ) == false )
+		return false;
+
+	if ( b )   // Check that bit
+	{
+
+		if ( ReadBits( inOutByteArray + currentByte, 4 ) == false )
+			return false;
+
+		inOutByteArray[ currentByte ] |= halfByteMatch; // We have to set the high 4 bits since these are set to 0 by ReadBits
+	}
+	else
+	{
+		if ( ReadBits( inOutByteArray + currentByte, 8 ) == false )
+			return false;
+	}
+
+	return true;
+}
+
+// Reallocates (if necessary) in preparation of writing numberOfBitsToWrite
+void BitStream::AddBitsAndReallocate( const BitSize_t numberOfBitsToWrite )
+{
+	BitSize_t newNumberOfBitsAllocated = numberOfBitsToWrite + numberOfBitsUsed;
+
+	if ( numberOfBitsToWrite + numberOfBitsUsed > 0 && ( ( numberOfBitsAllocated - 1 ) >> 3 ) < ( ( newNumberOfBitsAllocated - 1 ) >> 3 ) )   // If we need to allocate 1 or more new bytes
+	{
+#ifdef _DEBUG
+		// If this assert hits then we need to specify true for the third parameter in the constructor
+		// It needs to reallocate to hold all the data and can't do it unless we allocated to begin with
+		// Often hits if you call Write or Serialize on a read-only bitstream
+		OVR_ASSERT( copyData == true );
+#endif
+
+		// Less memory efficient but saves on news and deletes
+		/// Cap to 1 meg buffer to save on huge allocations
+		newNumberOfBitsAllocated = ( numberOfBitsToWrite + numberOfBitsUsed ) * 2;
+		if (newNumberOfBitsAllocated - ( numberOfBitsToWrite + numberOfBitsUsed ) > 1048576 )
+			newNumberOfBitsAllocated = numberOfBitsToWrite + numberOfBitsUsed + 1048576;
+
+		//		BitSize_t newByteOffset = BITS_TO_BYTES( numberOfBitsAllocated );
+		// Use realloc and free so we are more efficient than delete and new for resizing
+		BitSize_t amountToAllocate = BITS_TO_BYTES( newNumberOfBitsAllocated );
+		if (data==(unsigned char*)stackData)
+		{
+			if (amountToAllocate > BITSTREAM_STACK_ALLOCATION_SIZE)
+			{
+				data = ( unsigned char* ) OVR_ALLOC( (size_t) amountToAllocate);
+				OVR_ASSERT(data);
+
+				// need to copy the stack data over to our new memory area too
+				memcpy ((void *)data, (void *)stackData, (size_t) BITS_TO_BYTES( numberOfBitsAllocated )); 
+			}
+		}
+		else
+		{
+			data = ( unsigned char* ) OVR_REALLOC( data, (size_t) amountToAllocate);
+		}
+
+#ifdef _DEBUG
+		OVR_ASSERT( data ); // Make sure realloc succeeded
+#endif
+		//  memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
+	}
+
+	if ( newNumberOfBitsAllocated > numberOfBitsAllocated )
+		numberOfBitsAllocated = newNumberOfBitsAllocated;
+}
+BitSize_t BitStream::GetNumberOfBitsAllocated(void) const
+{
+	return numberOfBitsAllocated;
+}
+void BitStream::PadWithZeroToByteLength( unsigned int bytes )
+{
+	if (GetNumberOfBytesUsed() < bytes)
+	{
+		AlignWriteToByteBoundary();
+		unsigned int numToWrite = bytes - GetNumberOfBytesUsed();
+		AddBitsAndReallocate( BYTES_TO_BITS(numToWrite) );
+		memset(data+BITS_TO_BYTES(numberOfBitsUsed), 0, (size_t) numToWrite);
+		numberOfBitsUsed+=BYTES_TO_BITS(numToWrite);
+	}
+}
+
+/* 
+// Julius Goryavsky's version of Harley's algorithm.
+// 17 elementary ops plus an indexed load, if the machine
+// has "and not."
+
+int nlz10b(unsigned x) {
+
+   static char table[64] =
+     {32,20,19, u, u,18, u, 7,  10,17, u, u,14, u, 6, u,
+       u, 9, u,16, u, u, 1,26,   u,13, u, u,24, 5, u, u,
+       u,21, u, 8,11, u,15, u,   u, u, u, 2,27, 0,25, u,
+      22, u,12, u, u, 3,28, u,  23, u, 4,29, u, u,30,31};
+
+   x = x | (x >> 1);    // Propagate leftmost
+   x = x | (x >> 2);    // 1-bit to the right.
+   x = x | (x >> 4);
+   x = x | (x >> 8);
+   x = x & ~(x >> 16);
+   x = x*0xFD7049FF;    // Activate this line or the following 3.
+// x = (x << 9) - x;    // Multiply by 511.
+// x = (x << 11) - x;   // Multiply by 2047.
+// x = (x << 14) - x;   // Multiply by 16383.
+   return table[x >> 26];
+}
+*/
+int BitStream::NumberOfLeadingZeroes( int8_t x ) {return NumberOfLeadingZeroes((uint8_t)x);}
+int BitStream::NumberOfLeadingZeroes( uint8_t x )
+{
+	uint8_t y;
+	int n;
+
+	n = 8;
+	y = x >> 4;  if (y != 0) {n = n - 4;  x = y;}
+	y = x >> 2;  if (y != 0) {n = n - 2;  x = y;}
+	y = x >> 1;  if (y != 0) return n - 2;
+	return (int)(n - x);
+}
+int BitStream::NumberOfLeadingZeroes( int16_t x ) {return NumberOfLeadingZeroes((uint16_t)x);}
+int BitStream::NumberOfLeadingZeroes( uint16_t x )
+{
+	uint16_t y;
+	int n;
+
+	n = 16;
+	y = x >> 8;  if (y != 0) {n = n - 8;  x = y;}
+	y = x >> 4;  if (y != 0) {n = n - 4;  x = y;}
+	y = x >> 2;  if (y != 0) {n = n - 2;  x = y;}
+	y = x >> 1;  if (y != 0) return n - 2;
+	return (int)(n - x);
+}
+int BitStream::NumberOfLeadingZeroes( int32_t x ) {return NumberOfLeadingZeroes((uint32_t)x);}
+int BitStream::NumberOfLeadingZeroes( uint32_t x )
+{
+	uint32_t y;
+	int n;
+
+	n = 32;
+	y = x >>16;  if (y != 0) {n = n -16;  x = y;}
+	y = x >> 8;  if (y != 0) {n = n - 8;  x = y;}
+	y = x >> 4;  if (y != 0) {n = n - 4;  x = y;}
+	y = x >> 2;  if (y != 0) {n = n - 2;  x = y;}
+	y = x >> 1;  if (y != 0) return n - 2;
+	return (int)(n - x);
+}
+int BitStream::NumberOfLeadingZeroes( int64_t x ) {return NumberOfLeadingZeroes((uint64_t)x);}
+int BitStream::NumberOfLeadingZeroes( uint64_t x )
+{
+	uint64_t y;
+	int n;
+
+	n = 64;
+	y = x >>32;  if (y != 0) {n = n -32;  x = y;}
+	y = x >>16;  if (y != 0) {n = n -16;  x = y;}
+	y = x >> 8;  if (y != 0) {n = n - 8;  x = y;}
+	y = x >> 4;  if (y != 0) {n = n - 4;  x = y;}
+	y = x >> 2;  if (y != 0) {n = n - 2;  x = y;}
+	y = x >> 1;  if (y != 0) return n - 2;
+	return (int)(n - x);
+}
+
+// Should hit if reads didn't match writes
+void BitStream::AssertStreamEmpty( void )
+{
+	OVR_ASSERT( readOffset == numberOfBitsUsed );
+}
+void BitStream::PrintBits( char *out ) const
+{
+	if ( numberOfBitsUsed <= 0 )
+	{
+		OVR_strcpy(out, 128, "No bits\n" );
+		return;
+	}
+
+	unsigned int strIndex=0;
+	for ( BitSize_t counter = 0; counter < BITS_TO_BYTES( numberOfBitsUsed ) && strIndex < 2000 ; counter++ )
+	{
+		BitSize_t stop;
+
+		if ( counter == ( numberOfBitsUsed - 1 ) >> 3 )
+			stop = 8 - ( ( ( numberOfBitsUsed - 1 ) & 7 ) + 1 );
+		else
+			stop = 0;
+
+		for ( BitSize_t counter2 = 7; counter2 >= stop; counter2-- )
+		{
+			if ( ( data[ counter ] >> counter2 ) & 1 )
+				out[strIndex++]='1';
+			else
+				out[strIndex++]='0';
+
+			if (counter2==0)
+				break;
+		}
+
+		out[strIndex++]=' ';
+	}
+
+	out[strIndex++]='\n';
+
+	out[strIndex++]=0;
+}
+void BitStream::PrintBits( void ) const
+{
+	char out[2048];
+	PrintBits(out);
+	printf("%s", out);
+}
+void BitStream::PrintHex( char *out ) const
+{
+	BitSize_t i;
+	for ( i=0; i < GetNumberOfBytesUsed(); i++)
+	{
+		OVR_sprintf(out+i*3, 128, "%02x ", data[i]);
+	}
+}
+void BitStream::PrintHex( void ) const
+{
+	char out[2048];
+	PrintHex(out);
+	printf("%s", out);
+}
+
+// Exposes the data for you to look at, like PrintBits does.
+// Data will point to the stream.  Returns the length in bits of the stream.
+BitSize_t BitStream::CopyData( unsigned char** _data ) const
+{
+#ifdef _DEBUG
+	OVR_ASSERT( numberOfBitsUsed > 0 );
+#endif
+
+	*_data = (unsigned char*) OVR_ALLOC( (size_t) BITS_TO_BYTES( numberOfBitsUsed ));
+	memcpy( *_data, data, sizeof(unsigned char) * (size_t) ( BITS_TO_BYTES( numberOfBitsUsed ) ) );
+	return numberOfBitsUsed;
+}
+
+// Ignore data we don't intend to read
+void BitStream::IgnoreBits( const BitSize_t numberOfBits )
+{
+	readOffset += numberOfBits;
+}
+
+void BitStream::IgnoreBytes( const unsigned int numberOfBytes )
+{
+	IgnoreBits(BYTES_TO_BITS(numberOfBytes));
+}
+
+// Move the write pointer to a position on the array.  Dangerous if you don't know what you are doing!
+// Doesn't work with non-aligned data!
+void BitStream::SetWriteOffset( const BitSize_t offset )
+{
+	numberOfBitsUsed = offset;
+}
+
+/*
+BitSize_t BitStream::GetWriteOffset( void ) const
+{
+return numberOfBitsUsed;
+}
+
+// Returns the length in bits of the stream
+BitSize_t BitStream::GetNumberOfBitsUsed( void ) const
+{
+return GetWriteOffset();
+}
+
+// Returns the length in bytes of the stream
+BitSize_t BitStream::GetNumberOfBytesUsed( void ) const
+{
+return BITS_TO_BYTES( numberOfBitsUsed );
+}
+
+// Returns the number of bits into the stream that we have read
+BitSize_t BitStream::GetReadOffset( void ) const
+{
+return readOffset;
+}
+
+
+// Sets the read bit index
+void BitStream::SetReadOffset( const BitSize_t newReadOffset )
+{
+readOffset=newReadOffset;
+}
+
+// Returns the number of bits left in the stream that haven't been read
+BitSize_t BitStream::GetNumberOfUnreadBits( void ) const
+{
+return numberOfBitsUsed - readOffset;
+}
+// Exposes the internal data
+unsigned char* BitStream::GetData( void ) const
+{
+return data;
+}
+
+*/
+// If we used the constructor version with copy data off, this makes sure it is set to on and the data pointed to is copied.
+void BitStream::AssertCopyData( void )
+{
+	if ( copyData == false )
+	{
+		copyData = true;
+
+		if ( numberOfBitsAllocated > 0 )
+		{
+			unsigned char * newdata = ( unsigned char* ) OVR_ALLOC( (size_t) BITS_TO_BYTES( numberOfBitsAllocated ));
+#ifdef _DEBUG
+
+			OVR_ASSERT( data );
+#endif
+
+			memcpy( newdata, data, (size_t) BITS_TO_BYTES( numberOfBitsAllocated ) );
+			data = newdata;
+		}
+
+		else
+			data = 0;
+	}
+}
+bool BitStream::IsNetworkOrderInternal(void)
+{
+#if defined(_PS3) || defined(__PS3__) || defined(SN_TARGET_PS3)
+	return true;
+#elif defined(SN_TARGET_PSP2)
+	return false;
+#else
+	static unsigned long htonlValue = htonl(12345);
+	return htonlValue == 12345;
+#endif
+}
+void BitStream::ReverseBytes(unsigned char *inByteArray, unsigned char *inOutByteArray, const unsigned int length)
+{
+	for (BitSize_t i=0; i < length; i++)
+		inOutByteArray[i]=inByteArray[length-i-1];
+}
+void BitStream::ReverseBytesInPlace(unsigned char *inOutData,const unsigned int length)
+{
+	unsigned char temp;
+	BitSize_t i;
+	for (i=0; i < (length>>1); i++)
+	{
+		temp = inOutData[i];
+		inOutData[i]=inOutData[length-i-1];
+		inOutData[length-i-1]=temp;
+	}
+}
+
+void BitStream::WriteAlignedVar8(const char *inByteArray)
+{
+	OVR_ASSERT((numberOfBitsUsed&7)==0);
+	AddBitsAndReallocate(1*8);
+	data[( numberOfBitsUsed >> 3 ) + 0] = inByteArray[0];
+	numberOfBitsUsed+=1*8;
+}
+bool BitStream::ReadAlignedVar8(char *inOutByteArray)
+{
+	OVR_ASSERT((readOffset&7)==0);
+	if ( readOffset + 1*8 > numberOfBitsUsed )
+		return false;
+
+	inOutByteArray[0] = data[( readOffset >> 3 ) + 0];
+	readOffset+=1*8;
+	return true;
+}
+void BitStream::WriteAlignedVar16(const char *inByteArray)
+{
+	OVR_ASSERT((numberOfBitsUsed&7)==0);
+	AddBitsAndReallocate(2*8);
+#ifndef __BITSTREAM_NATIVE_END
+	if (DoEndianSwap())
+	{
+		data[( numberOfBitsUsed >> 3 ) + 0] = inByteArray[1];
+		data[( numberOfBitsUsed >> 3 ) + 1] = inByteArray[0];
+	}
+	else
+#endif
+	{
+		data[( numberOfBitsUsed >> 3 ) + 0] = inByteArray[0];
+		data[( numberOfBitsUsed >> 3 ) + 1] = inByteArray[1];
+	}
+
+	numberOfBitsUsed+=2*8;
+}
+bool BitStream::ReadAlignedVar16(char *inOutByteArray)
+{
+	OVR_ASSERT((readOffset&7)==0);
+	if ( readOffset + 2*8 > numberOfBitsUsed )
+		return false;
+#ifndef __BITSTREAM_NATIVE_END
+	if (DoEndianSwap())
+	{
+		inOutByteArray[0] = data[( readOffset >> 3 ) + 1];
+		inOutByteArray[1] = data[( readOffset >> 3 ) + 0];
+	}
+	else
+#endif
+	{
+		inOutByteArray[0] = data[( readOffset >> 3 ) + 0];
+		inOutByteArray[1] = data[( readOffset >> 3 ) + 1];
+	}
+
+	readOffset+=2*8;
+	return true;
+}
+void BitStream::WriteAlignedVar32(const char *inByteArray)
+{
+	OVR_ASSERT((numberOfBitsUsed&7)==0);
+	AddBitsAndReallocate(4*8);
+#ifndef __BITSTREAM_NATIVE_END
+	if (DoEndianSwap())
+	{
+		data[( numberOfBitsUsed >> 3 ) + 0] = inByteArray[3];
+		data[( numberOfBitsUsed >> 3 ) + 1] = inByteArray[2];
+		data[( numberOfBitsUsed >> 3 ) + 2] = inByteArray[1];
+		data[( numberOfBitsUsed >> 3 ) + 3] = inByteArray[0];
+	}
+	else
+#endif
+	{
+		data[( numberOfBitsUsed >> 3 ) + 0] = inByteArray[0];
+		data[( numberOfBitsUsed >> 3 ) + 1] = inByteArray[1];
+		data[( numberOfBitsUsed >> 3 ) + 2] = inByteArray[2];
+		data[( numberOfBitsUsed >> 3 ) + 3] = inByteArray[3];
+	}
+
+	numberOfBitsUsed+=4*8;
+}
+bool BitStream::ReadAlignedVar32(char *inOutByteArray)
+{
+	OVR_ASSERT((readOffset&7)==0);
+	if ( readOffset + 4*8 > numberOfBitsUsed )
+		return false;
+#ifndef __BITSTREAM_NATIVE_END
+	if (DoEndianSwap())
+	{
+		inOutByteArray[0] = data[( readOffset >> 3 ) + 3];
+		inOutByteArray[1] = data[( readOffset >> 3 ) + 2];
+		inOutByteArray[2] = data[( readOffset >> 3 ) + 1];
+		inOutByteArray[3] = data[( readOffset >> 3 ) + 0];
+	}
+	else
+#endif
+	{
+		inOutByteArray[0] = data[( readOffset >> 3 ) + 0];
+		inOutByteArray[1] = data[( readOffset >> 3 ) + 1];
+		inOutByteArray[2] = data[( readOffset >> 3 ) + 2];
+		inOutByteArray[3] = data[( readOffset >> 3 ) + 3];
+	}
+
+	readOffset+=4*8;
+	return true;
+}
+bool BitStream::ReadFloat16( float &outFloat, float floatMin, float floatMax )
+{
+	uint16_t percentile;
+	if (Read(percentile))
+	{
+		OVR_ASSERT(floatMax>floatMin);
+		outFloat = floatMin + ((float) percentile / 65535.0f) * (floatMax-floatMin);
+		if (outFloat<floatMin)
+			outFloat=floatMin;
+		else if (outFloat>floatMax)
+			outFloat=floatMax;
+		return true;
+	}
+	return false;
+}
+bool BitStream::SerializeFloat16(bool writeToBitstream, float &inOutFloat, float floatMin, float floatMax)
+{
+	if (writeToBitstream)
+		WriteFloat16(inOutFloat, floatMin, floatMax);
+	else
+		return ReadFloat16(inOutFloat, floatMin, floatMax);
+	return true;
+}
+void BitStream::WriteFloat16( float inOutFloat, float floatMin, float floatMax )
+{
+	OVR_ASSERT(floatMax>floatMin);
+	if (inOutFloat>floatMax+.001)
+	{
+		OVR_ASSERT(inOutFloat<=floatMax+.001);
+	}
+	if (inOutFloat<floatMin-.001)
+	{
+		OVR_ASSERT(inOutFloat>=floatMin-.001);
+	}
+	float percentile=65535.0f * (inOutFloat-floatMin)/(floatMax-floatMin);
+	if (percentile<0.0)
+		percentile=0.0;
+	if (percentile>65535.0f)
+		percentile=65535.0f;
+	Write((uint16_t)percentile);
+}
+
+
+}} // OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1746 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_BitStream.h
+Content     :   A generic serialization toolkit for packing data to a binary stream.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Bitstream_h
+#define OVR_Bitstream_h
+
+#include <math.h>
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Std.h"
+#include "../Kernel/OVR_String.h"
+
+namespace OVR { namespace Net {
+
+typedef uint32_t BitSize_t;
+#define BITSTREAM_STACK_ALLOCATION_SIZE 256
+#define BITS_TO_BYTES(x) (((x)+7)>>3)
+#define BYTES_TO_BITS(x) ((x)<<3)
+
+
+//-----------------------------------------------------------------------------
+// BitStream
+
+// Generic serialization class to binary stream
+class BitStream : public NewOverrideBase
+{
+public:
+	/// Default Constructor
+	BitStream();
+
+	/// \brief Create the bitstream, with some number of bytes to immediately allocate.
+	/// \details There is no benefit to calling this, unless you know exactly how many bytes you need and it is greater than BITSTREAM_STACK_ALLOCATION_SIZE.
+	/// In that case all it does is save you one or more realloc calls.
+	/// \param[in] initialBytesToAllocate the number of bytes to pre-allocate.
+	BitStream( const unsigned int initialBytesToAllocate );
+
+	/// \brief Initialize the BitStream, immediately setting the data it contains to a predefined pointer.
+	/// \details Set \a _copyData to true if you want to make an internal copy of the data you are passing. Set it to false to just save a pointer to the data.
+	/// You shouldn't call Write functions with \a _copyData as false, as this will write to unallocated memory
+	/// 99% of the time you will use this function to cast Packet::data to a bitstream for reading, in which case you should write something as follows:
+	/// \code
+	/// RakNet::BitStream bs(packet->data, packet->length, false);
+	/// \endcode
+	/// \param[in] _data An array of bytes.
+	/// \param[in] lengthInBytes Size of the \a _data.
+	/// \param[in] _copyData true or false to make a copy of \a _data or not.
+	BitStream( char* _data, const unsigned int lengthInBytes, bool _copyData );
+
+	// Destructor
+	~BitStream();
+
+public:
+	/// Resets the bitstream for reuse.
+	void Reset( void );
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutTemplateVar The value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool Serialize(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream. 
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \param[in] lastValue The last value to compare against.  Only used if \a writeToBitstream is true.
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue);
+
+	/// \brief Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutTemplateVar The value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeCompressed(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \param[in] lastValue The last value to compare against.  Only used if \a writeToBitstream is true.
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue);
+
+	/// \brief Save as SerializeCompressedDelta(templateType &currentValue, const templateType &lastValue) when we have an unknown second parameter
+	/// \return true on data read. False on insufficient data in bitstream
+	template <class templateType>
+	bool SerializeCompressedDelta(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize an array or casted stream or raw data.  This does NOT do endian swapping.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutByteArray a byte buffer
+	/// \param[in] numberOfBytes the size of \a input in bytes
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	bool Serialize(bool writeToBitstream,  char* inOutByteArray, const unsigned int numberOfBytes );
+
+	/// \brief Serialize a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutFloat The float to write
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	bool SerializeFloat16(bool writeToBitstream, float &inOutFloat, float floatMin, float floatMax);
+
+	/// Serialize one type casted to another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num=53; SerializeCasted<uint8_t>(true, num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes)
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] value The value to serialize
+	template <class serializationType, class sourceType >
+	bool SerializeCasted( bool writeToBitstream, sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then serialize only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] value Integer value to write, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates
+	template <class templateType>
+	bool SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	bool SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeNormVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z );
+
+	/// \brief Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z );
+
+	/// \brief Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeNormQuat(bool writeToBitstream,  templateType &w, templateType &x, templateType &y, templateType &z);
+
+	/// \brief Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeOrthMatrix(
+		bool writeToBitstream,
+		templateType &m00, templateType &m01, templateType &m02,
+		templateType &m10, templateType &m11, templateType &m12,
+		templateType &m20, templateType &m21, templateType &m22 );
+
+	/// \brief Bidirectional serialize/deserialize numberToSerialize bits to/from the input. 
+	/// \details Right aligned data means in the case of a partial byte, the bits are aligned
+	/// from the right (bit 0) rather than the left (as in the normal
+	/// internal representation) You would set this to true when
+	/// writing user data, and false when copying bitstream data, such
+	/// as writing one bitstream to another
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutByteArray The data
+	/// \param[in] numberOfBitsToSerialize The number of bits to write
+	/// \param[in] rightAlignedBits if true data will be right aligned
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	bool SerializeBits(bool writeToBitstream, unsigned char* inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits = true );
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void Write(const templateType &inTemplateVar);
+
+	/// \brief Write the dereferenced pointer to any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void WritePtr(templateType *inTemplateVar);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <class templateType>
+	void WriteDelta(const templateType &currentValue, const templateType &lastValue);
+
+	/// \brief WriteDelta when you don't know what the last value is, or there is no last value.
+	/// \param[in] currentValue The current value to write
+	template <class templateType>
+	void WriteDelta(const templateType &currentValue);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void WriteCompressed(const templateType &inTemplateVar);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <class templateType>
+	void WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue);
+
+	/// \brief Save as WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue) when we have an unknown second parameter
+	template <class templateType>
+	void WriteCompressedDelta(const templateType &currentValue);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details Define __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool Read(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details If the written value differed from the value compared against in the write function,
+	/// var will be updated.  Otherwise it will retain the current value.
+	/// ReadDelta is only valid from a previous call to WriteDelta
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadDelta(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadCompressed(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details If the written value differed from the value compared against in the write function,
+	/// var will be updated.  Otherwise it will retain the current value.
+	/// the current value will be updated.
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// ReadCompressedDelta is only valid from a previous call to WriteDelta
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadCompressedDelta(templateType &outTemplateVar);
+
+	/// \brief Read one bitstream to another.
+	/// \param[in] numberOfBits bits to read
+	/// \param bitStream the bitstream to read into from
+	/// \return true on success, false on failure.
+	bool Read( BitStream *bitStream, BitSize_t numberOfBits );
+	bool Read( BitStream *bitStream );
+	bool Read( BitStream &bitStream, BitSize_t numberOfBits );
+	bool Read( BitStream &bitStream );
+
+	/// \brief Write an array or casted stream or raw data.  This does NOT do endian swapping.
+	/// \param[in] inputByteArray a byte buffer
+	/// \param[in] numberOfBytes the size of \a input in bytes
+	void Write( const char* inputByteArray, const unsigned int numberOfBytes );
+
+	/// \brief Write one bitstream to another.
+	/// \param[in] numberOfBits bits to write
+	/// \param bitStream the bitstream to copy from
+	void Write( BitStream *bitStream, BitSize_t numberOfBits );
+	void Write( BitStream *bitStream );
+	void Write( BitStream &bitStream, BitSize_t numberOfBits );
+	void Write( BitStream &bitStream );\
+
+	/// \brief Write a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] x The float to write
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	void WriteFloat16( float x, float floatMin, float floatMax );
+
+	/// Write one type serialized as another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num=53; WriteCasted<uint8_t>(num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes)
+	/// \param[in] value The value to write
+	template <class serializationType, class sourceType >
+	void WriteCasted( const sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then write only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] value Integer value to write, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates. This should match the corresponding value passed to Read().
+	template <class templateType>
+	void WriteBitsFromIntegerRange( const templateType value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	void WriteBitsFromIntegerRange( const templateType value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteNormVector( templateType x, templateType y, templateType z );
+
+	/// \brief Write a vector, using 10 bytes instead of 12.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, 
+	/// so only use if accuracy is not important.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteVector( templateType x, templateType y, templateType z );
+
+	/// \brief Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.  Slightly lossy.
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteNormQuat( templateType w, templateType x, templateType y, templateType z);
+
+	/// \brief Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteOrthMatrix(
+		templateType m00, templateType m01, templateType m02,
+		templateType m10, templateType m11, templateType m12,
+		templateType m20, templateType m21, templateType m22 );
+
+	/// \brief Read an array or casted stream of byte.
+	/// \details The array is raw data. There is no automatic endian conversion with this function
+	/// \param[in] output The result byte array. It should be larger than @em numberOfBytes.
+	/// \param[in] numberOfBytes The number of byte to read
+	/// \return true on success false if there is some missing bytes.
+	bool Read( char* output, const unsigned int numberOfBytes );
+
+	/// \brief Read a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] outFloat The float to read
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	bool ReadFloat16( float &outFloat, float floatMin, float floatMax );
+
+	/// Read one type serialized to another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num; ReadCasted<uint8_t>(num); would read 1 bytefrom the stream, and put the value in an integer
+	/// \param[in] value The value to write
+	template <class serializationType, class sourceType >
+	bool ReadCasted( sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then read only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] value Integer value to read, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates. This should match the corresponding value passed to Write().
+	template <class templateType>
+	bool ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	bool ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadNormVector( templateType &x, templateType &y, templateType &z );
+
+	/// \brief Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, 
+	/// so only use if accuracy is not important.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadVector( templateType &x, templateType &y, templateType &z );
+
+	/// \brief Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadNormQuat( templateType &w, templateType &x, templateType &y, templateType &z);
+
+	/// \brief Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadOrthMatrix(
+		templateType &m00, templateType &m01, templateType &m02,
+		templateType &m10, templateType &m11, templateType &m12,
+		templateType &m20, templateType &m21, templateType &m22 );
+
+	/// \brief Sets the read pointer back to the beginning of your data.
+	void ResetReadPointer( void );
+
+	/// \brief Sets the write pointer back to the beginning of your data.
+	void ResetWritePointer( void );
+
+	/// \brief This is good to call when you are done with the stream to make
+	/// sure you didn't leave any data left over void
+	void AssertStreamEmpty( void );
+
+	/// \brief RAKNET_DEBUG_PRINTF the bits in the stream.  Great for debugging.
+	void PrintBits( char *out ) const;
+	void PrintBits( void ) const;
+	void PrintHex( char *out ) const;
+	void PrintHex( void ) const;
+
+	/// \brief Ignore data we don't intend to read
+	/// \param[in] numberOfBits The number of bits to ignore
+	void IgnoreBits( const BitSize_t numberOfBits );
+
+	/// \brief Ignore data we don't intend to read
+	/// \param[in] numberOfBits The number of bytes to ignore
+	void IgnoreBytes( const unsigned int numberOfBytes );
+
+	/// \brief Move the write pointer to a position on the array.
+	/// \param[in] offset the offset from the start of the array.
+	/// \attention
+	/// \details Dangerous if you don't know what you are doing!
+	/// For efficiency reasons you can only write mid-stream if your data is byte aligned.
+	void SetWriteOffset( const BitSize_t offset );
+
+	/// \brief Returns the length in bits of the stream
+	inline BitSize_t GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}
+	inline BitSize_t GetWriteOffset( void ) const {return numberOfBitsUsed;}
+
+	/// \brief Returns the length in bytes of the stream
+	inline BitSize_t GetNumberOfBytesUsed( void ) const {return BITS_TO_BYTES( numberOfBitsUsed );}
+
+	/// \brief Returns the number of bits into the stream that we have read
+	inline BitSize_t GetReadOffset( void ) const {return readOffset;}
+
+	/// \brief Sets the read bit index
+	void SetReadOffset( const BitSize_t newReadOffset ) {readOffset=newReadOffset;}
+
+	/// \brief Returns the number of bits left in the stream that haven't been read
+	inline BitSize_t GetNumberOfUnreadBits( void ) const {return numberOfBitsUsed - readOffset;}
+
+	/// \brief Makes a copy of the internal data for you \a _data will point to
+	/// the stream. Partial bytes are left aligned.
+	/// \param[out] _data The allocated copy of GetData()
+	/// \return The length in bits of the stream.
+	BitSize_t CopyData( unsigned char** _data ) const;
+
+	/// \internal
+	/// Set the stream to some initial data.
+	void SetData( unsigned char *inByteArray );
+
+	/// Gets the data that BitStream is writing to / reading from.
+	/// Partial bytes are left aligned.
+	/// \return A pointer to the internal state
+	inline char* GetData( void ) const {return (char*) data;}
+
+	/// \brief Write numberToWrite bits from the input source.
+	/// \details Right aligned data means in the case of a partial byte, the bits are aligned
+	/// from the right (bit 0) rather than the left (as in the normal
+	/// internal representation) You would set this to true when
+	/// writing user data, and false when copying bitstream data, such
+	/// as writing one bitstream to another.
+	/// \param[in] inByteArray The data
+	/// \param[in] numberOfBitsToWrite The number of bits to write
+	/// \param[in] rightAlignedBits if true data will be right aligned
+	void WriteBits( const unsigned char* inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits = true );
+
+	/// \brief Align the bitstream to the byte boundary and then write the
+	/// specified number of bits.  
+	/// \details This is faster than WriteBits but
+	/// wastes the bits to do the alignment and requires you to call
+	/// ReadAlignedBits at the corresponding read position.
+	/// \param[in] inByteArray The data
+	/// \param[in] numberOfBytesToWrite The size of input.
+	void WriteAlignedBytes( const unsigned char *inByteArray, const unsigned int numberOfBytesToWrite );
+
+	// Endian swap bytes already in the bitstream
+	void EndianSwapBytes( int byteOffset, int length );
+
+	/// \brief Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite
+	/// \param[in] inByteArray The data
+	/// \param[in] inputLength The size of input.
+	/// \param[in] maxBytesToWrite Max bytes to write
+	void WriteAlignedBytesSafe( const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite );
+
+	/// \brief Read bits, starting at the next aligned bits. 
+	/// \details Note that the modulus 8 starting offset of the sequence must be the same as
+	/// was used with WriteBits. This will be a problem with packet
+	/// coalescence unless you byte align the coalesced packets.
+	/// \param[in] inOutByteArray The byte array larger than @em numberOfBytesToRead
+	/// \param[in] numberOfBytesToRead The number of byte to read from the internal state
+	/// \return true if there is enough byte.
+	bool ReadAlignedBytes( unsigned char *inOutByteArray, const unsigned int numberOfBytesToRead );
+
+	/// \brief Reads what was written by WriteAlignedBytesSafe.
+	/// \param[in] inOutByteArray The data
+	/// \param[in] maxBytesToRead Maximum number of bytes to read
+	/// \return true on success, false on failure.
+	bool ReadAlignedBytesSafe( char *inOutByteArray, int &inputLength, const int maxBytesToRead );
+	bool ReadAlignedBytesSafe( char *inOutByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead );
+
+	/// \brief Same as ReadAlignedBytesSafe() but allocates the memory for you using new, rather than assuming it is safe to write to
+	/// \param[in] outByteArray outByteArray will be deleted if it is not a pointer to 0
+	/// \return true on success, false on failure.
+	bool ReadAlignedBytesSafeAlloc( char **outByteArray, int &inputLength, const unsigned int maxBytesToRead );
+	bool ReadAlignedBytesSafeAlloc( char **outByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead );
+
+	/// \brief Align the next write and/or read to a byte boundary.  
+	/// \details This can be used to 'waste' bits to byte align for efficiency reasons It
+	/// can also be used to force coalesced bitstreams to start on byte
+	/// boundaries so so WriteAlignedBits and ReadAlignedBits both
+	/// calculate the same offset when aligning.
+	inline void AlignWriteToByteBoundary( void ) {numberOfBitsUsed += 8 - ( (( numberOfBitsUsed - 1 ) & 7) + 1 );}
+
+	/// \brief Align the next write and/or read to a byte boundary.  
+	/// \details This can be used to 'waste' bits to byte align for efficiency reasons It
+	/// can also be used to force coalesced bitstreams to start on byte
+	/// boundaries so so WriteAlignedBits and ReadAlignedBits both
+	/// calculate the same offset when aligning.
+	inline void AlignReadToByteBoundary( void ) {readOffset += 8 - ( (( readOffset - 1 ) & 7 ) + 1 );}
+
+	/// \brief Read \a numberOfBitsToRead bits to the output source.
+	/// \details alignBitsToRight should be set to true to convert internal
+	/// bitstream data to userdata. It should be false if you used
+	/// WriteBits with rightAlignedBits false
+	/// \param[in] inOutByteArray The resulting bits array
+	/// \param[in] numberOfBitsToRead The number of bits to read
+	/// \param[in] alignBitsToRight if true bits will be right aligned.
+	/// \return true if there is enough bits to read
+	bool ReadBits( unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight = true );
+
+	/// \brief Write a 0
+	void Write0( void );
+
+	/// \brief Write a 1
+	void Write1( void );
+
+	/// \brief Reads 1 bit and returns true if that bit is 1 and false if it is 0.
+	bool ReadBit( void );
+
+	/// \brief If we used the constructor version with copy data off, this
+	/// *makes sure it is set to on and the data pointed to is copied.
+	void AssertCopyData( void );
+
+	/// \brief Use this if you pass a pointer copy to the constructor
+	/// *(_copyData==false) and want to overallocate to prevent
+	/// reallocation.
+	void SetNumberOfBitsAllocated( const BitSize_t lengthInBits );
+
+	/// \brief Reallocates (if necessary) in preparation of writing numberOfBitsToWrite
+	void AddBitsAndReallocate( const BitSize_t numberOfBitsToWrite );
+
+	/// \internal
+	/// \return How many bits have been allocated internally
+	BitSize_t GetNumberOfBitsAllocated(void) const;
+
+	/// Write zeros until the bitstream is filled up to \a bytes
+	void PadWithZeroToByteLength( unsigned int bytes );
+
+	/// Get the number of leading zeros for a number
+	/// \param[in] x Number to test
+	static int NumberOfLeadingZeroes( uint8_t x );
+	static int NumberOfLeadingZeroes( uint16_t x );
+	static int NumberOfLeadingZeroes( uint32_t x );
+	static int NumberOfLeadingZeroes( uint64_t x );
+	static int NumberOfLeadingZeroes( int8_t x );
+	static int NumberOfLeadingZeroes( int16_t x );
+	static int NumberOfLeadingZeroes( int32_t x );
+	static int NumberOfLeadingZeroes( int64_t x );
+
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar8(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar8(char *inOutByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar16(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar16(char *inOutByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar32(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar32(char *inOutByteArray);
+
+	inline void Write(const char * const inStringVar)
+	{
+		uint16_t l = (uint16_t) OVR_strlen(inStringVar);
+		Write(l);
+		WriteAlignedBytes((const unsigned char*) inStringVar, (const unsigned int) l);
+	}
+	inline void Write(const unsigned char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+	inline void Write(char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+	inline void Write(unsigned char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+
+	/// ---- Member function template specialization declarations ----
+	// Used for VC7
+#if defined(OVR_CC_MSVC) && _MSC_VER == 1300
+	/// Write a bool to a bitstream.
+	/// \param[in] var The value to write
+	template <>
+	void Write(const bool &var);
+
+	/// Write a RakNetGUID to a bitsteam
+	/// \param[in] var The value to write
+	template <>
+	void Write(const RakNetGuid &var);
+
+	/// Write a string to a bitstream
+	/// \param[in] var The value to write
+	template <>
+	void Write(const char* const &var);
+	template <>
+	void Write(const unsigned char* const &var);
+	template <>
+	void Write(char* const &var);
+	template <>
+	void Write(unsigned char* const &var);
+	template <>
+	void Write(const OVR::String &var);
+
+	/// \brief Write a bool delta.  
+	/// \details Same thing as just calling Write
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <>
+	void WriteDelta(const bool &currentValue, const bool &lastValue);
+
+	template <>
+	void WriteCompressed(const bool &var);
+
+	/// For values between -1 and 1
+	template <>
+	void WriteCompressed(const float &var);
+
+	/// For values between -1 and 1
+	template <>
+	void WriteCompressed(const double &var);
+	
+	/// \brief Write a bool delta.  
+	/// \details Same thing as just calling Write
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <>
+	void WriteCompressedDelta(const bool &currentValue, const bool &lastValue);
+
+	/// \brief Save as WriteCompressedDelta(bool currentValue, const templateType &lastValue) 
+	/// when we have an unknown second bool
+	template <>
+	void WriteCompressedDelta(const bool &currentValue);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool Read(bool &var);
+
+	/// \brief Read a String from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool Read(char *&var);
+	template <>
+	bool Read(wchar_t *&var);
+	template <>
+	bool Read(unsigned char *&var);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadDelta(bool &var);
+
+	template <>
+	bool ReadCompressed(bool &var);
+
+	template <>
+	bool ReadCompressed(float &var);
+
+	/// For values between -1 and 1
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadCompressed(double &var);
+
+	template <>
+	bool ReadCompressed(char* &var);
+	template <>
+	bool ReadCompressed(wchar_t* &var);
+	template <>
+	bool ReadCompressed(unsigned char *&var);
+	template <>
+	bool ReadCompressed(OVR::String &var);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadCompressedDelta(bool &var);
+#endif
+
+	inline static bool DoEndianSwap(void) {
+#ifndef __BITSTREAM_NATIVE_END
+		return IsNetworkOrder()==false;
+#else
+		return false;
+#endif
+	}
+	inline static bool IsBigEndian(void)
+	{
+		return IsNetworkOrder();
+	}
+	inline static bool IsNetworkOrder(void) {bool r = IsNetworkOrderInternal(); return r;}
+	// Not inline, won't compile on PC due to winsock include errors
+	static bool IsNetworkOrderInternal(void);
+	static void ReverseBytes(unsigned char *inByteArray, unsigned char *inOutByteArray, const unsigned int length);
+	static void ReverseBytesInPlace(unsigned char *inOutData,const unsigned int length);
+
+private:
+
+	BitStream( const BitStream &invalid) {
+		(void) invalid;
+		OVR_ASSERT(0);
+	}
+
+	BitStream& operator = ( const BitStream& invalid ) {
+		(void) invalid;
+		OVR_ASSERT(0);
+		static BitStream i;
+		return i;
+	}
+
+	/// \brief Assume the input source points to a native type, compress and write it.
+	void WriteCompressed( const unsigned char* inByteArray, const unsigned int size, const bool unsignedData );
+
+	/// \brief Assume the input source points to a compressed native type. Decompress and read it.
+	bool ReadCompressed( unsigned char* inOutByteArray,	const unsigned int size, const bool unsignedData );
+
+
+	BitSize_t numberOfBitsUsed;
+
+	BitSize_t numberOfBitsAllocated;
+
+	BitSize_t readOffset;
+
+	unsigned char *data;
+
+	/// true if the internal buffer is copy of the data passed to the constructor
+	bool copyData;
+
+	/// BitStreams that use less than BITSTREAM_STACK_ALLOCATION_SIZE use the stack, rather than the heap to store data.  It switches over if BITSTREAM_STACK_ALLOCATION_SIZE is exceeded
+	unsigned char stackData[BITSTREAM_STACK_ALLOCATION_SIZE];
+};
+
+template <class templateType>
+inline bool BitStream::Serialize(bool writeToBitstream, templateType &inOutTemplateVar)
+{
+	if (writeToBitstream)
+		Write(inOutTemplateVar);
+	else
+		return Read(inOutTemplateVar);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue)
+{
+	if (writeToBitstream)
+		WriteDelta(inOutCurrentValue, lastValue);
+	else
+		return ReadDelta(inOutCurrentValue);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue)
+{
+	if (writeToBitstream)
+		WriteDelta(inOutCurrentValue);
+	else
+		return ReadDelta(inOutCurrentValue);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeCompressed(bool writeToBitstream, templateType &inOutTemplateVar)
+{
+	if (writeToBitstream)
+		WriteCompressed(inOutTemplateVar);
+	else
+		return ReadCompressed(inOutTemplateVar);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue)
+{
+	if (writeToBitstream)
+		WriteCompressedDelta(inOutCurrentValue,lastValue);
+	else
+		return ReadCompressedDelta(inOutCurrentValue);
+	return true;
+}
+//Stoppedhere
+template <class templateType>
+inline bool BitStream::SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue)
+{
+	if (writeToBitstream)
+		WriteCompressedDelta(inOutCurrentValue);
+	else
+		return ReadCompressedDelta(inOutCurrentValue);
+	return true;
+}
+
+inline bool BitStream::Serialize(bool writeToBitstream, char* inOutByteArray, const unsigned int numberOfBytes )
+{
+	if (writeToBitstream)
+		Write(inOutByteArray, numberOfBytes);
+	else
+		return Read(inOutByteArray, numberOfBytes);
+	return true;
+}
+
+template <class serializationType, class sourceType >
+bool BitStream::SerializeCasted( bool writeToBitstream, sourceType &value )
+{
+	if (writeToBitstream) WriteCasted<serializationType>(value);
+	else return ReadCasted<serializationType>(value);
+	return true;
+}
+
+template <class templateType>
+bool BitStream::SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	return SerializeBitsFromIntegerRange(writeToBitstream,value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+bool BitStream::SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	if (writeToBitstream) WriteBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+	else return ReadBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeNormVector(bool writeToBitstream, templateType &x, templateType &y, templateType &z )
+{
+	if (writeToBitstream)
+		WriteNormVector(x,y,z);
+	else
+		return ReadNormVector(x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z )
+{
+	if (writeToBitstream)
+		WriteVector(x,y,z);
+	else
+		return ReadVector(x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeNormQuat(bool writeToBitstream,  templateType &w, templateType &x, templateType &y, templateType &z)
+{
+	if (writeToBitstream)
+		WriteNormQuat(w,x,y,z);
+	else
+		return ReadNormQuat(w,x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeOrthMatrix(
+	bool writeToBitstream,
+	templateType &m00, templateType &m01, templateType &m02,
+	templateType &m10, templateType &m11, templateType &m12,
+	templateType &m20, templateType &m21, templateType &m22 )
+{
+	if (writeToBitstream)
+		WriteOrthMatrix(m00,m01,m02,m10,m11,m12,m20,m21,m22);
+	else
+		return ReadOrthMatrix(m00,m01,m02,m10,m11,m12,m20,m21,m22);
+	return true;
+}
+
+inline bool BitStream::SerializeBits(bool writeToBitstream, unsigned char* inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits )
+{
+	if (writeToBitstream)
+		WriteBits(inOutByteArray,numberOfBitsToSerialize,rightAlignedBits);
+	else
+		return ReadBits(inOutByteArray,numberOfBitsToSerialize,rightAlignedBits);
+	return true;
+}
+
+template <class templateType>
+inline void BitStream::Write(const templateType &inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(inTemplateVar)==1)
+		WriteBits( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));
+			WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteBits( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <class templateType>
+inline void BitStream::WritePtr(templateType *inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(templateType)==1)
+		WriteBits( ( unsigned char* ) inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*) inTemplateVar, output, sizeof(templateType));
+			WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteBits( ( unsigned char* ) inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+/// \brief Write a bool to a bitstream.
+/// \param[in] inTemplateVar The value to write
+template <>
+inline void BitStream::Write(const bool &inTemplateVar)
+{
+	if ( inTemplateVar )
+		Write1();
+	else
+		Write0();
+}
+
+
+/// \brief Write a string to a bitstream.
+/// \param[in] var The value to write
+template <>
+inline void BitStream::Write(const OVR::String &inTemplateVar)
+{
+	uint16_t l = (uint16_t) inTemplateVar.GetLength();
+	Write(l);
+	WriteAlignedBytes((const unsigned char*) inTemplateVar.ToCStr(), (const unsigned int) l);
+}
+template <>
+inline void BitStream::Write(const char * const &inStringVar)
+{
+	uint16_t l = (uint16_t) strlen(inStringVar);
+	Write(l);
+	WriteAlignedBytes((const unsigned char*) inStringVar, (const unsigned int) l);
+}
+template <>
+inline void BitStream::Write(const unsigned char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+template <>
+inline void BitStream::Write(char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+template <>
+inline void BitStream::Write(unsigned char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details If the current value is different from the last value
+/// the current value will be written.  Otherwise, a single bit will be written
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <class templateType>
+inline void BitStream::WriteDelta(const templateType &currentValue, const templateType &lastValue)
+{
+	if (currentValue==lastValue)
+	{
+		Write(false);
+	}
+	else
+	{
+		Write(true);
+		Write(currentValue);
+	}
+}
+
+/// \brief Write a bool delta. Same thing as just calling Write
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <>
+inline void BitStream::WriteDelta(const bool &currentValue, const bool &lastValue)
+{
+	(void) lastValue;
+
+	Write(currentValue);
+}
+
+/// \brief WriteDelta when you don't know what the last value is, or there is no last value.
+/// \param[in] currentValue The current value to write
+template <class templateType>
+inline void BitStream::WriteDelta(const templateType &currentValue)
+{
+	Write(true);
+	Write(currentValue);
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] inTemplateVar The value to write
+template <class templateType>
+inline void BitStream::WriteCompressed(const templateType &inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(inTemplateVar)==1)
+		WriteCompressed( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'uint16_t', possible loss of data
+#endif
+
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));
+			WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteCompressed( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <>
+inline void BitStream::WriteCompressed(const bool &inTemplateVar)
+{
+	Write(inTemplateVar);
+}
+
+/// For values between -1 and 1
+template <>
+inline void BitStream::WriteCompressed(const float &inTemplateVar)
+{
+	OVR_ASSERT(inTemplateVar > -1.01f && inTemplateVar < 1.01f);
+	float varCopy=inTemplateVar;
+	if (varCopy < -1.0f)
+		varCopy=-1.0f;
+	if (varCopy > 1.0f)
+		varCopy=1.0f;
+	Write((uint16_t)((varCopy+1.0f)*32767.5f));
+}
+
+/// For values between -1 and 1
+template <>
+inline void BitStream::WriteCompressed(const double &inTemplateVar)
+{
+	OVR_ASSERT(inTemplateVar > -1.01 && inTemplateVar < 1.01);
+	double varCopy=inTemplateVar;
+	if (varCopy < -1.0f)
+		varCopy=-1.0f;
+	if (varCopy > 1.0f)
+		varCopy=1.0f;
+	Write((uint32_t)((varCopy+1.0)*2147483648.0));
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details If the current value is different from the last value
+/// the current value will be written.  Otherwise, a single bit will be written
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <class templateType>
+inline void BitStream::WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue)
+{
+	if (currentValue==lastValue)
+	{
+		Write(false);
+	}
+	else
+	{
+		Write(true);
+		WriteCompressed(currentValue);
+	}
+}
+
+/// \brief Write a bool delta.  Same thing as just calling Write
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <>
+inline void BitStream::WriteCompressedDelta(const bool &currentValue, const bool &lastValue)
+{
+	(void) lastValue;
+
+	Write(currentValue);
+}
+
+/// \brief Save as WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue) 
+/// when we have an unknown second parameter
+template <class templateType>
+inline void BitStream::WriteCompressedDelta(const templateType &currentValue)
+{
+	Write(true);
+	WriteCompressed(currentValue);
+}
+
+/// \brief Save as WriteCompressedDelta(bool currentValue, const templateType &lastValue) 
+/// when we have an unknown second bool
+template <>
+inline void BitStream::WriteCompressedDelta(const bool &currentValue)
+{
+	Write(currentValue);
+}
+
+/// \brief Read any integral type from a bitstream.  Define __BITSTREAM_NATIVE_END if you need endian swapping.
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::Read(templateType &outTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(outTemplateVar)==1)
+		return ReadBits( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'uint16_t', possible loss of data
+#endif
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
+			{
+				ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));
+				return true;
+			}
+			return false;
+		}
+		else
+#endif
+			return ReadBits( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::Read(bool &outTemplateVar)
+{
+	if ( readOffset + 1 > numberOfBitsUsed )
+		return false;
+
+	if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset & 7 ) ) )   // Is it faster to just write it out here?
+		outTemplateVar = true;
+	else
+		outTemplateVar = false;
+
+	// Has to be on a different line for Mac
+	readOffset++;
+
+	return true;
+}
+
+template <>
+inline bool BitStream::Read(OVR::String &outTemplateVar)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		AlignReadToByteBoundary();
+		outTemplateVar.AssignString((const char*) (data + ( readOffset >> 3 )), (size_t) l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+template <>
+inline bool BitStream::Read(char *&varString)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		memcpy(varString, data + ( readOffset >> 3 ), l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+template <>
+inline bool BitStream::Read(unsigned char *&varString)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		memcpy(varString, data + ( readOffset >> 3 ), l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details If the written value differed from the value compared against in the write function,
+/// var will be updated.  Otherwise it will retain the current value.
+/// ReadDelta is only valid from a previous call to WriteDelta
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadDelta(templateType &outTemplateVar)
+{
+	bool dataWritten;
+	bool success;
+	success=Read(dataWritten);
+	if (dataWritten)
+		success=Read(outTemplateVar);
+	return success;
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::ReadDelta(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadCompressed(templateType &outTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(outTemplateVar)==1)
+		return ReadCompressed( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
+			{
+				ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));
+				return true;
+			}
+			return false;
+		}
+		else
+#endif
+			return ReadCompressed( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <>
+inline bool BitStream::ReadCompressed(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+/// For values between -1 and 1
+template <>
+inline bool BitStream::ReadCompressed(float &outTemplateVar)
+{
+	uint16_t compressedFloat;
+	if (Read(compressedFloat))
+	{
+		outTemplateVar = ((float)compressedFloat / 32767.5f - 1.0f);
+		return true;
+	}
+	return false;
+}
+
+/// For values between -1 and 1
+template <>
+inline bool BitStream::ReadCompressed(double &outTemplateVar)
+{
+	uint32_t compressedFloat;
+	if (Read(compressedFloat))
+	{
+		outTemplateVar = ((double)compressedFloat / 2147483648.0 - 1.0);
+		return true;
+	}
+	return false;
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details If the written value differed from the value compared against in the write function,
+/// var will be updated.  Otherwise it will retain the current value.
+/// the current value will be updated.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// ReadCompressedDelta is only valid from a previous call to WriteDelta
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadCompressedDelta(templateType &outTemplateVar)
+{
+	bool dataWritten;
+	bool success;
+	success=Read(dataWritten);
+	if (dataWritten)
+		success=ReadCompressed(outTemplateVar);
+	return success;
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::ReadCompressedDelta(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+template <class destinationType, class sourceType >
+void BitStream::WriteCasted( const sourceType &value )
+{
+	destinationType val = (destinationType) value;
+	Write(val);
+}
+
+template <class templateType>
+void BitStream::WriteBitsFromIntegerRange( const templateType value, const templateType minimum,const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	WriteBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+void BitStream::WriteBitsFromIntegerRange( const templateType value, const templateType minimum,const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	OVR_ASSERT(maximum>=minimum);
+	OVR_ASSERT(allowOutsideRange==true || (value>=minimum && value<=maximum));
+	if (allowOutsideRange)
+	{
+		if (value<minimum || value>maximum)
+		{
+			Write(true);
+			Write(value);
+			return;
+		}
+		Write(false);
+	}
+	templateType valueOffMin=value-minimum;
+	if (IsBigEndian()==true)
+	{
+		unsigned char output[sizeof(templateType)];
+		ReverseBytes((unsigned char*)&valueOffMin, output, sizeof(templateType));
+		WriteBits(output,requiredBits);
+	}
+	else
+	{
+		WriteBits((unsigned char*) &valueOffMin,requiredBits);
+	}
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteNormVector( templateType x, templateType y, templateType z )
+{
+#ifdef _DEBUG
+	OVR_ASSERT(x <= 1.01 && y <= 1.01 && z <= 1.01 && x >= -1.01 && y >= -1.01 && z >= -1.01);
+#endif
+
+	WriteFloat16((float)x,-1.0f,1.0f);
+	WriteFloat16((float)y,-1.0f,1.0f);
+	WriteFloat16((float)z,-1.0f,1.0f);
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteVector( templateType x, templateType y, templateType z )
+{
+	templateType magnitude = sqrt(x * x + y * y + z * z);
+	Write((float)magnitude);
+	if (magnitude > 0.00001f)
+	{
+		WriteCompressed((float)(x/magnitude));
+		WriteCompressed((float)(y/magnitude));
+		WriteCompressed((float)(z/magnitude));
+		//	Write((uint16_t)((x/magnitude+1.0f)*32767.5f));
+		//	Write((uint16_t)((y/magnitude+1.0f)*32767.5f));
+		//	Write((uint16_t)((z/magnitude+1.0f)*32767.5f));
+	}
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteNormQuat( templateType w, templateType x, templateType y, templateType z)
+{
+	Write((bool)(w<0.0));
+	Write((bool)(x<0.0));
+	Write((bool)(y<0.0));
+	Write((bool)(z<0.0));
+	Write((uint16_t)(fabs(x)*65535.0));
+	Write((uint16_t)(fabs(y)*65535.0));
+	Write((uint16_t)(fabs(z)*65535.0));
+	// Leave out w and calculate it on the target
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteOrthMatrix(
+	templateType m00, templateType m01, templateType m02,
+	templateType m10, templateType m11, templateType m12,
+	templateType m20, templateType m21, templateType m22 )
+{
+
+	double qw;
+	double qx;
+	double qy;
+	double qz;
+
+	// Convert matrix to quat
+	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
+	float sum;
+	sum = 1 + m00 + m11 + m22;
+	if (sum < 0.0f) sum=0.0f;
+	qw = sqrt( sum  ) / 2;
+	sum = 1 + m00 - m11 - m22;
+	if (sum < 0.0f) sum=0.0f;
+	qx = sqrt( sum  ) / 2;
+	sum = 1 - m00 + m11 - m22;
+	if (sum < 0.0f) sum=0.0f;
+	qy = sqrt( sum  ) / 2;
+	sum = 1 - m00 - m11 + m22;
+	if (sum < 0.0f) sum=0.0f;
+	qz = sqrt( sum  ) / 2;
+	if (qw < 0.0) qw=0.0;
+	if (qx < 0.0) qx=0.0;
+	if (qy < 0.0) qy=0.0;
+	if (qz < 0.0) qz=0.0;
+#ifdef OVR_OS_WIN32
+	qx = _copysign( (double) qx, (double) (m21 - m12) );
+	qy = _copysign( (double) qy, (double) (m02 - m20) );
+	qz = _copysign( (double) qz, (double) (m10 - m01) );
+#else
+	qx = copysign( (double) qx, (double) (m21 - m12) );
+	qy = copysign( (double) qy, (double) (m02 - m20) );
+	qz = copysign( (double) qz, (double) (m10 - m01) );
+#endif
+
+	WriteNormQuat(qw,qx,qy,qz);
+}
+
+template <class serializationType, class sourceType >
+bool BitStream::ReadCasted( sourceType &value )
+{
+	serializationType val;
+	bool success = Read(val);
+	value=(sourceType) val;
+	return success;
+}
+
+template <class templateType>
+bool BitStream::ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	return ReadBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+bool BitStream::ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	OVR_ASSERT(maximum>=minimum);
+	if (allowOutsideRange)
+	{
+		bool isOutsideRange;
+		Read(isOutsideRange);
+		if (isOutsideRange)
+			return Read(value);
+	}
+	unsigned char output[sizeof(templateType)];
+	memset(output,0,sizeof(output));
+	bool success = ReadBits(output,requiredBits);
+	if (success)
+	{
+		if (IsBigEndian()==true)
+			ReverseBytesInPlace(output,sizeof(output));
+		memcpy(&value,output,sizeof(output));
+
+		value+=minimum;
+	}
+
+	return success;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadNormVector( templateType &x, templateType &y, templateType &z )
+{
+	float xIn,yIn,zIn;
+	ReadFloat16(xIn,-1.0f,1.0f);
+	ReadFloat16(yIn,-1.0f,1.0f);
+	ReadFloat16(zIn,-1.0f,1.0f);
+	x=xIn;
+	y=yIn;
+	z=zIn;
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadVector( templateType &x, templateType &y, templateType &z )
+{
+	float magnitude;
+	//uint16_t sx,sy,sz;
+	if (!Read(magnitude))
+		return false;
+	if (magnitude>0.00001f)
+	{
+		//	Read(sx);
+		//	Read(sy);
+		//	if (!Read(sz))
+		//		return false;
+		//	x=((float)sx / 32767.5f - 1.0f) * magnitude;
+		//	y=((float)sy / 32767.5f - 1.0f) * magnitude;
+		//	z=((float)sz / 32767.5f - 1.0f) * magnitude;
+		float cx=0.0f,cy=0.0f,cz=0.0f;
+		ReadCompressed(cx);
+		ReadCompressed(cy);
+		if (!ReadCompressed(cz))
+			return false;
+		x=cx;
+		y=cy;
+		z=cz;
+		x*=magnitude;
+		y*=magnitude;
+		z*=magnitude;
+	}
+	else
+	{
+		x=0.0;
+		y=0.0;
+		z=0.0;
+	}
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadNormQuat( templateType &w, templateType &x, templateType &y, templateType &z)
+{
+	bool cwNeg=false, cxNeg=false, cyNeg=false, czNeg=false;
+	uint16_t cx,cy,cz;
+	Read(cwNeg);
+	Read(cxNeg);
+	Read(cyNeg);
+	Read(czNeg);
+	Read(cx);
+	Read(cy);
+	if (!Read(cz))
+		return false;
+
+	// Calculate w from x,y,z
+	x=(templateType)(cx/65535.0);
+	y=(templateType)(cy/65535.0);
+	z=(templateType)(cz/65535.0);
+	if (cxNeg) x=-x;
+	if (cyNeg) y=-y;
+	if (czNeg) z=-z;
+	float difference = 1.0f - x*x - y*y - z*z;
+	if (difference < 0.0f)
+		difference=0.0f;
+	w = (templateType)(sqrt(difference));
+	if (cwNeg)
+		w=-w;
+
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadOrthMatrix(
+	templateType &m00, templateType &m01, templateType &m02,
+	templateType &m10, templateType &m11, templateType &m12,
+	templateType &m20, templateType &m21, templateType &m22 )
+{
+	float qw,qx,qy,qz;
+	if (!ReadNormQuat(qw,qx,qy,qz))
+		return false;
+
+	// Quat to orthogonal rotation matrix
+	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm
+	double sqw = (double)qw*(double)qw;
+	double sqx = (double)qx*(double)qx;
+	double sqy = (double)qy*(double)qy;
+	double sqz = (double)qz*(double)qz;
+	m00 =  (templateType)(sqx - sqy - sqz + sqw); // since sqw + sqx + sqy + sqz =1
+	m11 = (templateType)(-sqx + sqy - sqz + sqw);
+	m22 = (templateType)(-sqx - sqy + sqz + sqw);
+
+	double tmp1 = (double)qx*(double)qy;
+	double tmp2 = (double)qz*(double)qw;
+	m10 = (templateType)(2.0 * (tmp1 + tmp2));
+	m01 = (templateType)(2.0 * (tmp1 - tmp2));
+
+	tmp1 = (double)qx*(double)qz;
+	tmp2 = (double)qy*(double)qw;
+	m20 =(templateType)(2.0 * (tmp1 - tmp2));
+	m02 = (templateType)(2.0 * (tmp1 + tmp2));
+	tmp1 = (double)qy*(double)qz;
+	tmp2 = (double)qx*(double)qw;
+	m21 = (templateType)(2.0 * (tmp1 + tmp2));
+	m12 = (templateType)(2.0 * (tmp1 - tmp2));
+
+	return true;
+}
+
+template <class templateType>
+BitStream& operator<<(BitStream& out, templateType& c)
+{
+	out.Write(c);
+	return out;
+}
+template <class templateType>
+BitStream& operator>>(BitStream& in, templateType& c)
+{
+	bool success = in.Read(c);
+	(void)success;
+
+	OVR_ASSERT(success);
+	return in;
+}
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_MessageIDTypes.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_MessageIDTypes.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,39 @@
+/************************************************************************************
+
+Filename    :   OVR_MessageIDTypes.h
+Content     :   Enumeration list indicating what type of message is being sent
+Created     :   July 3, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+namespace OVR { namespace Net {
+
+/// First byte of a network message
+typedef unsigned char MessageID;
+
+enum DefaultMessageIDTypes
+{
+    OVRID_RPC1,
+    OVRID_END = 128,
+    OVRID_LATENCY_TESTER_1,
+};
+
+}} // namespace OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,70 @@
+/************************************************************************************
+
+Filename    :   OVR_NetworkPlugin.cpp
+Content     :   Base class for an extension to the network objects.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_NetworkPlugin.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+
+//-----------------------------------------------------------------------------
+// Plugin identifier to assign next
+
+//static uint8_t pluginIdNext = 0;
+
+
+//-----------------------------------------------------------------------------
+// NetworkPlugin
+
+NetworkPlugin::NetworkPlugin()
+{
+	pSession = 0;
+	//PluginId = pluginIdNext++;
+}
+
+NetworkPlugin::~NetworkPlugin()
+{
+}
+
+void NetworkPlugin::OnAddedToSession(Session* _pSession)
+{
+	if (pSession != 0)
+	{
+		pSession->RemoveSessionListener(this);
+	}
+
+	pSession = _pSession;
+}
+
+void NetworkPlugin::OnRemovedFromSession(Session* _pSession)
+{
+	OVR_UNUSED(_pSession);
+	OVR_ASSERT(_pSession == pSession);
+
+	pSession = 0;
+}
+
+
+}}} // OVR::Net::Plugins
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,59 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_NetworkPlugin.h
+Content     :   Base class for an extension to the network objects.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_NetworkPlugin_h
+#define OVR_NetworkPlugin_h
+
+#include "OVR_Session.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+//-----------------------------------------------------------------------------
+// NetworkPlugin
+
+// NetworkPlugins use Session and SessionListener to provide network functionality
+// independent of the transport medium.
+// Uses the chain of command design pattern such that plugins can invoke or intercept
+// network events via the Session.
+class NetworkPlugin : public SessionListener
+{
+public:
+	NetworkPlugin();
+	virtual ~NetworkPlugin();
+
+protected:
+	virtual void OnAddedToSession(Session* _pSession);
+	virtual void OnRemovedFromSession(Session* _pSession);
+
+	Session *pSession;
+	//uint8_t PluginId;
+};
+
+
+}}} // OVR::Net::Plugins
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkTypes.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkTypes.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,42 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_NetworkTypes.h
+Content     :   Shared header for network types
+Created     :   June 12, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_NetworkTypes_h
+#define OVR_NetworkTypes_h
+
+#include "../Kernel/OVR_Types.h"
+
+namespace OVR {	namespace Net {
+
+
+typedef uint64_t NetworkID;
+const NetworkID InvalidNetworkID = ~((NetworkID)0);
+
+
+} } // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,190 @@
+/************************************************************************************
+
+Filename    :   OVR_PacketizedTCPSocket.cpp
+Content     :   TCP with automated message framing.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_PacketizedTCPSocket.h"
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// Constants
+
+static const int LENGTH_FIELD_BYTES = 4;
+
+
+//-----------------------------------------------------------------------------
+// PacketizedTCPSocket
+
+PacketizedTCPSocket::PacketizedTCPSocket()
+{
+	pRecvBuff = 0;
+	pRecvBuffSize = 0;
+	Transport = TransportType_PacketizedTCP;
+}
+
+PacketizedTCPSocket::PacketizedTCPSocket(SocketHandle _sock, bool isListenSocket) : PacketizedTCPSocketBase(_sock, isListenSocket)
+{
+	pRecvBuff = 0;
+	pRecvBuffSize = 0;
+	Transport = TransportType_PacketizedTCP;
+}
+
+PacketizedTCPSocket::~PacketizedTCPSocket()
+{
+	OVR_FREE(pRecvBuff);
+}
+
+int PacketizedTCPSocket::Send(const void* pData, int bytes)
+{
+    Lock::Locker locker(&sendLock);
+
+	if (bytes <= 0)
+	{
+		return -1;
+	}
+
+	// Convert length to 4 endian-neutral bytes
+	uint32_t lengthWord = bytes;
+	uint8_t lengthBytes[LENGTH_FIELD_BYTES] = {
+		(uint8_t)lengthWord,
+		(uint8_t)(lengthWord >> 8),
+		(uint8_t)(lengthWord >> 16),
+		(uint8_t)(lengthWord >> 24)
+	};
+
+	int s = PacketizedTCPSocketBase::Send(lengthBytes, LENGTH_FIELD_BYTES);
+	if (s > 0)
+	{
+		return PacketizedTCPSocketBase::Send(pData,bytes);
+	}
+	else
+	{
+		return s;
+	}
+}
+
+int PacketizedTCPSocket::SendAndConcatenate(const void** pDataArray, int* dataLengthArray, int arrayCount)
+{
+    Lock::Locker locker(&sendLock);
+
+    if (arrayCount == 0)
+		return 0;
+
+	int totalBytes = 0;
+	for (int i = 0; i < arrayCount; i++)
+		totalBytes += dataLengthArray[i];
+
+	// Convert length to 4 endian-neutral bytes
+	uint32_t lengthWord = totalBytes;
+	uint8_t lengthBytes[LENGTH_FIELD_BYTES] = {
+		(uint8_t)lengthWord,
+		(uint8_t)(lengthWord >> 8),
+		(uint8_t)(lengthWord >> 16),
+		(uint8_t)(lengthWord >> 24)
+	};
+
+	int s = PacketizedTCPSocketBase::Send(lengthBytes, LENGTH_FIELD_BYTES);
+	if (s > 0)
+	{
+		for (int i = 0; i < arrayCount; i++)
+		{
+			PacketizedTCPSocketBase::Send(pDataArray[i], dataLengthArray[i]);
+		}
+	}
+
+	return s;
+}
+
+void PacketizedTCPSocket::OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData, int bytesRead)
+{
+	uint8_t* dataSource;
+	int dataSourceSize;
+
+	recvBuffLock.DoLock();
+
+	if (pRecvBuff == NULL)
+	{
+		dataSource = pData;
+		dataSourceSize = bytesRead;
+	}
+	else
+	{
+		pRecvBuff = (uint8_t*)OVR_REALLOC(pRecvBuff, bytesRead + pRecvBuffSize);
+		memcpy(pRecvBuff + pRecvBuffSize, pData, bytesRead);
+
+		dataSourceSize = pRecvBuffSize + bytesRead;
+		dataSource = pRecvBuff;
+	}
+
+	int bytesReadFromStream;
+	while (bytesReadFromStream = BytesFromStream(dataSource, dataSourceSize),
+		   LENGTH_FIELD_BYTES + bytesReadFromStream <= dataSourceSize)
+	{
+		dataSource += LENGTH_FIELD_BYTES;
+		dataSourceSize -= LENGTH_FIELD_BYTES;
+
+		TCPSocket::OnRecv(eventHandler, dataSource, bytesReadFromStream);
+
+		dataSource += bytesReadFromStream;
+		dataSourceSize -= bytesReadFromStream;
+	}
+
+	if (dataSourceSize > 0)
+	{
+		if (pRecvBuff == NULL)
+		{
+			pRecvBuff = (uint8_t*)OVR_ALLOC(dataSourceSize);
+			memcpy(pRecvBuff, dataSource, dataSourceSize);
+		}
+		else
+		{
+			memmove(pRecvBuff, dataSource, dataSourceSize);
+		}
+	}
+	else
+	{
+		if (pRecvBuff != NULL)
+			OVR_FREE(pRecvBuff);
+
+		pRecvBuff = NULL;
+	}
+	pRecvBuffSize = dataSourceSize;
+
+	recvBuffLock.Unlock();
+}
+
+int PacketizedTCPSocket::BytesFromStream(uint8_t* pData, int bytesRead)
+{
+	if (pData != 0 && bytesRead >= LENGTH_FIELD_BYTES)
+	{
+		return pData[0] | ((uint32_t)pData[1] << 8) | ((uint32_t)pData[2] << 16) | ((uint32_t)pData[3] << 24);
+	}
+
+	return 0;
+}
+
+
+}} // OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,87 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_PacketizedTCPSocket.cpp
+Content     :   TCP with automated message framing.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_PacketizedTCPSocket_h
+#define OVR_PacketizedTCPSocket_h
+
+#include "OVR_Socket.h"
+#include "../Kernel/OVR_Allocator.h"
+#include "../Kernel/OVR_Atomic.h"
+
+#ifdef OVR_OS_WIN32
+#include "OVR_Win32_Socket.h"
+#else
+#include "OVR_Unix_Socket.h"
+#endif
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// NetworkPlugin
+
+// Packetized TCP base socket
+class PacketizedTCPSocketBase : public TCPSocket
+{
+public:
+	PacketizedTCPSocketBase() {}
+	PacketizedTCPSocketBase(SocketHandle _sock, bool isListenSocket) : TCPSocket(_sock, isListenSocket) {}
+};
+
+
+//-----------------------------------------------------------------------------
+// PacketizedTCPSocket
+
+// Uses TCP but is message aligned rather than stream aligned
+// Alternative to reliable UDP
+class PacketizedTCPSocket : public PacketizedTCPSocketBase
+{
+public:
+	PacketizedTCPSocket();
+	PacketizedTCPSocket(SocketHandle _sock, bool isListenSocket);
+	virtual ~PacketizedTCPSocket();
+
+public:
+	virtual int Send(const void* pData, int bytes);
+	virtual int SendAndConcatenate(const void** pDataArray, int *dataLengthArray, int arrayCount);
+
+protected:
+	virtual void OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData, int bytesRead);
+
+	int BytesFromStream(uint8_t* pData, int bytesRead);
+
+    Lock   sendLock;
+    Lock   recvBuffLock;
+
+	uint8_t* pRecvBuff;     // Queued receive buffered data
+	int    pRecvBuffSize; // Size of receive queue in bytes
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,266 @@
+/************************************************************************************
+
+Filename    :   OVR_RPC1.cpp
+Content     :   A network plugin that provides remote procedure call functionality.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_RPC1.h"
+#include "OVR_BitStream.h"
+#include "../Kernel/OVR_Threads.h" // Thread::MSleep
+#include "OVR_MessageIDTypes.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+
+//-----------------------------------------------------------------------------
+// Types
+
+enum {
+	ID_RPC4_SIGNAL,
+	CALL_BLOCKING,
+	RPC_ERROR_FUNCTION_NOT_REGISTERED,
+	ID_RPC4_RETURN,
+};
+
+
+//-----------------------------------------------------------------------------
+// RPC1
+
+RPC1::RPC1()
+{
+	blockingOnThisConnection = 0;
+	blockingReturnValue = new BitStream();
+}
+
+RPC1::~RPC1()
+{
+	slotHash.Clear();
+	delete blockingReturnValue;
+}
+
+void RPC1::RegisterSlot(OVR::String sharedIdentifier,  OVR::Observer<RPCSlot> *rpcSlotObserver )
+{
+	slotHash.AddObserverToSubject(sharedIdentifier, rpcSlotObserver);
+}
+
+bool RPC1::RegisterBlockingFunction(OVR::String uniqueID, RPCDelegate blockingFunction)
+{
+	if (registeredBlockingFunctions.Get(uniqueID))
+		return false;
+
+	registeredBlockingFunctions.Set(uniqueID, blockingFunction);
+	return true;
+}
+
+void RPC1::UnregisterBlockingFunction(OVR::String uniqueID)
+{
+	registeredBlockingFunctions.Remove(uniqueID);
+}
+
+bool RPC1::CallBlocking( OVR::String uniqueID, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection, OVR::Net::BitStream *returnData )
+{
+    // If invalid parameters,
+    if (!pConnection)
+    {
+        // Note: This may happen if the endpoint disconnects just before the call
+        return false;
+    }
+
+	OVR::Net::BitStream out;
+	out.Write((MessageID) OVRID_RPC1);
+	out.Write((MessageID) CALL_BLOCKING);
+	out.Write(uniqueID);
+	if (bitStream)
+	{
+		bitStream->ResetReadPointer();
+		out.AlignWriteToByteBoundary();
+		out.Write(bitStream);
+	}
+
+	SendParameters sp(pConnection, out.GetData(), out.GetNumberOfBytesUsed());
+
+    if (returnData)
+    {
+        returnData->Reset();
+    }
+
+    // Only one thread call at a time
+    Lock::Locker singleRPCLocker(&singleRPCLock);
+
+    // Note this does not prevent multiple calls at a time because .Wait will unlock it below.
+    // The purpose of this mutex is to synchronize the polling thread and this one, not prevent
+    // multiple threads from invoking RPC.
+    Mutex::Locker locker(&callBlockingMutex);
+
+    blockingReturnValue->Reset();
+    blockingOnThisConnection = pConnection;
+
+    int bytesSent = pSession->Send(&sp);
+    if (bytesSent == sp.Bytes)
+    {
+        while (blockingOnThisConnection == pConnection)
+        {
+            callBlockingWait.Wait(&callBlockingMutex);
+        }
+    }
+
+    if (returnData)
+    {
+        returnData->Write(blockingReturnValue);
+        returnData->ResetReadPointer();
+    }
+
+	return true;
+}
+
+bool RPC1::Signal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection)
+{
+	OVR::Net::BitStream out;
+	out.Write((MessageID) OVRID_RPC1);
+	out.Write((MessageID) ID_RPC4_SIGNAL);
+	//out.Write(PluginId);
+	out.Write(sharedIdentifier);
+	if (bitStream)
+	{
+		bitStream->ResetReadPointer();
+		out.AlignWriteToByteBoundary();
+		out.Write(bitStream);
+	}
+	SendParameters sp(pConnection, out.GetData(), out.GetNumberOfBytesUsed());
+	int32_t bytesSent = pSession->Send(&sp);
+	return bytesSent == sp.Bytes;
+}
+void RPC1::BroadcastSignal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream)
+{
+    OVR::Net::BitStream out;
+    out.Write((MessageID) OVRID_RPC1);
+    out.Write((MessageID) ID_RPC4_SIGNAL);
+    //out.Write(PluginId);
+    out.Write(sharedIdentifier);
+    if (bitStream)
+    {
+        bitStream->ResetReadPointer();
+        out.AlignWriteToByteBoundary();
+        out.Write(bitStream);
+    }
+    BroadcastParameters p(out.GetData(), out.GetNumberOfBytesUsed());
+    pSession->Broadcast(&p);
+}
+void RPC1::OnReceive(ReceivePayload *pPayload, ListenerReceiveResult *lrrOut)
+{
+	OVR_UNUSED(lrrOut);
+
+    if (pPayload->pData[0] == OVRID_RPC1)
+    {
+		OVR_ASSERT(pPayload->Bytes >= 2);
+
+		OVR::Net::BitStream bsIn((char*)pPayload->pData, pPayload->Bytes, false);
+		bsIn.IgnoreBytes(2);
+
+        if (pPayload->pData[1] == RPC_ERROR_FUNCTION_NOT_REGISTERED)
+        {
+            Mutex::Locker locker(&callBlockingMutex);
+
+            blockingReturnValue->Reset();
+            blockingOnThisConnection = 0;
+            callBlockingWait.NotifyAll();
+        }
+        else if (pPayload->pData[1] == ID_RPC4_RETURN)
+        {
+            Mutex::Locker locker(&callBlockingMutex);
+
+            blockingReturnValue->Reset();
+			blockingReturnValue->Write(bsIn);
+            blockingOnThisConnection = 0;
+            callBlockingWait.NotifyAll();
+		}
+        else if (pPayload->pData[1] == CALL_BLOCKING)
+        {
+			OVR::String uniqueId;
+			bsIn.Read(uniqueId);
+
+			RPCDelegate *bf = registeredBlockingFunctions.Get(uniqueId);
+			if (bf==0)
+			{
+				OVR::Net::BitStream bsOut;
+				bsOut.Write((unsigned char) OVRID_RPC1);
+				bsOut.Write((unsigned char) RPC_ERROR_FUNCTION_NOT_REGISTERED);
+
+				SendParameters sp(pPayload->pConnection, bsOut.GetData(), bsOut.GetNumberOfBytesUsed());
+				pSession->Send(&sp);
+
+				return;
+			}
+
+			OVR::Net::BitStream returnData;
+			bsIn.AlignReadToByteBoundary();
+			(*bf)(&bsIn, &returnData, pPayload);
+
+			OVR::Net::BitStream out;
+			out.Write((MessageID) OVRID_RPC1);
+			out.Write((MessageID) ID_RPC4_RETURN);
+			returnData.ResetReadPointer();
+			out.AlignWriteToByteBoundary();
+			out.Write(returnData);
+
+			SendParameters sp(pPayload->pConnection, out.GetData(), out.GetNumberOfBytesUsed());
+			pSession->Send(&sp);
+		}
+		else if (pPayload->pData[1]==ID_RPC4_SIGNAL)
+		{
+			OVR::String sharedIdentifier;
+			bsIn.Read(sharedIdentifier);
+
+			Observer<RPCSlot> *o = slotHash.GetSubject(sharedIdentifier);
+
+			if (o)
+			{
+				bsIn.AlignReadToByteBoundary();
+
+				if (o)
+				{
+					OVR::Net::BitStream serializedParameters(bsIn.GetData() + bsIn.GetReadOffset()/8, bsIn.GetNumberOfUnreadBits()/8, false);
+
+					o->Call(&serializedParameters, pPayload);
+				}
+			}
+		}
+	}
+}
+
+void RPC1::OnDisconnected(Connection* conn)
+{
+    if (blockingOnThisConnection == conn)
+    {
+        blockingOnThisConnection = 0;
+        callBlockingWait.NotifyAll();
+    }
+}
+
+void RPC1::OnConnected(Connection* conn)
+{
+    OVR_UNUSED(conn);
+}
+
+
+}}} // OVR::Net::Plugins
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,105 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_RPC1.h
+Content     :   A network plugin that provides remote procedure call functionality.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Net_RPC_h
+#define OVR_Net_RPC_h
+
+#include "OVR_NetworkPlugin.h"
+#include "../Kernel/OVR_Hash.h"
+#include "../Kernel/OVR_String.h"
+#include "OVR_BitStream.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Delegates.h"
+#include "../Kernel//OVR_Observer.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+
+typedef Delegate3<void, BitStream*, BitStream*, ReceivePayload*> RPCDelegate;
+typedef Delegate2<void, BitStream*, ReceivePayload*> RPCSlot;
+// typedef void ( *Slot ) ( OVR::Net::BitStream *userData, OVR::Net::ReceivePayload *pPayload );
+
+/// NetworkPlugin that maps strings to function pointers. Can invoke the functions using blocking calls with return values, or signal/slots. Networked parameters serialized with BitStream
+class RPC1 : public NetworkPlugin
+{
+public:
+	RPC1();
+	virtual ~RPC1();
+
+	/// Register a slot, which is a function pointer to one or more implementations that supports this function signature
+	/// When a signal occurs, all slots with the same identifier are called.
+	/// \param[in] sharedIdentifier A string to identify the slot. Recommended to be the same as the name of the function.
+	/// \param[in] functionPtr Pointer to the function.
+	/// \param[in] callPriority Slots are called by order of the highest callPriority first. For slots with the same priority, they are called in the order they are registered
+	void RegisterSlot(OVR::String sharedIdentifier,  OVR::Observer<RPCSlot> *rpcSlotObserver);
+
+	/// \brief Same as \a RegisterFunction, but is called with CallBlocking() instead of Call() and returns a value to the caller
+	bool RegisterBlockingFunction(OVR::String uniqueID, RPCDelegate blockingFunction);
+
+	/// \brief Same as UnregisterFunction, except for a blocking function
+	void UnregisterBlockingFunction(OVR::String uniqueID);
+
+	// \brief Same as call, but don't return until the remote system replies.
+	/// Broadcasting parameter does not exist, this can only call one remote system
+	/// \note This function does not return until the remote system responds, disconnects, or was never connected to begin with
+	/// \param[in] Identifier originally passed to RegisterBlockingFunction() on the remote system(s)
+	/// \param[in] bitStream bitStream encoded data to send to the function callback
+	/// \param[in] pConnection connection to send on
+	/// \param[out] returnData Written to by the function registered with RegisterBlockingFunction.
+	/// \return true if successfully called. False on disconnect, function not registered, or not connected to begin with
+	bool CallBlocking( OVR::String uniqueID, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection, OVR::Net::BitStream *returnData = NULL );
+
+	/// Calls zero or more functions identified by sharedIdentifier registered with RegisterSlot()
+	/// \param[in] sharedIdentifier parameter of the same name passed to RegisterSlot() on the remote system
+	/// \param[in] bitStream bitStream encoded data to send to the function callback
+	/// \param[in] pConnection connection to send on
+	bool Signal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection);
+    void BroadcastSignal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream);
+
+
+protected:
+	virtual void OnReceive(ReceivePayload *pPayload, ListenerReceiveResult *lrrOut);
+
+    virtual void OnDisconnected(Connection* conn);
+    virtual void OnConnected(Connection* conn);
+
+	Hash< String, RPCDelegate, String::HashFunctor > registeredBlockingFunctions;
+	ObserverHash< RPCSlot > slotHash;
+
+    // Synchronization for RPC caller
+    Lock            singleRPCLock;
+    Mutex           callBlockingMutex;
+    WaitCondition   callBlockingWait;
+
+    Net::BitStream* blockingReturnValue;
+	Ptr<Connection> blockingOnThisConnection;
+};
+
+
+}}} // OVR::Net::Plugins
+
+#endif // OVR_Net_RPC_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,703 @@
+/************************************************************************************
+
+Filename    :   OVR_Session.h
+Content     :   One network session that provides connection/disconnection events.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Session.h"
+#include "OVR_PacketizedTCPSocket.h"
+#include "../Kernel/OVR_Log.h"
+#include "../Service/Service_NetSessionCommon.h"
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// Protocol
+
+static const char* OfficialHelloString = "OculusVR_Hello";
+static const char* OfficialAuthorizedString = "OculusVR_Authorized";
+
+void RPC_C2S_Hello::Generate(Net::BitStream* bs)
+{
+    RPC_C2S_Hello hello;
+    hello.HelloString = OfficialHelloString;
+    hello.MajorVersion = RPCVersion_Major;
+    hello.MinorVersion = RPCVersion_Minor;
+    hello.PatchVersion = RPCVersion_Patch;
+    hello.Serialize(bs);
+}
+
+bool RPC_C2S_Hello::Validate()
+{
+    return MajorVersion == RPCVersion_Major &&
+           MinorVersion <= RPCVersion_Minor &&
+           HelloString.CompareNoCase(OfficialHelloString) == 0;
+}
+
+void RPC_S2C_Authorization::Generate(Net::BitStream* bs)
+{
+    RPC_S2C_Authorization auth;
+    auth.AuthString = OfficialAuthorizedString;
+    auth.MajorVersion = RPCVersion_Major;
+    auth.MinorVersion = RPCVersion_Minor;
+    auth.PatchVersion = RPCVersion_Patch;
+    auth.Serialize(bs);
+}
+
+bool RPC_S2C_Authorization::Validate()
+{
+    return AuthString.CompareNoCase(OfficialAuthorizedString) == 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// Session
+
+void Session::Shutdown()
+{
+    {
+        Lock::Locker locker(&SocketListenersLock);
+
+        const int count = SocketListeners.GetSizeI();
+        for (int i = 0; i < count; ++i)
+        {
+            SocketListeners[i]->Close();
+        }
+    }
+
+    Lock::Locker locker(&ConnectionsLock);
+
+    const int count = AllConnections.GetSizeI();
+    for (int i = 0; i < count; ++i)
+    {
+        Connection* arrayItem = AllConnections[i].GetPtr();
+
+        if (arrayItem->Transport == TransportType_PacketizedTCP)
+        {
+            PacketizedTCPConnection* ptcp = (PacketizedTCPConnection*)arrayItem;
+
+            ptcp->pSocket->Close();
+        }
+    }
+}
+
+SessionResult Session::Listen(ListenerDescription* pListenerDescription)
+{
+	if (pListenerDescription->Transport == TransportType_PacketizedTCP)
+	{
+		BerkleyListenerDescription* bld = (BerkleyListenerDescription*)pListenerDescription;
+		TCPSocket* tcpSocket = (TCPSocket*)bld->BoundSocketToListenWith.GetPtr();
+
+        if (tcpSocket->Listen() < 0)
+        {
+            return SessionResult_ListenFailure;
+        }
+
+		Lock::Locker locker(&SocketListenersLock);
+        SocketListeners.PushBack(tcpSocket);
+	}
+    else if (pListenerDescription->Transport == TransportType_Loopback)
+	{
+		HasLoopbackListener = true;
+	}
+    else
+    {
+        OVR_ASSERT(false);
+    }
+
+	return SessionResult_OK;
+}
+
+SessionResult Session::Connect(ConnectParameters *cp)
+{
+    if (cp->Transport == TransportType_PacketizedTCP)
+    {
+        ConnectParametersBerkleySocket* cp2 = (ConnectParametersBerkleySocket*)cp;
+        Ptr<PacketizedTCPConnection> c;
+
+        {
+            Lock::Locker locker(&ConnectionsLock);
+
+            int connIndex;
+            Ptr<PacketizedTCPConnection> conn = findConnectionBySocket(AllConnections, cp2->BoundSocketToConnectWith, &connIndex);
+            if (conn)
+            {
+                return SessionResult_AlreadyConnected;
+            }
+
+            TCPSocketBase* tcpSock = (TCPSocketBase*)cp2->BoundSocketToConnectWith.GetPtr();
+
+            int ret = tcpSock->Connect(&cp2->RemoteAddress);
+            if (ret < 0)
+            {
+                return SessionResult_ConnectFailure;
+            }
+
+            Ptr<Connection> newConnection = AllocConnection(cp2->Transport);
+            if (!newConnection)
+            {
+                return SessionResult_ConnectFailure;
+            }
+
+            c = (PacketizedTCPConnection*)newConnection.GetPtr();
+            c->pSocket = (TCPSocket*) cp2->BoundSocketToConnectWith.GetPtr();
+            c->Address = cp2->RemoteAddress;
+            c->Transport = cp2->Transport;
+            c->SetState(Client_Connecting);
+
+            AllConnections.PushBack(c);
+
+        }
+        
+        if (cp2->Blocking)
+        {
+            c->WaitOnConnecting();
+
+            if (c->State == State_Connected)
+                return SessionResult_OK;
+            else
+                return SessionResult_ConnectFailure;
+        }
+	}
+    else if (cp->Transport == TransportType_Loopback)
+	{
+		if (HasLoopbackListener)
+		{
+            Ptr<Connection> c = AllocConnection(cp->Transport);
+            if (!c)
+            {
+                return SessionResult_ConnectFailure;
+            }
+
+            c->Transport = cp->Transport;
+            c->SetState(State_Connected);
+
+            {
+                Lock::Locker locker(&ConnectionsLock);
+                AllConnections.PushBack(c);
+            }
+
+			invokeSessionEvent(&SessionListener::OnConnectionRequestAccepted, c);
+		}
+		else
+		{
+            OVR_ASSERT(false);
+		}
+	}
+    else
+    {
+        OVR_ASSERT(false);
+    }
+
+	return SessionResult_OK;
+}
+
+SessionResult Session::ListenPTCP(OVR::Net::BerkleyBindParameters *bbp)
+{
+	Ptr<PacketizedTCPSocket> listenSocket = *new OVR::Net::PacketizedTCPSocket();
+    if (listenSocket->Bind(bbp) == INVALID_SOCKET)
+    {
+        return SessionResult_BindFailure;
+    }
+
+	BerkleyListenerDescription bld;
+	bld.BoundSocketToListenWith = listenSocket.GetPtr();
+    bld.Transport = TransportType_PacketizedTCP;
+
+    return Listen(&bld);
+}
+
+SessionResult Session::ConnectPTCP(OVR::Net::BerkleyBindParameters* bbp, SockAddr* RemoteAddress, bool blocking)
+{
+	ConnectParametersBerkleySocket cp;
+    cp.RemoteAddress = RemoteAddress;
+    cp.Transport = TransportType_PacketizedTCP;
+    cp.Blocking = blocking;
+    Ptr<PacketizedTCPSocket> connectSocket = *new PacketizedTCPSocket();
+
+	cp.BoundSocketToConnectWith = connectSocket.GetPtr();
+    if (connectSocket->Bind(bbp) == INVALID_SOCKET)
+    {
+        return SessionResult_BindFailure;
+    }
+
+	return Connect(&cp);
+}
+
+Ptr<PacketizedTCPConnection> Session::findConnectionBySockAddr(SockAddr* address)
+{
+    const int count = AllConnections.GetSizeI();
+    for (int i = 0; i < count; ++i)
+    {
+        Connection* arrayItem = AllConnections[i].GetPtr();
+
+        if (arrayItem->Transport == TransportType_PacketizedTCP)
+        {
+            PacketizedTCPConnection* conn = (PacketizedTCPConnection*)arrayItem;
+
+            if (conn->Address == *address)
+            {
+                return conn;
+            }
+        }
+    }
+
+    return 0;
+}
+
+int Session::Send(SendParameters *payload)
+{
+	if (payload->pConnection->Transport == TransportType_Loopback)
+	{
+		Lock::Locker locker(&SessionListenersLock);
+
+        const int count = SessionListeners.GetSizeI();
+        for (int i = 0; i < count; ++i)
+		{
+			SessionListener* sl = SessionListeners[i];
+
+            // FIXME: This looks like it needs to be reviewed at some point..
+			ReceivePayload rp;
+			rp.Bytes = payload->Bytes;
+			rp.pConnection = payload->pConnection;
+			rp.pData = (uint8_t*)payload->pData; // FIXME
+			ListenerReceiveResult lrr = LRR_CONTINUE;
+			sl->OnReceive(&rp, &lrr);
+			if (lrr==LRR_RETURN)
+				return payload->Bytes;
+			else if (lrr == LRR_BREAK)
+			{
+				break;
+			}	
+		}
+
+		return payload->Bytes;
+	}
+    else if (payload->pConnection->Transport == TransportType_PacketizedTCP)
+	{
+		PacketizedTCPConnection* conn = (PacketizedTCPConnection*)payload->pConnection.GetPtr();
+
+        return conn->pSocket->Send(payload->pData, payload->Bytes);
+	}
+    else
+    {
+        OVR_ASSERT(false);
+    }
+
+    return 0;
+}
+void Session::Broadcast(BroadcastParameters *payload)
+{
+    SendParameters sp;
+    sp.Bytes=payload->Bytes;
+    sp.pData=payload->pData;
+
+    {
+        Lock::Locker locker(&ConnectionsLock);
+
+        const int connectionCount = FullConnections.GetSizeI();
+        for (int i = 0; i < connectionCount; ++i)
+        {
+            sp.pConnection = FullConnections[i];
+            Send(&sp);
+        }    
+    }
+}
+void Session::Poll(bool listeners)
+{
+	Array< Ptr< Net::TCPSocket > > allBlockingTcpSockets;
+
+	if (listeners)
+	{
+		Lock::Locker locker(&SocketListenersLock);
+
+        const int listenerCount = SocketListeners.GetSizeI();
+        for (int i = 0; i < listenerCount; ++i)
+		{
+            allBlockingTcpSockets.PushBack(SocketListeners[i]);
+		}
+	}
+
+    {
+        Lock::Locker locker(&ConnectionsLock);
+
+        const int connectionCount = AllConnections.GetSizeI();
+        for (int i = 0; i < connectionCount; ++i)
+        {
+            Connection* arrayItem = AllConnections[i].GetPtr();
+
+            if (arrayItem->Transport == TransportType_PacketizedTCP)
+            {
+                PacketizedTCPConnection* ptcp = (PacketizedTCPConnection*)arrayItem;
+
+                allBlockingTcpSockets.PushBack(ptcp->pSocket);
+            }
+            else
+            {
+                OVR_ASSERT(false);
+            }
+        }
+    }
+
+    const int count = allBlockingTcpSockets.GetSizeI();
+	if (count > 0)
+	{
+        TCPSocketPollState state;
+
+        // Add all the sockets for polling,
+        for (int i = 0; i < count; ++i)
+        {
+            Net::TCPSocket* sock = allBlockingTcpSockets[i].GetPtr();
+
+            // If socket handle is invalid,
+            if (sock->GetSocketHandle() == INVALID_SOCKET)
+            {
+                OVR_DEBUG_LOG(("[Session] Detected an invalid socket handle - Treating it as a disconnection."));
+                sock->IsConnecting = false;
+                TCP_OnClosed(sock);
+            }
+            else
+            {
+                state.Add(sock);
+            }
+        }
+
+        // If polling returns with an event,
+        if (state.Poll(allBlockingTcpSockets[0]->GetBlockingTimeoutUsec(), allBlockingTcpSockets[0]->GetBlockingTimeoutSec()))
+        {
+            // Handle any events for each socket
+            for (int i = 0; i < count; ++i)
+            {
+                state.HandleEvent(allBlockingTcpSockets[i], this);
+            }
+        }
+	}
+}
+
+void Session::AddSessionListener(SessionListener* se)
+{
+	Lock::Locker locker(&SessionListenersLock);
+
+    const int count = SessionListeners.GetSizeI();
+    for (int i = 0; i < count; ++i)
+    {
+        if (SessionListeners[i] == se)
+        {
+            // Already added
+            return;
+        }
+    }
+
+    SessionListeners.PushBack(se);
+	se->OnAddedToSession(this);
+}
+
+void Session::RemoveSessionListener(SessionListener* se)
+{
+	Lock::Locker locker(&SessionListenersLock);
+
+    const int count = SessionListeners.GetSizeI();
+	for (int i = 0; i < count; ++i)
+	{
+        if (SessionListeners[i] == se)
+		{
+            se->OnRemovedFromSession(this);
+
+            SessionListeners.RemoveAtUnordered(i);
+            break;
+		}
+	}
+}
+SInt32 Session::GetActiveSocketsCount()
+{
+    Lock::Locker locker1(&SocketListenersLock);
+    Lock::Locker locker2(&ConnectionsLock);
+    return SocketListeners.GetSize() + AllConnections.GetSize()>0;
+}
+Ptr<Connection> Session::AllocConnection(TransportType transport)
+{
+    switch (transport)
+    {
+    case TransportType_Loopback:      return *new Connection();
+    case TransportType_TCP:           return *new TCPConnection();
+    case TransportType_PacketizedTCP: return *new PacketizedTCPConnection();
+    default:
+        OVR_ASSERT(false);
+        break;
+    }
+
+    return NULL;
+}
+
+Ptr<PacketizedTCPConnection> Session::findConnectionBySocket(Array< Ptr<Connection> >& connectionArray, Socket* s, int *connectionIndex)
+{
+    const int count = connectionArray.GetSizeI();
+    for (int i = 0; i < count; ++i)
+    {
+        Connection* arrayItem = connectionArray[i].GetPtr();
+
+        if (arrayItem->Transport == TransportType_PacketizedTCP)
+        {
+            PacketizedTCPConnection* ptc = (PacketizedTCPConnection*)arrayItem;
+
+            if (ptc->pSocket == s)
+            {
+                if (connectionIndex)
+                {
+                    *connectionIndex = i;
+                }
+                return ptc;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+int Session::invokeSessionListeners(ReceivePayload* rp)
+{
+    Lock::Locker locker(&SessionListenersLock);
+
+    const int count = SessionListeners.GetSizeI();
+    for (int j = 0; j < count; ++j)
+    {
+        ListenerReceiveResult lrr = LRR_CONTINUE;
+        SessionListeners[j]->OnReceive(rp, &lrr);
+
+        if (lrr == LRR_RETURN || lrr == LRR_BREAK)
+        {
+            break;
+        }
+    }
+
+    return rp->Bytes;
+}
+
+void Session::TCP_OnRecv(Socket* pSocket, uint8_t* pData, int bytesRead)
+{
+	Lock::Locker locker(&ConnectionsLock);
+
+    // Look for the connection in the full connection list first
+    int connIndex;
+    PacketizedTCPConnection* conn = findConnectionBySocket(AllConnections, pSocket, &connIndex);
+    if (conn)
+    {
+        if (conn->State == State_Connected)
+        {
+            ReceivePayload rp;
+            rp.Bytes = bytesRead;
+            rp.pConnection = conn;
+            rp.pData = pData;
+
+            // Call listeners
+            invokeSessionListeners(&rp);
+        }
+        else if (conn->State == Client_ConnectedWait)
+        {
+            // Check the version data from the message
+            BitStream bsIn((char*)pData, bytesRead, false);
+
+            RPC_S2C_Authorization auth;
+            if (!auth.Deserialize(&bsIn) ||
+                !auth.Validate())
+            {
+                conn->SetState(State_Zombie);
+                invokeSessionEvent(&SessionListener::OnIncompatibleProtocol, conn);
+
+                LogError("[Session] REJECTED: Server did not respond with a valid authorization message");
+                AllConnections.RemoveAtUnordered(connIndex);
+            }
+            else
+            {
+                // Read remote version
+                conn->RemoteMajorVersion = auth.MajorVersion;
+                conn->RemoteMinorVersion = auth.MinorVersion;
+                conn->RemotePatchVersion = auth.PatchVersion;
+
+                // Mark as connected
+                conn->SetState(State_Connected);
+                FullConnections.PushBack(conn);
+                invokeSessionEvent(&SessionListener::OnConnectionRequestAccepted, conn);
+            }
+        }
+        else if (conn->State == Server_ConnectedWait)
+        {
+            // Check the version data from the message
+            BitStream bsIn((char*)pData, bytesRead, false);
+
+            RPC_C2S_Hello hello;
+            if (!hello.Deserialize(&bsIn) ||
+                !hello.Validate())
+            {
+                conn->SetState(State_Zombie);
+                invokeSessionEvent(&SessionListener::OnIncompatibleProtocol, conn);
+
+                LogError("[Session] REJECTED: Rift application is using an incompatible version %d.%d.%d (my version=%d.%d.%d)",
+                         hello.MajorVersion, hello.MinorVersion, hello.PatchVersion,
+                         RPCVersion_Major, RPCVersion_Minor, RPCVersion_Patch);
+                AllConnections.RemoveAtUnordered(connIndex);
+            }
+            else
+            {
+                // Read remote version
+                conn->RemoteMajorVersion = hello.MajorVersion;
+                conn->RemoteMinorVersion = hello.MinorVersion;
+                conn->RemotePatchVersion = hello.PatchVersion;
+
+                // Send auth response
+                BitStream bsOut;
+                RPC_S2C_Authorization::Generate(&bsOut);
+                conn->pSocket->Send(bsOut.GetData(), bsOut.GetNumberOfBytesUsed());
+
+                // Mark as connected
+                conn->SetState(State_Connected);
+                FullConnections.PushBack(conn);
+                invokeSessionEvent(&SessionListener::OnNewIncomingConnection, conn);
+
+            }
+        }
+        else
+        {
+            OVR_ASSERT(false);
+        }
+    }
+}
+
+void Session::TCP_OnClosed(TCPSocket* s)
+{
+	Lock::Locker locker(&ConnectionsLock);
+
+    // If found in the full connection list,
+    int connIndex;
+    Ptr<PacketizedTCPConnection> conn = findConnectionBySocket(AllConnections, s, &connIndex);
+    if (conn)
+    {
+        AllConnections.RemoveAtUnordered(connIndex);
+
+        // If in the full connection list,
+        if (findConnectionBySocket(FullConnections, s, &connIndex))
+        {
+            FullConnections.RemoveAtUnordered(connIndex);
+        }
+
+        // Generate an appropriate event for the current state
+        switch (conn->State)
+        {
+        case Client_Connecting:
+            invokeSessionEvent(&SessionListener::OnConnectionAttemptFailed, conn);
+            break;
+        case Client_ConnectedWait:
+        case Server_ConnectedWait:
+            invokeSessionEvent(&SessionListener::OnHandshakeAttemptFailed, conn);
+            break;
+        case State_Connected:
+            invokeSessionEvent(&SessionListener::OnDisconnected, conn);
+            break;
+        default:
+            OVR_ASSERT(false);
+            break;
+        }
+
+        conn->SetState(State_Zombie);
+    }
+}
+
+void Session::TCP_OnAccept(TCPSocket* pListener, SockAddr* pSockAddr, SocketHandle newSock)
+{
+    OVR_UNUSED(pListener);
+	OVR_ASSERT(pListener->Transport == TransportType_PacketizedTCP);
+
+
+	Ptr<PacketizedTCPSocket> newSocket = *new PacketizedTCPSocket(newSock, false);
+    // If pSockAddr is not localhost, then close newSock
+    if (pSockAddr->IsLocalhost()==false)
+    {
+        newSocket->Close();
+        return;
+    }
+
+	if (newSocket)
+	{
+		Ptr<Connection> b = AllocConnection(TransportType_PacketizedTCP);
+		Ptr<PacketizedTCPConnection> c = (PacketizedTCPConnection*)b.GetPtr();
+		c->pSocket = newSocket;
+		c->Address = *pSockAddr;
+        c->State = Server_ConnectedWait;
+
+        {
+            Lock::Locker locker(&ConnectionsLock);
+            AllConnections.PushBack(c);
+        }
+
+        // Server does not send the first packet.  It waits for the client to send its version
+	}
+}
+
+void Session::TCP_OnConnected(TCPSocket *s)
+{
+    Lock::Locker locker(&ConnectionsLock);
+
+    // If connection was found,
+    PacketizedTCPConnection* conn = findConnectionBySocket(AllConnections, s);
+    if (conn)
+    {
+        OVR_ASSERT(conn->State == Client_Connecting);
+
+        // Send hello message
+        BitStream bsOut;
+        RPC_C2S_Hello::Generate(&bsOut);
+        conn->pSocket->Send(bsOut.GetData(), bsOut.GetNumberOfBytesUsed());
+
+        // Just update state but do not generate any notifications yet
+        conn->State = Client_ConnectedWait;
+    }
+}
+
+void Session::invokeSessionEvent(void(SessionListener::*f)(Connection*), Connection* conn)
+{
+    Lock::Locker locker(&SessionListenersLock);
+
+    const int count = SessionListeners.GetSizeI();
+    for (int i = 0; i < count; ++i)
+    {
+        (SessionListeners[i]->*f)(conn);
+    }
+}
+
+Ptr<Connection> Session::GetConnectionAtIndex(int index)
+{
+    Lock::Locker locker(&ConnectionsLock);
+
+    const int count = FullConnections.GetSizeI();
+
+    if (index < count)
+    {
+        return FullConnections[index];
+    }
+
+    return NULL;
+}
+
+
+}} // OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,490 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Session.h
+Content     :   One network session that provides connection/disconnection events.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Session_h
+#define OVR_Session_h
+
+#include "OVR_Socket.h"
+#include "OVR_PacketizedTCPSocket.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_RefCount.h"
+
+namespace OVR { namespace Net {
+
+class Session;
+
+
+//-----------------------------------------------------------------------------
+// Based on Semantic Versioning ( http://semver.org/ )
+//
+// Please update changelog below:
+// 1.0.0 - Initial DK2 release version (July 21, 2014) -catid
+//-----------------------------------------------------------------------------
+
+static const uint16_t RPCVersion_Major = 1; // MAJOR version when you make incompatible API changes,
+static const uint16_t RPCVersion_Minor = 0; // MINOR version when you add functionality in a backwards-compatible manner, and
+static const uint16_t RPCVersion_Patch = 0; // PATCH version when you make backwards-compatible bug fixes.
+
+// Client starts communication by sending its version number.
+struct RPC_C2S_Hello
+{
+    RPC_C2S_Hello() :
+        MajorVersion(0),
+        MinorVersion(0),
+        PatchVersion(0)
+    {
+    }
+
+    String HelloString;
+
+    // Client version info
+    uint16_t MajorVersion, MinorVersion, PatchVersion;
+
+    void Serialize(Net::BitStream* bs)
+    {
+        bs->Write(HelloString);
+        bs->Write(MajorVersion);
+        bs->Write(MinorVersion);
+        bs->Write(PatchVersion);
+    }
+
+    bool Deserialize(Net::BitStream* bs)
+    {
+        bs->Read(HelloString);
+        bs->Read(MajorVersion);
+        bs->Read(MinorVersion);
+        return bs->Read(PatchVersion);
+    }
+
+    static void Generate(Net::BitStream* bs);
+
+    bool Validate();
+};
+
+// Server responds with an authorization accepted message, including the server's version number
+struct RPC_S2C_Authorization
+{
+    RPC_S2C_Authorization() :
+        MajorVersion(0),
+        MinorVersion(0),
+        PatchVersion(0)
+    {
+    }
+
+    String AuthString;
+
+    // Server version info
+    uint16_t MajorVersion, MinorVersion, PatchVersion;
+
+    void Serialize(Net::BitStream* bs)
+    {
+        bs->Write(AuthString);
+        bs->Write(MajorVersion);
+        bs->Write(MinorVersion);
+        bs->Write(PatchVersion);
+    }
+
+    bool Deserialize(Net::BitStream* bs)
+    {
+        bs->Read(AuthString);
+        bs->Read(MajorVersion);
+        bs->Read(MinorVersion);
+        return bs->Read(PatchVersion);
+    }
+
+    static void Generate(Net::BitStream* bs);
+
+    bool Validate();
+};
+
+
+//-----------------------------------------------------------------------------
+// Result of a session function
+enum SessionResult
+{
+	SessionResult_OK,
+	SessionResult_BindFailure,
+	SessionResult_ListenFailure,
+	SessionResult_ConnectFailure,
+    SessionResult_AlreadyConnected,
+};
+
+
+//-----------------------------------------------------------------------------
+// Connection state
+enum EConnectionState
+{
+    State_Zombie,          // Disconnected
+
+    // Client-only:
+    Client_Connecting,     // Waiting for TCP connection
+    Client_ConnectedWait,  // Connected! Waiting for server to authorize
+
+    // Server-only:
+    Server_ConnectedWait,  // Connected! Waiting for client handshake
+
+    State_Connected        // Connected
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic connection over any transport
+class Connection : public RefCountBase<Connection>
+{
+public:
+    Connection() :
+        Transport(TransportType_None),
+        State(State_Zombie),
+        RemoteMajorVersion(0),
+        RemoteMinorVersion(0),
+        RemotePatchVersion(0)
+    {
+    }
+	virtual ~Connection() // Allow delete from base
+    {
+    }
+
+public:
+    virtual void SetState(EConnectionState s) {State = s;}
+
+    TransportType    Transport;
+    EConnectionState State;
+
+    // Version number read from remote host just before connection completes
+    int              RemoteMajorVersion;
+    int              RemoteMinorVersion;
+    int              RemotePatchVersion;
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic network connection over any network transport
+class NetworkConnection : public Connection
+{
+protected:
+    NetworkConnection()
+	{
+	}
+    virtual ~NetworkConnection()
+    {
+    }
+
+public:
+    virtual void SetState(EConnectionState s) {
+        if (s==State)
+            return;
+
+        Mutex::Locker locker(&StateMutex);
+        State = s;
+        if (State != Client_Connecting)
+            ConnectingWait.NotifyAll();
+    }
+
+    void WaitOnConnecting() {
+        while (State == Client_Connecting)
+        {
+            Mutex::Locker locker(&StateMutex);
+            ConnectingWait.Wait(&StateMutex);
+        }
+    }
+
+	SockAddr Address;
+
+    OVR::Mutex         StateMutex;
+    OVR::WaitCondition ConnectingWait;
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Connection
+class TCPConnection : public NetworkConnection
+{
+public:
+    TCPConnection()
+    {
+    }
+    virtual ~TCPConnection()
+    {
+    }
+
+public:
+	Ptr<TCPSocket> pSocket;
+};
+
+
+//-----------------------------------------------------------------------------
+// Packetized TCP Connection
+class PacketizedTCPConnection : public TCPConnection
+{
+public:
+	PacketizedTCPConnection()
+    {
+        Transport = TransportType_PacketizedTCP;
+    }
+    virtual ~PacketizedTCPConnection()
+    {
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic socket listener description
+class ListenerDescription
+{
+public:
+    ListenerDescription() :
+        Transport(TransportType_None)
+    {
+    }
+
+    TransportType Transport;
+};
+
+
+//-----------------------------------------------------------------------------
+// Description for a Berkley socket listener
+class BerkleyListenerDescription : public ListenerDescription
+{
+public:
+	static const int DefaultMaxIncomingConnections =  64;
+	static const int DefaultMaxConnections         = 128;
+
+	BerkleyListenerDescription() :
+		MaxIncomingConnections(DefaultMaxIncomingConnections),
+		MaxConnections(DefaultMaxConnections)
+	{
+	}
+
+	Ptr<BerkleySocket> BoundSocketToListenWith;
+    int                MaxIncomingConnections;
+    int                MaxConnections;
+};
+
+
+//-----------------------------------------------------------------------------
+// Receive payload
+struct ReceivePayload
+{
+	Connection* pConnection; // Source connection
+	uint8_t*      pData;       // Pointer to data received
+	int         Bytes;       // Number of bytes of data received
+};
+
+//-----------------------------------------------------------------------------
+// Broadcast parameters
+class BroadcastParameters
+{
+public:
+    BroadcastParameters() :
+        pData(NULL),
+        Bytes(0)
+    {
+    }
+
+    BroadcastParameters(const void* _pData, int _bytes) :
+        pData(_pData),
+        Bytes(_bytes)
+    {
+    }
+
+public:
+    const void*     pData;       // Pointer to data to send
+    int             Bytes;       // Number of bytes of data received
+};
+
+//-----------------------------------------------------------------------------
+// Send parameters
+class SendParameters
+{
+public:
+	SendParameters() :
+		pData(NULL),
+		Bytes(0)
+	{
+	}
+	SendParameters(Ptr<Connection> _pConnection, const void* _pData, int _bytes) :
+		pConnection(_pConnection),
+		pData(_pData),
+		Bytes(_bytes)
+	{
+	}
+
+public:
+	Ptr<Connection> pConnection; // Connection to use
+	const void*     pData;       // Pointer to data to send
+	int             Bytes;       // Number of bytes of data received
+};
+
+
+//-----------------------------------------------------------------------------
+// Parameters to connect
+struct ConnectParameters
+{
+public:
+	ConnectParameters() :
+		Transport(TransportType_None)
+	{
+	}
+
+	TransportType Transport;
+};
+
+struct ConnectParametersBerkleySocket : public ConnectParameters
+{
+	SockAddr           RemoteAddress;
+	Ptr<BerkleySocket> BoundSocketToConnectWith;
+    bool                Blocking;
+
+	ConnectParametersBerkleySocket()
+    {
+    }
+
+	ConnectParametersBerkleySocket(Socket* s, SockAddr* addr) :
+        RemoteAddress(*addr)
+    {
+        BoundSocketToConnectWith = (BerkleySocket*)s;
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// Listener receive result
+enum ListenerReceiveResult
+{
+	/// The SessionListener used this message and it shouldn't be given to the user.
+	LRR_RETURN = 0,
+
+	/// The SessionListener is going to hold on to this message.  Do not deallocate it but do not pass it to other plugins either.
+	LRR_BREAK,
+
+    /// This message will be processed by other SessionListeners, and at last by the user.
+    LRR_CONTINUE,
+};
+
+
+//-----------------------------------------------------------------------------
+// SessionListener
+
+// Callback interface for network events such as connecting, disconnecting, getting data, independent of the transport medium
+class SessionListener
+{
+public:
+	// Data events
+    virtual void OnReceive(ReceivePayload* pPayload, ListenerReceiveResult* lrrOut) { OVR_UNUSED2(pPayload, lrrOut);  }
+
+	// Connection was closed
+    virtual void OnDisconnected(Connection* conn) = 0;
+
+	// Connection was created (some data was exchanged to verify protocol compatibility too)
+    virtual void OnConnected(Connection* conn) = 0;
+
+    // Server accepted client
+    virtual void OnNewIncomingConnection(Connection* conn)     { OnConnected(conn); }
+    // Client was accepted
+    virtual void OnConnectionRequestAccepted(Connection* conn) { OnConnected(conn); }
+
+    // Connection attempt failed for some reason
+    virtual void OnConnectionAttemptFailed(Connection* conn)   { OnDisconnected(conn); }
+
+    // Incompatible protocol
+    virtual void OnIncompatibleProtocol(Connection* conn)      { OnConnectionAttemptFailed(conn); }
+    // Disconnected during initial handshake
+    virtual void OnHandshakeAttemptFailed(Connection* conn)    { OnConnectionAttemptFailed(conn); }
+
+	// Other
+    virtual void OnAddedToSession(Session* session)            { OVR_UNUSED(session); }
+    virtual void OnRemovedFromSession(Session* session)        { OVR_UNUSED(session); }
+};
+
+
+//-----------------------------------------------------------------------------
+// Session
+
+//  Interface for network events such as listening on a socket, sending data, connecting, and disconnecting. Works independently of the transport medium and also implements loopback
+class Session : public SocketEvent_TCP, public NewOverrideBase
+{
+public:
+    Session() :
+        HasLoopbackListener(false)
+    {
+    }
+    virtual ~Session()
+    {
+    }
+
+	virtual SessionResult Listen(ListenerDescription* pListenerDescription);
+	virtual SessionResult Connect(ConnectParameters* cp);
+	virtual int           Send(SendParameters* payload);
+    virtual void          Broadcast(BroadcastParameters* payload);
+    virtual void          Poll(bool listeners = true);
+	virtual void          AddSessionListener(SessionListener* se);
+	virtual void          RemoveSessionListener(SessionListener* se);
+    virtual SInt32        GetActiveSocketsCount();
+
+    // Packetized TCP convenience functions
+    virtual SessionResult ListenPTCP(BerkleyBindParameters* bbp);
+    virtual SessionResult ConnectPTCP(BerkleyBindParameters* bbp, SockAddr* RemoteAddress, bool blocking);
+
+    // Closes all the sockets; useful for interrupting the socket polling during shutdown
+    void            Shutdown();
+
+    // Get count of successful connections (past handshake point)
+    int             GetConnectionCount() const
+    {
+        return FullConnections.GetSizeI();
+    }
+    Ptr<Connection> GetConnectionAtIndex(int index);
+
+protected:
+	virtual Ptr<Connection> AllocConnection(TransportType transportType);
+
+    Lock SocketListenersLock, ConnectionsLock, SessionListenersLock;
+    bool                      HasLoopbackListener; // Has loopback listener installed?
+	Array< Ptr<TCPSocket> >   SocketListeners;     // List of active sockets
+    Array< Ptr<Connection> >  AllConnections;      // List of active connections stuck at the versioning handshake
+    Array< Ptr<Connection> >  FullConnections;     // List of active connections past the versioning handshake
+    Array< SessionListener* > SessionListeners;    // List of session listeners
+
+    // Tools
+    Ptr<PacketizedTCPConnection> findConnectionBySocket(Array< Ptr<Connection> >& connectionArray, Socket* s, int *connectionIndex = NULL); // Call with ConnectionsLock held
+    Ptr<PacketizedTCPConnection> findConnectionBySockAddr(SockAddr* address); // Call with ConnectionsLock held
+    int                   invokeSessionListeners(ReceivePayload*);
+    void                  invokeSessionEvent(void(SessionListener::*f)(Connection*), Connection* pConnection);
+
+	// TCP
+	virtual void          TCP_OnRecv(Socket* pSocket, uint8_t* pData, int bytesRead);
+	virtual void          TCP_OnClosed(TCPSocket* pSocket);
+	virtual void          TCP_OnAccept(TCPSocket* pListener, SockAddr* pSockAddr, SocketHandle newSock);
+	virtual void          TCP_OnConnected(TCPSocket* pSocket);
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,89 @@
+/************************************************************************************
+
+Filename    :   OVR_Socket.cpp
+Content     :   Socket common data shared between all platforms.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Socket.h"
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// Socket
+
+Socket::Socket() :
+	Transport(TransportType_None)
+{
+}
+
+
+//-----------------------------------------------------------------------------
+// BerkleyBindParameters
+
+BerkleyBindParameters::BerkleyBindParameters() :
+	Port(0),
+    blockingTimeout(0x7fffffff)
+{
+}
+
+//-----------------------------------------------------------------------------
+// BerkleySocket
+
+BerkleySocket::BerkleySocket() :
+	TheSocket(INVALID_SOCKET)
+{
+    SetBlockingTimeout(1000);
+}
+
+BerkleySocket::~BerkleySocket()
+{
+	// Close socket on destruction
+	Close();
+}
+
+
+//-----------------------------------------------------------------------------
+// UDPSocketBase
+
+UDPSocketBase::UDPSocketBase()
+{
+	Transport = TransportType_UDP;
+}
+
+
+//-----------------------------------------------------------------------------
+// TCPSocketBase
+
+TCPSocketBase::TCPSocketBase()
+{
+	Transport = TransportType_TCP;
+}
+
+TCPSocketBase::TCPSocketBase(SocketHandle handle)
+{
+	TheSocket = handle;
+}
+
+
+}} // OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,238 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Socket.h
+Content     :   Socket common data shared between all platforms.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Socket_h
+#define OVR_Socket_h
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Timer.h"
+#include "../Kernel/OVR_Allocator.h"
+#include "../Kernel/OVR_RefCount.h"
+#include "../Kernel/OVR_String.h"
+
+// OS-specific socket headers
+#if defined(OVR_OS_WIN32)
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#else
+# include <unistd.h>
+# include <sys/types.h>
+# include <netinet/in.h>
+#ifdef OVR_OS_ANDROID
+#include <sys/socket.h>
+#endif
+#endif
+
+namespace OVR { namespace Net {
+
+class SockAddr;
+class UDPSocket;
+class TCPSocket;
+
+
+//-----------------------------------------------------------------------------
+// Portable numeric Socket handle
+#if defined(OVR_OS_WIN32)
+typedef SOCKET SocketHandle;
+#else
+typedef int SocketHandle;
+static const SocketHandle INVALID_SOCKET = -1;
+static const int SOCKET_ERROR = -1;
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Types of network transport
+enum TransportType
+{
+	TransportType_None,          // No transport (useful placeholder for invalid states)
+	TransportType_Loopback,      // Loopback transport: Class talks to itself
+	TransportType_TCP,           // TCP/IPv4/v6
+	TransportType_UDP,           // UDP/IPv4/v6
+	TransportType_PacketizedTCP  // Packetized TCP: Message framing is automatic
+};
+
+
+//-----------------------------------------------------------------------------
+// Abstraction for a network socket. Inheritance hierarchy
+// modeled after RakNet so that future support can be added
+// for Linux, Windows RT, consoles, etc.
+class Socket : public RefCountBase<Socket>
+{
+public:
+	Socket();
+	virtual void Close() = 0;
+
+public:
+	TransportType Transport; // Type of transport
+};
+
+
+//-----------------------------------------------------------------------------
+// Bind parameters for Berkley sockets
+struct BerkleyBindParameters
+{
+public:
+	BerkleyBindParameters();
+
+public:
+	uint16_t Port;     // Port
+	String Address;
+    uint32_t blockingTimeout;
+};
+
+
+//-----------------------------------------------------------------------------
+// Berkley socket
+class BerkleySocket : public Socket
+{
+public:
+	BerkleySocket();
+	virtual ~BerkleySocket();
+
+	virtual void   Close();
+	virtual int32_t GetSockname(SockAddr* pSockAddrOut);
+	virtual void   SetBlockingTimeout(int timeoutMs) // milliseconds
+	{
+        TimeoutSec = timeoutMs / 1000;
+        TimeoutUsec = (timeoutMs % 1000) * 1000;
+	}
+    int            GetBlockingTimeoutUsec() const
+    {
+        return TimeoutUsec;
+    }
+    int            GetBlockingTimeoutSec() const
+    {
+        return TimeoutSec;
+    }
+    SocketHandle   GetSocketHandle() const
+    {
+        return TheSocket;
+    }
+
+protected:
+	SocketHandle TheSocket;           // Socket handle
+    int TimeoutUsec, TimeoutSec;
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP socket events
+class SocketEvent_UDP
+{
+public:
+	virtual void UDP_OnRecv(Socket* pSocket, uint8_t* pData,
+							uint32_t bytesRead, SockAddr* pSockAddr)
+	{
+		OVR_UNUSED4(pSocket, pData, bytesRead, pSockAddr);
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP socket events
+class SocketEvent_TCP
+{
+public:
+	virtual void TCP_OnRecv     (Socket* pSocket,
+                                 uint8_t* pData,
+                                 int bytesRead)
+	{
+		OVR_UNUSED3(pSocket, pData, bytesRead);
+	}
+	virtual void TCP_OnClosed   (TCPSocket* pSocket)
+	{
+		OVR_UNUSED(pSocket);
+	}
+	virtual void TCP_OnAccept   (TCPSocket* pListener,
+                                 SockAddr* pSockAddr,
+								 SocketHandle newSock)
+	{
+		OVR_UNUSED3(pListener, pSockAddr, newSock);
+	}
+	virtual void TCP_OnConnected(TCPSocket* pSocket)
+	{
+		OVR_UNUSED(pSocket);
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP Berkley socket
+
+// Base class for UDP sockets, code shared between platforms
+class UDPSocketBase : public BerkleySocket
+{
+public:
+	UDPSocketBase();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters) = 0;
+	virtual int          Send(const void* pData,
+                              int bytes,
+                              SockAddr* pSockAddr) = 0;
+	virtual void         Poll(SocketEvent_UDP* eventHandler) = 0;
+
+protected:
+	virtual void         OnRecv(SocketEvent_UDP* eventHandler,
+                                uint8_t* pData,
+								int bytesRead,
+                                SockAddr* address) = 0;
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Berkley socket
+
+// Base class for TCP sockets, code shared between platforms
+class TCPSocketBase : public BerkleySocket
+{
+public:
+	TCPSocketBase();
+	TCPSocketBase(SocketHandle handle);
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters) = 0;
+	virtual int          Listen() = 0;
+	virtual int          Connect(SockAddr* pSockAddr) = 0;
+	virtual int          Send(const void* pData,
+                              int bytes) = 0;
+protected:
+	virtual void         OnRecv(SocketEvent_TCP* eventHandler,
+                                uint8_t* pData,
+                                int bytesRead) = 0;
+
+protected:
+	bool IsListenSocket; // Is the socket listening (acting as a server)?
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,602 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_Socket.cpp
+Content     :   Windows-specific socket-based networking implementation
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Win32_Socket.h"
+#include "../Kernel/OVR_Std.h"
+#include "../Kernel/OVR_Allocator.h"
+#include "../Kernel/OVR_Threads.h" // Thread::MSleep
+#include "../Kernel/OVR_Log.h"
+
+#include <Winsock2.h>
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// WSAStartupSingleton
+
+class WSAStartupSingleton
+{
+public:
+	static void AddRef(void);
+	static void Deref(void);
+
+protected:
+	static int RefCount;
+};
+
+
+// Local data
+int WSAStartupSingleton::RefCount = 0;
+
+
+// Implementation
+void WSAStartupSingleton::AddRef()
+{
+	if (++RefCount == 1)
+	{
+		WSADATA winsockInfo;
+		const int errCode = WSAStartup(MAKEWORD(2, 2), &winsockInfo);
+		OVR_ASSERT(errCode == 0);
+
+		// If an error code is returned
+		if (errCode != 0)
+		{
+			LogError("[Socket] Unable to initialize Winsock %d", errCode);
+		}
+	}
+}
+
+void WSAStartupSingleton::Deref()
+{
+	OVR_ASSERT(RefCount > 0);
+
+	if (RefCount > 0)
+	{
+		if (--RefCount == 0)
+		{
+			WSACleanup();
+			RefCount = 0;
+		}
+	}
+}
+
+
+//-----------------------------------------------------------------------------
+// BerkleySocket
+
+void BerkleySocket::Close()
+{
+	if (TheSocket != INVALID_SOCKET)
+	{
+		closesocket(TheSocket);
+		TheSocket = INVALID_SOCKET;
+	}
+}
+
+int32_t BerkleySocket::GetSockname(SockAddr *pSockAddrOut)
+{
+	struct sockaddr_in6 sa;
+	memset(&sa,0,sizeof(sa));
+	int size = sizeof(sa);
+	int32_t i = getsockname(TheSocket, (sockaddr*) &sa, &size);
+	if (i>=0)
+	{
+		pSockAddrOut->Set(&sa);
+	}
+	return i;
+}
+
+
+//-----------------------------------------------------------------------------
+// BitStream overloads for SockAddr
+
+BitStream& operator<<(BitStream& out, SockAddr& in)
+{
+	out.WriteBits((const unsigned char*) &in.Addr6, sizeof(in.Addr6)*8, true);
+	return out;
+}
+
+BitStream& operator>>(BitStream& in, SockAddr& out)
+{
+	bool success = in.ReadBits((unsigned char*) &out.Addr6, sizeof(out.Addr6)*8, true);
+	OVR_ASSERT(success);
+	OVR_UNUSED(success);
+	return in;
+}
+
+
+//-----------------------------------------------------------------------------
+// SockAddr
+
+SockAddr::SockAddr()
+{
+	WSAStartupSingleton::AddRef();
+}
+
+SockAddr::SockAddr(SockAddr* address)
+{
+	WSAStartupSingleton::AddRef();
+	Set(&address->Addr6);
+}
+
+SockAddr::SockAddr(sockaddr_storage* storage)
+{
+	WSAStartupSingleton::AddRef();
+	Set(storage);
+}
+
+SockAddr::SockAddr(sockaddr_in6* address)
+{
+	WSAStartupSingleton::AddRef();
+	Set(address);
+}
+
+SockAddr::SockAddr(const char* hostAddress, uint16_t port, int sockType)
+{
+	WSAStartupSingleton::AddRef();
+	Set(hostAddress, port, sockType);
+}
+
+void SockAddr::Set(const sockaddr_storage* storage)
+{
+	memcpy(&Addr6, storage, sizeof(Addr6));
+}
+
+void SockAddr::Set(const sockaddr_in6* address)
+{
+	memcpy(&Addr6, address, sizeof(Addr6));
+}
+
+void SockAddr::Set(const char* hostAddress, uint16_t port, int sockType)
+{
+	memset(&Addr6, 0, sizeof(Addr6));
+
+	struct addrinfo* servinfo = 0;  // will point to the results
+	struct addrinfo hints;
+
+	// make sure the struct is empty
+	memset(&hints, 0, sizeof (addrinfo));
+
+	hints.ai_socktype = sockType; // SOCK_DGRAM or SOCK_STREAM
+	hints.ai_flags = AI_PASSIVE;     // fill in my IP for me
+	hints.ai_family = AF_UNSPEC ;
+
+    // FIXME See OVR_Unix_Socket implementation and man pages for getaddrinfo.
+    //       ai_protocol is expecting to be either IPPROTO_UDP and IPPROTO_TCP.
+    //       But this has been working on windows so I'm leaving it be for
+    //       now instead of introducing another variable.
+	hints.ai_protocol = IPPROTO_IPV6;
+
+	char portStr[32];
+	OVR_itoa(port, portStr, sizeof(portStr), 10);
+	int errcode = getaddrinfo(hostAddress, portStr, &hints, &servinfo);
+
+    if (0 != errcode)
+    {
+        OVR::LogError("getaddrinfo error: %s", gai_strerror(errcode));
+    }
+
+    OVR_ASSERT(0 != servinfo);
+
+	memcpy(&Addr6, servinfo->ai_addr, sizeof(Addr6));
+
+    freeaddrinfo(servinfo);
+}
+
+uint16_t SockAddr::GetPort()
+{
+	return htons(Addr6.sin6_port);
+}
+
+String SockAddr::ToString(bool writePort, char portDelineator) const
+{
+    char dest[INET6_ADDRSTRLEN + 1];
+
+	int ret = getnameinfo((struct sockaddr*)&Addr6,
+						  sizeof(struct sockaddr_in6),
+						  dest,
+						  INET6_ADDRSTRLEN,
+						  NULL,
+						  0,
+						  NI_NUMERICHOST);
+	if (ret != 0)
+	{
+		dest[0] = '\0';
+	}
+
+	if (writePort)
+	{
+		unsigned char ch[2];
+		ch[0]=portDelineator;
+		ch[1]=0;
+		OVR_strcat(dest, 16, (const char*) ch);
+		OVR_itoa(ntohs(Addr6.sin6_port), dest+strlen(dest), 16, 10);
+	}
+
+    return String(dest);
+}
+bool SockAddr::IsLocalhost() const
+{
+    static const unsigned char localhost_bytes[] =
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+    return memcmp(Addr6.sin6_addr.s6_addr, localhost_bytes, 16) == 0;
+}
+bool SockAddr::operator==( const SockAddr& right ) const
+{
+	return memcmp(&Addr6, &right.Addr6, sizeof(Addr6)) == 0;
+}
+
+bool SockAddr::operator!=( const SockAddr& right ) const
+{
+	return !(*this == right);
+}
+
+bool SockAddr::operator>( const SockAddr& right ) const
+{
+	return memcmp(&Addr6, &right.Addr6, sizeof(Addr6)) > 0;
+}
+
+bool SockAddr::operator<( const SockAddr& right ) const
+{
+	return memcmp(&Addr6, &right.Addr6, sizeof(Addr6)) < 0;
+}
+
+
+static void SetSocketOptions(SocketHandle sock)
+{
+	int sock_opt;
+
+	// This doubles the max throughput rate
+	sock_opt=1024*256;
+	setsockopt(sock, SOL_SOCKET, SO_RCVBUF, ( char * ) & sock_opt, sizeof ( sock_opt ) );
+
+	// Immediate hard close. Don't linger the socket, or recreating the socket quickly on Vista fails.
+	// Fail with voice
+	sock_opt=0;
+	setsockopt(sock, SOL_SOCKET, SO_LINGER, ( char * ) & sock_opt, sizeof ( sock_opt ) );
+
+	// This doesn't make much difference: 10% maybe
+	// Not supported on console 2
+	sock_opt=1024*16;
+	setsockopt(sock, SOL_SOCKET, SO_SNDBUF, ( char * ) & sock_opt, sizeof ( sock_opt ) );
+}
+void _Ioctlsocket(SocketHandle sock, unsigned long nonblocking)
+{
+	ioctlsocket( sock, FIONBIO, &nonblocking );
+}
+
+static SocketHandle BindShared(int ai_family, int ai_socktype, BerkleyBindParameters *pBindParameters)
+{
+	SocketHandle sock;
+
+	struct addrinfo hints;
+	memset(&hints, 0, sizeof (addrinfo)); // make sure the struct is empty
+	hints.ai_family = ai_family;
+	hints.ai_socktype = ai_socktype;
+	hints.ai_flags = AI_PASSIVE;     // fill in my IP for me
+	struct addrinfo *servinfo=0, *aip;  // will point to the results
+	char portStr[32];
+	OVR_itoa(pBindParameters->Port, portStr, sizeof(portStr), 10);
+
+    int errcode = 0;
+	if (!pBindParameters->Address.IsEmpty())
+		errcode = getaddrinfo(pBindParameters->Address.ToCStr(), portStr, &hints, &servinfo);
+	else
+		errcode = getaddrinfo(0, portStr, &hints, &servinfo);
+
+    if (0 != errcode)
+    {
+        OVR::LogError("getaddrinfo error: %s", gai_strerror(errcode));
+    }
+
+	for (aip = servinfo; aip != NULL; aip = aip->ai_next)
+	{
+		// Open socket. The address type depends on what
+		// getaddrinfo() gave us.
+		sock = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);
+		if (sock != 0)
+		{
+			int ret = bind( sock, aip->ai_addr, (int) aip->ai_addrlen );
+			if (ret>=0)
+			{
+				// The actual socket is always non-blocking
+				// I control blocking or not using WSAEventSelect
+				_Ioctlsocket(sock, 1);
+                freeaddrinfo(servinfo);
+				return sock;
+			}
+			else
+			{
+				closesocket(sock);
+			}
+		}
+	}
+
+    if (servinfo) { freeaddrinfo(servinfo); }
+	return INVALID_SOCKET;
+}
+
+
+//-----------------------------------------------------------------------------
+// UDPSocket
+
+UDPSocket::UDPSocket()
+{
+	WSAStartupSingleton::AddRef();
+	RecvBuf = new uint8_t[RecvBufSize];
+}
+
+UDPSocket::~UDPSocket()
+{
+	WSAStartupSingleton::Deref();
+	delete[] RecvBuf;
+}
+
+SocketHandle UDPSocket::Bind(BerkleyBindParameters *pBindParameters)
+{
+	SocketHandle s = BindShared(AF_INET6, SOCK_DGRAM, pBindParameters);
+	if (s == INVALID_SOCKET)
+		return s;
+
+	Close();
+	TheSocket = s;
+	SetSocketOptions(TheSocket);
+
+	return TheSocket;
+}
+
+void UDPSocket::OnRecv(SocketEvent_UDP* eventHandler, uint8_t* pData, int bytesRead, SockAddr* address)
+{
+	eventHandler->UDP_OnRecv(this, pData, bytesRead, address);
+}
+
+int UDPSocket::Send(const void* pData, int bytes, SockAddr* address)
+{
+	return sendto(TheSocket, (const char*)pData, bytes, 0, (const sockaddr*)&address->Addr6, sizeof(address->Addr6));
+}
+
+void UDPSocket::Poll(SocketEvent_UDP *eventHandler)
+{
+	struct sockaddr_storage win32_addr;
+	socklen_t fromlen;
+	int bytesRead;
+
+    // FIXME: Implement blocking poll wait for UDP
+
+	// While some bytes are read,
+	while (fromlen = sizeof(win32_addr), // Must set fromlen each time
+		   bytesRead = recvfrom(TheSocket, (char*)RecvBuf, RecvBufSize, 0, (sockaddr*)&win32_addr, &fromlen),
+		   bytesRead > 0)
+	{
+		SockAddr address(&win32_addr); // Wrap address
+
+		OnRecv(eventHandler, RecvBuf, bytesRead, &address);
+	}
+}
+
+
+//-----------------------------------------------------------------------------
+// TCPSocket
+
+TCPSocket::TCPSocket()
+{
+	IsConnecting = false;
+	IsListenSocket = false;
+	WSAStartupSingleton::AddRef();
+}
+TCPSocket::TCPSocket(SocketHandle boundHandle, bool isListenSocket)
+{
+	TheSocket = boundHandle;
+	IsListenSocket = isListenSocket;
+	IsConnecting = false;
+	WSAStartupSingleton::AddRef();
+	SetSocketOptions(TheSocket);
+
+	// The actual socket is always non-blocking
+	_Ioctlsocket(TheSocket, 1);
+}
+
+TCPSocket::~TCPSocket()
+{
+	WSAStartupSingleton::Deref();
+}
+
+void TCPSocket::OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData, int bytesRead)
+{
+	eventHandler->TCP_OnRecv(this, pData, bytesRead);
+}
+
+SocketHandle TCPSocket::Bind(BerkleyBindParameters* pBindParameters)
+{	
+	SocketHandle s = BindShared(AF_INET6, SOCK_STREAM, pBindParameters);
+	if (s == INVALID_SOCKET)
+		return s;
+
+	Close();
+
+    SetBlockingTimeout(pBindParameters->blockingTimeout);
+    TheSocket = s;
+
+    SetSocketOptions(TheSocket);
+
+	return TheSocket;
+}
+
+int TCPSocket::Listen()
+{
+    if (IsListenSocket)
+    {
+        return 0;
+    }
+
+	int i = listen(TheSocket, SOMAXCONN);
+	if (i >= 0)
+	{
+		IsListenSocket = true;
+	}
+
+	return i;
+}
+
+int TCPSocket::Connect(SockAddr* address)
+{
+	int retval;
+
+	retval = connect(TheSocket, (struct sockaddr *) &address->Addr6, sizeof(address->Addr6));
+	if (retval < 0)
+	{
+		DWORD dwIOError = WSAGetLastError();
+		if (dwIOError == WSAEWOULDBLOCK)
+		{
+            IsConnecting = true;
+            return 0;
+		}
+
+		printf( "TCPSocket::Connect failed:Error code - %d\n", dwIOError );
+	}
+
+	return retval;
+}
+
+int TCPSocket::Send(const void* pData, int bytes)
+{
+	if (bytes <= 0)
+	{
+		return 0;
+	}
+	else
+	{
+		return send(TheSocket, (const char*)pData, bytes, 0);
+	}
+}
+
+
+//// TCPSocketPollState
+
+TCPSocketPollState::TCPSocketPollState()
+{
+    FD_ZERO(&readFD);
+    FD_ZERO(&exceptionFD);
+    FD_ZERO(&writeFD);
+    largestDescriptor = INVALID_SOCKET;
+}
+
+bool TCPSocketPollState::IsValid() const
+{
+    return largestDescriptor != INVALID_SOCKET;
+}
+
+void TCPSocketPollState::Add(TCPSocket* tcpSocket)
+{
+    if (!tcpSocket)
+    {
+        return;
+    }
+
+    SocketHandle handle = tcpSocket->GetSocketHandle();
+
+    if (largestDescriptor == INVALID_SOCKET ||
+        largestDescriptor < handle)
+    {
+        largestDescriptor = handle;
+    }
+
+    FD_SET(handle, &readFD);
+    FD_SET(handle, &exceptionFD);
+
+    if (tcpSocket->IsConnecting)
+    {
+        FD_SET(handle, &writeFD);
+    }
+}
+
+bool TCPSocketPollState::Poll(long usec, long seconds)
+{
+    timeval tv;
+    tv.tv_sec = seconds;
+    tv.tv_usec = usec;
+
+    return (int)select((int)largestDescriptor + 1, &readFD, &writeFD, &exceptionFD, &tv) > 0;
+}
+
+void TCPSocketPollState::HandleEvent(TCPSocket* tcpSocket, SocketEvent_TCP* eventHandler)
+{
+    if (!tcpSocket || !eventHandler)
+    {
+        return;
+    }
+
+    SocketHandle handle = tcpSocket->GetSocketHandle();
+
+    if (tcpSocket->IsConnecting && FD_ISSET(handle, &writeFD))
+    {
+        tcpSocket->IsConnecting = false;
+        eventHandler->TCP_OnConnected(tcpSocket);
+    }
+
+    if (FD_ISSET(handle, &readFD))
+    {
+        if (!tcpSocket->IsListenSocket)
+        {
+            static const int BUFF_SIZE = 8096;
+            char data[BUFF_SIZE];
+
+            int bytesRead = recv(handle, data, BUFF_SIZE, 0);
+            if (bytesRead > 0)
+            {
+                tcpSocket->OnRecv(eventHandler, (uint8_t*)data, bytesRead);
+            }
+            else // Disconnection event:
+            {
+                tcpSocket->IsConnecting = false;
+                eventHandler->TCP_OnClosed(tcpSocket);
+            }
+        }
+        else
+        {
+            struct sockaddr_storage sockAddr;
+            socklen_t sockAddrSize = sizeof(sockAddr);
+
+            SocketHandle newSock = accept(handle, (sockaddr*)&sockAddr, (socklen_t*)&sockAddrSize);
+            if (newSock > 0)
+            {
+                SockAddr sa(&sockAddr);
+                eventHandler->TCP_OnAccept(tcpSocket, &sa, newSock);
+            }
+        }
+    }
+
+    if (FD_ISSET(handle, &exceptionFD))
+    {
+        tcpSocket->IsConnecting = false;
+        eventHandler->TCP_OnClosed(tcpSocket);
+    }
+}
+
+
+}} // namespace OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,151 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Win32_Socket.h
+Content     :   Windows-specific socket-based networking implementation
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Win32_Socket_h
+#define OVR_Win32_Socket_h
+
+#include "OVR_Socket.h"
+#include "OVR_BitStream.h"
+
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <io.h>
+
+namespace OVR { namespace Net { 
+
+
+//-----------------------------------------------------------------------------
+// SockAddr
+
+// Abstraction for IPV6 socket address, with various convenience functions
+class SockAddr
+{
+public:
+	SockAddr();
+	SockAddr(SockAddr* sa);
+	SockAddr(sockaddr_storage* sa);
+	SockAddr(sockaddr_in6* sa);
+	SockAddr(const char* hostAddress, uint16_t port, int sockType);
+
+public:
+	void   Set(const sockaddr_storage* sa);
+	void   Set(const sockaddr_in6* sa);
+	void   Set(const char* hostAddress, uint16_t port, int sockType); // SOCK_DGRAM or SOCK_STREAM
+
+	uint16_t GetPort();
+
+	String ToString(bool writePort, char portDelineator) const;
+    bool IsLocalhost() const;
+
+	void   Serialize(BitStream* bs);
+	bool   Deserialize(BitStream);
+
+	bool   operator==( const SockAddr& right ) const;
+	bool   operator!=( const SockAddr& right ) const;
+	bool   operator >( const SockAddr& right ) const;
+	bool   operator <( const SockAddr& right ) const;
+
+public:
+	sockaddr_in6 Addr6;
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP Socket
+
+// Windows version of TCP socket
+class UDPSocket : public UDPSocketBase
+{
+public:
+	UDPSocket();
+	virtual ~UDPSocket();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters);
+	virtual int          Send(const void* pData, int bytes, SockAddr* address);
+	virtual void         Poll(SocketEvent_UDP* eventHandler);
+
+protected:
+	static const int RecvBufSize = 1048576;
+	uint8_t* RecvBuf;
+
+	virtual void         OnRecv(SocketEvent_UDP* eventHandler, uint8_t* pData,
+								int bytesRead, SockAddr* address);
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Socket
+
+// Windows version of TCP socket
+class TCPSocket : public TCPSocketBase
+{
+    friend class TCPSocketPollState;
+
+public:
+	TCPSocket();
+	TCPSocket(SocketHandle boundHandle, bool isListenSocket);
+	virtual ~TCPSocket();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters);
+	virtual int          Listen();
+	virtual int          Connect(SockAddr* address);
+	virtual int          Send(const void* pData, int bytes);
+
+protected:
+	virtual void         OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData,
+								int bytesRead);
+
+public:
+	bool IsConnecting; // Is in the process of connecting?
+};
+
+
+//-----------------------------------------------------------------------------
+// TCPSocketPollState
+
+// Polls multiple blocking TCP sockets at once
+class TCPSocketPollState
+{
+    fd_set readFD, exceptionFD, writeFD;
+    SocketHandle largestDescriptor;
+
+public:
+    TCPSocketPollState();
+    bool IsValid() const;
+    void Add(TCPSocket* tcpSocket);
+    bool Poll(long usec = 30000, long seconds = 0);
+    void HandleEvent(TCPSocket* tcpSocket, SocketEvent_TCP* eventHandler);
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1101 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI.cpp
+Content     :   Experimental simple C interface to the HMD - version 1.
+Created     :   November 30, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_CAPI.h"
+#include "Kernel/OVR_Timer.h"
+#include "Kernel/OVR_Math.h"
+#include "Kernel/OVR_System.h"
+#include "OVR_Stereo.h"
+#include "OVR_Profile.h"
+#include "../Include/OVR_Version.h"
+
+#include "CAPI/CAPI_HMDState.h"
+#include "CAPI/CAPI_FrameTimeManager.h"
+
+#include "Service/Service_NetClient.h"
+#ifdef OVR_SINGLE_PROCESS
+#include "Service/Service_NetServer.h"
+#endif
+
+#ifdef OVR_OS_WIN32
+#include "Displays/OVR_Win32_ShimFunctions.h"
+#endif
+
+
+using namespace OVR;
+using namespace OVR::Util::Render;
+using namespace OVR::Tracking;
+
+//-------------------------------------------------------------------------------------
+// Math
+namespace OVR {
+
+
+// ***** FovPort
+
+// C-interop support: FovPort <-> ovrFovPort
+FovPort::FovPort(const ovrFovPort &src)
+    : UpTan(src.UpTan), DownTan(src.DownTan), LeftTan(src.LeftTan), RightTan(src.RightTan)
+{ }    
+
+FovPort::operator ovrFovPort () const
+{
+    ovrFovPort result;
+    result.LeftTan  = LeftTan;
+    result.RightTan = RightTan;
+    result.UpTan    = UpTan;
+    result.DownTan  = DownTan;
+    return result;
+}
+
+// Converts Fov Tan angle units to [-1,1] render target NDC space
+Vector2f FovPort::TanAngleToRendertargetNDC(Vector2f const &tanEyeAngle)
+{  
+    ScaleAndOffset2D eyeToSourceNDC = CreateNDCScaleAndOffsetFromFov(*this);
+    return tanEyeAngle * eyeToSourceNDC.Scale + eyeToSourceNDC.Offset;
+}
+
+// ***** SensorDataType
+
+SensorDataType::SensorDataType(const ovrSensorData& s)
+{
+    Acceleration = s.Accelerometer;
+    RotationRate = s.Gyro;
+    MagneticField = s.Magnetometer;
+    Temperature = s.Temperature;
+    AbsoluteTimeSeconds = s.TimeInSeconds;
+}
+
+SensorDataType::operator ovrSensorData () const
+{
+    ovrSensorData result;
+    result.Accelerometer = Acceleration;
+    result.Gyro = RotationRate;
+    result.Magnetometer = MagneticField;
+    result.Temperature = Temperature;
+    result.TimeInSeconds = (float) AbsoluteTimeSeconds;
+    return result;
+}
+
+
+// ***** SensorState
+
+TrackingState::TrackingState(const ovrTrackingState& s)
+{
+    HeadPose    = s.HeadPose;
+    CameraPose  = s.CameraPose;
+    LeveledCameraPose = s.LeveledCameraPose;
+    RawSensorData = s.RawSensorData;
+    StatusFlags = s.StatusFlags;
+}
+
+TrackingState::operator ovrTrackingState() const
+{
+    ovrTrackingState result;
+    result.HeadPose     = HeadPose;
+    result.CameraPose   = CameraPose;
+    result.LeveledCameraPose = LeveledCameraPose;
+    result.RawSensorData  = RawSensorData;
+    result.StatusFlags  = StatusFlags;
+    return result;
+}
+
+
+} // namespace OVR
+
+//-------------------------------------------------------------------------------------
+
+using namespace OVR::CAPI;
+
+#ifdef __cplusplus 
+extern "C" {
+#endif
+
+
+// Used to generate projection from ovrEyeDesc::Fov
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_Projection(ovrFovPort fov, float znear, float zfar, ovrBool rightHanded)
+{
+    return CreateProjection(rightHanded ? true : false, fov, znear, zfar);
+}
+
+
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale,
+                                                      float orthoDistance, float eyeViewAdjustX)
+{
+
+    float orthoHorizontalOffset = eyeViewAdjustX / orthoDistance;
+
+    // Current projection maps real-world vector (x,y,1) to the RT.
+    // We want to find the projection that maps the range [-FovPixels/2,FovPixels/2] to
+    // the physical [-orthoHalfFov,orthoHalfFov]
+    // Note moving the offset from M[0][2]+M[1][2] to M[0][3]+M[1][3] - this means
+    // we don't have to feed in Z=1 all the time.
+    // The horizontal offset math is a little hinky because the destination is
+    // actually [-orthoHalfFov+orthoHorizontalOffset,orthoHalfFov+orthoHorizontalOffset]
+    // So we need to first map [-FovPixels/2,FovPixels/2] to
+    //                         [-orthoHalfFov+orthoHorizontalOffset,orthoHalfFov+orthoHorizontalOffset]:
+    // x1 = x0 * orthoHalfFov/(FovPixels/2) + orthoHorizontalOffset;
+    //    = x0 * 2*orthoHalfFov/FovPixels + orthoHorizontalOffset;
+    // But then we need the sam mapping as the existing projection matrix, i.e.
+    // x2 = x1 * Projection.M[0][0] + Projection.M[0][2];
+    //    = x0 * (2*orthoHalfFov/FovPixels + orthoHorizontalOffset) * Projection.M[0][0] + Projection.M[0][2];
+    //    = x0 * Projection.M[0][0]*2*orthoHalfFov/FovPixels +
+    //      orthoHorizontalOffset*Projection.M[0][0] + Projection.M[0][2];
+    // So in the new projection matrix we need to scale by Projection.M[0][0]*2*orthoHalfFov/FovPixels and
+    // offset by orthoHorizontalOffset*Projection.M[0][0] + Projection.M[0][2].
+
+    Matrix4f ortho;
+    ortho.M[0][0] = projection.M[0][0] * orthoScale.x;
+    ortho.M[0][1] = 0.0f;
+    ortho.M[0][2] = 0.0f;
+    ortho.M[0][3] = -projection.M[0][2] + ( orthoHorizontalOffset * projection.M[0][0] );
+
+    ortho.M[1][0] = 0.0f;
+    ortho.M[1][1] = -projection.M[1][1] * orthoScale.y;       // Note sign flip (text rendering uses Y=down).
+    ortho.M[1][2] = 0.0f;
+    ortho.M[1][3] = -projection.M[1][2];
+
+    /*
+    if ( fabsf ( zNear - zFar ) < 0.001f )
+    {
+        ortho.M[2][0] = 0.0f;
+        ortho.M[2][1] = 0.0f;
+        ortho.M[2][2] = 0.0f;
+        ortho.M[2][3] = zFar;
+    }
+    else
+    {
+        ortho.M[2][0] = 0.0f;
+        ortho.M[2][1] = 0.0f;
+        ortho.M[2][2] = zFar / (zNear - zFar);
+        ortho.M[2][3] = (zFar * zNear) / (zNear - zFar);
+    }
+    */
+
+    // MA: Undo effect of sign
+    ortho.M[2][0] = 0.0f;
+    ortho.M[2][1] = 0.0f;
+    //ortho.M[2][2] = projection.M[2][2] * projection.M[3][2] * -1.0f; // reverse right-handedness
+    ortho.M[2][2] = 0.0f;
+    ortho.M[2][3] = 0.0f;
+        //projection.M[2][3];
+
+    // No perspective correction for ortho.
+    ortho.M[3][0] = 0.0f;
+    ortho.M[3][1] = 0.0f;
+    ortho.M[3][2] = 0.0f;
+    ortho.M[3][3] = 1.0f;
+
+    return ortho;
+}
+
+
+OVR_EXPORT double ovr_GetTimeInSeconds()
+{
+    return Timer::GetSeconds();
+}
+
+// Waits until the specified absolute time.
+OVR_EXPORT double ovr_WaitTillTime(double absTime)
+{
+    volatile int i;
+    double       initialTime = ovr_GetTimeInSeconds();
+    double       newTime     = initialTime;
+    
+    while(newTime < absTime)
+    {
+        for (int j = 0; j < 50; j++)
+            i = 0;
+        newTime = ovr_GetTimeInSeconds();
+    }
+
+    // How long we waited
+    return newTime - initialTime;
+}
+
+
+//-------------------------------------------------------------------------------------
+
+// 1. Init/shutdown.
+
+static ovrBool CAPI_SystemInitCalled = 0;
+static ovrBool CAPI_ovrInitializeCalled = 0;
+
+static OVR::Service::NetClient* CAPI_pNetClient = 0;
+
+OVR_EXPORT void ovr_InitializeRenderingShim()
+{
+	OVR::System::DirectDisplayInitialize();
+}
+
+OVR_EXPORT ovrBool ovr_Initialize()
+{
+    if (CAPI_ovrInitializeCalled)
+        return 1;
+
+    // We must set up the system for the plugin to work
+    if (!OVR::System::IsInitialized())
+    {
+        OVR::System::Init(OVR::Log::ConfigureDefaultLog(OVR::LogMask_All));
+        CAPI_SystemInitCalled = 1;
+    }
+
+    CAPI_pNetClient = NetClient::GetInstance();
+
+#ifdef OVR_SINGLE_PROCESS
+
+    // If the server could not start running,
+    if (Service::NetServer::GetInstance()->IsInitialized())
+    {
+        CAPI_pNetClient->Connect();
+    }
+    else
+    {
+        // This normally will happen if the OVRService is running in the background,
+        // or another SingleProcess-mode app is running in the background.
+        // In this case, it's using the hardware and we should not also attempt to use
+        // the hardware.
+        LogError("[LibOVR] Server is already running");
+    }
+#else
+    CAPI_pNetClient->Connect();
+#endif
+
+	CAPI_ovrInitializeCalled = 1;
+
+    return 1;
+}
+
+OVR_EXPORT void ovr_Shutdown()
+{  
+    // We should clean up the system to be complete
+	if (OVR::System::IsInitialized() && CAPI_SystemInitCalled)
+    {
+		OVR::System::Destroy();
+	}
+
+    CAPI_SystemInitCalled = 0;
+	CAPI_ovrInitializeCalled = 0;
+}
+
+
+// There is a thread safety issue with ovrHmd_Detect in that multiple calls from different
+// threads can corrupt the global array state. This would lead to two problems:
+//  a) Create(index) enumerator may miss or overshoot items. Probably not a big deal
+//     as game logic can easily be written to only do Detect(s)/Creates in one place.
+//     The alternative would be to return list handle.
+//  b) TBD: Un-mutexed Detect access from two threads could lead to crash. We should
+//         probably check this.
+//
+
+OVR_EXPORT int ovrHmd_Detect()
+{
+	if (!CAPI_ovrInitializeCalled)
+        return 0;
+
+	return CAPI_pNetClient->Hmd_Detect();
+}
+
+
+// ovrHmd_Create us explicitly separated from ConfigureTracking and ConfigureRendering to allow creation of 
+// a relatively light-weight handle that would reference the device going forward and would 
+// survive future ovrHmd_Detect calls. That is once ovrHMD is returned, index is no longer
+// necessary and can be changed by a ovrHmd_Detect call.
+OVR_EXPORT ovrHmd ovrHmd_Create(int index)
+{
+    if (!CAPI_ovrInitializeCalled)
+        return 0;
+
+    double t0 = Timer::GetSeconds();
+    HMDNetworkInfo netInfo;
+
+    // There may be some delay before the HMD is fully detected.
+    // Since we are also trying to create the HMD immediately it may lose this race and
+    // get "NO HMD DETECTED."  Wait a bit longer to avoid this.
+    while (!CAPI_pNetClient->Hmd_Create(index, &netInfo) ||
+           netInfo.NetId == InvalidVirtualHmdId)
+    {
+        // If two seconds elapse and still no HMD detected,
+        if (Timer::GetSeconds() - t0 > 2.)
+        {
+            return 0;
+        }
+    }
+
+    // Create HMD State object
+    HMDState* hmds = HMDState::CreateHMDState(CAPI_pNetClient, netInfo);
+    if (!hmds)
+    {
+        CAPI_pNetClient->Hmd_Release(netInfo.NetId);
+        return 0;
+    }
+
+    // Reset frame timing so that FrameTimeManager values are properly initialized in AppRendered mode.
+    ovrHmd_ResetFrameTiming(hmds->pHmdDesc, 0);
+
+    return hmds->pHmdDesc;
+}
+
+
+OVR_EXPORT ovrBool ovrHmd_AttachToWindow( ovrHmd hmd, void* window,
+										 const ovrRecti* destMirrorRect,
+										 const ovrRecti* sourceRenderTargetRect )
+{
+	OVR_UNUSED( destMirrorRect );
+	OVR_UNUSED( sourceRenderTargetRect );
+
+	if (!CAPI_ovrInitializeCalled)
+		return false;
+
+	if (!hmd || !hmd->Handle)
+		return false;
+
+#ifdef OVR_OS_WIN32
+    HMDState* hmds = (HMDState*)hmd->Handle;
+    CAPI_pNetClient->Hmd_AttachToWindow(hmds->GetNetId(), window);
+    hmds->pWindow = window;
+
+    Win32::DisplayShim::GetInstance().hWindow = (HWND)window;
+#endif
+	return true;
+}
+
+OVR_EXPORT ovrHmd ovrHmd_CreateDebug(ovrHmdType type)
+{
+	if (!CAPI_ovrInitializeCalled)
+        return 0;
+
+	HMDState* hmds = HMDState::CreateHMDState(type);
+
+    return hmds->pHmdDesc;
+}
+
+OVR_EXPORT void ovrHmd_Destroy(ovrHmd hmddesc)
+{
+    if (!hmddesc || !hmddesc->Handle)
+        return;
+    
+    // TBD: Any extra shutdown?
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+        
+    {   // Thread checker in its own scope, to avoid access after 'delete'.
+        // Essentially just checks that no other RenderAPI function is executing.
+        ThreadChecker::Scope checkScope(&hmds->RenderAPIThreadChecker, "ovrHmd_Destroy");
+    }    
+
+#ifdef OVR_OS_WIN32
+    if (hmds->pWindow)
+    {
+        // ? ok to call
+        //CAPI_pNetClient->Hmd_AttachToWindow(hmds->GetNetId(), 0);
+        hmds->pWindow = 0;
+        Win32::DisplayShim::GetInstance().hWindow = (HWND)0;
+    }    
+#endif
+
+    delete (HMDState*)hmddesc->Handle;
+}
+
+
+OVR_EXPORT const char* ovrHmd_GetLastError(ovrHmd hmddesc)
+{
+    if (!CAPI_ovrInitializeCalled)
+    {
+        return "System initialize not called";
+    }
+
+    if (hmddesc && hmddesc->Handle)
+    {
+        HMDState* p = (HMDState*)hmddesc->Handle;
+        return CAPI_pNetClient->Hmd_GetLastError(p->GetNetId());
+    }
+
+	return "Uninitialized Hmd";
+}
+
+// Returns version string representing libOVR version. Static, so
+// string remains valid for app lifespan
+OVR_EXPORT const char* ovr_GetVersionString()
+{
+	return "libOVR:" OVR_VERSION_STRING;
+}
+
+
+
+//-------------------------------------------------------------------------------------
+
+// Returns capability bits that are enabled at this time; described by ovrHmdCapBits.
+// Note that this value is different font ovrHmdDesc::Caps, which describes what
+// capabilities are available.
+OVR_EXPORT unsigned int ovrHmd_GetEnabledCaps(ovrHmd hmddesc)
+{
+    HMDState* p = (HMDState*)hmddesc->Handle;
+    return p ? p->EnabledHmdCaps : 0;
+}
+
+// Modifies capability bits described by ovrHmdCapBits that can be modified,
+// such as ovrHmd_LowPersistance.
+OVR_EXPORT void ovrHmd_SetEnabledCaps(ovrHmd hmddesc, unsigned int capsBits)
+{
+    HMDState* p = (HMDState*)hmddesc->Handle;
+    if (p)
+    {
+        p->SetEnabledHmdCaps(capsBits);
+    }
+}
+
+
+//-------------------------------------------------------------------------------------
+// *** Sensor
+
+// Sensor APIs are separated from Create & Configure for several reasons:
+//  - They need custom parameters that control allocation of heavy resources
+//    such as Vision tracking, which you don't want to create unless necessary.
+//  - A game may want to switch some sensor settings based on user input, 
+//    or at lease enable/disable features such as Vision for debugging.
+//  - The same or syntactically similar sensor interface is likely to be used if we 
+//    introduce controllers.
+//
+//  - Sensor interface functions are all Thread-safe, unlike the frame/render API
+//    functions that have different rules (all frame access functions
+//    must be on render thread)
+
+OVR_EXPORT ovrBool ovrHmd_ConfigureTracking(ovrHmd hmddesc, unsigned int supportedCaps,
+                                                            unsigned int requiredCaps)
+{
+	if (hmddesc)
+	{
+        HMDState* p = (HMDState*)hmddesc->Handle;
+        return p->ConfigureTracking(supportedCaps, requiredCaps);
+    }
+
+	return 0;
+}
+
+OVR_EXPORT void ovrHmd_RecenterPose(ovrHmd hmddesc)
+{
+	if (hmddesc)
+    {
+        HMDState* p = (HMDState*)hmddesc->Handle;
+        p->TheSensorStateReader.RecenterPose();
+    }
+}
+
+OVR_EXPORT ovrTrackingState ovrHmd_GetTrackingState(ovrHmd hmddesc, double absTime)
+{
+	ovrTrackingState result = {0};
+
+    if (hmddesc)
+    {
+        HMDState* p = (HMDState*)hmddesc->Handle;
+        result = p->PredictedTrackingState(absTime);
+    }
+
+#ifdef OVR_OS_WIN32
+		// Set up display code for Windows
+		Win32::DisplayShim::GetInstance().Active = (result.StatusFlags & ovrStatus_HmdConnected) != 0;
+#endif
+
+	return result;
+}
+
+
+//-------------------------------------------------------------------------------------
+// *** General Setup
+
+// Per HMD -> calculateIdealPixelSize
+OVR_EXPORT ovrSizei ovrHmd_GetFovTextureSize(ovrHmd hmddesc, ovrEyeType eye, ovrFovPort fov,
+                                             float pixelsPerDisplayPixel)
+{
+	ovrHmdStruct *  hmd = hmddesc->Handle;
+    if (!hmd) return Sizei(0);
+    
+    HMDState* hmds = (HMDState*)hmd;
+    return hmds->RenderState.GetFOVTextureSize(eye, fov, pixelsPerDisplayPixel);
+}
+
+
+//-------------------------------------------------------------------------------------
+
+
+OVR_EXPORT 
+ovrBool ovrHmd_ConfigureRendering( ovrHmd hmddesc,
+                                   const ovrRenderAPIConfig* apiConfig,
+                                   unsigned int distortionCaps,
+                                   const ovrFovPort eyeFovIn[2],
+                                   ovrEyeRenderDesc eyeRenderDescOut[2] )
+{
+	ovrHmdStruct *  hmd = hmddesc->Handle;
+    if (!hmd) return 0;
+    return ((HMDState*)hmd)->ConfigureRendering(eyeRenderDescOut, eyeFovIn,
+                                                apiConfig, distortionCaps);
+}
+
+
+
+// TBD: MA - Deprecated, need alternative
+void ovrHmd_SetVsync(ovrHmd hmddesc, ovrBool vsync)
+{
+	ovrHmdStruct *  hmd = hmddesc->Handle;
+    if (!hmd) return;
+
+    return ((HMDState*)hmd)->TimeManager.SetVsync(vsync? true : false);
+}
+
+
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrame(ovrHmd hmddesc, unsigned int frameIndex)
+{           
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    if (!hmds)
+    {
+        ovrFrameTiming f;
+        memset(&f, 0, sizeof(f));
+        return f;
+    }
+
+    // Check: Proper configure and threading state for the call.
+    hmds->checkRenderingConfigured("ovrHmd_BeginFrame");
+    OVR_ASSERT_LOG(hmds->BeginFrameCalled == false, ("ovrHmd_BeginFrame called multiple times."));
+    ThreadChecker::Scope checkScope(&hmds->RenderAPIThreadChecker, "ovrHmd_BeginFrame");
+    
+    hmds->BeginFrameCalled   = true;
+    hmds->BeginFrameThreadId = OVR::GetCurrentThreadId();
+
+    return ovrHmd_BeginFrameTiming(hmddesc, frameIndex);
+}
+
+
+// Renders textures to frame buffer
+OVR_EXPORT void ovrHmd_EndFrame(ovrHmd hmddesc,
+                                const ovrPosef renderPose[2],
+                                const ovrTexture eyeTexture[2])
+{
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    if (!hmds) return;
+
+    hmds->SubmitEyeTextures(renderPose, eyeTexture);
+
+    // Debug state checks: Must be in BeginFrame, on the same thread.
+    hmds->checkBeginFrameScope("ovrHmd_EndFrame");
+    ThreadChecker::Scope checkScope(&hmds->RenderAPIThreadChecker, "ovrHmd_EndFrame");  
+    
+    hmds->pRenderer->SetLatencyTestColor(hmds->LatencyTestActive ? hmds->LatencyTestDrawColor : NULL);
+
+    // TBD: Move directly into renderer
+	bool dk2LatencyTest = (hmds->EnabledHmdCaps & ovrHmdCap_DynamicPrediction) != 0;
+    if (dk2LatencyTest)
+    {
+        hmds->TimeManager.GetFrameLatencyTestDrawColor(hmds->LatencyTest2DrawColor);
+        hmds->pRenderer->SetLatencyTest2Color(hmds->LatencyTest2DrawColor);
+    }
+    else
+    {
+        hmds->pRenderer->SetLatencyTest2Color(NULL);
+    }
+    
+    if (hmds->pRenderer)
+	{
+		hmds->pRenderer->SaveGraphicsState();
+
+        // See if we need to show the HSWDisplay.
+        if (hmds->pHSWDisplay) // Until we know that these are valid, assume any of them can't be.
+        {
+            ovrHSWDisplayState hswDisplayState;
+            hmds->pHSWDisplay->TickState(&hswDisplayState);  // This may internally call HASWarning::Display.
+
+            if (hswDisplayState.Displayed)
+            {
+                hmds->pHSWDisplay->Render(ovrEye_Left, &eyeTexture[ovrEye_Left]);
+                hmds->pHSWDisplay->Render(ovrEye_Right, &eyeTexture[ovrEye_Right]);
+            }
+        }
+
+        hmds->pRenderer->EndFrame(true);
+		hmds->pRenderer->RestoreGraphicsState();
+    }
+    // Call after present
+    ovrHmd_EndFrameTiming(hmddesc);
+    
+    if (dk2LatencyTest)
+    {
+        Util::FrameTimeRecordSet recordset;
+        hmds->TheLatencyTestStateReader.GetRecordSet(recordset);
+        hmds->TimeManager.UpdateFrameLatencyTrackingAfterEndFrame( hmds->LatencyTest2DrawColor,
+                                                                   recordset);
+    }
+
+    // Out of BeginFrame
+    hmds->BeginFrameThreadId = 0;
+    hmds->BeginFrameCalled   = false;
+}
+
+
+// Not exposed as part of public API
+OVR_EXPORT void ovrHmd_RegisterPostDistortionCallback(ovrHmd hmddesc, PostDistortionCallback callback)
+{
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    if (!hmds) return;
+
+    if (hmds->pRenderer)
+    {
+        hmds->pRenderer->RegisterPostDistortionCallback(callback);
+    }
+}
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** Frame Timing logic
+
+
+OVR_EXPORT ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmd hmddesc, unsigned int frameIndex)
+{
+	ovrHmdStruct *  hmd = hmddesc->Handle;
+    ovrFrameTiming f;
+    memset(&f, 0, sizeof(f));
+
+    HMDState* hmds = (HMDState*)hmd;
+    if (hmds)
+    {
+        FrameTimeManager::Timing frameTiming = hmds->TimeManager.GetFrameTiming(frameIndex);
+
+        f.ThisFrameSeconds       = frameTiming.ThisFrameTime;
+        f.NextFrameSeconds       = frameTiming.NextFrameTime;
+        f.TimewarpPointSeconds   = frameTiming.TimewarpPointTime;
+        f.ScanoutMidpointSeconds = frameTiming.MidpointTime;
+        f.EyeScanoutSeconds[0]   = frameTiming.EyeRenderTimes[0];
+        f.EyeScanoutSeconds[1]   = frameTiming.EyeRenderTimes[1];
+
+         // Compute DeltaSeconds.
+        f.DeltaSeconds = (hmds->LastGetFrameTimeSeconds == 0.0f) ? 0.0f :
+                         (float) (f.ThisFrameSeconds - hmds->LastFrameTimeSeconds);    
+        hmds->LastGetFrameTimeSeconds = f.ThisFrameSeconds;
+        if (f.DeltaSeconds > 1.0f)
+            f.DeltaSeconds = 1.0f;
+    }
+        
+    return f;
+}
+
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmd hmddesc, unsigned int frameIndex)
+{
+	ovrHmdStruct *  hmd = hmddesc->Handle;
+    ovrFrameTiming f;
+    memset(&f, 0, sizeof(f));
+
+    HMDState* hmds = (HMDState*)hmd;
+    if (!hmds) return f;
+
+    // Check: Proper state for the call.    
+    OVR_ASSERT_LOG(hmds->BeginFrameTimingCalled == false,
+                    ("ovrHmd_BeginFrameTiming called multiple times."));    
+    hmds->BeginFrameTimingCalled = true;
+
+    double thisFrameTime = hmds->TimeManager.BeginFrame(frameIndex);        
+
+    const FrameTimeManager::Timing &frameTiming = hmds->TimeManager.GetFrameTiming();
+
+    f.ThisFrameSeconds      = thisFrameTime;
+    f.NextFrameSeconds      = frameTiming.NextFrameTime;
+    f.TimewarpPointSeconds  = frameTiming.TimewarpPointTime;
+    f.ScanoutMidpointSeconds= frameTiming.MidpointTime;
+    f.EyeScanoutSeconds[0]  = frameTiming.EyeRenderTimes[0];
+    f.EyeScanoutSeconds[1]  = frameTiming.EyeRenderTimes[1];
+
+    // Compute DeltaSeconds.
+    f.DeltaSeconds = (hmds->LastFrameTimeSeconds == 0.0f) ? 0.0f :
+                     (float) (thisFrameTime - hmds->LastFrameTimeSeconds);
+    hmds->LastFrameTimeSeconds = thisFrameTime;
+    if (f.DeltaSeconds > 1.0f)
+        f.DeltaSeconds = 1.0f;
+
+    return f;
+}
+
+
+OVR_EXPORT void ovrHmd_EndFrameTiming(ovrHmd hmddesc)
+{
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    if (!hmds) return;
+
+    // Debug state checks: Must be in BeginFrameTiming, on the same thread.
+    hmds->checkBeginFrameTimingScope("ovrHmd_EndTiming");
+   // MA TBD: Correct chek or not?
+   // ThreadChecker::Scope checkScope(&hmds->RenderAPIThreadChecker, "ovrHmd_EndFrame");
+
+    hmds->TimeManager.EndFrame();   
+    hmds->BeginFrameTimingCalled = false;
+}
+
+
+OVR_EXPORT void ovrHmd_ResetFrameTiming(ovrHmd hmddesc,  unsigned int frameIndex) 
+{
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    if (!hmds) return;
+    
+    hmds->TimeManager.ResetFrameTiming(frameIndex, 
+                                       false,
+                                       hmds->RenderingConfigured);
+    hmds->LastFrameTimeSeconds    = 0.0;
+    hmds->LastGetFrameTimeSeconds = 0.0;
+}
+
+
+ovrPosef ovrHmd_GetEyePose(ovrHmd hmd, ovrEyeType eye)
+{
+	HMDState* hmds = (HMDState*)hmd->Handle;
+    if (!hmds) return ovrPosef();    
+
+    // This isn't a great place, but since we removed ovrHmd_BeginEyeRender...
+    // Only process latency tester for drawing the left eye (assumes left eye is drawn first)
+    if (hmds->pRenderer && eye == 0)
+    {
+        hmds->LatencyTestActive = hmds->ProcessLatencyTest(hmds->LatencyTestDrawColor);
+    }
+
+    hmds->checkBeginFrameTimingScope("ovrHmd_GetEyePose");
+	return hmds->TimeManager.GetEyePredictionPose(hmd, eye);
+}
+
+
+OVR_EXPORT void ovrHmd_AddDistortionTimeMeasurement(ovrHmd hmddesc, double distortionTimeSeconds)
+{
+    if (!hmddesc)
+        return;
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+
+    hmds->checkBeginFrameTimingScope("ovrHmd_GetTimewarpEyeMatrices");   
+	hmds->TimeManager.AddDistortionTimeMeasurement(distortionTimeSeconds);
+}
+
+
+
+OVR_EXPORT void ovrHmd_GetEyeTimewarpMatrices(ovrHmd hmddesc, ovrEyeType eye,
+                                              ovrPosef renderPose, ovrMatrix4f twmOut[2])
+{
+    if (!hmddesc)
+        return;
+	HMDState* hmds = (HMDState*)hmddesc->Handle;
+
+    // Debug checks: BeginFrame was called, on the same thread.
+    hmds->checkBeginFrameTimingScope("ovrHmd_GetTimewarpEyeMatrices");   
+
+    hmds->TimeManager.GetTimewarpMatrices(hmddesc, eye, renderPose, twmOut);
+
+    /*
+    // MA: Took this out because new latency test approach just sames
+    //     the sample times in FrameTimeManager.
+    // TODO: if no timewarp, then test latency in begin eye render
+    if (eye == 0)
+    {        
+        hmds->ProcessLatencyTest2(hmds->LatencyTest2DrawColor, -1.0f);
+    }
+    */
+}
+
+
+
+OVR_EXPORT ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmd hmddesc,
+                                                 ovrEyeType eyeType, ovrFovPort fov)
+{
+    HMDState* hmds = (HMDState*)hmddesc->Handle;
+    ovrEyeRenderDesc erd;
+   
+    if (!hmds)
+    {
+        memset(&erd, 0, sizeof(erd));
+        return erd;
+    }
+
+    return hmds->RenderState.CalcRenderDesc(eyeType, fov);
+}
+
+
+
+#define OVR_OFFSET_OF(s, field) ((size_t)&((s*)0)->field)
+
+
+
+OVR_EXPORT ovrBool ovrHmd_CreateDistortionMesh( ovrHmd hmddesc,
+                                                ovrEyeType eyeType, ovrFovPort fov,
+                                                unsigned int distortionCaps,
+                                                ovrDistortionMesh *meshData)
+{
+    // The 'internal' function below can be found in CAPI_HMDState.
+	// Not ideal, but navigating the convolutions of what compiles
+	// where, meant they are in the few places which actually lets these compile.
+	// Please relocate (if you wish) to a more meaningful place if you can navigate the compiler gymnastics :)
+	return(ovrHmd_CreateDistortionMeshInternal( hmddesc->Handle,
+                                                eyeType, fov,
+                                                distortionCaps,
+                                                meshData,
+												0));
+
+
+}
+
+
+
+// Frees distortion mesh allocated by ovrHmd_GenerateDistortionMesh. meshData elements
+// are set to null and 0s after the call.
+OVR_EXPORT void ovrHmd_DestroyDistortionMesh(ovrDistortionMesh* meshData)
+{
+    if (meshData->pVertexData)
+        DistortionMeshDestroy((DistortionMeshVertexData*)meshData->pVertexData,
+                              meshData->pIndexData);
+    meshData->pVertexData = 0;
+    meshData->pIndexData  = 0;
+    meshData->VertexCount = 0;
+    meshData->IndexCount  = 0;
+}
+
+
+
+// Computes updated 'uvScaleOffsetOut' to be used with a distortion if render target size or
+// viewport changes after the fact. This can be used to adjust render size every frame, if desired.
+OVR_EXPORT void ovrHmd_GetRenderScaleAndOffset( ovrFovPort fov,
+                                                ovrSizei textureSize, ovrRecti renderViewport,
+                                                ovrVector2f uvScaleOffsetOut[2] )
+{        
+    // Find the mapping from TanAngle space to target NDC space.
+    ScaleAndOffset2D  eyeToSourceNDC = CreateNDCScaleAndOffsetFromFov(fov);
+    // Find the mapping from TanAngle space to textureUV space.
+    ScaleAndOffset2D  eyeToSourceUV  = CreateUVScaleAndOffsetfromNDCScaleandOffset(
+                                         eyeToSourceNDC,
+                                         renderViewport, textureSize );
+
+    uvScaleOffsetOut[0] = eyeToSourceUV.Scale;
+    uvScaleOffsetOut[1] = eyeToSourceUV.Offset;
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Latency Test interface
+
+OVR_EXPORT ovrBool ovrHmd_GetLatencyTestDrawColor(ovrHmd hmddesc, unsigned char rgbColorOut[3])
+{
+    HMDState* p = (HMDState*)hmddesc->Handle;
+    rgbColorOut[0] = p->LatencyTestDrawColor[0];
+    rgbColorOut[1] = p->LatencyTestDrawColor[1];
+    rgbColorOut[2] = p->LatencyTestDrawColor[2];
+    return p->LatencyTestActive;
+}
+
+OVR_EXPORT ovrBool ovrHmd_ProcessLatencyTest(ovrHmd hmddesc, unsigned char rgbColorOut[3])
+{
+    OVR_UNUSED(hmddesc);
+    return NetClient::GetInstance()->LatencyUtil_ProcessInputs(Timer::GetSeconds(), rgbColorOut);
+}
+
+OVR_EXPORT const char*  ovrHmd_GetLatencyTestResult(ovrHmd hmddesc)
+{
+    OVR_UNUSED(hmddesc);
+    return NetClient::GetInstance()->LatencyUtil_GetResultsString();
+}
+
+OVR_EXPORT double ovrHmd_GetMeasuredLatencyTest2(ovrHmd hmddesc)
+{
+    HMDState* p = (HMDState*)hmddesc->Handle;
+
+    // MA Test
+    float latencies[3];
+    p->TimeManager.GetLatencyTimings(latencies);
+    return latencies[2];
+  //  return p->LatencyUtil2.GetMeasuredLatency();
+}
+
+
+//-------------------------------------------------------------------------------------
+// ***** Health and Safety Warning Display interface
+//
+
+OVR_EXPORT void ovrHmd_GetHSWDisplayState(ovrHmd hmd, ovrHSWDisplayState *hswDisplayState)
+{
+    OVR::CAPI::HMDState* pHMDState = (OVR::CAPI::HMDState*)hmd->Handle;
+
+	if (pHMDState)
+	{
+        OVR::CAPI::HSWDisplay* pHSWDisplay = pHMDState->pHSWDisplay;
+
+        if(pHSWDisplay)
+            pHSWDisplay->TickState(hswDisplayState); // This may internally call HSWDisplay::Display.
+    }
+}
+
+OVR_EXPORT ovrBool ovrHmd_DismissHSWDisplay(ovrHmd hmd)
+{
+    OVR::CAPI::HMDState* pHMDState = (OVR::CAPI::HMDState*)hmd->Handle;
+
+	if (pHMDState)
+	{
+        OVR::CAPI::HSWDisplay* pHSWDisplay = pHMDState->pHSWDisplay;
+
+        if(pHSWDisplay)
+            return (pHSWDisplay->Dismiss() ? 1 : 0);
+    }
+
+    return false;
+}
+
+
+// -----------------------------------------------------------------------------------
+// ***** Property Access
+OVR_EXPORT ovrBool ovrHmd_GetBool(ovrHmd hmddesc, const char* propertyName, ovrBool defaultVal)
+    {
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->getBoolValue(propertyName, (defaultVal != 0));
+        }
+
+    return defaultVal;
+}
+
+OVR_EXPORT ovrBool ovrHmd_SetBool(ovrHmd hmddesc, const char* propertyName, ovrBool value)
+    {
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->setBoolValue(propertyName, value != 0) ? 1 : 0;
+        }
+    return false;
+    }
+
+OVR_EXPORT int ovrHmd_GetInt(ovrHmd hmddesc, const char* propertyName, int defaultVal)
+{
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->getIntValue(propertyName, defaultVal);
+        }
+
+    return defaultVal;
+}
+
+OVR_EXPORT ovrBool ovrHmd_SetInt(ovrHmd hmddesc, const char* propertyName, int value)
+    {
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+        return hmds->setIntValue(propertyName, value);
+        }
+    return false;
+    }
+
+OVR_EXPORT float ovrHmd_GetFloat(ovrHmd hmddesc, const char* propertyName, float defaultVal)
+{
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->getFloatValue(propertyName, defaultVal);
+        }
+
+    return defaultVal;
+}
+
+OVR_EXPORT ovrBool ovrHmd_SetFloat(ovrHmd hmddesc, const char* propertyName, float value)
+    {
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+        return hmds->setFloatValue(propertyName, value);
+        }
+    return false;
+    }
+
+OVR_EXPORT unsigned int ovrHmd_GetFloatArray(ovrHmd hmddesc, const char* propertyName,
+                              float values[], unsigned int arraySize)
+{
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->getFloatArray(propertyName, values, arraySize);
+        }
+
+    return 0;
+}
+
+// Modify float[] property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool ovrHmd_SetFloatArray(ovrHmd hmddesc, const char* propertyName,
+                                        float values[], unsigned int arraySize)
+    {
+    OVR_ASSERT(hmddesc && propertyName);
+    
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+        return hmds->setFloatArray(propertyName, values, arraySize);
+    }
+
+    return 0;
+}
+
+OVR_EXPORT const char* ovrHmd_GetString(ovrHmd hmddesc, const char* propertyName,
+                                        const char* defaultVal)
+{
+    OVR_ASSERT(hmddesc && propertyName);
+    
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->getString(propertyName, defaultVal);
+        }
+
+    return defaultVal;
+}
+ 
+OVR_EXPORT ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char* propertyName,
+                                    const char* value)
+{
+    OVR_ASSERT(hmddesc && propertyName);
+
+        HMDState* hmds = (HMDState*)hmddesc->Handle;
+        if (hmds)
+        {
+            return hmds->setString(propertyName, value) ? 1 : 0;
+        }
+
+    return 0;
+}
+
+
+#ifdef __cplusplus 
+} // extern "C"
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,920 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI.h
+Content     :   C Interface to Oculus tracking and rendering.
+Created     :   November 23, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+/// @file OVR_CAPI.h
+/// Exposes all general Rift functionality.
+/// 
+/// @mainpage Overview
+/// Welcome to the Oculus SDK Reference Manual. All SDK functionality is exposed through a simple and portable C API, found in OVR_CAPI.h.
+///
+/// Please see the Oculus Developer Guide for detailed information about using the SDK in your native applications.
+
+#ifndef OVR_CAPI_h
+#define OVR_CAPI_h
+
+#include <stdint.h>
+
+typedef char ovrBool;
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_EXPORT definition
+
+#if !defined(OVR_EXPORT)
+    #ifdef OVR_OS_WIN32
+        #define OVR_EXPORT __declspec(dllexport)        
+    #else
+        #define OVR_EXPORT
+    #endif
+#endif
+
+//#define ENABLE_LATENCY_TESTER
+
+//-----------------------------------------------------------------------------------
+// ***** Simple Math Structures
+
+/// A 2D vector with integer components.
+typedef struct ovrVector2i_
+{
+    int x, y;
+} ovrVector2i;
+/// A 2D size with integer components.
+typedef struct ovrSizei_
+{
+    int w, h;
+} ovrSizei;
+/// A 2D rectangle with a position and size.
+/// All components are integers.
+typedef struct ovrRecti_
+{
+    ovrVector2i Pos;
+    ovrSizei    Size;
+} ovrRecti;
+
+/// A quaternion rotation.
+typedef struct ovrQuatf_
+{
+    float x, y, z, w;  
+} ovrQuatf;
+/// A 2D vector with float components.
+typedef struct ovrVector2f_
+{
+    float x, y;
+} ovrVector2f;
+/// A 3D vector with float components.
+typedef struct ovrVector3f_
+{
+    float x, y, z;
+} ovrVector3f;
+/// A 4x4 matrix with float elements.
+typedef struct ovrMatrix4f_
+{
+    float M[4][4];
+} ovrMatrix4f;
+/// Position and orientation together.
+typedef struct ovrPosef_
+{
+    ovrQuatf     Orientation;
+    ovrVector3f  Position;    
+} ovrPosef;
+
+/// A full pose (rigid body) configuration with first and second derivatives.
+typedef struct ovrPoseStatef_
+{
+    ovrPosef     ThePose;
+    ovrVector3f  AngularVelocity;
+    ovrVector3f  LinearVelocity;
+    ovrVector3f  AngularAcceleration;
+    ovrVector3f  LinearAcceleration;
+    double       TimeInSeconds;         // Absolute time of this state sample.
+} ovrPoseStatef;
+
+/// Field Of View (FOV) in tangent of the angle units.
+/// As an example, for a standard 90 degree vertical FOV, we would 
+/// have: { UpTan = tan(90 degrees / 2), DownTan = tan(90 degrees / 2) }.
+typedef struct ovrFovPort_
+{
+    /// The tangent of the angle between the viewing vector and the top edge of the field of view.
+    float UpTan;
+    /// The tangent of the angle between the viewing vector and the bottom edge of the field of view.
+    float DownTan;
+    /// The tangent of the angle between the viewing vector and the left edge of the field of view.
+    float LeftTan;
+    /// The tangent of the angle between the viewing vector and the right edge of the field of view.
+    float RightTan;
+} ovrFovPort;
+
+
+//-----------------------------------------------------------------------------------
+// ***** HMD Types
+
+/// Enumerates all HMD types that we support.
+typedef enum
+{
+    ovrHmd_None             = 0,    
+    ovrHmd_DK1              = 3,
+    ovrHmd_DKHD             = 4,    
+    ovrHmd_DK2              = 6,
+    ovrHmd_Other             // Some HMD other then the one in the enumeration.
+} ovrHmdType;
+
+/// HMD capability bits reported by device.
+typedef enum
+{
+    // Read-only flags.
+    ovrHmdCap_Present           = 0x0001,   ///  The HMD is plugged in and detected by the system.
+    ovrHmdCap_Available         = 0x0002,   ///  The HMD and its sensor is available for ownership use.
+											///  i.e. it is not already owned by another application.
+    ovrHmdCap_Captured          = 0x0004,   ///  Set to 'true' if we captured ownership of this HMD.
+
+    // These flags are intended for use with the new driver display mode.
+    ovrHmdCap_ExtendDesktop     = 0x0008,   /// (read only) Means the display driver is in compatibility mode.
+
+    // Modifiable flags (through ovrHmd_SetEnabledCaps).
+    ovrHmdCap_NoMirrorToWindow  = 0x2000,   /// Disables mirroring of HMD output to the window. This may improve 
+											/// rendering performance slightly (only if 'ExtendDesktop' is off).
+    ovrHmdCap_DisplayOff        = 0x0040,   /// Turns off HMD screen and output (only if 'ExtendDesktop' is off).
+
+    ovrHmdCap_LowPersistence    = 0x0080,   ///  HMD supports low persistence mode.
+    ovrHmdCap_DynamicPrediction = 0x0200,   ///  Adjust prediction dynamically based on internally measured latency.
+    /// Support rendering without VSync for debugging.
+    ovrHmdCap_NoVSync           = 0x1000,
+
+    // These bits can be modified by ovrHmd_SetEnabledCaps.
+    ovrHmdCap_Writable_Mask     = 0x33F0,
+    /// These flags are currently passed into the service. May change without notice.
+    ovrHmdCap_Service_Mask      = 0x23F0
+} ovrHmdCaps;
+
+
+/// Tracking capability bits reported by the device.
+/// Used with ovrHmd_ConfigureTracking.
+typedef enum
+{
+    ovrTrackingCap_Orientation      = 0x0010,   ///  Supports orientation tracking (IMU).
+    ovrTrackingCap_MagYawCorrection = 0x0020,   ///  Supports yaw drift correction via a magnetometer or other means.
+    ovrTrackingCap_Position         = 0x0040,   ///  Supports positional tracking.
+    ///  Overrides the other flags. Indicates that the application
+    ///  doesn't care about tracking settings. This is the internal
+    ///  default before ovrHmd_ConfigureTracking is called.
+    ovrTrackingCap_Idle             = 0x0100,
+} ovrTrackingCaps;
+
+/// Distortion capability bits reported by device.
+/// Used with ovrHmd_ConfigureRendering and ovrHmd_CreateDistortionMesh.
+typedef enum
+{        
+    ovrDistortionCap_Chromatic	    = 0x01,		///	Supports chromatic aberration correction.
+    ovrDistortionCap_TimeWarp	    = 0x02,		///	Supports timewarp.
+    ovrDistortionCap_Vignette	    = 0x08,		///	Supports vignetting around the edges of the view.
+    ovrDistortionCap_NoRestore      = 0x10,		///  Do not save and restore the graphics state when rendering distortion.
+    ovrDistortionCap_FlipInput      = 0x20,		///  Flip the vertical texture coordinate of input images.
+    ovrDistortionCap_SRGB           = 0x40,		///  Assume input images are in sRGB gamma-corrected color space.
+    ovrDistortionCap_Overdrive      = 0x80,		///  Overdrive brightness transitions to reduce artifacts on DK2+ displays
+
+    ovrDistortionCap_ProfileNoTimewarpSpinWaits = 0x10000,  /// Use when profiling with timewarp to remove false positives
+} ovrDistortionCaps;
+
+
+/// Specifies which eye is being used for rendering.
+/// This type explicitly does not include a third "NoStereo" option, as such is
+/// not required for an HMD-centered API.
+typedef enum
+{
+    ovrEye_Left  = 0,
+    ovrEye_Right = 1,
+    ovrEye_Count = 2
+} ovrEyeType;
+
+
+
+/// This is a complete descriptor of the HMD.
+typedef struct ovrHmdDesc_
+{
+    /// Internal handle of this HMD.
+    struct ovrHmdStruct* Handle;
+
+    /// This HMD's type.
+    ovrHmdType  Type;
+    
+    /// Name string describing the product: "Oculus Rift DK1", etc.
+    const char* ProductName;    
+    const char* Manufacturer;
+    
+    /// HID Vendor and ProductId of the device.
+    short       VendorId;
+    short       ProductId;
+    /// Sensor (and display) serial number.
+    char        SerialNumber[24];
+    /// Sensor firmware version.
+    short       FirmwareMajor;
+    short       FirmwareMinor;
+    /// External tracking camera frustum dimensions (if present).
+    float       CameraFrustumHFovInRadians;
+    float       CameraFrustumVFovInRadians;
+    float       CameraFrustumNearZInMeters;
+    float       CameraFrustumFarZInMeters;
+
+    /// Capability bits described by ovrHmdCaps.
+    unsigned int HmdCaps;
+	/// Capability bits described by ovrTrackingCaps.
+    unsigned int TrackingCaps;
+    /// Capability bits described by ovrDistortionCaps.
+    unsigned int DistortionCaps;
+
+    /// These define the recommended and maximum optical FOVs for the HMD.    
+    ovrFovPort  DefaultEyeFov[ovrEye_Count];
+    ovrFovPort  MaxEyeFov[ovrEye_Count];
+
+    /// Preferred eye rendering order for best performance.
+    /// Can help reduce latency on sideways-scanned screens.
+    ovrEyeType  EyeRenderOrder[ovrEye_Count];
+
+    /// Resolution of the full HMD screen (both eyes) in pixels.
+    ovrSizei    Resolution;
+    /// Location of the application window on the desktop (or 0,0).
+    ovrVector2i WindowsPos;     
+
+    /// Display that the HMD should present on.
+    /// TBD: It may be good to remove this information relying on WindowPos instead.
+    /// Ultimately, we may need to come up with a more convenient alternative,
+    /// such as API-specific functions that return adapter, or something that will
+    /// work with our monitor driver.
+    /// Windows: (e.g. "\\\\.\\DISPLAY3", can be used in EnumDisplaySettings/CreateDC).
+    const char* DisplayDeviceName;
+    /// MacOS:
+    int         DisplayId;
+  
+} ovrHmdDesc;
+
+
+/// Simple type ovrHmd is used in ovrHmd_* calls.
+typedef const ovrHmdDesc * ovrHmd;
+
+
+
+/// Bit flags describing the current status of sensor tracking.
+typedef enum
+{
+    ovrStatus_OrientationTracked    = 0x0001,   /// Orientation is currently tracked (connected and in use).
+    ovrStatus_PositionTracked       = 0x0002,   /// Position is currently tracked (false if out of range).
+    ovrStatus_CameraPoseTracked     = 0x0004,   /// Camera pose is currently tracked.
+    ovrStatus_PositionConnected     = 0x0020,   /// Position tracking hardware is connected.
+    ovrStatus_HmdConnected          = 0x0080    /// HMD Display is available and connected.
+} ovrStatusBits;
+
+/// Specifies a reading we can query from the sensor.
+typedef struct ovrSensorData_
+{
+    ovrVector3f    Accelerometer;    /// Acceleration reading in m/s^2.
+    ovrVector3f    Gyro;             /// Rotation rate in rad/s.
+    ovrVector3f    Magnetometer;     /// Magnetic field in Gauss.
+    float          Temperature;      /// Temperature of the sensor in degrees Celsius.
+    float          TimeInSeconds;    /// Time when the reported IMU reading took place, in seconds.
+} ovrSensorData;
+
+
+/// Tracking state at a given absolute time (describes predicted HMD pose etc).
+/// Returned by ovrHmd_GetTrackingState.
+typedef struct ovrTrackingState_
+{
+    /// Predicted head pose (and derivatives) at the requested absolute time.
+    /// The look-ahead interval is equal to (HeadPose.TimeInSeconds - RawSensorData.TimeInSeconds).
+    ovrPoseStatef  HeadPose;
+
+    /// Current pose of the external camera (if present).
+    /// This pose includes camera tilt (roll and pitch). For a leveled coordinate
+    /// system use LeveledCameraPose.
+    ovrPosef       CameraPose;
+
+    /// Camera frame aligned with gravity.
+    /// This value includes position and yaw of the camera, but not roll and pitch.
+    /// It can be used as a reference point to render real-world objects in the correct location.
+    ovrPosef       LeveledCameraPose;
+
+    /// The most recent sensor data received from the HMD.
+    ovrSensorData  RawSensorData;
+
+    /// Tracking status described by ovrStatusBits.
+    unsigned int   StatusFlags;
+} ovrTrackingState;
+
+
+/// Frame timing data reported by ovrHmd_BeginFrameTiming() or ovrHmd_BeginFrame().
+typedef struct ovrFrameTiming_
+{
+    /// The amount of time that has passed since the previous frame's
+	/// ThisFrameSeconds value (usable for movement scaling).
+    /// This will be clamped to no more than 0.1 seconds to prevent
+    /// excessive movement after pauses due to loading or initialization.
+    float			DeltaSeconds;
+
+    /// It is generally expected that the following holds:
+    /// ThisFrameSeconds < TimewarpPointSeconds < NextFrameSeconds < 
+    /// EyeScanoutSeconds[EyeOrder[0]] <= ScanoutMidpointSeconds <= EyeScanoutSeconds[EyeOrder[1]].
+
+    /// Absolute time value when rendering of this frame began or is expected to
+    /// begin. Generally equal to NextFrameSeconds of the previous frame. Can be used
+    /// for animation timing.
+    double			ThisFrameSeconds;
+    /// Absolute point when IMU expects to be sampled for this frame.
+    double			TimewarpPointSeconds;
+    /// Absolute time when frame Present followed by GPU Flush will finish and the next frame begins.
+    double			NextFrameSeconds;
+
+    /// Time when when half of the screen will be scanned out. Can be passed as an absolute time
+	/// to ovrHmd_GetTrackingState() to get the predicted general orientation.
+    double		    ScanoutMidpointSeconds;
+    /// Timing points when each eye will be scanned out to display. Used when rendering each eye.
+    double			EyeScanoutSeconds[2];    
+} ovrFrameTiming;
+
+
+
+/// Rendering information for each eye. Computed by either ovrHmd_ConfigureRendering()
+/// or ovrHmd_GetRenderDesc() based on the specified FOV. Note that the rendering viewport 
+/// is not included here as it can be specified separately and modified per frame through:
+///    (a) ovrHmd_GetRenderScaleAndOffset in the case of client rendered distortion,
+/// or (b) passing different values via ovrTexture in the case of SDK rendered distortion.
+typedef struct ovrEyeRenderDesc_
+{    
+    ovrEyeType  Eye;
+    ovrFovPort  Fov;
+	ovrRecti	DistortedViewport; 	        /// Distortion viewport.
+    ovrVector2f PixelsPerTanAngleAtCenter;  /// How many display pixels will fit in tan(angle) = 1.
+    ovrVector3f ViewAdjust;  		        /// Translation to be applied to view matrix.
+} ovrEyeRenderDesc;
+
+
+//-----------------------------------------------------------------------------------
+// ***** Platform-independent Rendering Configuration
+
+/// These types are used to hide platform-specific details when passing
+/// render device, OS, and texture data to the API.
+///
+/// The benefit of having these wrappers versus platform-specific API functions is
+/// that they allow game glue code to be portable. A typical example is an
+/// engine that has multiple back ends, say GL and D3D. Portable code that calls
+/// these back ends may also use LibOVR. To do this, back ends can be modified
+/// to return portable types such as ovrTexture and ovrRenderAPIConfig.
+typedef enum
+{
+    ovrRenderAPI_None,
+    ovrRenderAPI_OpenGL,
+    ovrRenderAPI_Android_GLES,  // May include extra native window pointers, etc.
+    ovrRenderAPI_D3D9,
+    ovrRenderAPI_D3D10,
+    ovrRenderAPI_D3D11,
+    ovrRenderAPI_Count
+} ovrRenderAPIType;
+
+/// Platform-independent part of rendering API-configuration data.
+/// It is a part of ovrRenderAPIConfig, passed to ovrHmd_Configure.
+typedef struct ovrRenderAPIConfigHeader_
+{
+    ovrRenderAPIType API;
+    ovrSizei         RTSize;
+    int              Multisample;
+} ovrRenderAPIConfigHeader;
+
+/// Contains platform-specific information for rendering.
+typedef struct ovrRenderAPIConfig_
+{
+    ovrRenderAPIConfigHeader Header;
+    uintptr_t                PlatformData[8];
+} ovrRenderAPIConfig;
+
+/// Platform-independent part of the eye texture descriptor.
+/// It is a part of ovrTexture, passed to ovrHmd_EndFrame.
+/// If RenderViewport is all zeros then the full texture will be used.
+typedef struct ovrTextureHeader_
+{
+    ovrRenderAPIType API;
+    ovrSizei         TextureSize;
+    ovrRecti         RenderViewport;  // Pixel viewport in texture that holds eye image.
+} ovrTextureHeader;
+
+/// Contains platform-specific information about a texture.
+typedef struct ovrTexture_
+{
+    ovrTextureHeader Header;
+    uintptr_t        PlatformData[8];
+} ovrTexture;
+
+
+// -----------------------------------------------------------------------------------
+// ***** API Interfaces
+
+// Basic steps to use the API:
+//
+// Setup:
+//  1. ovrInitialize()
+//  2. ovrHMD hmd = ovrHmd_Create(0)
+//  3. Use hmd members and ovrHmd_GetFovTextureSize() to determine graphics configuration.
+//  4. Call ovrHmd_ConfigureTracking() to configure and initialize tracking.
+//  5. Call ovrHmd_ConfigureRendering() to setup graphics for SDK rendering,
+//     which is the preferred approach.
+//     Please refer to "Client Distorton Rendering" below if you prefer to do that instead.
+//  6. If the ovrHmdCap_ExtendDesktop flag is not set, then use ovrHmd_AttachToWindow to 
+//     associate the relevant application window with the hmd.
+//  5. Allocate render target textures as needed.
+//
+// Game Loop:
+//  6. Call ovrHmd_BeginFrame() to get the current frame timing information.
+//  7. Render each eye using ovrHmd_GetEyePose to get the predicted head pose.
+//  8. Call ovrHmd_EndFrame() to render the distorted textures to the back buffer
+//     and present them on the hmd.
+//
+// Shutdown:
+//  9. ovrHmd_Destroy(hmd)
+//  10. ovr_Shutdown()
+//
+
+#ifdef __cplusplus 
+extern "C" {
+#endif
+
+// ovr_InitializeRenderingShim initializes the rendering shim appart from everything
+// else in LibOVR. This may be helpful if the application prefers to avoid
+// creating any OVR resources (allocations, service connections, etc) at this point.
+// ovr_InitializeRenderingShim does not bring up anything within LibOVR except the
+// necessary hooks to enable the Direct-to-Rift functionality.
+//
+// Either ovr_InitializeRenderingShim() or ovr_Initialize() must be called before any
+// Direct3D or OpenGL initilization is done by applictaion (creation of devices, etc).
+// ovr_Initialize() must still be called after to use the rest of LibOVR APIs.
+OVR_EXPORT void ovr_InitializeRenderingShim();
+
+// Library init/shutdown, must be called around all other OVR code.
+// No other functions calls besides ovr_InitializeRenderingShim are allowed
+// before ovr_Initialize succeeds or after ovr_Shutdown.
+/// Initializes all Oculus functionality.
+OVR_EXPORT ovrBool  ovr_Initialize();
+/// Shuts down all Oculus functionality.
+OVR_EXPORT void     ovr_Shutdown();
+
+/// Returns version string representing libOVR version. Static, so
+/// string remains valid for app lifespan
+OVR_EXPORT const char* ovr_GetVersionString();
+
+
+
+/// Detects or re-detects HMDs and reports the total number detected.
+/// Users can get information about each HMD by calling ovrHmd_Create with an index.
+OVR_EXPORT int      ovrHmd_Detect();
+
+
+/// Creates a handle to an HMD which doubles as a description structure.
+/// Index can [0 .. ovrHmd_Detect()-1]. Index mappings can cange after each ovrHmd_Detect call.
+/// If not null, then the returned handle must be freed with ovrHmd_Destroy.
+OVR_EXPORT ovrHmd   ovrHmd_Create(int index);
+OVR_EXPORT void     ovrHmd_Destroy(ovrHmd hmd);
+
+/// Creates a 'fake' HMD used for debugging only. This is not tied to specific hardware,
+/// but may be used to debug some of the related rendering.
+OVR_EXPORT ovrHmd   ovrHmd_CreateDebug(ovrHmdType type);
+
+
+/// Returns last error for HMD state. Returns null for no error.
+/// String is valid until next call or GetLastError or HMD is destroyed.
+/// Pass null hmd to get global errors (during create etc).
+OVR_EXPORT const char* ovrHmd_GetLastError(ovrHmd hmd);
+
+/// Platform specific function to specify the application window whose output will be 
+/// displayed on the HMD. Only used if the ovrHmdCap_ExtendDesktop flag is false.
+///   Windows: SwapChain associated with this window will be displayed on the HMD.
+///            Specify 'destMirrorRect' in window coordinates to indicate an area
+///            of the render target output that will be mirrored from 'sourceRenderTargetRect'.
+///            Null pointers mean "full size".
+/// @note Source and dest mirror rects are not yet implemented.
+OVR_EXPORT ovrBool ovrHmd_AttachToWindow(ovrHmd hmd, void* window,
+										 const ovrRecti* destMirrorRect,
+										 const ovrRecti* sourceRenderTargetRect);
+
+//-------------------------------------------------------------------------------------
+
+/// Returns capability bits that are enabled at this time as described by ovrHmdCaps.
+/// Note that this value is different font ovrHmdDesc::HmdCaps, which describes what
+/// capabilities are available for that HMD.
+OVR_EXPORT unsigned int ovrHmd_GetEnabledCaps(ovrHmd hmd);
+
+/// Modifies capability bits described by ovrHmdCaps that can be modified,
+/// such as ovrHmd_LowPersistance.
+OVR_EXPORT void         ovrHmd_SetEnabledCaps(ovrHmd hmd, unsigned int hmdCaps);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Tracking Interface
+
+/// All tracking interface functions are thread-safe, allowing tracking state to be sampled
+/// from different threads.
+/// ConfigureTracking starts sensor sampling, enabling specified capabilities,
+///    described by ovrTrackingCaps.
+///  - supportedTrackingCaps specifies support that is requested. The function will succeed 
+///	  even if these caps are not available (i.e. sensor or camera is unplugged). Support
+///    will automatically be enabled if such device is plugged in later. Software should
+///    check ovrTrackingState.StatusFlags for real-time status.
+///  - requiredTrackingCaps specify sensor capabilities required at the time of the call.
+///    If they are not available, the function will fail. Pass 0 if only specifying
+///    supportedTrackingCaps.
+///  - Pass 0 for both supportedTrackingCaps and requiredTrackingCaps to disable tracking.
+OVR_EXPORT ovrBool  ovrHmd_ConfigureTracking(ovrHmd hmd, unsigned int supportedTrackingCaps,
+													     unsigned int requiredTrackingCaps);
+
+/// Re-centers the sensor orientation.
+/// Normally this will recenter the (x,y,z) translational components and the yaw 
+/// component of orientation.
+OVR_EXPORT void     ovrHmd_RecenterPose(ovrHmd hmd);
+
+/// Returns tracking state reading based on the specified absolute system time.
+/// Pass an absTime value of 0.0 to request the most recent sensor reading. In this case
+/// both PredictedPose and SamplePose will have the same value.
+/// ovrHmd_GetEyePose relies on this internally.
+/// This may also be used for more refined timing of FrontBuffer rendering logic, etc.
+OVR_EXPORT ovrTrackingState ovrHmd_GetTrackingState(ovrHmd hmd, double absTime);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Graphics Setup
+
+
+/// Calculates the recommended texture size for rendering a given eye within the HMD
+/// with a given FOV cone. Higher FOV will generally require larger textures to 
+/// maintain quality.
+///  - pixelsPerDisplayPixel specifies the ratio of the number of render target pixels 
+///    to display pixels at the center of distortion. 1.0 is the default value. Lower
+///    values can improve performance.
+OVR_EXPORT ovrSizei ovrHmd_GetFovTextureSize(ovrHmd hmd, ovrEyeType eye, ovrFovPort fov,
+                                             float pixelsPerDisplayPixel);
+
+
+
+//-------------------------------------------------------------------------------------
+// *****  Rendering API Thread Safety
+
+//  All of rendering functions including the configure and frame functions
+// are *NOT thread safe*. It is ok to use ConfigureRendering on one thread and handle
+//  frames on another thread, but explicit synchronization must be done since
+//  functions that depend on configured state are not reentrant.
+//
+//  As an extra requirement, any of the following calls must be done on
+//  the render thread, which is the same thread that calls ovrHmd_BeginFrame
+//  or ovrHmd_BeginFrameTiming.
+//    - ovrHmd_EndFrame
+//    - ovrHmd_GetEyePose
+//    - ovrHmd_GetEyeTimewarpMatrices
+
+
+//-------------------------------------------------------------------------------------
+// *****  SDK Distortion Rendering Functions
+
+// These functions support rendering of distortion by the SDK through direct
+// access to the underlying rendering API, such as D3D or GL.
+// This is the recommended approach since it allows better support for future
+// Oculus hardware, and enables a range of low-level optimizations.
+
+
+/// Configures rendering and fills in computed render parameters.
+/// This function can be called multiple times to change rendering settings.
+/// eyeRenderDescOut is a pointer to an array of two ovrEyeRenderDesc structs
+/// that are used to return complete rendering information for each eye.
+///
+///  - apiConfig provides D3D/OpenGL specific parameters. Pass null
+///    to shutdown rendering and release all resources.
+///  - distortionCaps describe desired distortion settings.
+///
+OVR_EXPORT ovrBool ovrHmd_ConfigureRendering( ovrHmd hmd,
+                                              const ovrRenderAPIConfig* apiConfig,
+                                              unsigned int distortionCaps,
+                                              const ovrFovPort eyeFovIn[2],
+                                              ovrEyeRenderDesc eyeRenderDescOut[2] );
+
+
+/// Begins a frame, returning timing information.
+/// This should be called at the beginning of the game rendering loop (on the render thread).
+/// Pass 0 for the frame index if not using ovrHmd_GetFrameTiming.
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrame(ovrHmd hmd, unsigned int frameIndex);
+
+/// Ends a frame, submitting the rendered textures to the frame buffer.
+/// - RenderViewport within each eyeTexture can change per frame if necessary.
+/// - 'renderPose' will typically be the value returned from ovrHmd_GetEyePose, 
+///   but can be different if a different head pose was used for rendering.
+/// - This may perform distortion and scaling internally, assuming is it not 
+///   delegated to another thread. 
+/// - Must be called on the same thread as BeginFrame.
+/// - *** This Function will call Present/SwapBuffers and potentially wait for GPU Sync ***.
+OVR_EXPORT void     ovrHmd_EndFrame(ovrHmd hmd,
+                                    const ovrPosef renderPose[2],
+                                    const ovrTexture eyeTexture[2]);
+
+
+/// Returns the predicted head pose to use when rendering the specified eye.
+/// - Must be called between ovrHmd_BeginFrameTiming and ovrHmd_EndFrameTiming.
+/// - If the pose is used for rendering the eye, it should be passed to ovrHmd_EndFrame.
+OVR_EXPORT ovrPosef ovrHmd_GetEyePose(ovrHmd hmd, ovrEyeType eye);
+
+
+
+//-------------------------------------------------------------------------------------
+// *****  Client Distortion Rendering Functions
+
+// These functions provide the distortion data and render timing support necessary to allow
+// client rendering of distortion. Client-side rendering involves the following steps:
+//
+//  1. Setup ovrEyeDesc based on the desired texture size and FOV.
+//     Call ovrHmd_GetRenderDesc to get the necessary rendering parameters for each eye.
+// 
+//  2. Use ovrHmd_CreateDistortionMesh to generate the distortion mesh.
+//
+//  3. Use ovrHmd_BeginFrameTiming, ovrHmd_GetEyePose, and ovrHmd_BeginFrameTiming
+//     in the rendering loop to obtain timing and predicted head orientation when
+//     rendering each eye.
+//      - When using timewarp, use ovr_WaitTillTime after the rendering and gpu flush, followed
+//        by ovrHmd_GetEyeTimewarpMatrices to obtain the timewarp matrices used 
+//        by the distortion pixel shader. This will minimize latency.
+//
+
+/// Computes the distortion viewport, view adjust, and other rendering parameters for 
+/// the specified eye. This can be used instead of ovrHmd_ConfigureRendering to do 
+/// setup for client rendered distortion.
+OVR_EXPORT ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmd hmd,
+                                                 ovrEyeType eyeType, ovrFovPort fov);
+
+
+/// Describes a vertex used by the distortion mesh. This is intended to be converted into
+/// the engine-specific format. Some fields may be unused based on the ovrDistortionCaps 
+/// flags selected. TexG and TexB, for example, are not used if chromatic correction is 
+/// not requested.
+typedef struct ovrDistortionVertex_
+{
+    ovrVector2f ScreenPosNDC;    // [-1,+1],[-1,+1] over the entire framebuffer.
+    float       TimeWarpFactor;  // Lerp factor between time-warp matrices. Can be encoded in Pos.z.
+    float       VignetteFactor;  // Vignette fade factor. Can be encoded in Pos.w.
+    ovrVector2f TanEyeAnglesR;
+    ovrVector2f TanEyeAnglesG;
+    ovrVector2f TanEyeAnglesB;    
+} ovrDistortionVertex;
+
+/// Describes a full set of distortion mesh data, filled in by ovrHmd_CreateDistortionMesh.
+/// Contents of this data structure, if not null, should be freed by ovrHmd_DestroyDistortionMesh.
+typedef struct ovrDistortionMesh_
+{
+    ovrDistortionVertex* pVertexData;
+    unsigned short*      pIndexData;
+    unsigned int         VertexCount;
+    unsigned int         IndexCount;
+} ovrDistortionMesh;
+
+/// Generate distortion mesh per eye.
+/// Distortion capabilities will depend on 'distortionCaps' flags. Users should 
+/// render using the appropriate shaders based on their settings.
+/// Distortion mesh data will be allocated and written into the ovrDistortionMesh data structure,
+/// which should be explicitly freed with ovrHmd_DestroyDistortionMesh.
+/// Users should call ovrHmd_GetRenderScaleAndOffset to get uvScale and Offset values for rendering.
+/// The function shouldn't fail unless theres is a configuration or memory error, in which case
+/// ovrDistortionMesh values will be set to null.
+/// This is the only function in the SDK reliant on eye relief, currently imported from profiles, 
+/// or overriden here.
+OVR_EXPORT ovrBool  ovrHmd_CreateDistortionMesh( ovrHmd hmd,
+                                                 ovrEyeType eyeType, ovrFovPort fov,
+                                                 unsigned int distortionCaps,
+                                                 ovrDistortionMesh *meshData);
+
+/// Used to free the distortion mesh allocated by ovrHmd_GenerateDistortionMesh. meshData elements
+/// are set to null and zeroes after the call.
+OVR_EXPORT void     ovrHmd_DestroyDistortionMesh( ovrDistortionMesh* meshData );
+
+/// Computes updated 'uvScaleOffsetOut' to be used with a distortion if render target size or
+/// viewport changes after the fact. This can be used to adjust render size every frame if desired.
+OVR_EXPORT void     ovrHmd_GetRenderScaleAndOffset( ovrFovPort fov,
+                                                    ovrSizei textureSize, ovrRecti renderViewport,
+                                                    ovrVector2f uvScaleOffsetOut[2] );
+
+
+/// Thread-safe timing function for the main thread. Caller should increment frameIndex
+/// with every frame and pass the index where applicable to functions called on the 
+/// rendering thread.
+OVR_EXPORT ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+/// Called at the beginning of the frame on the rendering thread.
+/// Pass frameIndex == 0 if ovrHmd_GetFrameTiming isn't being used. Otherwise,
+/// pass the same frame index as was used for GetFrameTiming on the main thread.
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+/// Marks the end of client distortion rendered frame, tracking the necessary timing information.
+/// This function must be called immediately after Present/SwapBuffers + GPU sync. GPU sync is
+/// important before this call to reduce latency and ensure proper timing.
+OVR_EXPORT void     ovrHmd_EndFrameTiming(ovrHmd hmd);
+
+/// Initializes and resets frame time tracking. This is typically not necessary, but
+/// is helpful if game changes vsync state or video mode. vsync is assumed to be on if this
+/// isn't called. Resets internal frame index to the specified number.
+OVR_EXPORT void     ovrHmd_ResetFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+
+/// Computes timewarp matrices used by distortion mesh shader, these are used to adjust
+/// for head orientation change since the last call to ovrHmd_GetEyePose when rendering
+/// this eye. The ovrDistortionVertex::TimeWarpFactor is used to blend between the
+/// matrices, usually representing two different sides of the screen.
+/// Must be called on the same thread as ovrHmd_BeginFrameTiming.
+OVR_EXPORT void     ovrHmd_GetEyeTimewarpMatrices(ovrHmd hmd, ovrEyeType eye,
+                                                  ovrPosef renderPose, ovrMatrix4f twmOut[2]);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Stateless math setup functions
+
+/// Used to generate projection from ovrEyeDesc::Fov.
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_Projection( ovrFovPort fov,
+                                               float znear, float zfar, ovrBool rightHanded );
+
+/// Used for 2D rendering, Y is down
+/// orthoScale = 1.0f / pixelsPerTanAngleAtCenter
+/// orthoDistance = distance from camera, such as 0.8m
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale,
+                                                      float orthoDistance, float eyeViewAdjustX);
+
+/// Returns global, absolute high-resolution time in seconds. This is the same
+/// value as used in sensor messages.
+OVR_EXPORT double   ovr_GetTimeInSeconds();
+
+/// Waits until the specified absolute time.
+OVR_EXPORT double   ovr_WaitTillTime(double absTime);
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** Latency Test interface
+
+/// Does latency test processing and returns 'TRUE' if specified rgb color should
+/// be used to clear the screen.
+OVR_EXPORT ovrBool      ovrHmd_ProcessLatencyTest(ovrHmd hmd, unsigned char rgbColorOut[3]);
+
+/// Returns non-null string once with latency test result, when it is available.
+/// Buffer is valid until next call.
+OVR_EXPORT const char*  ovrHmd_GetLatencyTestResult(ovrHmd hmd);
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** Health and Safety Warning Display interface
+//
+
+/// Used by ovrhmd_GetHSWDisplayState to report the current display state.
+typedef struct ovrHSWDisplayState_
+{
+    /// If true then the warning should be currently visible
+    /// and the following variables have meaning. Else there is no
+    /// warning being displayed for this application on the given HMD.
+    ovrBool Displayed;
+    double  StartTime;       /// Absolute time when the warning was first displayed. See ovr_GetTimeInSeconds().
+    double  DismissibleTime; /// Earliest absolute time when the warning can be dismissed. May be a time in the past.
+} ovrHSWDisplayState;
+
+/// Returns the current state of the HSW display. If the application is doing the rendering of
+/// the HSW display then this function serves to indicate that the the warning should be 
+/// currently displayed. If the application is using SDK-based eye rendering then the SDK by 
+/// default automatically handles the drawing of the HSW display. An application that uses 
+/// application-based eye rendering should use this function to know when to start drawing the
+/// HSW display itself and can optionally use it in conjunction with ovrhmd_DismissHSWDisplay
+/// as described below.
+///
+/// Example usage for application-based rendering:
+///    bool HSWDisplayCurrentlyDisplayed = false; // global or class member variable
+///    ovrHSWDisplayState hswDisplayState;
+///    ovrhmd_GetHSWDisplayState(Hmd, &hswDisplayState);
+///
+///    if (hswDisplayState.Displayed && !HSWDisplayCurrentlyDisplayed) {
+///        <insert model into the scene that stays in front of the user>
+///        HSWDisplayCurrentlyDisplayed = true;
+///    }
+OVR_EXPORT void ovrHmd_GetHSWDisplayState(ovrHmd hmd, ovrHSWDisplayState *hasWarningState);
+
+/// Dismisses the HSW display if the warning is dismissible and the earliest dismissal time 
+/// has occurred. Returns true if the display is valid and could be dismissed. The application 
+/// should recognize that the HSW display is being displayed (via ovrhmd_GetHSWDisplayState)
+/// and if so then call this function when the appropriate user input to dismiss the warning
+/// occurs.
+///
+/// Example usage :
+///    void ProcessEvent(int key) {
+///        if(key == escape) {
+///            ovrHSWDisplayState hswDisplayState;
+///            ovrhmd_GetHSWDisplayState(hmd, &hswDisplayState);
+///
+///            if(hswDisplayState.Displayed && ovrhmd_DismissHSWDisplay(hmd)) {
+///                <remove model from the scene>
+///                HSWDisplayCurrentlyDisplayed = false;
+///            }
+///        }
+///    }
+OVR_EXPORT ovrBool ovrHmd_DismissHSWDisplay(ovrHmd hmd);
+
+
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** Property Access
+
+// NOTICE: This is experimental part of API that is likely to go away or change.
+
+// These allow accessing different properties of the HMD and profile.
+// Some of the properties may go away with profile/HMD versions, so software should
+// use defaults and/or proper fallbacks.
+// 
+
+// For now, access profile entries; this will change.
+#if !defined(OVR_KEY_USER)
+
+    #define OVR_KEY_USER                        "User"
+    #define OVR_KEY_NAME                        "Name"
+    #define OVR_KEY_GENDER                      "Gender"
+    #define OVR_KEY_PLAYER_HEIGHT               "PlayerHeight"
+    #define OVR_KEY_EYE_HEIGHT                  "EyeHeight"
+    #define OVR_KEY_IPD                         "IPD"
+    #define OVR_KEY_NECK_TO_EYE_DISTANCE        "NeckEyeDistance"
+
+	// TODO: remove this duplication with OVR_Profile.h
+	// Default measurements empirically determined at Oculus to make us happy
+	// The neck model numbers were derived as an average of the male and female averages from ANSUR-88
+	// NECK_TO_EYE_HORIZONTAL = H22 - H43 = INFRAORBITALE_BACK_OF_HEAD - TRAGION_BACK_OF_HEAD
+	// NECK_TO_EYE_VERTICAL = H21 - H15 = GONION_TOP_OF_HEAD - ECTOORBITALE_TOP_OF_HEAD
+	// These were determined to be the best in a small user study, clearly beating out the previous default values
+	#define OVR_DEFAULT_GENDER                  "Unknown"
+	#define OVR_DEFAULT_PLAYER_HEIGHT           1.778f
+	#define OVR_DEFAULT_EYE_HEIGHT              1.675f
+	#define OVR_DEFAULT_IPD                     0.064f
+	#define OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL  0.0805f
+	#define OVR_DEFAULT_NECK_TO_EYE_VERTICAL    0.075f
+	#define OVR_DEFAULT_EYE_RELIEF_DIAL         3
+#endif
+
+/// Get boolean property. Returns first element if property is a boolean array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT ovrBool      ovrHmd_GetBool(ovrHmd hmd, const char* propertyName, ovrBool defaultVal);
+
+/// Modify bool property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetBool(ovrHmd hmd, const char* propertyName, ovrBool value);
+
+/// Get integer property. Returns first element if property is an integer array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT int          ovrHmd_GetInt(ovrHmd hmd, const char* propertyName, int defaultVal);
+
+/// Modify integer property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetInt(ovrHmd hmd, const char* propertyName, int value);
+
+/// Get float property. Returns first element if property is a float array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT float        ovrHmd_GetFloat(ovrHmd hmd, const char* propertyName, float defaultVal);
+
+/// Modify float property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetFloat(ovrHmd hmd, const char* propertyName, float value);
+
+/// Get float[] property. Returns the number of elements filled in, 0 if property doesn't exist.
+/// Maximum of arraySize elements will be written.
+OVR_EXPORT unsigned int ovrHmd_GetFloatArray(ovrHmd hmd, const char* propertyName,
+                                            float values[], unsigned int arraySize);
+
+/// Modify float[] property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetFloatArray(ovrHmd hmd, const char* propertyName,
+                                             float values[], unsigned int arraySize);
+
+/// Get string property. Returns first element if property is a string array.
+/// Returns defaultValue if property doesn't exist.
+/// String memory is guaranteed to exist until next call to GetString or GetStringArray, or HMD is destroyed.
+OVR_EXPORT const char*  ovrHmd_GetString(ovrHmd hmd, const char* propertyName,
+                                        const char* defaultVal);
+
+/// Set string property
+OVR_EXPORT ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char* propertyName,
+                                    const char* value);
+
+#ifdef __cplusplus 
+} // extern "C"
+#endif
+
+
+#endif	// OVR_CAPI_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_D3D.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_D3D.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,173 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI_D3D.h
+Content     :   D3D specific structures used by the CAPI interface.
+Created     :   November 7, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_CAPI_D3D_h
+#define OVR_CAPI_D3D_h
+
+/// @file OVR_CAPI_D3D.h
+/// D3D rendering support.
+
+#include "OVR_CAPI.h"
+
+#ifndef OVR_D3D_VERSION
+#error Please define OVR_D3D_VERSION to 9 or 10 or 11 before including OVR_CAPI_D3D.h
+#endif
+
+
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+
+//-----------------------------------------------------------------------------------
+// ***** D3D11 Specific
+
+
+#include <d3d11.h>
+
+
+/// Used to configure slave D3D rendering (i.e. for devices created externally).
+struct ovrD3D11ConfigData
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+    /// The D3D device to use for rendering.
+	ID3D11Device*            pDevice;
+    /// The D3D device context to use for rendering.
+    ID3D11DeviceContext*     pDeviceContext;
+    /// A render target view for the backbuffer.
+    ID3D11RenderTargetView*  pBackBufferRT;
+    /// The swapchain that will present rendered frames.
+    IDXGISwapChain*          pSwapChain;
+};
+
+/// Contains D3D11-specific rendering information.
+union ovrD3D11Config
+{
+    /// General device settings.
+    ovrRenderAPIConfig Config;
+    /// D3D11-specific settings.
+    ovrD3D11ConfigData D3D11;
+};
+
+/// Used to pass D3D11 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D11TextureData
+{
+    /// General device settings.
+    ovrTextureHeader          Header;
+    /// The D3D11 texture containing the undistorted eye image.
+    ID3D11Texture2D*          pTexture;
+    /// The D3D11 shader resource view for this texture.
+    ID3D11ShaderResourceView* pSRView;
+};
+
+/// Contains OpenGL-specific texture information.
+union ovrD3D11Texture
+{
+    /// General device settings.
+    ovrTexture          Texture;
+    /// D3D11-specific settings.
+    ovrD3D11TextureData D3D11;
+};
+
+
+
+#elif defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 10)
+
+#include <d3d10_1.h>
+#include <d3d10.h>
+
+//-----------------------------------------------------------------------------------
+// ***** D3D10 Specific
+
+/// Used to configure slave D3D rendering (i.e. for devices created externally).
+struct ovrD3D10ConfigData
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+    ID3D10Device*            pDevice;
+    void*                    Unused;
+    ID3D10RenderTargetView*  pBackBufferRT;
+    IDXGISwapChain*          pSwapChain;
+};
+
+union ovrD3D10Config
+{
+    ovrRenderAPIConfig Config;
+    ovrD3D10ConfigData D3D10;
+};
+
+/// Used to pass D3D10 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D10TextureData
+{
+    /// General device settings.
+    ovrTextureHeader          Header;
+    ID3D10Texture2D*          pTexture;
+    ID3D10ShaderResourceView* pSRView;
+};
+
+union ovrD3D10Texture
+{
+    ovrTexture          Texture;
+    ovrD3D10TextureData D3D10;
+};
+
+#elif defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 9)
+
+#include <d3d9.h>
+
+//-----------------------------------------------------------------------------------
+// ***** D3D9 Specific
+
+// Used to configure D3D9 rendering 
+struct ovrD3D9ConfigData
+{
+    // General device settings.
+    ovrRenderAPIConfigHeader Header;
+    
+	IDirect3DDevice9*           pDevice;
+    IDirect3DSwapChain9*        pSwapChain;
+};
+
+union ovrD3D9Config
+{
+    ovrRenderAPIConfig Config;
+    ovrD3D9ConfigData D3D9;
+};
+
+// Used to pass D3D9 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D9TextureData
+{
+    // General device settings.
+    ovrTextureHeader            Header;
+    IDirect3DTexture9*          pTexture;  
+};
+
+union ovrD3D9Texture
+{
+    ovrTexture         Texture;
+    ovrD3D9TextureData D3D9;
+};
+
+#endif
+
+#endif	// OVR_CAPI_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_GL.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_GL.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,87 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI_GL.h
+Content     :   GL specific structures used by the CAPI interface.
+Created     :   November 7, 2013
+Authors     :   Lee Cooper
+
+Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+#ifndef OVR_CAPI_GL_h
+#define OVR_CAPI_GL_h
+
+/// @file OVR_CAPI_GL.h
+/// OpenGL rendering support.
+
+#include "OVR_CAPI.h"
+
+//-----------------------------------------------------------------------------------
+// ***** GL Specific
+
+#if defined(OVR_OS_WIN32)
+    #ifndef WIN32_LEAN_AND_MEAN
+    #define WIN32_LEAN_AND_MEAN
+    #endif
+    #include <Windows.h>
+    #include <GL/gl.h>
+#elif defined(OVR_OS_MAC)
+    #include <OpenGL/gl3.h>
+    #include <OpenGL/OpenGL.h>
+#else
+    #include <GL/gl.h>
+    #include <GL/glx.h>
+#endif
+
+
+/// Used to configure slave GL rendering (i.e. for devices created externally).
+typedef struct ovrGLConfigData_s
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+
+#if defined(OVR_OS_WIN32)
+    /// The optional window handle. If unset, rendering will use the current window.
+    HWND Window;
+    /// The optional device context. If unset, rendering will use a new context.
+    HDC  DC;
+#elif defined(OVR_OS_LINUX)
+    /// The optional display. If unset, rendering will use the current display.
+    _XDisplay* Disp;
+    /// The optional window. If unset, rendering will use the current window.
+    Window     Win;
+#endif
+} ovrGLConfigData;
+
+/// Contains OpenGL-specific rendering information.
+union ovrGLConfig
+{
+    /// General device settings.
+    ovrRenderAPIConfig Config;
+    /// OpenGL-specific settings.
+    ovrGLConfigData    OGL;
+};
+
+/// Used to pass GL eye texture data to ovrHmd_EndFrame.
+typedef struct ovrGLTextureData_s
+{
+    /// General device settings.
+    ovrTextureHeader Header;
+    /// The OpenGL name for this texture.
+    GLuint           TexId;       
+} ovrGLTextureData;
+
+/// Contains OpenGL-specific texture information.
+typedef union ovrGLTexture_s
+{
+    /// General device settings.
+    ovrTexture       Texture;
+    /// OpenGL-specific settings.
+    ovrGLTextureData OGL;
+} ovrGLTexture;
+
+#endif	// OVR_CAPI_GL_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1270 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_JSON.h
+Content     :   JSON format reader and writer
+Created     :   April 9, 2013
+Author      :   Brant Lewis
+Notes       :
+  The code is a derivative of the cJSON library written by Dave Gamble and subject 
+  to the following permissive copyright.
+
+  Copyright (c) 2009 Dave Gamble
+ 
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+ 
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+ 
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <float.h>
+#include <limits.h>
+#include <ctype.h>
+#include "OVR_JSON.h"
+#include "Kernel/OVR_SysFile.h"
+#include "Kernel/OVR_Log.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// Create a new copy of a string
+static char* JSON_strdup(const char* str)
+{
+    size_t len  = OVR_strlen(str) + 1;
+    char* copy = (char*)OVR_ALLOC(len);
+    if (!copy)
+        return 0;
+    memcpy(copy, str, len);
+    return copy;
+}
+
+
+//-----------------------------------------------------------------------------
+// Render the number from the given item into a string.
+static char* PrintInt(int valueint)
+{
+    char *str;
+    str = (char*)OVR_ALLOC(21);	// 2^64+1 can be represented in 21 chars.
+    if (str)
+    {
+        OVR_sprintf(str, 21, "%d", valueint);
+    }
+    return str;
+}
+
+
+//-----------------------------------------------------------------------------
+// Render the number from the given item into a string.
+static char* PrintNumber(double d)
+{
+    char *str;
+    int valueint = (int)d;
+	if (fabs(((double)valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
+	{
+        return PrintInt(valueint);
+	}
+	else
+	{
+		str=(char*)OVR_ALLOC(64);	// This is a nice tradeoff.
+		if (str)
+		{
+			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)
+                OVR_sprintf(str, 64, "%.0f", d);
+			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)
+                OVR_sprintf(str, 64, "%e", d);
+			else
+                OVR_sprintf(str, 64, "%f", d);
+		}
+	}
+	return str;
+}
+
+
+// Parse the input text into an un-escaped cstring, and populate item.
+static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+// Helper to assign error sting and return 0.
+const char* AssignError(const char** perror, const char *errorMessage)
+{
+    if (perror)
+        *perror = errorMessage;
+    return 0;
+}
+
+//-----------------------------------------------------------------------------
+// ***** JSON Node class
+
+JSON::JSON(JSONItemType itemType) :
+    Type(itemType), dValue(0.)
+{
+}
+
+JSON::~JSON()
+{
+    JSON* child = Children.GetFirst();
+    while (!Children.IsNull(child))
+    {
+        child->RemoveNode();
+        child->Release();
+        child = Children.GetFirst();
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Parse the input text to generate a number, and populate the result into item
+// Returns the text position after the parsed number
+const char* JSON::parseNumber(const char *num)
+{
+    const char* num_start = num;
+    double      n=0, scale=0;
+    int         subscale     = 0,
+                signsubscale = 1;
+    bool positiveSign = true;
+
+	// Could use sscanf for this?
+    if (*num == '-')
+    {
+        positiveSign = false;
+        num++;	// Has sign?
+    }
+    if (*num == '0')
+    {
+        num++;			// is zero
+    }
+
+    if (*num>='1' && *num<='9')	
+    {
+        do
+        {
+            n = (n*10.0) + (*num++ - '0');
+        }
+        while (*num>='0' && *num<='9');	// Number?
+    }
+
+	if (*num=='.' && num[1]>='0' && num[1]<='9')
+    {
+        num++;
+        do
+        {
+            n=(n*10.0)+(*num++ -'0');
+            scale--;
+        }
+        while (*num>='0' && *num<='9');  // Fractional part?
+    }
+
+	if (*num=='e' || *num=='E')		// Exponent?
+	{
+        num++;
+        if (*num == '+')
+        {
+            num++;
+        }
+        else if (*num=='-')
+        {
+            signsubscale=-1;
+            num++;		// With sign?
+        }
+
+        while (*num >= '0' && *num <= '9')
+        {
+            subscale = (subscale * 10) + (*num++ - '0');	// Number?
+        }
+	}
+
+    // Number = +/- number.fraction * 10^+/- exponent
+    n *= pow(10.0, (scale + subscale*signsubscale));
+
+    if (!positiveSign)
+    {
+        n = -n;
+    }
+
+    // Assign parsed value.
+    Type = JSON_Number;
+    dValue = n;
+    Value.AssignString(num_start, num - num_start);
+
+	return num;
+}
+
+// Parses a hex string up to the specified number of digits.
+// Returns the first character after the string.
+const char* ParseHex(unsigned* val, unsigned digits, const char* str)
+{
+    *val = 0;
+
+    for(unsigned digitCount = 0; digitCount < digits; digitCount++, str++)
+    {
+        unsigned v = *str;
+
+        if ((v >= '0') && (v <= '9'))
+            v -= '0';
+        else if ((v >= 'a') && (v <= 'f'))
+            v = 10 + v - 'a';
+        else if ((v >= 'A') && (v <= 'F'))
+            v = 10 + v - 'A';
+        else
+            break;
+
+        *val = *val * 16 + v;
+    }
+
+    return str;
+}
+
+//-----------------------------------------------------------------------------
+// Parses the input text into a string item and returns the text position after
+// the parsed string
+const char* JSON::parseString(const char* str, const char** perror)
+{
+	const char* ptr = str+1;
+    const char* p;
+    char*       ptr2;
+    char*       out;
+    int         len=0;
+    unsigned    uc, uc2;
+	
+    if (*str!='\"')
+    {
+        return AssignError(perror, "Syntax Error: Missing quote");
+    }
+	
+	while (*ptr!='\"' && *ptr && ++len)
+    {   
+        if (*ptr++ == '\\') ptr++;	// Skip escaped quotes.
+    }
+	
+    // This is how long we need for the string, roughly.
+	out=(char*)OVR_ALLOC(len+1);
+	if (!out)
+        return 0;
+	
+	ptr = str+1;
+    ptr2= out;
+
+	while (*ptr!='\"' && *ptr)
+	{
+		if (*ptr!='\\')
+        {
+            *ptr2++ = *ptr++;
+        }
+		else
+		{
+			ptr++;
+			switch (*ptr)
+			{
+				case 'b': *ptr2++ = '\b';	break;
+				case 'f': *ptr2++ = '\f';	break;
+				case 'n': *ptr2++ = '\n';	break;
+				case 'r': *ptr2++ = '\r';	break;
+				case 't': *ptr2++ = '\t';	break;
+
+                // Transcode utf16 to utf8.
+                case 'u':
+
+                    // Get the unicode char.
+                    p = ParseHex(&uc, 4, ptr + 1);
+                    if (ptr != p)
+                        ptr = p - 1;
+
+					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)
+                        break;	// Check for invalid.
+
+                    // UTF16 surrogate pairs.
+					if (uc>=0xD800 && uc<=0xDBFF)
+					{
+						if (ptr[1]!='\\' || ptr[2]!='u')
+                            break;	// Missing second-half of surrogate.
+
+                        p= ParseHex(&uc2, 4, ptr + 3);
+                        if (ptr != p)
+                            ptr = p - 1;
+                        
+						if (uc2<0xDC00 || uc2>0xDFFF)
+                            break;	// Invalid second-half of surrogate.
+
+						uc = 0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
+					}
+
+					len=4;
+                    
+                    if (uc<0x80)
+                        len=1;
+                    else if (uc<0x800)
+                        len=2;
+                    else if (uc<0x10000)
+                        len=3;
+                    
+                    ptr2+=len;
+					
+					switch (len)
+                    {
+						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 1: *--ptr2 = (char)(uc | firstByteMark[len]);
+					}
+					ptr2+=len;
+					break;
+
+                default:
+                    *ptr2++ = *ptr;
+                    break;
+			}
+			ptr++;
+		}
+	}
+
+	*ptr2 = 0;
+	if (*ptr=='\"')
+        ptr++;
+	
+    // Make a copy of the string 
+    Value=out;
+    OVR_FREE(out);
+	Type=JSON_String;
+
+	return ptr;
+}
+
+//-----------------------------------------------------------------------------
+// Render the string provided to an escaped version that can be printed.
+char* PrintString(const char* str)
+{
+	const char *ptr;
+    char *ptr2,*out;
+    int len=0;
+    unsigned char token;
+	
+	if (!str)
+        return JSON_strdup("");
+	ptr=str;
+    
+    token=*ptr;
+    while (token && ++len)\
+    {
+        if (strchr("\"\\\b\f\n\r\t",token))
+            len++;
+        else if (token<32) 
+            len+=5;
+        ptr++;
+        token=*ptr;
+    }
+	
+	int buff_size = len+3;
+    out=(char*)OVR_ALLOC(buff_size);
+	if (!out)
+        return 0;
+
+	ptr2 = out;
+    ptr  = str;
+	*ptr2++ = '\"';
+
+	while (*ptr)
+	{
+		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') 
+            *ptr2++=*ptr++;
+		else
+		{
+			*ptr2++='\\';
+			switch (token=*ptr++)
+			{
+				case '\\':	*ptr2++='\\';	break;
+				case '\"':	*ptr2++='\"';	break;
+				case '\b':	*ptr2++='b';	break;
+				case '\f':	*ptr2++='f';	break;
+				case '\n':	*ptr2++='n';	break;
+				case '\r':	*ptr2++='r';	break;
+				case '\t':	*ptr2++='t';	break;
+				default: 
+                    OVR_sprintf(ptr2, buff_size - (ptr2-out), "u%04x",token);
+                    ptr2+=5;
+                    break;	// Escape and print.
+			}
+		}
+	}
+	*ptr2++='\"';
+    *ptr2++=0;
+	return out;
+}
+
+//-----------------------------------------------------------------------------
+// Utility to jump whitespace and cr/lf
+static const char* skip(const char* in)
+{
+    while (in && *in && (unsigned char)*in<=' ') 
+        in++; 
+    return in;
+}
+
+//-----------------------------------------------------------------------------
+// Parses the supplied buffer of JSON text and returns a JSON object tree
+// The returned object must be Released after use
+JSON* JSON::Parse(const char* buff, const char** perror)
+{
+    const char* end = 0;
+	JSON*       json = new JSON();
+	
+	if (!json)
+    {
+        AssignError(perror, "Error: Failed to allocate memory");
+        return 0;
+    }
+ 
+	end = json->parseValue(skip(buff), perror);
+	if (!end)
+    {
+        json->Release();
+        return NULL;
+    }	// parse failure. ep is set.
+
+    return json;
+}
+
+//-----------------------------------------------------------------------------
+// This version works for buffers that are not null terminated strings.
+JSON* JSON::ParseBuffer(const char *buff, int len, const char** perror)
+{
+	// Our JSON parser does not support length-based parsing,
+	// so ensure it is null-terminated.
+	char *termStr = new char[len + 1];
+	memcpy(termStr, buff, len);
+	termStr[len] = '\0';
+
+	JSON *objJson = Parse(termStr, perror);
+
+	delete[]termStr;
+
+	return objJson;
+}
+
+//-----------------------------------------------------------------------------
+// Parser core - when encountering text, process appropriately.
+const char* JSON::parseValue(const char* buff, const char** perror)
+{
+    if (perror)
+        *perror = 0;
+
+	if (!buff)
+        return NULL;	// Fail on null.
+
+	if (!strncmp(buff,"null",4))
+    {
+        Type = JSON_Null;
+        return buff+4;
+    }
+	if (!strncmp(buff,"false",5))
+    { 
+        Type   = JSON_Bool;
+        Value  = "false";
+        dValue = 0.;
+        return buff+5;
+    }
+	if (!strncmp(buff,"true",4))
+    {
+        Type   = JSON_Bool;
+        Value  = "true";
+        dValue = 1.;
+        return buff + 4;
+    }
+	if (*buff=='\"')
+    {
+        return parseString(buff, perror);
+    }
+	if (*buff=='-' || (*buff>='0' && *buff<='9'))
+    { 
+        return parseNumber(buff);
+    }
+	if (*buff=='[')
+    { 
+        return parseArray(buff, perror);
+    }
+	if (*buff=='{')
+    {
+        return parseObject(buff, perror);
+    }
+
+    return AssignError(perror, "Syntax Error: Invalid syntax");
+}
+
+
+//-----------------------------------------------------------------------------
+// Render a value to text. 
+char* JSON::PrintValue(int depth, bool fmt)
+{
+	char *out=0;
+
+    switch (Type)
+	{
+        case JSON_Null:	    out = JSON_strdup("null");	break;
+        case JSON_Bool:
+            if ((int)dValue == 0)
+                out = JSON_strdup("false");
+            else
+                out = JSON_strdup("true");
+            break;
+        case JSON_Number:	out = PrintNumber(dValue); break;
+        case JSON_String:	out = PrintString(Value); break;
+        case JSON_Array:	out = PrintArray(depth, fmt); break;
+        case JSON_Object:	out = PrintObject(depth, fmt); break;
+        case JSON_None: OVR_ASSERT_LOG(false, ("Bad JSON type.")); break;
+	}
+	return out;
+}
+
+//-----------------------------------------------------------------------------
+// Build an array object from input text and returns the text position after
+// the parsed array
+const char* JSON::parseArray(const char* buff, const char** perror)
+{
+	JSON *child;
+	if (*buff!='[')
+    {
+        return AssignError(perror, "Syntax Error: Missing opening bracket");
+    }
+
+	Type=JSON_Array;
+	buff=skip(buff+1);
+	
+    if (*buff==']')
+        return buff+1;	// empty array.
+
+    child = new JSON();
+	if (!child)
+        return 0;		 // memory fail
+    Children.PushBack(child);
+	
+    buff=skip(child->parseValue(skip(buff), perror));	// skip any spacing, get the buff. 
+	if (!buff)
+        return 0;
+
+	while (*buff==',')
+	{
+		JSON *new_item = new JSON();
+		if (!new_item)
+            return AssignError(perror, "Error: Failed to allocate memory");
+		
+        Children.PushBack(new_item);
+
+		buff=skip(new_item->parseValue(skip(buff+1), perror));
+		if (!buff)
+            return AssignError(perror, "Error: Failed to allocate memory");
+	}
+
+	if (*buff==']')
+        return buff+1;	// end of array
+
+    return AssignError(perror, "Syntax Error: Missing ending bracket");
+}
+
+//-----------------------------------------------------------------------------
+// Render an array to text.  The returned text must be freed
+char* JSON::PrintArray(int depth, bool fmt)
+{
+	char **  entries;
+	char *   out = 0, *ptr,*ret;
+    intptr_t len = 5;
+	
+    bool fail = false;
+	
+	// How many entries in the array? 
+    int numentries = GetItemCount();
+	if (!numentries)
+	{
+		out=(char*)OVR_ALLOC(3);
+		if (out)
+            OVR_strcpy(out, 3, "[]");
+		return out;
+	}
+	// Allocate an array to hold the values for each
+	entries=(char**)OVR_ALLOC(numentries*sizeof(char*));
+	if (!entries)
+        return 0;
+	memset(entries,0,numentries*sizeof(char*));
+
+	//// Retrieve all the results:
+    JSON* child = Children.GetFirst();
+    for (int i=0; i<numentries; i++)
+	{
+		//JSON* child = Children[i];
+        ret=child->PrintValue(depth+1, fmt);
+		entries[i]=ret;
+		if (ret)
+            len+=OVR_strlen(ret)+2+(fmt?1:0);
+        else
+        {
+            fail = true;
+            break;
+        }
+        child = Children.GetNext(child);
+	}
+	
+	// If we didn't fail, try to malloc the output string 
+	if (!fail)
+        out=(char*)OVR_ALLOC(len);
+	// If that fails, we fail. 
+	if (!out)
+        fail = true;
+
+	// Handle failure.
+	if (fail)
+	{
+		for (int i=0; i<numentries; i++) 
+        {
+            if (entries[i])
+                OVR_FREE(entries[i]);
+        }
+		OVR_FREE(entries);
+		return 0;
+	}
+	
+	// Compose the output array.
+	*out='[';
+	ptr=out+1;
+    *ptr=0;
+	for (int i=0; i<numentries; i++)
+	{
+		OVR_strcpy(ptr, len - (ptr-out), entries[i]);
+        ptr+=OVR_strlen(entries[i]);
+		if (i!=numentries-1)
+        {
+            *ptr++=',';
+            if (fmt)
+                *ptr++=' ';
+            *ptr=0;
+        }
+		OVR_FREE(entries[i]);
+	}
+	OVR_FREE(entries);
+	*ptr++=']';
+    *ptr++=0;
+	return out;	
+}
+
+//-----------------------------------------------------------------------------
+// Build an object from the supplied text and returns the text position after
+// the parsed object
+const char* JSON::parseObject(const char* buff, const char** perror)
+{
+	if (*buff!='{')
+    {
+        return AssignError(perror, "Syntax Error: Missing opening brace");
+    }
+	
+	Type=JSON_Object;
+	buff=skip(buff+1);
+	if (*buff=='}')
+        return buff+1;	// empty array.
+	
+    JSON* child = new JSON();
+    Children.PushBack(child);
+
+	buff=skip(child->parseString(skip(buff), perror));
+	if (!buff) 
+        return 0;
+	child->Name = child->Value;
+    child->Value.Clear();
+	
+    if (*buff!=':')
+    {
+        return AssignError(perror, "Syntax Error: Missing colon");
+    }
+
+	buff=skip(child->parseValue(skip(buff+1), perror));	// skip any spacing, get the value.
+	if (!buff)
+        return 0;
+	
+	while (*buff==',')
+	{
+        child = new JSON();
+		if (!child)
+            return 0; // memory fail
+		
+        Children.PushBack(child);
+
+		buff=skip(child->parseString(skip(buff+1), perror));
+		if (!buff)
+            return 0;
+		
+        child->Name=child->Value;
+        child->Value.Clear();
+		
+        if (*buff!=':')
+        {
+            return AssignError(perror, "Syntax Error: Missing colon");
+        }	// fail!
+		
+        // Skip any spacing, get the value.
+        buff=skip(child->parseValue(skip(buff+1), perror));
+		if (!buff)
+            return 0;
+	}
+	
+	if (*buff=='}')
+        return buff+1;	// end of array 
+	
+    return AssignError(perror, "Syntax Error: Missing closing brace");
+}
+
+//-----------------------------------------------------------------------------
+// Render an object to text.  The returned string must be freed
+char* JSON::PrintObject(int depth, bool fmt)
+{
+	char**   entries = 0, **names = 0;
+	char*    out = 0;
+    char*    ptr, *ret, *str;
+    intptr_t len = 7, i = 0, j;
+    bool     fail = false;
+	
+    // Count the number of entries.
+    int numentries = GetItemCount();
+    
+	// Explicitly handle empty object case
+	if (numentries == 0)
+	{
+		out=(char*)OVR_ALLOC(fmt?depth+4:4);
+		if (!out)
+            return 0;
+		ptr=out;
+        *ptr++='{';
+		
+        if (fmt)
+        {
+            *ptr++='\n';
+            for (i=0;i<depth-1;i++)
+                *ptr++='\t';
+        }
+		*ptr++='}';
+        *ptr++=0;
+		return out;
+	}
+	// Allocate space for the names and the objects
+	entries=(char**)OVR_ALLOC(numentries*sizeof(char*));
+	if (!entries)
+        return 0;
+	names=(char**)OVR_ALLOC(numentries*sizeof(char*));
+	
+    if (!names)
+    {
+        OVR_FREE(entries);
+        return 0;
+    }
+	memset(entries,0,sizeof(char*)*numentries);
+	memset(names,0,sizeof(char*)*numentries);
+
+	// Collect all the results into our arrays:
+    depth++;
+    if (fmt)
+        len+=depth;
+
+    JSON* child = Children.GetFirst();
+    while (!Children.IsNull(child))
+	{
+		names[i]     = str = PrintString(child->Name);
+		entries[i++] = ret = child->PrintValue(depth, fmt);
+
+		if (str && ret)
+        {
+            len += OVR_strlen(ret)+OVR_strlen(str)+2+(fmt?3+depth:0);
+        }
+        else
+        {
+            fail = true;
+            break;
+        }
+		
+        child = Children.GetNext(child);
+	}
+	
+	// Try to allocate the output string
+	if (!fail)
+        out=(char*)OVR_ALLOC(len);
+	if (!out)
+        fail=true;
+
+	// Handle failure
+	if (fail)
+	{
+		for (i=0;i<numentries;i++)
+        {
+            if (names[i])
+                OVR_FREE(names[i]);
+            
+            if (entries[i])
+                OVR_FREE(entries[i]);}
+		
+        OVR_FREE(names);
+        OVR_FREE(entries);
+		return 0;
+	}
+	
+	// Compose the output:
+	*out = '{';
+    ptr  = out+1;
+    if (fmt)
+    {
+#ifdef OVR_OS_WIN32
+        *ptr++ = '\r';
+#endif
+        *ptr++ = '\n';
+    }
+    *ptr = 0;
+	
+    for (i=0; i<numentries; i++)
+	{
+		if (fmt)
+        {
+            for (j = 0; j < depth; j++)
+            {
+                *ptr++ = '\t';
+            }
+        }
+		OVR_strcpy(ptr, len - (ptr-out), names[i]);
+        ptr   += OVR_strlen(names[i]);
+		*ptr++ =':';
+        
+        if (fmt)
+        {
+            *ptr++ = '\t';
+        }
+		
+        OVR_strcpy(ptr, len - (ptr-out), entries[i]);
+        ptr+=OVR_strlen(entries[i]);
+		
+        if (i != numentries - 1)
+        {
+            *ptr++ = ',';
+        }
+		
+        if (fmt)
+        {
+#ifdef OVR_OS_WIN32
+            *ptr++ = '\r';
+#endif
+            *ptr++ = '\n';
+        }
+        *ptr = 0;
+		
+        OVR_FREE(names[i]);
+        OVR_FREE(entries[i]);
+	}
+	
+	OVR_FREE(names);
+    OVR_FREE(entries);
+	
+    if (fmt)
+    {
+        for (i = 0; i < depth - 1; i++)
+        {
+            *ptr++ = '\t';
+        }
+    }
+	*ptr++='}';
+    *ptr++=0;
+	
+    return out;	
+}
+
+
+
+// Returns the number of child items in the object
+// Counts the number of items in the object.
+unsigned JSON::GetItemCount() const
+{
+    unsigned count = 0;
+    for (const JSON* p = Children.GetFirst(); !Children.IsNull(p); p = p->pNext)
+    {
+        count++;
+    }
+    return count;
+}
+
+JSON* JSON::GetItemByIndex(unsigned index)
+{
+    unsigned i     = 0;
+    JSON*    child = 0;
+
+    if (!Children.IsEmpty())
+    {
+        child = Children.GetFirst();
+
+        while (i < index)
+        {   
+            if (Children.IsNull(child->pNext))
+            {
+                child = 0;
+                break;
+            }
+            child = child->pNext;
+            i++;
+        }
+    }
+  
+    return child;
+}
+
+// Returns the child item with the given name or NULL if not found
+JSON* JSON::GetItemByName(const char* name)
+{
+    JSON* child = 0;
+
+    if (!Children.IsEmpty())
+    {
+        child = Children.GetFirst();
+
+        while (OVR_strcmp(child->Name, name) != 0)
+        {   
+            if (Children.IsNull(child->pNext))
+            {
+                child = 0;
+                break;
+            }
+            child = child->pNext;
+        }
+    }
+
+    return child;
+}
+
+//-----------------------------------------------------------------------------
+// Adds a new item to the end of the child list
+void JSON::AddItem(const char *string, JSON *item)
+{
+    if (item)
+    {
+        item->Name = string;
+        Children.PushBack(item);
+    }
+}
+
+/*
+
+// Removes and frees the items at the given index
+void JSON::DeleteItem(unsigned int index)
+{
+    unsigned int num_items = 0;
+    JSON* child = Children.GetFirst();
+    while (!Children.IsNull(child) && num_items < index)
+    {   
+        num_items++;
+        child = Children.GetNext(child);
+    }
+
+    if (!Children.IsNull(child))
+    
+        child->RemoveNode();
+        child->Release();
+    }
+}
+
+// Replaces and frees the item at the give index with the new item
+void JSON::ReplaceItem(unsigned int index, JSON* new_item)
+{
+    unsigned int num_items = 0;
+    JSON* child = Children.GetFirst();
+    while (!Children.IsNull(child) && num_items < index)
+    {   
+        num_items++;
+        child = Children.GetNext(child);
+    }
+
+    if (!Children.IsNull(child))
+    {
+        child->ReplaceNodeWith(new_item);
+        child->Release();        
+    }
+}
+*/
+
+// Removes and frees the last child item
+void JSON::RemoveLast()
+{
+    JSON* child = Children.GetLast();
+    if (!Children.IsNull(child))
+    {
+        child->RemoveNode();
+        child->Release();
+    }
+}
+
+JSON* JSON::CreateBool(bool b)
+{
+    JSON *item = new JSON(JSON_Bool);
+    if (item)
+    {
+        item->dValue = b ? 1. : 0.;
+        item->Value = b ? "true" : "false";
+    }
+    return item;
+}
+
+JSON* JSON::CreateNumber(double num)
+{
+    JSON *item = new JSON(JSON_Number);
+    if (item)
+    {
+        item->dValue = num;
+    }
+    return item;
+}
+
+JSON* JSON::CreateInt(int num)
+{
+    JSON *item = new JSON(JSON_Number);
+    if (item)
+    {
+        item->dValue = num;
+    }
+    return item;
+}
+
+JSON* JSON::CreateString(const char *s)
+{
+    JSON *item = new JSON(JSON_String);
+    if (item && s)
+    {
+        item->Value = s;
+    }
+    return item;
+}
+
+
+//-----------------------------------------------------------------------------
+// Get elements by name
+double JSON::GetNumberByName(const char *name, double defValue)
+{
+	JSON* item = GetItemByName(name);
+	if (!item || item->Type != JSON_Number)
+    {
+		return defValue;
+	}
+	else
+    {
+		return item->dValue;
+	}
+}
+
+int JSON::GetIntByName(const char *name, int defValue)
+{
+	JSON* item = GetItemByName(name);
+	if (!item || item->Type != JSON_Number)
+    {
+		return defValue;
+	}
+	else
+    {
+		return (int)item->dValue;
+	}
+}
+
+bool JSON::GetBoolByName(const char *name, bool defValue)
+{
+	JSON* item = GetItemByName(name);
+	if (!item || item->Type != JSON_Bool)
+    {
+		return defValue;
+	}
+	else
+    {
+		return (int)item->dValue != 0;
+	}
+}
+
+String JSON::GetStringByName(const char *name, const String &defValue)
+{
+	JSON* item = GetItemByName(name);
+	if (!item || item->Type != JSON_String)
+    {
+		return defValue;
+	}
+	else
+    {
+		return item->Value;
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Adds an element to an array object type
+void JSON::AddArrayElement(JSON *item)
+{
+    if (item)
+    {
+        Children.PushBack(item);
+    }
+}
+
+// Inserts an element into a valid array position
+void JSON::InsertArrayElement(int index, JSON *item)
+{
+    if (!item)
+    {
+        return;
+    }
+
+    if (index == 0)
+    {
+        Children.PushFront(item);
+        return;
+    }
+
+    JSON* iter = Children.GetFirst();
+    int i=0;
+    while (iter && i<index)
+    {
+        iter = Children.GetNext(iter);
+        i++;
+    }
+
+    if (iter)
+        iter->InsertNodeBefore(item);
+    else
+        Children.PushBack(item);
+}
+
+// Returns the size of an array
+int JSON::GetArraySize()
+{
+    if (Type == JSON_Array)
+    {
+        return GetItemCount();
+    }
+
+    return 0;
+}
+
+// Returns the number value an the give array index
+double JSON::GetArrayNumber(int index)
+{
+    if (Type == JSON_Array)
+    {
+        JSON* number = GetItemByIndex(index);
+        return number ? number->dValue : 0.0;
+    }
+
+    return 0;
+}
+
+// Returns the string value at the given array index
+const char* JSON::GetArrayString(int index)
+{
+    if (Type == JSON_Array)
+    {
+        JSON* number = GetItemByIndex(index);
+        return number ? number->Value : 0;
+    }
+
+    return 0;
+}
+
+JSON* JSON::Copy()
+{
+    JSON* copy = new JSON(Type);
+    copy->Name = Name;
+    copy->Value = Value;
+    copy->dValue = dValue;
+
+    JSON* child = Children.GetFirst();
+    while (!Children.IsNull(child))
+    {
+        copy->Children.PushBack(child->Copy());
+        child = Children.GetNext(child);
+    }
+
+    return copy;
+}
+
+//-----------------------------------------------------------------------------
+// Loads and parses the given JSON file pathname and returns a JSON object tree.
+// The returned object must be Released after use.
+JSON* JSON::Load(const char* path, const char** perror)
+{
+    SysFile f;
+    if (!f.Open(path, File::Open_Read, File::Mode_Read))
+    {
+        AssignError(perror, "Failed to open file");
+        return NULL;
+    }
+
+    int    len   = f.GetLength();
+    uint8_t* buff  = (uint8_t*)OVR_ALLOC(len + 1);
+    int    bytes = f.Read(buff, len);
+    f.Close();
+
+    if (bytes == 0 || bytes != len)
+    {
+        OVR_FREE(buff);
+        return NULL;
+    }
+
+	// Ensure the result is null-terminated since Parse() expects null-terminated input.
+	buff[len] = '\0';
+
+    JSON* json = JSON::Parse((char*)buff, perror);
+    OVR_FREE(buff);
+    return json;
+}
+
+//-----------------------------------------------------------------------------
+// Serializes the JSON object and writes to the give file path
+bool JSON::Save(const char* path)
+{
+    SysFile f;
+    if (!f.Open(path, File::Open_Write | File::Open_Create | File::Open_Truncate, File::Mode_Write))
+        return false;
+
+    char* text = PrintValue(0, true);
+    if (text)
+    {
+        intptr_t len   = OVR_strlen(text);
+        OVR_ASSERT(len <= (intptr_t)(int)len);
+
+        int   bytes = f.Write((uint8_t*)text, (int)len);
+        f.Close();
+        OVR_FREE(text);
+        return (bytes == len);
+    }
+    else
+    {
+        return false;
+    }
+}
+
+
+} // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,165 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_JSON.h
+Content     :   JSON format reader and writer
+Created     :   April 9, 2013
+Author      :   Brant Lewis
+Notes       :
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_JSON_H
+#define OVR_JSON_H
+
+#include "Kernel/OVR_RefCount.h"
+#include "Kernel/OVR_String.h"
+#include "Kernel/OVR_List.h"
+
+namespace OVR {  
+
+// JSONItemType describes the type of JSON item, specifying the type of
+// data that can be obtained from it.
+enum JSONItemType
+{
+    JSON_None      = 0,
+    JSON_Null      = 1,
+    JSON_Bool      = 2,
+    JSON_Number    = 3,
+    JSON_String    = 4,
+    JSON_Array     = 5,
+    JSON_Object    = 6
+};
+
+//-----------------------------------------------------------------------------
+// ***** JSON
+
+// JSON object represents a JSON node that can be either a root of the JSON tree
+// or a child item. Every node has a type that describes what is is.
+// New JSON trees are typically loaded JSON::Load or created with JSON::Parse.
+
+class JSON : public RefCountBase<JSON>, public ListNode<JSON>
+{
+protected:
+    List<JSON>      Children;
+
+public:
+    JSONItemType    Type;       // Type of this JSON node.
+    String          Name;       // Name part of the {Name, Value} pair in a parent object.
+    String          Value;
+    double          dValue;
+
+public:
+    ~JSON();
+
+    // *** Creation of NEW JSON objects
+
+    static JSON*    CreateObject() { return new JSON(JSON_Object);}
+    static JSON*    CreateNull()   { return new JSON(JSON_Null); }
+    static JSON*    CreateArray()  { return new JSON(JSON_Array); }
+    static JSON*    CreateBool(bool b);
+    static JSON*    CreateNumber(double num);
+    static JSON*    CreateInt(int num);
+    static JSON*    CreateString(const char *s);
+
+    // Creates a new JSON object from parsing string.
+    // Returns null pointer and fills in *perror in case of parse error.
+    static JSON*    Parse(const char* buff, const char** perror = 0);
+
+	// This version works for buffers that are not null terminated strings.
+	static JSON*	ParseBuffer(const char *buff, int len, const char** perror = 0);
+
+    // Loads and parses a JSON object from a file.
+    // Returns 0 and assigns perror with error message on fail.
+    static JSON*    Load(const char* path, const char** perror = 0);
+
+    // Saves a JSON object to a file.
+    bool            Save(const char* path);
+
+    // *** Object Member Access
+
+    // These provide access to child items of the list.
+    bool            HasItems() const         { return Children.IsEmpty(); }
+    // Returns first/last child item, or null if child list is empty
+    JSON*           GetFirstItem()           { return (!Children.IsEmpty()) ? Children.GetFirst() : 0; }
+    JSON*           GetLastItem()            { return (!Children.IsEmpty()) ? Children.GetLast() : 0; }
+
+    // Counts the number of items in the object; these methods are inefficient.
+    unsigned        GetItemCount() const;
+    JSON*           GetItemByIndex(unsigned i);
+    JSON*           GetItemByName(const char* name);
+
+	// Accessors by name
+	double			GetNumberByName(const char *name, double defValue = 0.0);
+	int				GetIntByName(const char *name, int defValue = 0);
+	bool			GetBoolByName(const char *name, bool defValue = false);
+	String			GetStringByName(const char *name, const String &defValue = "");
+
+    // Returns next item in a list of children; 0 if no more items exist.
+    JSON*           GetNextItem(JSON* item)  { return Children.IsNull(item->pNext) ? 0 : item->pNext; }
+    JSON*           GetPrevItem(JSON* item)  { return Children.IsNull(item->pPrev) ? 0 : item->pPrev; }
+
+
+    // Child item access functions
+    void            AddItem(const char *string, JSON* item);
+    void            AddNullItem(const char* name)                    { AddItem(name, CreateNull()); }
+    void            AddBoolItem(const char* name, bool b)            { AddItem(name, CreateBool(b)); }
+    void            AddIntItem(const char* name, int n)              { AddItem(name, CreateInt(n)); }
+    void            AddNumberItem(const char* name, double n)        { AddItem(name, CreateNumber(n)); }
+    void            AddStringItem(const char* name, const char* s)   { AddItem(name, CreateString(s)); }
+//    void            ReplaceItem(unsigned index, JSON* new_item);
+//    void            DeleteItem(unsigned index);
+    void            RemoveLast();
+
+    // *** Array Element Access
+
+    // Add new elements to the end of array.
+    void            AddArrayElement(JSON *item);
+    void            InsertArrayElement(int index, JSON* item);
+    void            AddArrayNumber(double n)        { AddArrayElement(CreateNumber(n)); }
+    void            AddArrayInt(int n)              { AddArrayElement(CreateInt(n)); }
+    void            AddArrayString(const char* s)   { AddArrayElement(CreateString(s)); }
+
+    // Accessed array elements; currently inefficient.
+    int             GetArraySize();
+    double          GetArrayNumber(int index);
+    const char*     GetArrayString(int index);
+
+    JSON*           Copy();  // Create a copy of this object
+
+protected:
+    JSON(JSONItemType itemType = JSON_Object);
+
+    // JSON Parsing helper functions.
+    const char*     parseValue(const char *buff, const char** perror);
+    const char*     parseNumber(const char *num);
+    const char*     parseArray(const char* value, const char** perror);
+    const char*     parseObject(const char* value, const char** perror);
+    const char*     parseString(const char* str, const char** perror);
+
+    char*           PrintValue(int depth, bool fmt);
+    char*           PrintObject(int depth, bool fmt);
+    char*           PrintArray(int depth, bool fmt);
+};
+
+
+}
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1583 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Profile.cpp
+Content     :   Structs and functions for loading and storing device profile settings
+Created     :   February 14, 2013
+Notes       :
+   
+   Profiles are used to store per-user settings that can be transferred and used
+   across multiple applications.  For example, player IPD can be configured once 
+   and reused for a unified experience across games.  Configuration and saving of profiles
+   can be accomplished in game via the Profile API or by the official Oculus Configuration
+   Utility.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_Profile.h"
+#include "OVR_JSON.h"
+#include "Kernel/OVR_SysFile.h"
+#include "Kernel/OVR_Allocator.h"
+#include "OVR_Stereo.h"
+
+#ifdef OVR_OS_WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <Shlobj.h>
+#else
+#include <dirent.h>
+#include <sys/stat.h>
+
+#ifdef OVR_OS_LINUX
+#include <unistd.h>
+#include <pwd.h>
+#endif
+
+#endif
+
+#define PROFILE_VERSION 2.0
+#define MAX_PROFILE_MAJOR_VERSION 2
+#define MAX_DEVICE_PROFILE_MAJOR_VERSION 1
+
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// ProfileDeviceKey
+
+ProfileDeviceKey::ProfileDeviceKey(const HMDInfo* info) :
+    Valid(false)
+{
+    if (info)
+    {
+        PrintedSerial = info->PrintedSerial;
+        ProductName = SanitizeProductName(info->ProductName);
+        ProductId = info->ProductId;
+        HmdType = info->HmdType;
+
+        if (ProductId != 0)
+        {
+            Valid = true;
+        }
+    }
+}
+
+String ProfileDeviceKey::SanitizeProductName(String productName)
+{
+    String result;
+
+    if (!productName.IsEmpty())
+    {
+        const char* product_name = productName.ToCStr();
+
+        // First strip off "Oculus"
+        const char* oculus = strstr(product_name, "Oculus ");
+        if (oculus)
+        {
+            product_name = oculus + OVR_strlen("Oculus ");
+        }
+
+        // And remove spaces from the name
+        for (const char* s = product_name; *s != 0; s++)
+        {
+            if (*s != ' ')
+            {
+                result.AppendChar(*s);
+            }
+        }
+    }
+
+    return result;
+}
+
+
+
+//-----------------------------------------------------------------------------
+// Returns the pathname of the JSON file containing the stored profiles
+String GetBaseOVRPath(bool create_dir)
+{
+    String path;
+
+#if defined(OVR_OS_WIN32)
+
+    TCHAR data_path[MAX_PATH];
+    SHGetFolderPath(0, CSIDL_LOCAL_APPDATA, NULL, 0, data_path);
+    path = String(data_path);
+    
+    path += "/Oculus";
+
+    if (create_dir)
+    {   // Create the Oculus directory if it doesn't exist
+        WCHAR wpath[128];
+        OVR::UTF8Util::DecodeString(wpath, path.ToCStr());
+
+        DWORD attrib = GetFileAttributes(wpath);
+        bool exists = attrib != INVALID_FILE_ATTRIBUTES && (attrib & FILE_ATTRIBUTE_DIRECTORY);
+        if (!exists)
+        {   
+            CreateDirectory(wpath, NULL);
+        }
+    }
+        
+#elif defined(OVR_OS_MAC)
+
+    const char* home = getenv("HOME");
+    path = home;
+    path += "/Library/Preferences/Oculus";
+
+    if (create_dir)
+    {   // Create the Oculus directory if it doesn't exist
+        DIR* dir = opendir(path);
+        if (dir == NULL)
+        {
+            mkdir(path, S_IRWXU | S_IRWXG | S_IRWXO);
+        }
+        else
+        {
+            closedir(dir);
+        }
+    }
+
+#else
+
+    passwd* pwd = getpwuid(getuid());
+    const char* home = pwd->pw_dir;
+    path = home;
+    path += "/.config/Oculus";
+
+    if (create_dir)
+    {   // Create the Oculus directory if it doesn't exist
+        DIR* dir = opendir(path);
+        if (dir == NULL)
+        {
+            mkdir(path, S_IRWXU | S_IRWXG | S_IRWXO);
+        }
+        else
+        {
+            closedir(dir);
+        }
+    }
+
+#endif
+
+    return path;
+}
+
+String ProfileManager::GetProfilePath()
+{
+	return BasePath + "/ProfileDB.json";
+}
+
+static JSON* FindTaggedData(JSON* data, const char** tag_names, const char** qtags, int num_qtags)
+{
+    if (data == NULL || !(data->Name == "TaggedData") || data->Type != JSON_Array)
+        return NULL;
+
+    JSON* tagged_item = data->GetFirstItem();
+    while (tagged_item)
+    {
+        JSON* tags = tagged_item->GetItemByName("tags");
+        if (tags->Type == JSON_Array && num_qtags == tags->GetArraySize())
+        {   // Check for a full tag match on each item
+            int num_matches = 0;
+            
+            for (int k=0; k<num_qtags; k++)
+            {
+                JSON* tag = tags->GetFirstItem();
+                while (tag)
+                {
+                    JSON* tagval = tag->GetFirstItem();
+                    if (tagval && tagval->Name == tag_names[k])
+                    {
+                        if (tagval->Value == qtags[k])
+                            num_matches++;
+                        break;
+                    }
+                    tag = tags->GetNextItem(tag);
+                }
+            }
+
+            // if all tags were matched then copy the values into this Profile
+            if (num_matches == num_qtags)
+            {
+                JSON* vals = tagged_item->GetItemByName("vals");
+                return vals;
+            }
+        }
+
+        tagged_item = data->GetNextItem(tagged_item);
+    }
+
+    return NULL;
+}
+
+static void FilterTaggedData(JSON* data, const char* tag_name, const char* qtag, Array<JSON*>& items)
+{
+    if (data == NULL || !(data->Name == "TaggedData") || data->Type != JSON_Array)
+        return;
+
+    JSON* tagged_item = data->GetFirstItem();
+    while (tagged_item)
+    {
+        JSON* tags = tagged_item->GetItemByName("tags");
+        if (tags->Type == JSON_Array)
+        {   // Check for a tag match on the requested tag
+            
+            JSON* tag = tags->GetFirstItem();
+            while (tag)
+            {
+                JSON* tagval = tag->GetFirstItem();
+                if (tagval && tagval->Name == tag_name)
+                {
+                    if (tagval->Value == qtag)
+                    {   // Add this item to the output list
+                        items.PushBack(tagged_item);
+                    }
+                    break;
+                }
+                tag = tags->GetNextItem(tag);
+            }
+        }
+
+        tagged_item = data->GetNextItem(tagged_item);
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// ***** ProfileManager
+
+template<> ProfileManager* OVR::SystemSingletonBase<ProfileManager>::SlowGetInstance()
+{
+    static OVR::Lock lock;
+    OVR::Lock::Locker locker(&lock);
+    if (!SingletonInstance) SingletonInstance = new ProfileManager(true);
+    return SingletonInstance;
+}
+
+ProfileManager::ProfileManager(bool sys_register) :
+	Changed(false)
+{
+	// Attempt to get the base path automatically, but this may fail
+	BasePath = GetBaseOVRPath(false);
+
+    if (sys_register)
+        PushDestroyCallbacks();
+}
+
+ProfileManager::~ProfileManager()
+{
+    ClearProfileData();
+}
+
+void ProfileManager::OnSystemDestroy()
+{
+    delete this;
+}
+
+// In the service process it is important to set the base path because this cannot be detected automatically
+void ProfileManager::SetBasePath(String basePath)
+{
+	if (basePath != BasePath)
+	{
+		BasePath = basePath;
+		LoadCache(false);
+	}
+}
+
+// Clear the local profile cache
+void ProfileManager::ClearProfileData()
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    ProfileCache.Clear();
+    Changed = false;
+}
+
+// Serializes the profiles to disk.
+void ProfileManager::Save()
+{
+	Lock::Locker lockScope(&ProfileLock);
+
+	if (ProfileCache == NULL)
+		return;
+
+    // Save the profile to disk
+    BasePath = GetBaseOVRPath(true);  // create the base directory if it doesn't exist
+    String path = GetProfilePath();
+    ProfileCache->Save(path);
+    Changed = false;
+}
+
+// Returns a profile with all system default values
+Profile* ProfileManager::GetDefaultProfile(HmdTypeEnum device)
+{
+    // In the absence of any data, set some reasonable profile defaults.
+    // However, this is not future proof and developers should still
+    // provide reasonable default values for queried fields.
+    
+    // Biometric data
+    Profile* profile = CreateProfile();
+    profile->SetValue(OVR_KEY_USER,               "default");
+    profile->SetValue(OVR_KEY_NAME,               "Default");
+    profile->SetValue(OVR_KEY_GENDER,             OVR_DEFAULT_GENDER);
+    profile->SetFloatValue(OVR_KEY_PLAYER_HEIGHT, OVR_DEFAULT_PLAYER_HEIGHT);
+    profile->SetFloatValue(OVR_KEY_EYE_HEIGHT,    OVR_DEFAULT_EYE_HEIGHT);
+    profile->SetFloatValue(OVR_KEY_IPD,           OVR_DEFAULT_IPD);
+    float half_ipd[2] = { OVR_DEFAULT_IPD / 2, OVR_DEFAULT_IPD / 2 };
+    profile->SetFloatValues(OVR_KEY_EYE_TO_NOSE_DISTANCE, half_ipd, 2);
+    float dist[2] = {OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL, OVR_DEFAULT_NECK_TO_EYE_VERTICAL};
+    profile->SetFloatValues(OVR_KEY_NECK_TO_EYE_DISTANCE, dist, 2);
+    
+    // Device specific data
+    if (device != HmdType_None)
+    {
+        if (device == HmdType_CrystalCoveProto || device == HmdType_DK2)
+        {
+            profile->SetValue("EyeCup", "A");
+            profile->SetIntValue(OVR_KEY_EYE_RELIEF_DIAL, OVR_DEFAULT_EYE_RELIEF_DIAL);
+
+            // TODO: These defaults are a little bogus and designed for continuity with 0.3
+            // eye-relief values.  We need better measurement-based numbers in future releases
+            float max_eye_plate[2] = { 0.01965f + 0.017f, 0.01965f + 0.017f };
+            profile->SetFloatValues(OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE, max_eye_plate, 2);
+        }
+        else
+        {   // DK1 and DKHD variants
+            profile->SetValue("EyeCup", "A");
+            profile->SetIntValue(OVR_KEY_EYE_RELIEF_DIAL, OVR_DEFAULT_EYE_RELIEF_DIAL);
+
+            // TODO: These defaults are a little bogus and designed for continuity with 0.3
+            // DK1 distortion.  We need better measurement-based numbers in future releases
+            float max_eye_plate[2] = { 0.02357f + 0.017f, 0.02357f + 0.017f };
+            profile->SetFloatValues(OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE, max_eye_plate, 2);
+        }
+    }
+
+    return profile;
+}
+
+//------------------------------------------------------------------------------
+void ProfileManager::Read()
+{
+    LoadCache(false);
+}
+
+// Populates the local profile cache.  This occurs on the first access of the profile
+// data.  All profile operations are performed against the local cache until the
+// ProfileManager is released or goes out of scope at which time the cache is serialized
+// to disk.
+void ProfileManager::LoadCache(bool create)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    ClearProfileData();
+
+    String path = GetProfilePath();
+
+    Ptr<JSON> root = *JSON::Load(path);
+    if (root == NULL)
+    {   
+        path = BasePath + "/Profiles.json";  // look for legacy profile
+        root = *JSON::Load(path);
+        
+        if (root == NULL)
+        {
+            if (create)
+            {   // Generate a skeleton profile database
+                root = *JSON::CreateObject();
+                root->AddNumberItem("Oculus Profile Version", 2.0);
+                root->AddItem("Users", JSON::CreateArray());
+                root->AddItem("TaggedData", JSON::CreateArray());
+                ProfileCache = root;
+            }
+            
+            return;
+        }
+
+        // Verify the legacy version
+        JSON* version_item = root->GetFirstItem();
+        if (version_item->Name == "Oculus Profile Version")
+        {
+            int major = atoi(version_item->Value.ToCStr());
+            if (major != 1)
+                return;   // don't use the file on unsupported major version number
+        }
+        else
+        {
+            return;      // invalid file
+        }
+
+        // Convert the legacy format to the new database format
+        LoadV1Profiles(root);
+    }
+    else
+    {
+        // Verify the file format and version
+        JSON* version_item = root->GetFirstItem();
+        if (version_item->Name == "Oculus Profile Version")
+        {
+            int major = atoi(version_item->Value.ToCStr());
+            if (major != 2)
+                return;   // don't use the file on unsupported major version number
+        }
+        else
+        {
+            return;       // invalid file 
+        }
+
+        ProfileCache = root;   // store the database contents for traversal
+    }
+}
+
+void ProfileManager::LoadV1Profiles(JSON* v1)
+{
+    JSON* item0 = v1->GetFirstItem();
+    JSON* item1 = v1->GetNextItem(item0);
+    JSON* item2 = v1->GetNextItem(item1);
+
+    // Create the new profile database
+    Ptr<JSON> root = *JSON::CreateObject();
+    root->AddNumberItem("Oculus Profile Version", 2.0);
+    root->AddItem("Users", JSON::CreateArray());
+    root->AddItem("TaggedData", JSON::CreateArray());
+    ProfileCache = root;
+
+    const char* default_dk1_user = item1->Value;
+    
+    // Read the number of profiles
+    int   profileCount = (int)item2->dValue;
+    JSON* profileItem  = item2;
+
+    for (int p=0; p<profileCount; p++)
+    {
+        profileItem = root->GetNextItem(profileItem);
+        if (profileItem == NULL)
+            break;
+
+        if (profileItem->Name == "Profile")
+        {
+            // Read the required Name field
+            const char* profileName;
+            JSON* item = profileItem->GetFirstItem();
+        
+            if (item && (item->Name == "Name"))
+            {   
+                profileName = item->Value;
+            }
+            else
+            {
+                return;   // invalid field
+            }
+            
+            // Read the user profile fields
+            if (CreateUser(profileName, profileName))
+            {
+                const char* tag_names[2] = {"User", "Product"};
+                const char* tags[2];
+                tags[0] = profileName;
+
+                Ptr<Profile> user_profile = *CreateProfile();
+                user_profile->SetValue(OVR_KEY_NAME, profileName);
+
+                float neckeye[2] = { 0, 0 };
+
+                item = profileItem->GetNextItem(item);
+                while (item)
+                {
+                    if (item->Type != JSON_Object)
+                    {
+                        if (item->Name == OVR_KEY_PLAYER_HEIGHT)
+                        {   // Add an explicit eye height
+
+                        }
+                        if (item->Name == "NeckEyeHori")
+                            neckeye[0] = (float)item->dValue;
+                        else if (item->Name == "NeckEyeVert")
+                            neckeye[1] = (float)item->dValue;
+                        else 
+                            user_profile->SetValue(item);
+                    }
+                    else
+                    {   
+                        // Add the user/device tag values
+                        const char* device_name = item->Name.ToCStr();
+                        Ptr<Profile> device_profile = *CreateProfile();
+
+                        JSON* device_item = item->GetFirstItem();
+                        while (device_item)
+                        {
+                            device_profile->SetValue(device_item);
+                            device_item = item->GetNextItem(device_item);
+                        }
+
+                        tags[1] = device_name;
+                        SetTaggedProfile(tag_names, tags, 2, device_profile);
+                    }
+
+                    item = profileItem->GetNextItem(item);
+                }
+
+                // Add an explicit eye-height field
+                float player_height = user_profile->GetFloatValue(OVR_KEY_PLAYER_HEIGHT,
+                                                                  OVR_DEFAULT_PLAYER_HEIGHT);
+                if (player_height > 0)
+                {
+                    char gender[16];
+                    user_profile->GetValue(OVR_KEY_GENDER, gender, 16);
+        
+                    const float EYE_TO_HEADTOP_RATIO =   0.44538f;
+                    const float MALE_AVG_HEAD_HEIGHT =   0.232f;
+                    const float FEMALE_AVG_HEAD_HEIGHT = 0.218f;
+     
+                    // compute distance from top of skull to the eye
+                    float head_height;
+                    if (OVR_strcmp(gender, "Female") == 0)
+                        head_height = FEMALE_AVG_HEAD_HEIGHT;
+                    else
+                        head_height = MALE_AVG_HEAD_HEIGHT;
+
+                    float skull = EYE_TO_HEADTOP_RATIO * head_height;
+                    float eye_height = player_height - skull;
+
+                    user_profile->SetFloatValue(OVR_KEY_EYE_HEIGHT, eye_height);
+                }
+
+                // Convert NeckEye values to an array
+                if (neckeye[0] > 0 && neckeye[1] > 0)
+                    user_profile->SetFloatValues(OVR_KEY_NECK_TO_EYE_DISTANCE, neckeye, 2);
+
+                // Add the user tag values
+                SetTaggedProfile(tag_names, tags, 1, user_profile);
+            }
+        }
+    }
+
+    // since V1 profiles were only for DK1, the assign the user to all DK1's
+    const char* tag_names[1] = { "Product" };
+    const char* tags[1] = { "RiftDK1" };
+    Ptr<Profile> product_profile = *CreateProfile();
+    product_profile->SetValue("DefaultUser", default_dk1_user);
+    SetTaggedProfile(tag_names, tags, 1, product_profile);
+}
+
+// Returns the number of stored profiles for this device type
+int ProfileManager::GetUserCount()
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(false);
+        if (ProfileCache == NULL)
+            return 0;
+    }
+
+    JSON* users = ProfileCache->GetItemByName("Users");
+    if (users == NULL)
+        return 0;
+
+    return users->GetItemCount();
+}
+
+bool ProfileManager::CreateUser(const char* user, const char* name)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(true);
+        if (ProfileCache == NULL)
+            return false;
+    }
+
+    JSON* users = ProfileCache->GetItemByName("Users");
+    if (users == NULL)
+    {   // Generate the User section
+        users = JSON::CreateArray();
+        ProfileCache->AddItem("Users", users);
+//TODO: Insert this before the TaggedData
+    }
+
+    // Search for the pre-existence of this user
+    JSON* user_item = users->GetFirstItem();
+    int index = 0;
+    while (user_item)
+    {
+        JSON* userid = user_item->GetItemByName("User");
+        int compare = OVR_strcmp(user, userid->Value);
+        if (compare == 0)
+        {   // The user already exists so simply update the fields
+            JSON* name_item = user_item->GetItemByName("Name");
+            if (name_item && OVR_strcmp(name, name_item->Value) != 0)
+            {
+                name_item->Value = name;
+                Changed = true;
+            }
+            return true;
+        }
+        else if (compare < 0)
+        {   // A new user should be placed before this item
+            break;
+        }
+        
+        user_item = users->GetNextItem(user_item);
+        index++;
+    }
+
+    // Create and fill the user struct
+    JSON* new_user = JSON::CreateObject();
+    new_user->AddStringItem(OVR_KEY_USER, user);
+    new_user->AddStringItem(OVR_KEY_NAME, name);
+    // user_item->AddStringItem("Password", password);
+
+    if (user_item == NULL)
+        users->AddArrayElement(new_user);
+    else
+        users->InsertArrayElement(index, new_user);
+
+    Changed = true;
+    return true;
+}
+
+// Returns the user id of a specific user in the list.  The returned 
+// memory is locally allocated and should not be stored or deleted.  Returns NULL
+// if the index is invalid
+const char* ProfileManager::GetUser(unsigned int index)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(false);
+        if (ProfileCache == NULL)
+            return NULL;
+    }
+
+    JSON* users = ProfileCache->GetItemByName("Users");
+    
+    if (users && index < users->GetItemCount())
+    {
+        JSON* user_item = users->GetItemByIndex(index);
+        if (user_item)
+        {
+            JSON* user = user_item->GetFirstItem();
+            if (user)
+            {
+                JSON* userid = user_item->GetItemByName(OVR_KEY_USER);
+                if (userid)
+                    return userid->Value.ToCStr();
+            }
+        }
+    }
+    
+
+    return NULL;
+}
+
+bool ProfileManager::RemoveUser(const char* user)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(false);
+        if (ProfileCache == NULL)
+            return true;
+    }
+
+    JSON* users = ProfileCache->GetItemByName("Users");
+    if (users == NULL)
+        return true;
+
+    // Remove this user from the User table
+    JSON* user_item = users->GetFirstItem();
+    while (user_item)
+    {
+        JSON* userid = user_item->GetItemByName("User");
+        if (OVR_strcmp(user, userid->Value) == 0)
+        {   // Delete the user entry
+            user_item->RemoveNode();
+            user_item->Release();
+            Changed = true;
+            break;
+        }
+        
+        user_item = users->GetNextItem(user_item);
+    }
+
+    // Now remove all data entries with this user tag
+    JSON* tagged_data = ProfileCache->GetItemByName("TaggedData");
+    Array<JSON*> user_items;
+    FilterTaggedData(tagged_data, "User", user, user_items);
+    for (unsigned int i=0; i<user_items.GetSize(); i++)
+    {
+        user_items[i]->RemoveNode();
+        user_items[i]->Release();
+        Changed = true;
+    }
+ 
+    return Changed;
+}
+
+Profile* ProfileManager::CreateProfile()
+{
+    Profile* profile = new Profile(BasePath);
+    return profile;
+}
+
+const char* ProfileManager::GetDefaultUser(const ProfileDeviceKey& deviceKey)
+{
+    const char* product_str = deviceKey.ProductName.IsEmpty() ? NULL : deviceKey.ProductName.ToCStr();
+    const char* serial_str = deviceKey.PrintedSerial.IsEmpty() ? NULL : deviceKey.PrintedSerial.ToCStr();
+
+    return GetDefaultUser(product_str, serial_str);
+}
+
+// Returns the name of the profile that is marked as the current default user.
+const char* ProfileManager::GetDefaultUser(const char* product, const char* serial)
+{
+    const char* tag_names[2] = {"Product", "Serial"};
+    const char* tags[2];
+
+    if (product && serial)
+    {
+        tags[0] = product;
+        tags[1] = serial;
+        // Look for a default user on this specific device
+        Ptr<Profile> p = *GetTaggedProfile(tag_names, tags, 2);
+        if (p == NULL)
+        {   // Look for a default user on this product
+            p = *GetTaggedProfile(tag_names, tags, 1);
+        }
+
+        if (p)
+        {   
+            const char* user = p->GetValue("DefaultUser");
+            if (user != NULL && user[0] != 0)
+            {
+                TempBuff = user;
+                return TempBuff.ToCStr();
+            }
+        }
+    }
+
+    return NULL;
+}
+
+//-----------------------------------------------------------------------------
+bool ProfileManager::SetDefaultUser(const ProfileDeviceKey& deviceKey, const char* user)
+{
+    const char* tag_names[2] = {"Product", "Serial"};
+    const char* tags[2];
+
+	const char* product_str = deviceKey.ProductName.IsEmpty() ? NULL : deviceKey.ProductName.ToCStr();
+	const char* serial_str = deviceKey.PrintedSerial.IsEmpty() ? NULL : deviceKey.PrintedSerial.ToCStr();
+
+    if (product_str && serial_str)
+    {
+        tags[0] = product_str;
+        tags[1] = serial_str;
+
+        Ptr<Profile> p = *CreateProfile();
+        p->SetValue("DefaultUser", user);
+        return SetTaggedProfile(tag_names, tags, 2, p);
+    }
+
+    return false;
+}
+
+//-----------------------------------------------------------------------------
+Profile* ProfileManager::GetTaggedProfile(const char** tag_names, const char** tags, int num_tags)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(false);
+        if (ProfileCache == NULL)
+            return NULL;
+    }
+
+    JSON* tagged_data = ProfileCache->GetItemByName("TaggedData");
+    OVR_ASSERT(tagged_data);
+    if (tagged_data == NULL)
+        return NULL;
+    
+    Profile* profile = new Profile(BasePath);
+    
+    JSON* vals = FindTaggedData(tagged_data, tag_names, tags, num_tags);
+    if (vals)
+    {   
+        JSON* item = vals->GetFirstItem();
+        while (item)
+        {
+            //printf("Add %s, %s\n", item->Name.ToCStr(), item->Value.ToCStr());
+            //profile->Settings.Set(item->Name, item->Value);
+            profile->SetValue(item);
+            item = vals->GetNextItem(item);
+        }
+
+        return profile;
+    }
+    else
+    {
+        profile->Release();
+        return NULL;
+    }
+}
+
+//-----------------------------------------------------------------------------
+bool ProfileManager::SetTaggedProfile(const char** tag_names, const char** tags, int num_tags, Profile* profile)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(true);
+        if (ProfileCache == NULL)
+            return false;  // TODO: Generate a new profile DB
+    }
+
+    JSON* tagged_data = ProfileCache->GetItemByName("TaggedData");
+    OVR_ASSERT(tagged_data);
+    if (tagged_data == NULL)
+        return false;
+
+    // Get the cached tagged data section
+    JSON* vals = FindTaggedData(tagged_data, tag_names, tags, num_tags);
+    if (vals == NULL)
+    {  
+        JSON* tagged_item = JSON::CreateObject();
+        JSON* taglist = JSON::CreateArray();
+        for (int i=0; i<num_tags; i++)
+        {
+            JSON* k = JSON::CreateObject();
+            k->AddStringItem(tag_names[i], tags[i]);
+            taglist->AddArrayElement(k);
+        }
+
+        vals = JSON::CreateObject();
+        
+        tagged_item->AddItem("tags", taglist);
+        tagged_item->AddItem("vals", vals);
+        tagged_data->AddArrayElement(tagged_item);
+    }
+
+    // Now add or update each profile setting in cache
+    for (unsigned int i=0; i<profile->Values.GetSize(); i++)
+    {
+        JSON* value = profile->Values[i];
+        
+        bool found = false;
+        JSON* item = vals->GetFirstItem();
+        while (item)
+        {
+            if (value->Name == item->Name)
+            {
+                // Don't allow a pre-existing type to be overridden
+                OVR_ASSERT(value->Type == item->Type);
+
+                if (value->Type == item->Type)
+                {   // Check for the same value
+                    if (value->Type == JSON_Array)
+                    {   // Update each array item
+                        if (item->GetArraySize() == value->GetArraySize())
+                        {   // Update each value (assumed to be basic types and not array of objects)
+                            JSON* value_element = value->GetFirstItem();
+                            JSON* item_element = item->GetFirstItem();
+                            while (item_element && value_element)
+                            {
+                                if (value_element->Type == JSON_String)
+                                {
+                                    if (item_element->Value != value_element->Value)
+                                    {   // Overwrite the changed value and mark for file update
+                                        item_element->Value = value_element->Value;
+                                        Changed = true;
+                                    }
+                                }
+                                else {
+                                    if (item_element->dValue != value_element->dValue)
+                                    {   // Overwrite the changed value and mark for file update
+                                        item_element->dValue = value_element->dValue;
+                                        Changed = true;
+                                    }
+                                }
+                                
+                                value_element = value->GetNextItem(value_element);
+                                item_element = item->GetNextItem(item_element);
+                            }
+                        }
+                        else
+                        {   // if the array size changed, simply create a new one                            
+// TODO: Create the new array
+                        }
+                    }
+                    else if (value->Type == JSON_String)
+                    {
+                        if (item->Value != value->Value)
+                        {   // Overwrite the changed value and mark for file update
+                            item->Value = value->Value;
+                            Changed = true;
+                        }
+                    }
+                    else {
+                        if (item->dValue != value->dValue)
+                        {   // Overwrite the changed value and mark for file update
+                            item->dValue = value->dValue;
+                            Changed = true;
+                        }
+                    }
+                }
+                else
+                {
+                    return false;
+                }
+
+                found = true;
+                break;
+            }
+            
+            item = vals->GetNextItem(item);
+        }
+
+        if (!found)
+        {   // Add the new value
+            Changed = true;
+
+            if (value->Type == JSON_String)
+                vals->AddStringItem(value->Name, value->Value);
+            else if (value->Type == JSON_Bool)
+                vals->AddBoolItem(value->Name, ((int)value->dValue != 0));
+            else if (value->Type == JSON_Number)
+                vals->AddNumberItem(value->Name, value->dValue);
+            else if (value->Type == JSON_Array)
+                vals->AddItem(value->Name, value->Copy());
+            else
+            {
+                OVR_ASSERT(false);
+                Changed = false;
+            }
+        }
+    }
+
+    return true;
+}
+
+//-----------------------------------------------------------------------------
+Profile* ProfileManager::GetDefaultUserProfile(const ProfileDeviceKey& deviceKey)
+{
+	const char* userName = GetDefaultUser(deviceKey);
+
+    Profile* profile = GetProfile(deviceKey, userName);
+
+    if (!profile)
+    {
+        profile = GetDefaultProfile(deviceKey.HmdType);
+    }
+
+    return profile;
+}
+
+//-----------------------------------------------------------------------------
+Profile* ProfileManager::GetProfile(const ProfileDeviceKey& deviceKey, const char* user)
+{
+    Lock::Locker lockScope(&ProfileLock);
+
+    if (ProfileCache == NULL)
+    {   // Load the cache
+        LoadCache(false);
+        if (ProfileCache == NULL)
+            return NULL;
+    }
+    
+	Profile* profile = new Profile(BasePath);
+
+	if (deviceKey.Valid)
+    {
+		if (!profile->LoadDeviceProfile(deviceKey) && (user == NULL))
+        {
+            profile->Release();
+            return NULL;
+        }
+    }
+    
+    if (user)
+    {
+		const char* product_str = deviceKey.ProductName.IsEmpty() ? NULL : deviceKey.ProductName.ToCStr();
+		const char* serial_str = deviceKey.PrintedSerial.IsEmpty() ? NULL : deviceKey.PrintedSerial.ToCStr();
+
+        if (!profile->LoadProfile(ProfileCache.GetPtr(), user, product_str, serial_str))
+        {
+            profile->Release();
+            return NULL;
+        }
+    }
+
+    return profile;
+}
+
+
+//-----------------------------------------------------------------------------
+// ***** Profile
+
+Profile::~Profile()
+{
+    ValMap.Clear();
+    for (unsigned int i=0; i<Values.GetSize(); i++)
+        Values[i]->Release();
+
+    Values.Clear();
+}
+
+bool Profile::Close()
+{
+    // TODO:
+    return true;
+}
+
+//-----------------------------------------------------------------------------
+void Profile::CopyItems(JSON* root, String prefix)
+{
+    JSON* item = root->GetFirstItem();
+    while (item)
+    {
+        String item_name;
+        if (prefix.IsEmpty())
+            item_name = item->Name;
+        else
+            item_name = prefix + "." + item->Name;
+
+        if (item->Type == JSON_Object)
+        {   // recursively copy the children
+            
+            CopyItems(item, item_name);
+        }
+        else
+        {
+            //Settings.Set(item_name, item->Value);
+            SetValue(item);
+        }
+
+        item = root->GetNextItem(item);
+    }
+}
+
+//-----------------------------------------------------------------------------
+bool Profile::LoadDeviceFile(unsigned int productId, const char* printedSerialNumber)
+{
+	if (printedSerialNumber[0] == 0)
+        return false;
+
+    String path = BasePath + "/Devices.json";
+
+    // Load the device profiles
+    Ptr<JSON> root = *JSON::Load(path);
+    if (root == NULL)
+        return false;
+
+    // Quick sanity check of the file type and format before we parse it
+    JSON* version = root->GetFirstItem();
+    if (version && version->Name == "Oculus Device Profile Version")
+    {   
+        int major = atoi(version->Value.ToCStr());
+        if (major > MAX_DEVICE_PROFILE_MAJOR_VERSION)
+            return false;   // don't parse the file on unsupported major version number
+    }
+    else
+    {
+        return false;
+    }   
+
+    JSON* device = root->GetNextItem(version);
+    while (device)
+    {   
+        if (device->Name == "Device")
+        {   
+            JSON* product_item = device->GetItemByName("ProductID");
+            JSON* serial_item = device->GetItemByName("Serial");
+            if (product_item && serial_item &&
+				(product_item->dValue == productId) && (serial_item->Value == printedSerialNumber))
+            {   
+                // found the entry for this device so recursively copy all the settings to the profile
+                CopyItems(device, "");
+                return true;   
+            }
+        }
+
+        device = root->GetNextItem(device);
+    }
+    
+    return false;
+}
+
+#if 0
+//-----------------------------------------------------------------------------
+static int BCDByte(unsigned int byte)
+{
+    int digit1 = (byte >> 4) & 0x000f;
+    int digit2 = byte & 0x000f;
+    int decimal = digit1 * 10 + digit2;
+    return decimal;
+}
+#endif
+
+//-----------------------------------------------------------------------------
+bool Profile::LoadDeviceProfile(const ProfileDeviceKey& deviceKey)
+{
+    bool success = false;
+	if (!deviceKey.Valid)
+            return false;
+
+#if 0
+        int dev_major = BCDByte((sinfo.Version >> 8) & 0x00ff);
+        OVR_UNUSED(dev_major);
+        //int dev_minor = BCDByte(sinfo.Version & 0xff);
+      
+        //if (dev_minor > 18)
+        //{   // If the firmware supports hardware stored profiles then grab the device profile
+            // from the sensor
+            // TBD:  Implement this
+        //}
+        //else
+        {
+#endif
+            // Grab the model and serial number from the device and use it to access the device
+            // profile file stored on the local machine
+		success = LoadDeviceFile(deviceKey.ProductId, deviceKey.PrintedSerial);
+    //}
+
+    return success;
+}
+
+//-----------------------------------------------------------------------------
+bool Profile::LoadUser(JSON* root, 
+                         const char* user,
+                          const char* model_name,
+                          const char* device_serial)
+{
+    if (user == NULL)
+        return false;
+
+    // For legacy files, convert to old style names
+    //if (model_name && OVR_strcmp(model_name, "Oculus Rift DK1") == 0)
+    //    model_name = "RiftDK1";
+    
+    bool user_found = false;
+    JSON* data = root->GetItemByName("TaggedData");
+    if (data)
+    {   
+        const char* tag_names[3];
+        const char* tags[3];
+        tag_names[0] = "User";
+        tags[0] = user;
+        int num_tags = 1;
+
+        if (model_name)
+        {
+            tag_names[num_tags] = "Product";
+            tags[num_tags] = model_name;
+            num_tags++;
+        }
+
+        if (device_serial)
+        {
+            tag_names[num_tags] = "Serial";
+            tags[num_tags] = device_serial;
+            num_tags++;
+        }
+
+        // Retrieve all tag permutations
+        for (int combos=1; combos<=num_tags; combos++)
+        {
+            for (int i=0; i<(num_tags - combos + 1); i++)
+            {
+                JSON* vals = FindTaggedData(data, tag_names+i, tags+i, combos);
+                if (vals)
+                {   
+                    if (i==0)   // This tag-combination contains a user match
+                        user_found = true;
+
+                    // Add the values to the Profile.  More specialized multi-tag values
+                    // will take precedence over and overwrite generalized ones 
+                    // For example: ("Me","RiftDK1").IPD would overwrite ("Me").IPD
+                    JSON* item = vals->GetFirstItem();
+                    while (item)
+                    {
+                        //printf("Add %s, %s\n", item->Name.ToCStr(), item->Value.ToCStr());
+                        //Settings.Set(item->Name, item->Value);
+                        SetValue(item);
+                        item = vals->GetNextItem(item);
+                    }
+                }
+            }
+        }
+    }
+
+    if (user_found)
+        SetValue(OVR_KEY_USER, user);
+
+    return user_found;
+}
+
+
+//-----------------------------------------------------------------------------
+bool Profile::LoadProfile(JSON* root,
+                          const char* user,
+                          const char* device_model,
+                          const char* device_serial)
+{
+    if (!LoadUser(root, user, device_model, device_serial))
+        return false;
+
+    return true;
+}
+
+
+//-----------------------------------------------------------------------------
+char* Profile::GetValue(const char* key, char* val, int val_length) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {
+        OVR_strcpy(val, val_length, value->Value.ToCStr());
+        return val;
+    }
+    else
+    {
+        val[0] = 0;
+        return NULL;
+    }
+}
+
+//-----------------------------------------------------------------------------
+const char* Profile::GetValue(const char* key)
+{
+    // Non-reentrant query.  The returned buffer can only be used until the next call
+    // to GetValue()
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {
+        TempVal = value->Value;
+        return TempVal.ToCStr();
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+//-----------------------------------------------------------------------------
+int Profile::GetNumValues(const char* key) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {  
+        if (value->Type == JSON_Array)
+            return value->GetArraySize();
+        else
+            return 1;
+    }
+    else
+        return 0;        
+}
+
+//-----------------------------------------------------------------------------
+bool Profile::GetBoolValue(const char* key, bool default_val) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Bool)
+        return (value->dValue != 0);
+    else
+        return default_val;
+}
+
+//-----------------------------------------------------------------------------
+int Profile::GetIntValue(const char* key, int default_val) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Number)
+        return (int)(value->dValue);
+    else
+        return default_val;
+}
+
+//-----------------------------------------------------------------------------
+float Profile::GetFloatValue(const char* key, float default_val) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Number)
+        return (float)(value->dValue);
+    else
+        return default_val;
+}
+
+//-----------------------------------------------------------------------------
+int Profile::GetFloatValues(const char* key, float* values, int num_vals) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Array)
+    {
+        int val_count = Alg::Min(value->GetArraySize(), num_vals);
+        JSON* item = value->GetFirstItem();
+        int count=0;
+        while (item && count < val_count)
+        {
+            if (item->Type == JSON_Number)
+                values[count] = (float)item->dValue;
+            else
+                break;
+
+            count++;
+            item = value->GetNextItem(item);
+        }
+
+        return count;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+//-----------------------------------------------------------------------------
+double Profile::GetDoubleValue(const char* key, double default_val) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Number)
+        return value->dValue;
+    else
+        return default_val;
+}
+
+//-----------------------------------------------------------------------------
+int Profile::GetDoubleValues(const char* key, double* values, int num_vals) const
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value) && value->Type == JSON_Array)
+    {
+        int val_count = Alg::Min(value->GetArraySize(), num_vals);
+        JSON* item = value->GetFirstItem();
+        int count=0;
+        while (item && count < val_count)
+        {
+            if (item->Type == JSON_Number)
+                values[count] = item->dValue;
+            else
+                break;
+
+            count++;
+            item = value->GetNextItem(item);
+        }
+
+        return count;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetValue(JSON* val)
+{
+    if (val->Type == JSON_Number)
+        SetDoubleValue(val->Name, val->dValue);
+    else if (val->Type == JSON_Bool)
+        SetBoolValue(val->Name, (val->dValue != 0));
+    else if (val->Type == JSON_String)
+        SetValue(val->Name, val->Value);
+    else if (val->Type == JSON_Array)
+    {
+        if (val == NULL)
+            return;
+
+        // Create a copy of the array
+        JSON* value = val->Copy();
+        Values.PushBack(value);
+        ValMap.Set(value->Name, value);
+    }
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetValue(const char* key, const char* val)
+{
+    if (key == NULL || val == NULL)
+        return;
+
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {
+        value->Value = val;
+    }
+    else
+    {
+        value = JSON::CreateString(val);
+        value->Name = key;
+
+        Values.PushBack(value);
+        ValMap.Set(key, value);
+    }
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetBoolValue(const char* key, bool val)
+{
+    if (key == NULL)
+        return;
+
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {
+        value->dValue = val;
+    }
+    else
+    {
+        value = JSON::CreateBool(val);
+        value->Name = key;
+
+        Values.PushBack(value);
+        ValMap.Set(key, value);
+    }
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetIntValue(const char* key, int val)
+{
+    SetDoubleValue(key, val);
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetFloatValue(const char* key, float val)
+{
+    SetDoubleValue(key, val);
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetFloatValues(const char* key, const float* vals, int num_vals)
+{
+    JSON* value = NULL;
+    int val_count = 0;
+    if (ValMap.Get(key, &value))
+    {
+        if (value->Type == JSON_Array)
+        {
+            // truncate the existing array if fewer entries provided
+            int num_existing_vals = value->GetArraySize();
+            for (int i=num_vals; i<num_existing_vals; i++)
+                value->RemoveLast();
+            
+            JSON* item = value->GetFirstItem();
+            while (item && val_count < num_vals)
+            {
+                if (item->Type == JSON_Number)
+                    item->dValue = vals[val_count];
+
+                item = value->GetNextItem(item);
+                val_count++;
+            }
+        }
+        else
+        {
+            return;  // Maybe we should change the data type?
+        }
+    }
+    else
+    {
+        value = JSON::CreateArray();
+        value->Name = key;
+
+        Values.PushBack(value);
+        ValMap.Set(key, value);
+    }
+
+    for (; val_count < num_vals; val_count++)
+        value->AddArrayNumber(vals[val_count]);
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetDoubleValue(const char* key, double val)
+{
+    JSON* value = NULL;
+    if (ValMap.Get(key, &value))
+    {
+        value->dValue = val;
+    }
+    else
+    {
+        value = JSON::CreateNumber(val);
+        value->Name = key;
+
+        Values.PushBack(value);
+        ValMap.Set(key, value);
+    }
+}
+
+//-----------------------------------------------------------------------------
+void Profile::SetDoubleValues(const char* key, const double* vals, int num_vals)
+{
+    JSON* value = NULL;
+    int val_count = 0;
+    if (ValMap.Get(key, &value))
+    {
+        if (value->Type == JSON_Array)
+        {
+            // truncate the existing array if fewer entries provided
+            int num_existing_vals = value->GetArraySize();
+            for (int i=num_vals; i<num_existing_vals; i++)
+                value->RemoveLast();
+            
+            JSON* item = value->GetFirstItem();
+            while (item && val_count < num_vals)
+            {
+                if (item->Type == JSON_Number)
+                    item->dValue = vals[val_count];
+
+                item = value->GetNextItem(item);
+                val_count++;
+            }
+        }
+        else
+        {
+            return;  // Maybe we should change the data type?
+        }
+    }
+    else
+    {
+        value = JSON::CreateArray();
+        value->Name = key;
+
+        Values.PushBack(value);
+        ValMap.Set(key, value);
+    }
+
+    for (; val_count < num_vals; val_count++)
+        value->AddArrayNumber(vals[val_count]);
+}
+
+//------------------------------------------------------------------------------
+bool Profile::IsDefaultProfile()
+{
+	return 0 == OVR::String::CompareNoCase("Default", GetValue(OVR_KEY_NAME));
+}
+
+
+}  // namespace OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,253 @@
+/************************************************************************************
+
+Filename    :   OVR_Profile.h
+Content     :   Structs and functions for loading and storing device profile settings
+Created     :   February 14, 2013
+Notes       :
+   Profiles are used to store per-user settings that can be transferred and used
+   across multiple applications.  For example, player IPD can be configured once 
+   and reused for a unified experience across games.  Configuration and saving of profiles
+   can be accomplished in game via the Profile API or by the official Oculus Configuration
+   Utility.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Profile_h
+#define OVR_Profile_h
+
+#include "Sensors/OVR_DeviceConstants.h"
+#include "Kernel/OVR_String.h"
+#include "Kernel/OVR_RefCount.h"
+#include "Kernel/OVR_Array.h"
+#include "Kernel/OVR_StringHash.h"
+#include "Kernel/OVR_System.h"
+
+namespace OVR {
+
+class HMDInfo; // Opaque forward declaration
+class Profile;
+class JSON;
+
+
+// Device key for looking up profiles
+struct ProfileDeviceKey
+{
+    ProfileDeviceKey(const HMDInfo* info);
+
+	// Initialized properly?
+	bool Valid;
+
+    // The HMD type
+    HmdTypeEnum HmdType;
+
+	// This is the 12 character serial number printed on the HMD
+	String PrintedSerial;
+
+	// This is the product name string of the USB sensor device
+	// Note: It has been modified from the original to remove spaces and strip off "Oculus"
+	String ProductName;
+
+	// This is the product id from the HID info of the USB sensor device
+	unsigned ProductId;
+
+    static String SanitizeProductName(String productName);
+};
+
+
+// -----------------------------------------------------------------------------
+// ***** ProfileManager
+
+// Profiles are interfaced through a ProfileManager object.  Applications should
+// create a ProfileManager each time they intend to read or write user profile data.
+// The scope of the ProfileManager object defines when disk I/O is performed.  Disk
+// reads are performed on the first profile access and disk writes are performed when
+// the ProfileManager goes out of scope.  All profile interactions between these times
+// are performed in local memory and are fast.  A typical profile interaction might
+// look like this:
+//
+// {
+//     Ptr<ProfileManager> pm      = *ProfileManager::Create();
+//     Ptr<Profile>        profile = pm->LoadProfile(Profile_RiftDK1,
+//                                                   pm->GetDefaultProfileName(Profile_RiftDK1));
+//     if (profile)
+//     {   // Retrieve the current profile settings
+//     }
+// }   // Profile will be destroyed and any disk I/O completed when going out of scope
+class ProfileManager : public NewOverrideBase, public SystemSingletonBase<ProfileManager>
+{
+    friend class OVR::SystemSingletonBase<ProfileManager>;
+
+protected:
+    ProfileManager(bool sys_register);
+    ~ProfileManager();
+    virtual void OnSystemDestroy();
+
+protected:
+    // Synchronize ProfileManager access since it may be accessed from multiple threads,
+    // as it's shared through DeviceManager.
+    Lock                ProfileLock;
+    Ptr<JSON>           ProfileCache;
+    bool                Changed;
+    String              TempBuff;
+    String              BasePath;
+    
+public:
+    // In the service process it is important to set the base path because this cannot be detected automatically
+    void                SetBasePath(String basePath);
+
+    int                 GetUserCount();
+    const char*         GetUser(unsigned int index);
+    bool                CreateUser(const char* user, const char* name);
+    bool                RemoveUser(const char* user);
+    const char*         GetDefaultUser(const ProfileDeviceKey& deviceKey);
+    bool                SetDefaultUser(const ProfileDeviceKey& deviceKey, const char* user);
+
+    virtual Profile*    CreateProfile();
+    Profile*            GetProfile(const ProfileDeviceKey& deviceKey, const char* user);
+    Profile*            GetDefaultUserProfile(const ProfileDeviceKey& deviceKey);
+    Profile*            GetDefaultProfile(HmdTypeEnum device);
+    Profile*            GetTaggedProfile(const char** key_names, const char** keys, int num_keys);
+    bool                SetTaggedProfile(const char** key_names, const char** keys, int num_keys, Profile* profile);
+    
+    // Force re-reading the settings
+    void                Read();
+
+protected:
+    // Force writing the settings
+    void                ClearProfileData();
+    void                Save();
+
+    String              GetProfilePath();
+    void                LoadCache(bool create);
+    void                LoadV1Profiles(JSON* v1);
+    const char*         GetDefaultUser(const char* product, const char* serial);
+};
+
+
+//-------------------------------------------------------------------
+// ***** Profile
+
+// The base profile for all users.  This object is not created directly.
+// Instead derived device objects provide add specific device members to 
+// the base profile
+class Profile : public RefCountBase<Profile>
+{
+protected:
+    OVR::Hash<String, JSON*, String::HashFunctor>   ValMap;
+    OVR::Array<JSON*>   Values;  
+    OVR::String         TempVal;
+    String              BasePath;
+    bool                IsDefault;
+
+public:
+    ~Profile();
+
+    int                 GetNumValues(const char* key) const;
+    const char*         GetValue(const char* key);
+    char*               GetValue(const char* key, char* val, int val_length) const;
+    bool                GetBoolValue(const char* key, bool default_val) const;
+    int                 GetIntValue(const char* key, int default_val) const;
+    float               GetFloatValue(const char* key, float default_val) const;
+    int                 GetFloatValues(const char* key, float* values, int num_vals) const;
+    double              GetDoubleValue(const char* key, double default_val) const;
+    int                 GetDoubleValues(const char* key, double* values, int num_vals) const;
+
+    void                SetValue(const char* key, const char* val);
+    void                SetBoolValue(const char* key, bool val);
+    void                SetIntValue(const char* key, int val);
+    void                SetFloatValue(const char* key, float val);
+    void                SetFloatValues(const char* key, const float* vals, int num_vals);
+    void                SetDoubleValue(const char* key, double val);
+    void                SetDoubleValues(const char* key, const double* vals, int num_vals);
+
+    bool                IsDefaultProfile();
+    
+    bool Close();
+
+protected:
+	Profile(String basePath) :
+		BasePath(basePath)
+	{
+	}
+    
+    void                SetValue(JSON* val);
+
+	static bool         LoadProfile(const ProfileDeviceKey& deviceKey,
+                                    const char* user,
+                                    Profile** profile);
+    void                CopyItems(JSON* root, String prefix);
+    
+    bool                LoadDeviceFile(unsigned int device_id, const char* serial);
+	bool                LoadDeviceProfile(const ProfileDeviceKey& deviceKey);
+
+    bool                LoadProfile(JSON* root,
+                                    const char* user,
+                                    const char* device_model,
+                                    const char* device_serial);
+
+    bool                LoadUser(JSON* root,
+                                 const char* user,
+                                 const char* device_name,
+                                 const char* device_serial);
+
+    friend class ProfileManager;
+    friend class WProfileManager;
+};
+
+// # defined() check for CAPI compatibility near term that re-defines these
+//   for now. To be unified.
+#if !defined(OVR_KEY_USER)
+
+#define OVR_KEY_USER                        "User"
+#define OVR_KEY_NAME                        "Name"
+#define OVR_KEY_GENDER                      "Gender"
+#define OVR_KEY_PLAYER_HEIGHT               "PlayerHeight"
+#define OVR_KEY_EYE_HEIGHT                  "EyeHeight"
+#define OVR_KEY_IPD                         "IPD"
+#define OVR_KEY_NECK_TO_EYE_DISTANCE        "NeckEyeDistance"
+#define OVR_KEY_EYE_RELIEF_DIAL             "EyeReliefDial"
+#define OVR_KEY_EYE_TO_NOSE_DISTANCE        "EyeToNoseDist"
+#define OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE   "MaxEyeToPlateDist"
+#define OVR_KEY_EYE_CUP                     "EyeCup"
+#define OVR_KEY_CUSTOM_EYE_RENDER           "CustomEyeRender"
+
+// Default measurements empirically determined at Oculus to make us happy
+// The neck model numbers were derived as an average of the male and female averages from ANSUR-88
+// NECK_TO_EYE_HORIZONTAL = H22 - H43 = INFRAORBITALE_BACK_OF_HEAD - TRAGION_BACK_OF_HEAD
+// NECK_TO_EYE_VERTICAL = H21 - H15 = GONION_TOP_OF_HEAD - ECTOORBITALE_TOP_OF_HEAD
+// These were determined to be the best in a small user study, clearly beating out the previous default values
+#define OVR_DEFAULT_GENDER                  "Unknown"
+#define OVR_DEFAULT_PLAYER_HEIGHT           1.778f
+#define OVR_DEFAULT_EYE_HEIGHT              1.675f
+#define OVR_DEFAULT_IPD                     0.064f
+#define OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL  0.0805f
+#define OVR_DEFAULT_NECK_TO_EYE_VERTICAL    0.075f
+#define OVR_DEFAULT_EYE_RELIEF_DIAL         3
+
+#endif // OVR_KEY_USER
+
+
+// This path should be passed into the ProfileManager
+String GetBaseOVRPath(bool create_dir);
+
+
+} // namespace OVR
+
+#endif // OVR_Profile_h
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,445 @@
+/************************************************************************************
+
+Filename    :   OVR_System.cpp
+Content     :   General kernel initialization/cleanup, including that
+                of the memory allocator.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "OVR_SerialFormat.h"
+
+namespace OVR {
+
+
+//// Serial Format Detection
+
+SerialFormatType DetectBufferFormat(uint8_t firstByte, int sizeInBytes)
+{
+	switch (firstByte)
+	{
+	case SerialFormatType_DK2:
+		if (sizeInBytes == 12)
+		{
+			return SerialFormatType_DK2;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return SerialFormatType_Invalid;
+}
+
+
+//// DK2 Helpers
+
+static bool ValidDK2ProductId(int x)
+{
+	switch (x)
+	{
+	case DK2ProductId_DK1:
+	case DK2ProductId_DK2:
+	case DK2ProductId_Refurb:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool ValidDK2PartId(int x)
+{
+	switch (x)
+	{
+	case DK2PartId_HMD:
+	case DK2PartId_PTC:
+	case DK2PartId_Carton:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+
+//// DK2BinarySerialFormat
+
+bool DK2BinarySerialFormat::FromBuffer(const uint8_t buffer[12], bool allowUnknownTypes)
+{
+	// Format Type must be 0
+	
+	int formatType = buffer[0];
+
+	if (formatType != SerialFormatType_DK2)
+	{
+		return false;
+	}
+
+	// Product Id
+
+	int productId = buffer[1] >> 4;
+
+	if (!allowUnknownTypes && !ValidDK2ProductId(productId))
+	{
+		return false;
+	}
+
+	ProductId = (DK2ProductId)productId;
+
+	// Part Id
+
+	int partId = buffer[1] & 15;
+
+	if (!allowUnknownTypes && !ValidDK2PartId(partId))
+	{
+		return false;
+	}
+
+	PartId = (DK2PartId)partId;
+
+	// Minutes Since Epoch (May 1, 2014)
+
+	MinutesSinceEpoch = buffer[4] | ((uint32_t)buffer[3] << 8) | ((uint32_t)buffer[2] << 16);
+
+	// Unit number on that day
+
+	UnitNumber = buffer[6] | ((uint32_t)buffer[5] << 8);
+
+	// Hash of MAC address
+
+	MacHash[0] = buffer[7];
+	MacHash[1] = buffer[8];
+	MacHash[2] = buffer[9];
+	MacHash[3] = buffer[10];
+	MacHash[4] = buffer[11];
+
+	return true;
+}
+
+void DK2BinarySerialFormat::ToBuffer(uint8_t buffer[12])
+{
+	// Serialize to buffer
+	buffer[0] = SerialFormatType_DK2;
+	buffer[1] = (uint8_t)((ProductId << 4) | (PartId));
+	buffer[2] = (uint8_t)(MinutesSinceEpoch >> 16);
+	buffer[3] = (uint8_t)(MinutesSinceEpoch >> 8);
+	buffer[4] = (uint8_t)MinutesSinceEpoch;
+	buffer[5] = (uint8_t)(UnitNumber >> 8);
+	buffer[6] = (uint8_t)UnitNumber;
+
+	buffer[7] = MacHash[0];
+	buffer[8] = MacHash[1];
+	buffer[9] = MacHash[2];
+	buffer[10] = MacHash[3];
+	buffer[11] = MacHash[4];
+}
+
+bool DK2BinarySerialFormat::operator==(const DK2BinarySerialFormat& rhs)
+{
+	if (ProductId != rhs.ProductId)
+		return false;
+	if (PartId != rhs.PartId)
+		return false;
+	if (MinutesSinceEpoch != rhs.MinutesSinceEpoch)
+		return false;
+	if (UnitNumber != rhs.UnitNumber)
+		return false;
+	for (int ii = 0; ii < 5; ++ii)
+	{
+		if (MacHash[ii] != rhs.MacHash[ii])
+			return false;
+	}
+	return true;
+}
+
+
+//// DK2PrintedSerialFormat
+
+// Base-32 Crockford decoding rules:
+// 0 o O => 0
+// 1 i | I L l => 1
+// 2, 3, 4, 5, 6, 7, 8, 9 => 2 - 9
+// a, b, c, d, e, f, g, h => 10 - 17
+// j, k => 18, 19
+// m, n => 20, 21
+// p, q, r, s, t => 22, 23, 24, 25, 26
+// v, w, x, y, z => 27, 28, 29, 30, 31
+static const char Base32FromChar[256] = {
+	// Null - Unit Separator
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	// (sp)!"#$%&'()*+,-./
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	// 0123456789:;<=>?
+	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
+	// @ - _ (upper case)
+	-1, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19,  1, 20, 21,  0,
+	22, 23, 24, 25, 26, -1, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1,
+	// ` - DEL (lower case)
+	-1, 10, 11, 12, 13, 14, 15, 16, 17,  1, 18, 19,  1, 20, 21,  0,
+	22, 23, 24, 25, 26, -1, 27, 28, 29, 30, 31, -1,  1, -1, -1, -1,
+
+	// Extended ASCII:
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+// Base-32 Crockford encoding rules:
+// 0-9 => 0-9
+// 10 - 17 => a, b, c, d, e, f, g, h
+// 18, 19 => j, k
+// 20, 21 => m, n
+// 22, 23, 24, 25, 26 => p, q, r, s, t
+// 27, 28, 29, 30, 31 => v, w, x, y, z
+static const char* CharFromBase32 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
+
+bool DK2PrintedSerialFormat::FromBase32(const char* str, bool allowUnknownTypes)
+{
+	// Note: Truncated strings get caught by returning negative values from the table like other invalid characters
+
+	// Product Id
+
+	int productId = Base32FromChar[str[0]];
+	if (productId < 0 || (!allowUnknownTypes && !ValidDK2ProductId(productId)))
+	{
+		return false;
+	}
+
+	ProductId = (DK2ProductId)productId;
+
+	// Label Type
+
+	int labelType = Base32FromChar[str[1]];
+	if (labelType < 0 || (!allowUnknownTypes && !ValidDK2PartId(labelType)))
+	{
+		return false;
+	}
+
+	LabelType = (DK2LabelType)labelType;
+
+	uint8_t dataBytes[7];
+	for (int ii = 0; ii < 7; ++ii)
+	{
+		int c = Base32FromChar[str[2 + ii]];
+		if (c < 0) return false;
+		dataBytes[ii] = (uint8_t)c;
+	}
+
+	// Minutes Since Epoch
+
+	MinutesSinceEpoch = dataBytes[3] | ((uint32_t)dataBytes[2] << 5) | ((uint32_t)dataBytes[1] << 10) | ((uint32_t)dataBytes[0] << 15);
+
+	// Unit Number
+
+	UnitNumber = dataBytes[6] | ((uint32_t)dataBytes[5] << 5) | ((uint32_t)dataBytes[4] << 10);
+
+	// MAC Hash
+
+	for (int ii = 0; ii < 3; ++ii)
+	{
+		int c = Base32FromChar[str[9 + ii]];
+		if (c < 0)
+		{
+			return false;
+		}
+
+		MacHashLow[ii] = (uint8_t)c;
+	}
+
+	// String must be exactly 12 characters
+	if (str[12] != '\0')
+	{
+		return false;
+	}
+
+	return true;
+}
+
+String DK2PrintedSerialFormat::ToBase32()
+{
+	String s;
+
+	s += CharFromBase32[ProductId];
+	s += CharFromBase32[LabelType];
+	s += CharFromBase32[(MinutesSinceEpoch >> 15) & 31];
+	s += CharFromBase32[(MinutesSinceEpoch >> 10) & 31];
+	s += CharFromBase32[(MinutesSinceEpoch >> 5) & 31];
+	s += CharFromBase32[MinutesSinceEpoch & 31];
+	s += CharFromBase32[(UnitNumber >> 10) & 31];
+	s += CharFromBase32[(UnitNumber >> 5) & 31];
+	s += CharFromBase32[UnitNumber & 31];
+	s += CharFromBase32[MacHashLow[0] & 31];
+	s += CharFromBase32[MacHashLow[1] & 31];
+	s += CharFromBase32[MacHashLow[2] & 31];
+
+	return s;
+}
+
+bool DK2PrintedSerialFormat::operator==(const DK2PrintedSerialFormat& rhs)
+{
+	if (ProductId != rhs.ProductId)
+		return false;
+	if (LabelType != rhs.LabelType)
+		return false;
+	if (MinutesSinceEpoch != rhs.MinutesSinceEpoch)
+		return false;
+	if (UnitNumber != rhs.UnitNumber)
+		return false;
+	for (int ii = 0; ii < 3; ++ii)
+	{
+		if (MacHashLow[ii] != rhs.MacHashLow[ii])
+			return false;
+	}
+	return true;
+}
+
+bool DK2PrintedSerialFormat::operator==(const DK2BinarySerialFormat& rhs)
+{
+	if (ProductId != rhs.ProductId)
+		return false;
+	if (LabelType != rhs.PartId)
+		return false;
+	if (MinutesSinceEpoch != rhs.MinutesSinceEpoch)
+		return false;
+	if (UnitNumber != rhs.UnitNumber)
+		return false;
+	for (int ii = 0; ii < 3; ++ii)
+	{
+		if (MacHashLow[ii] != (rhs.MacHash[ii] & 31))
+			return false;
+	}
+	return true;
+}
+
+void DK2PrintedSerialFormat::FromBinary(const DK2BinarySerialFormat& bin)
+{
+	ProductId = bin.ProductId;
+	LabelType = bin.PartId;
+	MinutesSinceEpoch = bin.MinutesSinceEpoch;
+	UnitNumber = bin.UnitNumber;
+	MacHashLow[0] = bin.MacHash[0] & 31;
+	MacHashLow[1] = bin.MacHash[1] & 31;
+	MacHashLow[2] = bin.MacHash[2] & 31;
+}
+
+
+//// Unit Tests
+
+#ifdef SERIAL_FORMAT_UNIT_TEST
+
+int DecodeBase32(char ch)
+{
+	if (ch >= '2' && ch <= '9')
+		return 2 + ch - '2';
+	if (ch >= 'a' && ch <= 'h')
+		return 10 + ch - 'a';
+	if (ch >= 'A' && ch <= 'H')
+		return 10 + ch - 'A';
+	if (ch >= 'j' && ch <= 'k')
+		return 18 + ch - 'j';
+	if (ch >= 'J' && ch <= 'K')
+		return 18 + ch - 'J';
+	if (ch >= 'm' && ch <= 'n')
+		return 20 + ch - 'm';
+	if (ch >= 'M' && ch <= 'N')
+		return 20 + ch - 'M';
+	if (ch >= 'p' && ch <= 't')
+		return 22 + ch - 'p';
+	if (ch >= 'P' && ch <= 'T')
+		return 22 + ch - 'P';
+	if (ch >= 'v' && ch <= 'z')
+		return 27 + ch - 'v';
+	if (ch >= 'V' && ch <= 'Z')
+		return 27 + ch - 'V';
+
+	switch (ch)
+	{
+	case '0':
+	case 'o':
+	case 'O':
+		return 0;
+	case '1':
+	case 'i':
+	case '|':
+	case 'I':
+	case 'L':
+	case 'l':
+		return 1;
+	}
+
+	return -1;
+}
+
+void TestSerialFormatStuff()
+{
+	for (int ii = 0; ii < 256; ++ii)
+	{
+		OVR_ASSERT(Base32FromChar[ii] == (char)DecodeBase32((char)ii));
+	}
+
+	DK2BinarySerialFormat sa;
+	sa.ProductId = DK2ProductId_DK2;
+	sa.PartId = DK2PartId_HMD;
+	sa.MinutesSinceEpoch = 65000;
+	sa.UnitNumber = 2;
+	sa.MacHash[0] = 0xa1;
+	sa.MacHash[1] = 0xb2;
+	sa.MacHash[2] = 0xc3;
+	sa.MacHash[3] = 0xd4;
+	sa.MacHash[4] = 0xe5;
+
+	uint8_t buffer[12];
+	sa.ToBuffer(buffer);
+
+	DK2BinarySerialFormat sb;
+	OVR_ASSERT(sb.FromBuffer(buffer));
+
+	OVR_ASSERT(sa == sb);
+
+	DK2PrintedSerialFormat psn;
+	psn.FromBinary(sb);
+
+	OVR_ASSERT(psn == sa);
+
+	String s = psn.ToBase32();
+
+	DK2PrintedSerialFormat psn2;
+	psn2.FromBase32(s.ToCStr());
+
+	OVR_ASSERT(psn == psn2);
+}
+
+#endif // SERIAL_FORMAT_UNIT_TEST
+
+
+} // OVR
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,127 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_SerialFormat.h
+Content     :   Serial Number format tools
+Created     :   June 12, 2014
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SerialFormat_h
+#define OVR_SerialFormat_h
+
+#include "Kernel/OVR_Types.h"
+#include "Kernel/OVR_String.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// SerialFormatType enumeration
+
+enum SerialFormatType
+{
+	SerialFormatType_Invalid = -1, // Invalid format
+	SerialFormatType_DK2 = 0,	   // Format used for DK2
+};
+
+// Returns the expected serial format based on the first byte of the buffer
+SerialFormatType DetectBufferFormat(uint8_t firstByte, int sizeInBytes);
+
+
+//-----------------------------------------------------------------------------
+// DK2 Serial Format
+
+enum DK2ProductId
+{
+	DK2ProductId_DK1    = 1, // DK1
+	DK2ProductId_DK2    = 2, // Product Id used for initial DK2 launch
+	DK2ProductId_Refurb = 3, // Refurbished DK2
+};
+
+enum DK2PartId
+{
+	DK2PartId_HMD    = 0, // HMD
+	DK2PartId_PTC    = 1, // PTC(camera)
+	DK2PartId_Carton = 2, // Carton: An HMD + PTC combo (should not be stamped on a component) AKA Overpack
+};
+
+typedef DK2PartId DK2LabelType; // Printed Serial Number version
+
+
+// DK2 tool for reading/writing the binary serial format
+class DK2BinarySerialFormat
+{
+public:
+	static const SerialFormatType FormatType = SerialFormatType_DK2; // first byte
+
+	DK2ProductId ProductId;         // [4 bits] 2 = DK2
+	DK2PartId    PartId;            // [4 bits] 0 means HMD, 1 means PTC(camera)
+	int          MinutesSinceEpoch; // [3 bytes] Number of minutes that have elapsed since the epoch: May 1st, 2014
+	// [0] = high byte, [1] = middle byte, [2] = low byte
+	int          UnitNumber;        // [2 bytes] Value that increments each time a new serial number is created.  Resets to zero each day
+	// [0] = high byte, [1] = low byte
+	uint8_t      MacHash[5];        // [5 bytes] 5 most significant bytes of MD5 hash from first ethernet adapter mac address
+
+	bool operator==(const DK2BinarySerialFormat& rhs);
+
+public:
+	// Returns false if the input is invalid in some way
+	bool FromBuffer(const uint8_t buffer[12], bool allowUnknownTypes = false);
+
+	// Fills the provided buffer with 12 bytes
+	void ToBuffer(uint8_t buffer[12]);
+};
+
+
+// DK2 tool for reading/writing the printed serial format
+class DK2PrintedSerialFormat
+{
+public:
+	DK2ProductId ProductId;         // [1 char] 2 = DK2, 3 = Reconditioned bundle
+	DK2LabelType LabelType;         // [1 char] 0 means HMD, 1 means PTC(camera), 2 means Overpack(bundle)
+	int          MinutesSinceEpoch; // [4 char] Number of minutes that have elapsed since the epoch: May 1st, 2014
+	int          UnitNumber;        // [3 char] Value that increments each time a new serial number is created.  Resets to zero each day
+	uint8_t      MacHashLow[3];     // [3 char] 3 least significant bytes of mac hash
+
+	bool operator==(const DK2PrintedSerialFormat& rhs);
+	bool operator==(const DK2BinarySerialFormat& rhs);
+
+public:
+	// Convert from binary to printed
+	void FromBinary(const DK2BinarySerialFormat& bin);
+
+	// Returns false if the input is invalid in some way
+	// Convert from a 12 character printed serial number
+	bool FromBase32(const char* str, bool allowUnknownTypes = false);
+
+	// Returns a long human-readable base32 string (20 characters), NOT a printed serial number
+	String ToBase32();
+};
+
+
+//#define SERIAL_FORMAT_UNIT_TEST
+#ifdef SERIAL_FORMAT_UNIT_TEST
+void TestSerialFormatStuff();
+#endif
+
+} // OVR
+
+#endif // OVR_SerialFormat_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1842 @@
+/************************************************************************************
+
+Filename    :   OVR_Stereo.cpp
+Content     :   Stereo rendering functions
+Created     :   November 30, 2013
+Authors     :   Tom Fosyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "OVR_Stereo.h"
+#include "OVR_Profile.h"
+#include "Kernel/OVR_Log.h"
+#include "Kernel/OVR_Alg.h"
+
+//To allow custom distortion to be introduced to CatMulSpline.
+float (*CustomDistortion)(float) = NULL;
+float (*CustomDistortionInv)(float) = NULL;
+
+
+namespace OVR {
+
+
+using namespace Alg;
+
+//-----------------------------------------------------------------------------------
+
+// Inputs are 4 points (pFitX[0],pFitY[0]) through (pFitX[3],pFitY[3])
+// Result is four coefficients in pResults[0] through pResults[3] such that
+//      y = pResult[0] + x * ( pResult[1] + x * ( pResult[2] + x * ( pResult[3] ) ) );
+// passes through all four input points.
+// Return is true if it succeeded, false if it failed (because two control points
+// have the same pFitX value).
+bool FitCubicPolynomial ( float *pResult, const float *pFitX, const float *pFitY )
+{
+    float d0 = ( ( pFitX[0]-pFitX[1] ) * ( pFitX[0]-pFitX[2] ) * ( pFitX[0]-pFitX[3] ) );
+    float d1 = ( ( pFitX[1]-pFitX[2] ) * ( pFitX[1]-pFitX[3] ) * ( pFitX[1]-pFitX[0] ) );
+    float d2 = ( ( pFitX[2]-pFitX[3] ) * ( pFitX[2]-pFitX[0] ) * ( pFitX[2]-pFitX[1] ) );
+    float d3 = ( ( pFitX[3]-pFitX[0] ) * ( pFitX[3]-pFitX[1] ) * ( pFitX[3]-pFitX[2] ) );
+
+    if ( ( d0 == 0.0f ) || ( d1 == 0.0f ) || ( d2 == 0.0f ) || ( d3 == 0.0f ) )
+    {
+        return false;
+    }
+
+    float f0 = pFitY[0] / d0;
+    float f1 = pFitY[1] / d1;
+    float f2 = pFitY[2] / d2;
+    float f3 = pFitY[3] / d3;
+
+    pResult[0] = -( f0*pFitX[1]*pFitX[2]*pFitX[3]
+                  + f1*pFitX[0]*pFitX[2]*pFitX[3]
+                  + f2*pFitX[0]*pFitX[1]*pFitX[3]
+                  + f3*pFitX[0]*pFitX[1]*pFitX[2] );
+    pResult[1] = f0*(pFitX[1]*pFitX[2] + pFitX[2]*pFitX[3] + pFitX[3]*pFitX[1])
+               + f1*(pFitX[0]*pFitX[2] + pFitX[2]*pFitX[3] + pFitX[3]*pFitX[0])
+               + f2*(pFitX[0]*pFitX[1] + pFitX[1]*pFitX[3] + pFitX[3]*pFitX[0])
+               + f3*(pFitX[0]*pFitX[1] + pFitX[1]*pFitX[2] + pFitX[2]*pFitX[0]);
+    pResult[2] = -( f0*(pFitX[1]+pFitX[2]+pFitX[3])
+                  + f1*(pFitX[0]+pFitX[2]+pFitX[3])
+                  + f2*(pFitX[0]+pFitX[1]+pFitX[3])
+                  + f3*(pFitX[0]+pFitX[1]+pFitX[2]) );
+    pResult[3] = f0 + f1 + f2 + f3;
+
+    return true;
+}
+
+#define TPH_SPLINE_STATISTICS 0
+#if TPH_SPLINE_STATISTICS
+static float max_scaledVal = 0;
+static float average_total_out_of_range = 0;
+static float average_out_of_range;
+static int num_total = 0;
+static int num_out_of_range = 0;
+static int num_out_of_range_over_1 = 0;
+static int num_out_of_range_over_2 = 0;
+static int num_out_of_range_over_3 = 0;
+static float percent_out_of_range;
+#endif
+
+float EvalCatmullRom10Spline ( float const *K, float scaledVal )
+{
+    int const NumSegments = LensConfig::NumCoefficients;
+
+	#if TPH_SPLINE_STATISTICS
+	//Value should be in range of 0 to (NumSegments-1) (typically 10) if spline is valid. Right?
+	if (scaledVal > (NumSegments-1))
+	{
+		num_out_of_range++;
+		average_total_out_of_range+=scaledVal;
+		average_out_of_range = average_total_out_of_range / ((float) num_out_of_range); 
+		percent_out_of_range = 100.0f*(num_out_of_range)/num_total;
+	}
+	if (scaledVal > (NumSegments-1+1)) num_out_of_range_over_1++;
+	if (scaledVal > (NumSegments-1+2)) num_out_of_range_over_2++;
+	if (scaledVal > (NumSegments-1+3)) num_out_of_range_over_3++;
+	num_total++;
+	if (scaledVal > max_scaledVal)
+	{
+		max_scaledVal = scaledVal;
+		max_scaledVal = scaledVal;
+	}
+	#endif
+
+    float scaledValFloor = floorf ( scaledVal );
+    scaledValFloor = Alg::Max ( 0.0f, Alg::Min ( (float)(NumSegments-1), scaledValFloor ) );
+    float t = scaledVal - scaledValFloor;
+    int k = (int)scaledValFloor;
+
+    float p0, p1;
+    float m0, m1;
+    switch ( k )
+    {
+    case 0:
+        // Curve starts at 1.0 with gradient K[1]-K[0]
+        p0 = 1.0f;
+        m0 =        ( K[1] - K[0] );    // general case would have been (K[1]-K[-1])/2
+        p1 = K[1];
+        m1 = 0.5f * ( K[2] - K[0] );
+        break;
+    default:
+        // General case
+        p0 = K[k  ];
+        m0 = 0.5f * ( K[k+1] - K[k-1] );
+        p1 = K[k+1];
+        m1 = 0.5f * ( K[k+2] - K[k  ] );
+        break;
+    case NumSegments-2:
+        // Last tangent is just the slope of the last two points.
+        p0 = K[NumSegments-2];
+        m0 = 0.5f * ( K[NumSegments-1] - K[NumSegments-2] );
+        p1 = K[NumSegments-1];
+        m1 = K[NumSegments-1] - K[NumSegments-2];
+        break;
+    case NumSegments-1:
+        // Beyond the last segment it's just a straight line
+        p0 = K[NumSegments-1];
+        m0 = K[NumSegments-1] - K[NumSegments-2];
+        p1 = p0 + m0;
+        m1 = m0;
+        break;
+    }
+
+    float omt = 1.0f - t;
+    float res  = ( p0 * ( 1.0f + 2.0f *   t ) + m0 *   t ) * omt * omt
+               + ( p1 * ( 1.0f + 2.0f * omt ) - m1 * omt ) *   t *   t;
+
+    return res;
+}
+
+
+
+
+// Converts a Profile eyecup string into an eyecup enumeration
+void SetEyeCup(HmdRenderInfo* renderInfo, const char* cup)
+{
+    if (OVR_strcmp(cup, "A") == 0)
+        renderInfo->EyeCups = EyeCup_DK1A;
+    else if (OVR_strcmp(cup, "B") == 0)
+        renderInfo->EyeCups = EyeCup_DK1B;
+    else if (OVR_strcmp(cup, "C") == 0)
+        renderInfo->EyeCups = EyeCup_DK1C;
+    else if (OVR_strcmp(cup, "Orange A") == 0)
+        renderInfo->EyeCups =  EyeCup_OrangeA;
+    else if (OVR_strcmp(cup, "Red A") == 0)
+        renderInfo->EyeCups = EyeCup_RedA;
+    else if (OVR_strcmp(cup, "Pink A") == 0)
+        renderInfo->EyeCups = EyeCup_PinkA;
+    else if (OVR_strcmp(cup, "Blue A") == 0)
+        renderInfo->EyeCups = EyeCup_BlueA;
+    else
+        renderInfo->EyeCups = EyeCup_DK1A;
+}
+
+
+
+//-----------------------------------------------------------------------------------
+
+
+// The result is a scaling applied to the distance.
+float LensConfig::DistortionFnScaleRadiusSquared (float rsq) const
+{
+    float scale = 1.0f;
+    switch ( Eqn )
+    {
+    case Distortion_Poly4:
+        // This version is deprecated! Prefer one of the other two.
+        scale = ( K[0] + rsq * ( K[1] + rsq * ( K[2] + rsq * K[3] ) ) );
+        break;
+    case Distortion_RecipPoly4:
+        scale = 1.0f / ( K[0] + rsq * ( K[1] + rsq * ( K[2] + rsq * K[3] ) ) );
+        break;
+    case Distortion_CatmullRom10:{
+        // A Catmull-Rom spline through the values 1.0, K[1], K[2] ... K[10]
+        // evenly spaced in R^2 from 0.0 to MaxR^2
+        // K[0] controls the slope at radius=0.0, rather than the actual value.
+        const int NumSegments = LensConfig::NumCoefficients;
+        OVR_ASSERT ( NumSegments <= NumCoefficients );
+        float scaledRsq = (float)(NumSegments-1) * rsq / ( MaxR * MaxR );
+        scale = EvalCatmullRom10Spline ( K, scaledRsq );
+
+
+		//Intercept, and overrule if needed
+		if (CustomDistortion)
+		{
+			scale = CustomDistortion(rsq);
+		}
+
+        }break;
+    default:
+        OVR_ASSERT ( false );
+        break;
+    }
+    return scale;
+}
+
+// x,y,z components map to r,g,b
+Vector3f LensConfig::DistortionFnScaleRadiusSquaredChroma (float rsq) const
+{
+    float scale = DistortionFnScaleRadiusSquared ( rsq );
+    Vector3f scaleRGB;
+    scaleRGB.x = scale * ( 1.0f + ChromaticAberration[0] + rsq * ChromaticAberration[1] );     // Red
+    scaleRGB.y = scale;                                                                        // Green
+    scaleRGB.z = scale * ( 1.0f + ChromaticAberration[2] + rsq * ChromaticAberration[3] );     // Blue
+    return scaleRGB;
+}
+
+// DistortionFnInverse computes the inverse of the distortion function on an argument.
+float LensConfig::DistortionFnInverse(float r) const
+{    
+    OVR_ASSERT((r <= 20.0f));
+
+    float s, d;
+    float delta = r * 0.25f;
+
+    // Better to start guessing too low & take longer to converge than too high
+    // and hit singularities. Empirically, r * 0.5f is too high in some cases.
+    s = r * 0.25f;
+    d = fabs(r - DistortionFn(s));
+
+    for (int i = 0; i < 20; i++)
+    {
+        float sUp   = s + delta;
+        float sDown = s - delta;
+        float dUp   = fabs(r - DistortionFn(sUp));
+        float dDown = fabs(r - DistortionFn(sDown));
+
+        if (dUp < d)
+        {
+            s = sUp;
+            d = dUp;
+        }
+        else if (dDown < d)
+        {
+            s = sDown;
+            d = dDown;
+        }
+        else
+        {
+            delta *= 0.5f;
+        }
+    }
+
+    return s;
+}
+
+
+
+float LensConfig::DistortionFnInverseApprox(float r) const
+{
+    float rsq = r * r;
+    float scale = 1.0f;
+    switch ( Eqn )
+    {
+    case Distortion_Poly4:
+        // Deprecated
+        OVR_ASSERT ( false );
+        break;
+    case Distortion_RecipPoly4:
+        scale = 1.0f / ( InvK[0] + rsq * ( InvK[1] + rsq * ( InvK[2] + rsq * InvK[3] ) ) );
+        break;
+    case Distortion_CatmullRom10:{
+        // A Catmull-Rom spline through the values 1.0, K[1], K[2] ... K[9]
+        // evenly spaced in R^2 from 0.0 to MaxR^2
+        // K[0] controls the slope at radius=0.0, rather than the actual value.
+        const int NumSegments = LensConfig::NumCoefficients;
+        OVR_ASSERT ( NumSegments <= NumCoefficients );
+        float scaledRsq = (float)(NumSegments-1) * rsq / ( MaxInvR * MaxInvR );
+        scale = EvalCatmullRom10Spline ( InvK, scaledRsq );
+
+		//Intercept, and overrule if needed
+		if (CustomDistortionInv)
+		{
+			scale = CustomDistortionInv(rsq);
+		}
+
+        }break;
+    default:
+        OVR_ASSERT ( false );
+        break;
+    }
+    return r * scale;
+}
+
+void LensConfig::SetUpInverseApprox()
+{
+    float maxR = MaxInvR;
+
+    switch ( Eqn )
+    {
+    case Distortion_Poly4:
+        // Deprecated
+        OVR_ASSERT ( false );
+        break;
+    case Distortion_RecipPoly4:{
+
+        float sampleR[4];
+        float sampleRSq[4];
+        float sampleInv[4];
+        float sampleFit[4];
+
+        // Found heuristically...
+        sampleR[0] = 0.0f;
+        sampleR[1] = maxR * 0.4f;
+        sampleR[2] = maxR * 0.8f;
+        sampleR[3] = maxR * 1.5f;
+        for ( int i = 0; i < 4; i++ )
+        {
+            sampleRSq[i] = sampleR[i] * sampleR[i];
+            sampleInv[i] = DistortionFnInverse ( sampleR[i] );
+            sampleFit[i] = sampleR[i] / sampleInv[i];
+        }
+        sampleFit[0] = 1.0f;
+        FitCubicPolynomial ( InvK, sampleRSq, sampleFit );
+
+    #if 0
+        // Should be a nearly exact match on the chosen points.
+        OVR_ASSERT ( fabs ( DistortionFnInverse ( sampleR[0] ) - DistortionFnInverseApprox ( sampleR[0] ) ) / maxR < 0.0001f );
+        OVR_ASSERT ( fabs ( DistortionFnInverse ( sampleR[1] ) - DistortionFnInverseApprox ( sampleR[1] ) ) / maxR < 0.0001f );
+        OVR_ASSERT ( fabs ( DistortionFnInverse ( sampleR[2] ) - DistortionFnInverseApprox ( sampleR[2] ) ) / maxR < 0.0001f );
+        OVR_ASSERT ( fabs ( DistortionFnInverse ( sampleR[3] ) - DistortionFnInverseApprox ( sampleR[3] ) ) / maxR < 0.0001f );
+        // Should be a decent match on the rest of the range.
+        const int maxCheck = 20;
+        for ( int i = 0; i < maxCheck; i++ )
+        {
+            float checkR = (float)i * maxR / (float)maxCheck;
+            float realInv = DistortionFnInverse       ( checkR );
+            float testInv = DistortionFnInverseApprox ( checkR );
+            float error = fabsf ( realInv - testInv ) / maxR;
+            OVR_ASSERT ( error < 0.1f );
+        }
+    #endif
+
+        }break;
+    case Distortion_CatmullRom10:{
+
+        const int NumSegments = LensConfig::NumCoefficients;
+        OVR_ASSERT ( NumSegments <= NumCoefficients );
+        for ( int i = 1; i < NumSegments; i++ )
+        {
+            float scaledRsq = (float)i;
+            float rsq = scaledRsq * MaxInvR * MaxInvR / (float)( NumSegments - 1);
+            float r = sqrtf ( rsq );
+            float inv = DistortionFnInverse ( r );
+            InvK[i] = inv / r;
+            InvK[0] = 1.0f;     // TODO: fix this.
+        }
+
+#if 0
+        const int maxCheck = 20;
+        for ( int i = 0; i <= maxCheck; i++ )
+        {
+            float checkR = (float)i * MaxInvR / (float)maxCheck;
+            float realInv = DistortionFnInverse       ( checkR );
+            float testInv = DistortionFnInverseApprox ( checkR );
+            float error = fabsf ( realInv - testInv ) / MaxR;
+            OVR_ASSERT ( error < 0.01f );
+        }
+#endif
+
+        }break;
+
+    default:
+        break;
+    }
+}
+
+
+void LensConfig::SetToIdentity()
+{
+    for ( int i = 0; i < NumCoefficients; i++ )
+    {
+        K[i] = 0.0f;
+        InvK[i] = 0.0f;
+    }
+    Eqn = Distortion_RecipPoly4;
+    K[0] = 1.0f;
+    InvK[0] = 1.0f;
+    MaxR = 1.0f;
+    MaxInvR = 1.0f;
+    ChromaticAberration[0] = 0.0f;
+    ChromaticAberration[1] = 0.0f;
+    ChromaticAberration[2] = 0.0f;
+    ChromaticAberration[3] = 0.0f;
+    MetersPerTanAngleAtCenter = 0.05f;
+}
+
+
+enum LensConfigStoredVersion
+{
+    LCSV_CatmullRom10Version1 = 1
+};
+
+// DO NOT CHANGE THESE ONCE THEY HAVE BEEN BAKED INTO FIRMWARE.
+// If something needs to change, add a new one!
+struct LensConfigStored_CatmullRom10Version1
+{
+    // All these items must be fixed-length integers - no "float", no "int", etc.
+    uint16_t    VersionNumber;      // Must be LCSV_CatmullRom10Version1
+
+    uint16_t    K[11];
+    uint16_t    MaxR;
+    uint16_t    MetersPerTanAngleAtCenter;
+    uint16_t    ChromaticAberration[4];
+    // InvK and MaxInvR are calculated on load.
+};
+
+uint16_t EncodeFixedPointUInt16 ( float val, uint16_t zeroVal, int fractionalBits )
+{
+    OVR_ASSERT ( ( fractionalBits >= 0 ) && ( fractionalBits < 31 ) );
+    float valWhole = val * (float)( 1 << fractionalBits );
+    valWhole += (float)zeroVal + 0.5f;
+    valWhole = floorf ( valWhole );
+    OVR_ASSERT ( ( valWhole >= 0.0f ) && ( valWhole < (float)( 1 << 16 ) ) );
+    return (uint16_t)valWhole;
+}
+
+float DecodeFixedPointUInt16 ( uint16_t val, uint16_t zeroVal, int fractionalBits )
+{
+    OVR_ASSERT ( ( fractionalBits >= 0 ) && ( fractionalBits < 31 ) );
+    float valFloat = (float)val;
+    valFloat -= (float)zeroVal;
+    valFloat *= 1.0f / (float)( 1 << fractionalBits );
+    return valFloat;
+}
+
+
+// Returns true on success.
+bool LoadLensConfig ( LensConfig *presult, uint8_t const *pbuffer, int bufferSizeInBytes )
+{
+    if ( bufferSizeInBytes < 2 )
+    {
+        // Can't even tell the version number!
+        return false;
+    }
+    uint16_t version = DecodeUInt16 ( pbuffer + 0 );
+    switch ( version )
+    {
+    case LCSV_CatmullRom10Version1:
+        {
+            if ( bufferSizeInBytes < (int)sizeof(LensConfigStored_CatmullRom10Version1) )
+            {
+                return false;
+            }
+            LensConfigStored_CatmullRom10Version1 lcs;
+            lcs.VersionNumber               = DecodeUInt16 ( pbuffer + 0 );
+            for ( int i = 0; i < 11; i++ )
+            {
+                lcs.K[i]                    = DecodeUInt16 ( pbuffer + 2 + 2*i );
+            }
+            lcs.MaxR                        = DecodeUInt16 ( pbuffer + 24 );
+            lcs.MetersPerTanAngleAtCenter   = DecodeUInt16 ( pbuffer + 26 );
+            for ( int i = 0; i < 4; i++ )
+            {
+                lcs.ChromaticAberration[i]  = DecodeUInt16 ( pbuffer + 28 + 2*i );
+            }
+            OVR_COMPILER_ASSERT ( sizeof(lcs) ==                       36 );
+
+            // Convert to the real thing.
+            LensConfig result;
+            result.Eqn = Distortion_CatmullRom10;
+            for ( int i = 0; i < 11; i++ )
+            {
+                // K[] are mostly 1.something. They may get significantly bigger, but they never hit 0.0.
+                result.K[i] = DecodeFixedPointUInt16 ( lcs.K[i], 0, 14 );
+            }
+            // MaxR is tan(angle), so always >0, typically just over 1.0 (45 degrees half-fov),
+            // but may get arbitrarily high. tan(76)=4 is a very reasonable limit!
+            result.MaxR = DecodeFixedPointUInt16 ( lcs.MaxR, 0, 14 );
+            // MetersPerTanAngleAtCenter is also known as focal length!
+            // Typically around 0.04 for our current screens, minimum of 0, sensible maximum of 0.125 (i.e. 3 "extra" bits of fraction)
+            result.MetersPerTanAngleAtCenter = DecodeFixedPointUInt16 ( lcs.MetersPerTanAngleAtCenter, 0, 16+3 );
+            for ( int i = 0; i < 4; i++ )
+            {
+                // ChromaticAberration[] are mostly 0.0something, centered on 0.0. Largest seen is 0.04, so set max to 0.125 (i.e. 3 "extra" bits of fraction)
+                result.ChromaticAberration[i] = DecodeFixedPointUInt16 ( lcs.ChromaticAberration[i], 0x8000, 16+3 );
+            }
+            result.MaxInvR = result.DistortionFn ( result.MaxR );
+            result.SetUpInverseApprox();
+
+            OVR_ASSERT ( version == lcs.VersionNumber );
+
+            *presult = result;
+        }
+        break;
+    default:
+        // Unknown format.
+        return false;
+        break;
+    }
+    return true;
+}
+
+// Returns number of bytes needed.
+int SaveLensConfigSizeInBytes ( LensConfig const &config )
+{
+    OVR_UNUSED ( config );
+    return sizeof ( LensConfigStored_CatmullRom10Version1 );
+}
+
+// Returns true on success.
+bool SaveLensConfig ( uint8_t *pbuffer, int bufferSizeInBytes, LensConfig const &config )
+{
+    if ( bufferSizeInBytes < (int)sizeof ( LensConfigStored_CatmullRom10Version1 ) )
+    {
+        return false;
+    }
+
+    // Construct the values.
+    LensConfigStored_CatmullRom10Version1 lcs;
+    lcs.VersionNumber = LCSV_CatmullRom10Version1;
+    for ( int i = 0; i < 11; i++ )
+    {
+        // K[] are mostly 1.something. They may get significantly bigger, but they never hit 0.0.
+        lcs.K[i] = EncodeFixedPointUInt16 ( config.K[i], 0, 14 );
+    }
+    // MaxR is tan(angle), so always >0, typically just over 1.0 (45 degrees half-fov),
+    // but may get arbitrarily high. tan(76)=4 is a very reasonable limit!
+    lcs.MaxR = EncodeFixedPointUInt16 ( config.MaxR, 0, 14 );
+    // MetersPerTanAngleAtCenter is also known as focal length!
+    // Typically around 0.04 for our current screens, minimum of 0, sensible maximum of 0.125 (i.e. 3 "extra" bits of fraction)
+    lcs.MetersPerTanAngleAtCenter = EncodeFixedPointUInt16 ( config.MetersPerTanAngleAtCenter, 0, 16+3 );
+    for ( int i = 0; i < 4; i++ )
+    {
+        // ChromaticAberration[] are mostly 0.0something, centered on 0.0. Largest seen is 0.04, so set max to 0.125 (i.e. 3 "extra" bits of fraction)
+        lcs.ChromaticAberration[i] = EncodeFixedPointUInt16 ( config.ChromaticAberration[i], 0x8000, 16+3 );
+    }
+
+
+    // Now store them out, sensitive to endianness.
+    EncodeUInt16 (      pbuffer + 0,        lcs.VersionNumber );
+    for ( int i = 0; i < 11; i++ )
+    {
+        EncodeUInt16 (  pbuffer + 2 + 2*i,  lcs.K[i] );
+    }
+    EncodeUInt16 (      pbuffer + 24,       lcs.MaxR );
+    EncodeUInt16 (      pbuffer + 26,       lcs.MetersPerTanAngleAtCenter );
+    for ( int i = 0; i < 4; i++ )
+    {
+        EncodeUInt16 (  pbuffer + 28 + 2*i, lcs.ChromaticAberration[i] );
+    }
+    OVR_COMPILER_ASSERT (         36        == sizeof(lcs) );
+
+    return true;
+}
+
+#ifdef OVR_BUILD_DEBUG
+void TestSaveLoadLensConfig ( LensConfig const &config )
+{
+    OVR_ASSERT ( config.Eqn == Distortion_CatmullRom10 );
+    // As a test, make sure this can be encoded and decoded correctly.
+    const int bufferSize = 256;
+    uint8_t buffer[bufferSize];
+    OVR_ASSERT ( SaveLensConfigSizeInBytes ( config ) < bufferSize );
+    bool success;
+    success = SaveLensConfig ( buffer, bufferSize, config );
+    OVR_ASSERT ( success );
+    LensConfig testConfig;
+    success = LoadLensConfig ( &testConfig, buffer, bufferSize );
+    OVR_ASSERT ( success );
+    OVR_ASSERT ( testConfig.Eqn == config.Eqn );
+    for ( int i = 0; i < 11; i++ )
+    {
+        OVR_ASSERT ( fabs ( testConfig.K[i] - config.K[i] ) < 0.0001f );
+    }
+    OVR_ASSERT ( fabsf ( testConfig.MaxR - config.MaxR ) < 0.0001f );
+    OVR_ASSERT ( fabsf ( testConfig.MetersPerTanAngleAtCenter - config.MetersPerTanAngleAtCenter ) < 0.00001f );
+    for ( int i = 0; i < 4; i++ )
+    {
+        OVR_ASSERT ( fabsf ( testConfig.ChromaticAberration[i] - config.ChromaticAberration[i] ) < 0.00001f );
+    }
+}
+#endif
+
+
+
+//-----------------------------------------------------------------------------------
+
+// TBD: There is a question of whether this is the best file for CreateDebugHMDInfo. As long as there are many
+// constants for HmdRenderInfo here as well it is ok. The alternative would be OVR_Common_HMDDevice.cpp, but
+// that's specialized per platform... should probably move it there onces the code is in the common base class.
+
+HMDInfo CreateDebugHMDInfo(HmdTypeEnum hmdType)
+{
+    HMDInfo info;    
+
+    if ((hmdType != HmdType_DK1) &&
+        (hmdType != HmdType_CrystalCoveProto) &&
+        (hmdType != HmdType_DK2))
+    {
+        LogText("Debug HMDInfo - HmdType not supported. Defaulting to DK1.\n");
+        hmdType = HmdType_DK1;
+    }
+
+    // The alternative would be to initialize info.HmdType to HmdType_None instead. If we did that,
+    // code wouldn't be "maximally compatible" and devs wouldn't know what device we are
+    // simulating... so if differentiation becomes necessary we better add Debug flag in the future.
+    info.HmdType      = hmdType;
+    info.Manufacturer = "Oculus VR";    
+
+    switch(hmdType)
+    {
+    case HmdType_DK1:
+        info.ProductName                            = "Oculus Rift DK1";
+        info.ResolutionInPixels                     = Sizei ( 1280, 800 );
+        info.ScreenSizeInMeters                     = Sizef ( 0.1498f, 0.0936f );
+        info.ScreenGapSizeInMeters                  = 0.0f;
+        info.CenterFromTopInMeters                  = 0.0468f;
+        info.LensSeparationInMeters                 = 0.0635f;
+        info.Shutter.Type                           = HmdShutter_RollingTopToBottom;
+        info.Shutter.VsyncToNextVsync               = ( 1.0f / 60.0f );
+        info.Shutter.VsyncToFirstScanline           = 0.000052f;
+        info.Shutter.FirstScanlineToLastScanline    = 0.016580f;
+        info.Shutter.PixelSettleTime                = 0.015f;
+        info.Shutter.PixelPersistence               = ( 1.0f / 60.0f );
+        break;
+
+    case HmdType_CrystalCoveProto:
+        info.ProductName                            = "Oculus Rift Crystal Cove";        
+        info.ResolutionInPixels                     = Sizei ( 1920, 1080 );
+        info.ScreenSizeInMeters                     = Sizef ( 0.12576f, 0.07074f );
+        info.ScreenGapSizeInMeters                  = 0.0f;
+        info.CenterFromTopInMeters                  = info.ScreenSizeInMeters.h * 0.5f;
+        info.LensSeparationInMeters                 = 0.0635f;
+        info.Shutter.Type                           = HmdShutter_RollingRightToLeft;
+        info.Shutter.VsyncToNextVsync               = ( 1.0f / 76.0f );
+        info.Shutter.VsyncToFirstScanline           = 0.0000273f;
+        info.Shutter.FirstScanlineToLastScanline    = 0.0131033f;
+        info.Shutter.PixelSettleTime                = 0.0f;
+        info.Shutter.PixelPersistence               = 0.18f * info.Shutter.VsyncToNextVsync;
+        break;
+
+    case HmdType_DK2:
+        info.ProductName                            = "Oculus Rift DK2";        
+        info.ResolutionInPixels                     = Sizei ( 1920, 1080 );
+        info.ScreenSizeInMeters                     = Sizef ( 0.12576f, 0.07074f );
+        info.ScreenGapSizeInMeters                  = 0.0f;
+        info.CenterFromTopInMeters                  = info.ScreenSizeInMeters.h * 0.5f;
+        info.LensSeparationInMeters                 = 0.0635f;
+        info.Shutter.Type                           = HmdShutter_RollingRightToLeft;
+        info.Shutter.VsyncToNextVsync               = ( 1.0f / 76.0f );
+        info.Shutter.VsyncToFirstScanline           = 0.0000273f;
+        info.Shutter.FirstScanlineToLastScanline    = 0.0131033f;
+        info.Shutter.PixelSettleTime                = 0.0f;
+        info.Shutter.PixelPersistence               = 0.18f * info.Shutter.VsyncToNextVsync;
+        break;
+
+    default:
+        break;
+    }
+
+    return info;
+}
+
+// profile may be NULL, in which case it uses the hard-coded defaults.
+HmdRenderInfo GenerateHmdRenderInfoFromHmdInfo ( HMDInfo const &hmdInfo,
+                                                 Profile const *profile /*=NULL*/,
+                                                 DistortionEqnType distortionType /*= Distortion_CatmullRom10*/,
+                                                 EyeCupType eyeCupOverride /*= EyeCup_LAST*/ )
+{
+    OVR_ASSERT(profile);  // profiles are required
+    
+    HmdRenderInfo renderInfo;
+
+    renderInfo.HmdType                              = hmdInfo.HmdType;
+    renderInfo.ResolutionInPixels                   = hmdInfo.ResolutionInPixels;
+    renderInfo.ScreenSizeInMeters                   = hmdInfo.ScreenSizeInMeters;
+    renderInfo.CenterFromTopInMeters                = hmdInfo.CenterFromTopInMeters;
+    renderInfo.ScreenGapSizeInMeters                = hmdInfo.ScreenGapSizeInMeters;
+    renderInfo.LensSeparationInMeters               = hmdInfo.LensSeparationInMeters;
+
+    OVR_ASSERT ( sizeof(renderInfo.Shutter) == sizeof(hmdInfo.Shutter) );   // Try to keep the files in sync!
+    renderInfo.Shutter.Type                         = hmdInfo.Shutter.Type;
+    renderInfo.Shutter.VsyncToNextVsync             = hmdInfo.Shutter.VsyncToNextVsync;
+    renderInfo.Shutter.VsyncToFirstScanline         = hmdInfo.Shutter.VsyncToFirstScanline;
+    renderInfo.Shutter.FirstScanlineToLastScanline  = hmdInfo.Shutter.FirstScanlineToLastScanline;
+    renderInfo.Shutter.PixelSettleTime              = hmdInfo.Shutter.PixelSettleTime;
+    renderInfo.Shutter.PixelPersistence             = hmdInfo.Shutter.PixelPersistence;
+
+    renderInfo.LensDiameterInMeters                 = 0.035f;
+    renderInfo.LensSurfaceToMidplateInMeters        = 0.025f;
+    renderInfo.EyeCups                              = EyeCup_DK1A;
+
+#if 0       // Device settings are out of date - don't use them.
+    if (Contents & Contents_Distortion)
+    {
+        memcpy(renderInfo.DistortionK, DistortionK, sizeof(float)*4);
+        renderInfo.DistortionEqn = Distortion_RecipPoly4;
+    }
+#endif
+
+    // Defaults in case of no user profile.
+    renderInfo.EyeLeft.NoseToPupilInMeters   = 0.032f;
+    renderInfo.EyeLeft.ReliefInMeters        = 0.012f;
+
+    // 10mm eye-relief laser numbers for DK1 lenses.
+    // These are a decent seed for finding eye-relief and IPD.
+    // These are NOT used for rendering!
+    // Rendering distortions are now in GenerateLensConfigFromEyeRelief()
+    // So, if you're hacking in new distortions, don't do it here!
+    renderInfo.EyeLeft.Distortion.SetToIdentity();
+    renderInfo.EyeLeft.Distortion.MetersPerTanAngleAtCenter = 0.0449f;
+    renderInfo.EyeLeft.Distortion.Eqn       = Distortion_RecipPoly4;
+    renderInfo.EyeLeft.Distortion.K[0]      =  1.0f;
+    renderInfo.EyeLeft.Distortion.K[1]      = -0.494165344f;
+    renderInfo.EyeLeft.Distortion.K[2]      = 0.587046423f;
+    renderInfo.EyeLeft.Distortion.K[3]      = -0.841887126f;
+    renderInfo.EyeLeft.Distortion.MaxR      = 1.0f;
+
+    renderInfo.EyeLeft.Distortion.ChromaticAberration[0] = -0.006f;
+    renderInfo.EyeLeft.Distortion.ChromaticAberration[1] =  0.0f;
+    renderInfo.EyeLeft.Distortion.ChromaticAberration[2] =  0.014f;
+    renderInfo.EyeLeft.Distortion.ChromaticAberration[3] =  0.0f;
+
+    renderInfo.EyeRight = renderInfo.EyeLeft;
+
+    // Obtain data from profile.
+    char eyecup[16];
+    if (profile->GetValue(OVR_KEY_EYE_CUP, eyecup, 16))
+    {
+        SetEyeCup(&renderInfo, eyecup);
+    }
+    
+    switch ( hmdInfo.HmdType )
+    {
+    case HmdType_None:
+    case HmdType_DKProto:
+    case HmdType_DK1:
+        // Slight hack to improve usability.
+        // If you have a DKHD-style lens profile enabled,
+        // but you plug in DK1 and forget to change the profile,
+        // obviously you don't want those lens numbers.
+        if ( ( renderInfo.EyeCups != EyeCup_DK1A ) &&
+             ( renderInfo.EyeCups != EyeCup_DK1B ) &&
+             ( renderInfo.EyeCups != EyeCup_DK1C ) )
+        {
+            renderInfo.EyeCups = EyeCup_DK1A;
+        }
+        break;
+
+    case HmdType_DKHD2Proto:
+        renderInfo.EyeCups = EyeCup_DKHD2A;
+        break;
+    case HmdType_CrystalCoveProto:
+        renderInfo.EyeCups = EyeCup_PinkA;
+        break;
+    case HmdType_DK2:
+        renderInfo.EyeCups = EyeCup_DK2A;
+        break;
+    default:
+        break;
+    }
+
+    if ( eyeCupOverride != EyeCup_LAST )
+    {
+        renderInfo.EyeCups = eyeCupOverride;
+    }
+
+    switch ( renderInfo.EyeCups )
+    {
+    case EyeCup_DK1A:
+    case EyeCup_DK1B:
+    case EyeCup_DK1C:
+        renderInfo.LensDiameterInMeters                   = 0.035f;
+        renderInfo.LensSurfaceToMidplateInMeters          = 0.02357f;
+        // Not strictly lens-specific, but still wise to set a reasonable default for relief.
+        renderInfo.EyeLeft.ReliefInMeters                 = 0.010f; 
+        renderInfo.EyeRight.ReliefInMeters                = 0.010f; 
+        break;
+    case EyeCup_DKHD2A:
+        renderInfo.LensDiameterInMeters                   = 0.035f;
+        renderInfo.LensSurfaceToMidplateInMeters          = 0.02357f;
+        // Not strictly lens-specific, but still wise to set a reasonable default for relief.
+        renderInfo.EyeLeft.ReliefInMeters                 = 0.010f; 
+        renderInfo.EyeRight.ReliefInMeters                = 0.010f; 
+        break;
+    case EyeCup_PinkA:
+    case EyeCup_DK2A:
+        renderInfo.LensDiameterInMeters                   = 0.04f;      // approximate
+        renderInfo.LensSurfaceToMidplateInMeters          = 0.01965f;
+        // Not strictly lens-specific, but still wise to set a reasonable default for relief.
+        renderInfo.EyeLeft.ReliefInMeters                 = 0.012f;
+        renderInfo.EyeRight.ReliefInMeters                = 0.012f;
+        break;
+    default: OVR_ASSERT ( false ); break;
+    }
+
+    Profile* def = ProfileManager::GetInstance()->GetDefaultProfile(hmdInfo.HmdType);
+
+    // Set the eye position
+    // Use the user profile value unless they have elected to use the defaults
+    if (!profile->GetBoolValue(OVR_KEY_CUSTOM_EYE_RENDER, true))
+        profile = def;  // use the default
+
+    char user[32];
+    profile->GetValue(OVR_KEY_USER, user, 32);   // for debugging purposes
+
+    // TBD: Maybe we should separate custom camera positioning from custom distortion rendering ??
+    float eye2nose[2] = { OVR_DEFAULT_IPD / 2, OVR_DEFAULT_IPD / 2 };
+    if (profile->GetFloatValues(OVR_KEY_EYE_TO_NOSE_DISTANCE, eye2nose, 2) == 2)
+    {   
+        renderInfo.EyeLeft.NoseToPupilInMeters = eye2nose[0];
+        renderInfo.EyeRight.NoseToPupilInMeters = eye2nose[1];
+    }
+    else
+    {   // Legacy profiles may not include half-ipd, so use the regular IPD value instead
+        float ipd = profile->GetFloatValue(OVR_KEY_IPD, OVR_DEFAULT_IPD);
+        renderInfo.EyeLeft.NoseToPupilInMeters = 0.5f * ipd;
+        renderInfo.EyeRight.NoseToPupilInMeters = 0.5f * ipd;
+    }
+        
+    float eye2plate[2];
+    if ((profile->GetFloatValues(OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE, eye2plate, 2) == 2) ||
+        (def->GetFloatValues(OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE, eye2plate, 2) == 2))
+    {   // Subtract the eye-cup height from the plate distance to get the eye-to-lens distance
+        // This measurement should be the the distance at maximum dial setting
+        // We still need to adjust with the dial offset
+        renderInfo.EyeLeft.ReliefInMeters = eye2plate[0] - renderInfo.LensSurfaceToMidplateInMeters;
+        renderInfo.EyeRight.ReliefInMeters = eye2plate[1] - renderInfo.LensSurfaceToMidplateInMeters;
+
+        // Adjust the eye relief with the dial setting (from the assumed max eye relief)
+        int dial = profile->GetIntValue(OVR_KEY_EYE_RELIEF_DIAL, OVR_DEFAULT_EYE_RELIEF_DIAL);
+        renderInfo.EyeLeft.ReliefInMeters -= ((10 - dial) * 0.001f);
+        renderInfo.EyeRight.ReliefInMeters -= ((10 - dial) * 0.001f);
+    }
+    else
+    {
+        // We shouldn't be here.  The user or default profile should have the eye relief
+        OVR_ASSERT(false);
+
+        // Set the eye relief with the user configured dial setting
+		//int dial = profile->GetIntValue(OVR_KEY_EYE_RELIEF_DIAL, OVR_DEFAULT_EYE_RELIEF_DIAL);
+
+        // Assume a default of 7 to 17 mm eye relief based on the dial.  This corresponds
+        // to the sampled and tuned distortion range on the DK1.
+        //renderInfo.EyeLeft.ReliefInMeters = 0.007f + (dial * 0.001f);
+        //renderInfo.EyeRight.ReliefInMeters = 0.007f + (dial * 0.001f);
+    }
+
+    def->Release();
+
+
+    // Now we know where the eyes are relative to the lenses, we can compute a distortion for each.
+    // TODO: incorporate lateral offset in distortion generation.
+    // TODO: we used a distortion to calculate eye-relief, and now we're making a distortion from that eye-relief. Close the loop!
+
+    for ( int eyeNum = 0; eyeNum < 2; eyeNum++ )
+    {
+        HmdRenderInfo::EyeConfig *pHmdEyeConfig = ( eyeNum == 0 ) ? &(renderInfo.EyeLeft) : &(renderInfo.EyeRight);
+
+        float eye_relief = pHmdEyeConfig->ReliefInMeters;
+        LensConfig distortionConfig = GenerateLensConfigFromEyeRelief ( eye_relief, renderInfo, distortionType );
+        pHmdEyeConfig->Distortion = distortionConfig;
+    }
+
+    return renderInfo;
+}
+
+
+LensConfig GenerateLensConfigFromEyeRelief ( float eyeReliefInMeters, HmdRenderInfo const &hmd, DistortionEqnType distortionType /*= Distortion_CatmullRom10*/ )
+{
+    struct DistortionDescriptor
+    {
+        float EyeRelief;
+        // The three places we're going to sample & lerp the curve at.
+        // One sample is always at 0.0, and the distortion scale should be 1.0 or else!
+        // Only use for poly4 numbers - CR has an implicit scale.
+        float SampleRadius[3];
+        // Where the distortion has actually been measured/calibrated out to.
+        // Don't try to hallucinate data out beyond here.
+        float MaxRadius;
+        // The config itself.
+        LensConfig Config;
+    };
+
+	static const int MaxDistortions = 10;
+	DistortionDescriptor distortions[MaxDistortions];
+	for (int i = 0; i < MaxDistortions; i++)
+    {
+        distortions[i].Config.SetToIdentity(); // Note: This line causes a false static analysis error -cat
+        distortions[i].EyeRelief = 0.0f;
+        distortions[i].MaxRadius = 1.0f;
+    }
+    int numDistortions = 0;
+    int defaultDistortion = 0;     // index of the default distortion curve to use if zero eye relief supplied
+
+    if ( ( hmd.EyeCups == EyeCup_DK1A ) ||
+         ( hmd.EyeCups == EyeCup_DK1B ) ||
+         ( hmd.EyeCups == EyeCup_DK1C ) )
+    {
+
+        numDistortions = 0;
+                
+        // Tuned at minimum dial setting - extended to r^2 == 1.8
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].EyeRelief                            = 0.012760465f - 0.005f;
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.0425f;
+        distortions[numDistortions].Config.K[0]                          = 1.0000f;
+        distortions[numDistortions].Config.K[1]                          = 1.06505f;
+        distortions[numDistortions].Config.K[2]                          = 1.14725f;
+        distortions[numDistortions].Config.K[3]                          = 1.2705f;
+        distortions[numDistortions].Config.K[4]                          = 1.48f;
+        distortions[numDistortions].Config.K[5]                          = 1.87f;
+        distortions[numDistortions].Config.K[6]                          = 2.534f;
+        distortions[numDistortions].Config.K[7]                          = 3.6f;
+        distortions[numDistortions].Config.K[8]                          = 5.1f;
+        distortions[numDistortions].Config.K[9]                          = 7.4f;
+        distortions[numDistortions].Config.K[10]                         = 11.0f;
+        distortions[numDistortions].MaxRadius                            = sqrt(1.8f);
+        defaultDistortion = numDistortions;                      // this is the default
+        numDistortions++;
+        
+        // Tuned at middle dial setting
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].EyeRelief                            = 0.012760465f;  // my average eye-relief
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.0425f;
+        distortions[numDistortions].Config.K[0]                          = 1.0f;
+        distortions[numDistortions].Config.K[1]                          = 1.032407264f;
+        distortions[numDistortions].Config.K[2]                          = 1.07160462f;
+        distortions[numDistortions].Config.K[3]                          = 1.11998388f;
+        distortions[numDistortions].Config.K[4]                          = 1.1808606f;
+        distortions[numDistortions].Config.K[5]                          = 1.2590494f;
+        distortions[numDistortions].Config.K[6]                          = 1.361915f;
+        distortions[numDistortions].Config.K[7]                          = 1.5014339f;
+        distortions[numDistortions].Config.K[8]                          = 1.6986004f;
+        distortions[numDistortions].Config.K[9]                          = 1.9940577f;
+        distortions[numDistortions].Config.K[10]                         = 2.4783147f;
+        distortions[numDistortions].MaxRadius                            = 1.0f;
+        numDistortions++;
+
+        // Tuned at maximum dial setting
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].EyeRelief                            = 0.012760465f + 0.005f;
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.0425f;
+        distortions[numDistortions].Config.K[0]                          = 1.0102f;
+        distortions[numDistortions].Config.K[1]                          = 1.0371f;
+        distortions[numDistortions].Config.K[2]                          = 1.0831f;
+        distortions[numDistortions].Config.K[3]                          = 1.1353f;
+        distortions[numDistortions].Config.K[4]                          = 1.2f;
+        distortions[numDistortions].Config.K[5]                          = 1.2851f;
+        distortions[numDistortions].Config.K[6]                          = 1.3979f;
+        distortions[numDistortions].Config.K[7]                          = 1.56f;
+        distortions[numDistortions].Config.K[8]                          = 1.8f;
+        distortions[numDistortions].Config.K[9]                          = 2.25f;
+        distortions[numDistortions].Config.K[10]                         = 3.0f;
+        distortions[numDistortions].MaxRadius                            = 1.0f;
+        numDistortions++;
+        
+
+        
+        // Chromatic aberration doesn't seem to change with eye relief.
+        for ( int i = 0; i < numDistortions; i++ )
+        {
+            distortions[i].Config.ChromaticAberration[0]        = -0.006f;
+            distortions[i].Config.ChromaticAberration[1]        =  0.0f;
+            distortions[i].Config.ChromaticAberration[2]        =  0.014f;
+            distortions[i].Config.ChromaticAberration[3]        =  0.0f;
+        }
+    }
+    else if ( hmd.EyeCups == EyeCup_DKHD2A )
+    {
+        // Tuned DKHD2 lens
+        numDistortions = 0;
+       
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].EyeRelief                            = 0.010f;
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.0425f;
+        distortions[numDistortions].Config.K[0]                          = 1.0f;
+        distortions[numDistortions].Config.K[1]                          = 1.0425f;
+        distortions[numDistortions].Config.K[2]                          = 1.0826f;
+        distortions[numDistortions].Config.K[3]                          = 1.130f;
+        distortions[numDistortions].Config.K[4]                          = 1.185f;
+        distortions[numDistortions].Config.K[5]                          = 1.250f;
+        distortions[numDistortions].Config.K[6]                          = 1.338f;
+        distortions[numDistortions].Config.K[7]                          = 1.455f;
+        distortions[numDistortions].Config.K[8]                          = 1.620f;
+        distortions[numDistortions].Config.K[9]                          = 1.840f;
+        distortions[numDistortions].Config.K[10]                         = 2.200f;
+        distortions[numDistortions].MaxRadius                            = 1.0f;
+        
+        defaultDistortion = numDistortions;   // this is the default
+        numDistortions++;
+
+        distortions[numDistortions] = distortions[0];
+        distortions[numDistortions].EyeRelief = 0.020f;
+        numDistortions++;
+
+        // Chromatic aberration doesn't seem to change with eye relief.
+        for ( int i = 0; i < numDistortions; i++ )
+        {
+            distortions[i].Config.ChromaticAberration[0]        = -0.006f;
+            distortions[i].Config.ChromaticAberration[1]        =  0.0f;
+            distortions[i].Config.ChromaticAberration[2]        =  0.014f;
+            distortions[i].Config.ChromaticAberration[3]        =  0.0f;
+        }
+    }
+    else if ( hmd.EyeCups == EyeCup_PinkA || hmd.EyeCups == EyeCup_DK2A )
+    {
+        // Tuned Crystal Cove & DK2 Lens (CES & GDC)
+        numDistortions = 0;
+       
+        
+        distortions[numDistortions].EyeRelief                            = 0.010f;
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.036f;
+
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].Config.K[0]                          = 1.003f;
+        distortions[numDistortions].Config.K[1]                          = 1.02f;
+        distortions[numDistortions].Config.K[2]                          = 1.042f;
+        distortions[numDistortions].Config.K[3]                          = 1.066f;
+        distortions[numDistortions].Config.K[4]                          = 1.094f;  //1.0945f;
+        distortions[numDistortions].Config.K[5]                          = 1.126f;  //1.127f;
+        distortions[numDistortions].Config.K[6]                          = 1.162f;  //1.167f;
+        distortions[numDistortions].Config.K[7]                          = 1.203f;  //1.218f;
+        distortions[numDistortions].Config.K[8]                          = 1.25f;   //1.283f;
+        distortions[numDistortions].Config.K[9]                          = 1.31f;   //1.37f;
+        distortions[numDistortions].Config.K[10]                         = 1.38f;   //1.48f;
+        distortions[numDistortions].MaxRadius                            = 1.0f;
+        
+        /*
+        // Orange Lens on DK2
+        distortions[numDistortions].EyeRelief                            = 0.010f;
+        distortions[numDistortions].Config.MetersPerTanAngleAtCenter     = 0.031f;
+
+        distortions[numDistortions].Config.Eqn = Distortion_CatmullRom10;
+        distortions[numDistortions].Config.K[0]                          = 1.00f;
+        distortions[numDistortions].Config.K[1]                          = 1.0169f;
+        distortions[numDistortions].Config.K[2]                          = 1.0378f;
+        distortions[numDistortions].Config.K[3]                          = 1.0648f;
+        distortions[numDistortions].Config.K[4]                          = 1.0990f;
+        distortions[numDistortions].Config.K[5]                          = 1.141f;
+        distortions[numDistortions].Config.K[6]                          = 1.192f;
+        distortions[numDistortions].Config.K[7]                          = 1.255f;
+        distortions[numDistortions].Config.K[8]                          = 1.335f;
+        distortions[numDistortions].Config.K[9]                          = 1.435f;
+        distortions[numDistortions].Config.K[10]                         = 1.56f;
+        distortions[numDistortions].MaxRadius                            = 1.0f;
+        */
+        
+        defaultDistortion = numDistortions;   // this is the default
+        numDistortions++;
+
+        distortions[numDistortions] = distortions[0];
+        distortions[numDistortions].EyeRelief = 0.020f;
+        numDistortions++;
+
+        // Chromatic aberration doesn't seem to change with eye relief.
+        for ( int i = 0; i < numDistortions; i++ )
+        {
+            distortions[i].Config.ChromaticAberration[0]        = -0.015f;
+            distortions[i].Config.ChromaticAberration[1]        = -0.02f;
+            distortions[i].Config.ChromaticAberration[2]        =  0.025f;
+            distortions[i].Config.ChromaticAberration[3]        =  0.02f;
+        }
+    }
+    else
+    {
+        // Unknown lens.
+        // Use DK1 black lens settings, just so we can continue to run with something.
+        distortions[0].EyeRelief = 0.005f;
+        distortions[0].Config.MetersPerTanAngleAtCenter = 0.043875f;
+        distortions[0].Config.Eqn = Distortion_RecipPoly4;
+        distortions[0].Config.K[0] = 1.0f;
+        distortions[0].Config.K[1] = -0.3999f;
+        distortions[0].Config.K[2] =  0.2408f;
+        distortions[0].Config.K[3] = -0.4589f;
+        distortions[0].SampleRadius[0] = 0.2f;
+        distortions[0].SampleRadius[1] = 0.4f;
+        distortions[0].SampleRadius[2] = 0.6f;
+
+        distortions[1] = distortions[0];
+        distortions[1].EyeRelief = 0.010f;
+        numDistortions = 2;
+
+        // Chromatic aberration doesn't seem to change with eye relief.
+        for ( int i = 0; i < numDistortions; i++ )
+        {
+            // These are placeholder, they have not been tuned!
+            distortions[i].Config.ChromaticAberration[0]        =  0.0f;
+            distortions[i].Config.ChromaticAberration[1]        =  0.0f;
+            distortions[i].Config.ChromaticAberration[2]        =  0.0f;
+            distortions[i].Config.ChromaticAberration[3]        =  0.0f;
+        }
+    }
+
+	OVR_ASSERT(numDistortions < MaxDistortions);
+
+    DistortionDescriptor *pUpper = NULL;
+    DistortionDescriptor *pLower = NULL;
+    float lerpVal = 0.0f;
+    if (eyeReliefInMeters == 0)
+    {   // Use a constant default distortion if an invalid eye-relief is supplied
+        pLower = &(distortions[defaultDistortion]);
+        pUpper = &(distortions[defaultDistortion]);
+        lerpVal = 0.0f;
+    }
+    else
+    {
+        for ( int i = 0; i < numDistortions-1; i++ )
+        {
+            OVR_ASSERT ( distortions[i].EyeRelief < distortions[i+1].EyeRelief );
+            if ( ( distortions[i].EyeRelief <= eyeReliefInMeters ) && ( distortions[i+1].EyeRelief > eyeReliefInMeters ) )
+            {
+                pLower = &(distortions[i]);
+                pUpper = &(distortions[i+1]);
+                lerpVal = ( eyeReliefInMeters - pLower->EyeRelief ) / ( pUpper->EyeRelief - pLower->EyeRelief );
+                // No break here - I want the ASSERT to check everything every time!
+            }
+        }
+    }
+
+    if ( pUpper == NULL )
+    {
+#if 0
+        // Outside the range, so extrapolate rather than interpolate.
+        if ( distortions[0].EyeRelief > eyeReliefInMeters )
+        { 
+            pLower = &(distortions[0]);
+            pUpper = &(distortions[1]);
+        }
+        else
+        {
+            OVR_ASSERT ( distortions[numDistortions-1].EyeRelief <= eyeReliefInMeters );
+            pLower = &(distortions[numDistortions-2]);
+            pUpper = &(distortions[numDistortions-1]);
+        }
+        lerpVal = ( eyeReliefInMeters - pLower->EyeRelief ) / ( pUpper->EyeRelief - pLower->EyeRelief );
+#else
+        // Do not extrapolate, just clamp - slightly worried about people putting in bogus settings.
+        if ( distortions[0].EyeRelief > eyeReliefInMeters )
+        {
+            pLower = &(distortions[0]);
+            pUpper = &(distortions[0]);
+        }
+        else
+        {
+            OVR_ASSERT ( distortions[numDistortions-1].EyeRelief <= eyeReliefInMeters );
+            pLower = &(distortions[numDistortions-1]);
+            pUpper = &(distortions[numDistortions-1]);
+        }
+        lerpVal = 0.0f;
+#endif
+    }
+    float invLerpVal = 1.0f - lerpVal;
+
+    pLower->Config.MaxR = pLower->MaxRadius;
+    pUpper->Config.MaxR = pUpper->MaxRadius;
+
+    LensConfig result;
+    // Where is the edge of the lens - no point modelling further than this.
+    float maxValidRadius = invLerpVal * pLower->MaxRadius + lerpVal * pUpper->MaxRadius;
+    result.MaxR = maxValidRadius;
+
+    switch ( distortionType )
+    {
+    case Distortion_Poly4:
+        // Deprecated
+        OVR_ASSERT ( false );
+        break;
+    case Distortion_RecipPoly4:{
+        // Lerp control points and fit an equation to them.
+        float fitX[4];
+        float fitY[4];
+        fitX[0] = 0.0f;
+        fitY[0] = 1.0f;
+        for ( int ctrlPt = 1; ctrlPt < 4; ctrlPt ++ )
+        {
+            float radiusLerp = invLerpVal * pLower->SampleRadius[ctrlPt-1] + lerpVal * pUpper->SampleRadius[ctrlPt-1];
+            float radiusLerpSq = radiusLerp * radiusLerp;
+            float fitYLower = pLower->Config.DistortionFnScaleRadiusSquared ( radiusLerpSq );
+            float fitYUpper = pUpper->Config.DistortionFnScaleRadiusSquared ( radiusLerpSq );
+            fitX[ctrlPt] = radiusLerpSq;
+            fitY[ctrlPt] = 1.0f / ( invLerpVal * fitYLower + lerpVal * fitYUpper );
+        }
+
+        result.Eqn = Distortion_RecipPoly4;
+        bool bSuccess = FitCubicPolynomial ( result.K, fitX, fitY );
+        OVR_ASSERT ( bSuccess );
+        OVR_UNUSED ( bSuccess );
+
+        // Set up the fast inverse.
+        float maxRDist = result.DistortionFn ( maxValidRadius );
+        result.MaxInvR = maxRDist;
+        result.SetUpInverseApprox();
+
+        }break;
+
+    case Distortion_CatmullRom10:{
+
+        // Evenly sample & lerp points on the curve.
+        const int NumSegments = LensConfig::NumCoefficients;
+        result.MaxR = maxValidRadius;
+        // Directly interpolate the K0 values
+        result.K[0] = invLerpVal * pLower->Config.K[0] + lerpVal * pUpper->Config.K[0];
+
+        // Sample and interpolate the distortion curves to derive K[1] ... K[n]
+        for ( int ctrlPt = 1; ctrlPt < NumSegments; ctrlPt++ )
+        {
+            float radiusSq = ( (float)ctrlPt / (float)(NumSegments-1) ) * maxValidRadius * maxValidRadius;
+            float fitYLower = pLower->Config.DistortionFnScaleRadiusSquared ( radiusSq );
+            float fitYUpper = pUpper->Config.DistortionFnScaleRadiusSquared ( radiusSq );
+            float fitLerp = invLerpVal * fitYLower + lerpVal * fitYUpper;
+            result.K[ctrlPt] = fitLerp;
+        }
+
+        result.Eqn = Distortion_CatmullRom10;
+
+        for ( int ctrlPt = 1; ctrlPt < NumSegments; ctrlPt++ )
+        {
+            float radiusSq = ( (float)ctrlPt / (float)(NumSegments-1) ) * maxValidRadius * maxValidRadius;
+            float val = result.DistortionFnScaleRadiusSquared ( radiusSq );            
+            OVR_ASSERT ( Alg::Abs ( val - result.K[ctrlPt] ) < 0.0001f );
+            OVR_UNUSED1(val); // For release build.
+        }
+
+        // Set up the fast inverse.
+        float maxRDist = result.DistortionFn ( maxValidRadius );
+        result.MaxInvR = maxRDist;
+        result.SetUpInverseApprox();
+
+        }break;
+
+    default: OVR_ASSERT ( false ); break;
+    }
+
+
+    // Chromatic aberration.
+    result.ChromaticAberration[0] = invLerpVal * pLower->Config.ChromaticAberration[0] + lerpVal * pUpper->Config.ChromaticAberration[0];
+    result.ChromaticAberration[1] = invLerpVal * pLower->Config.ChromaticAberration[1] + lerpVal * pUpper->Config.ChromaticAberration[1];
+    result.ChromaticAberration[2] = invLerpVal * pLower->Config.ChromaticAberration[2] + lerpVal * pUpper->Config.ChromaticAberration[2];
+    result.ChromaticAberration[3] = invLerpVal * pLower->Config.ChromaticAberration[3] + lerpVal * pUpper->Config.ChromaticAberration[3];
+
+    // Scale.
+    result.MetersPerTanAngleAtCenter =  pLower->Config.MetersPerTanAngleAtCenter * invLerpVal +
+                                        pUpper->Config.MetersPerTanAngleAtCenter * lerpVal;
+    /*
+    // Commented out - Causes ASSERT with no HMD plugged in
+#ifdef OVR_BUILD_DEBUG
+    if ( distortionType == Distortion_CatmullRom10 )
+    {
+        TestSaveLoadLensConfig ( result );
+    }
+#endif
+    */
+    return result;
+}
+
+
+DistortionRenderDesc CalculateDistortionRenderDesc ( StereoEye eyeType, HmdRenderInfo const &hmd,
+                                                     const LensConfig *pLensOverride /*= NULL */ )
+{
+    // From eye relief, IPD and device characteristics, we get the distortion mapping.
+    // This distortion does the following things:
+    // 1. It undoes the distortion that happens at the edges of the lens.
+    // 2. It maps the undistorted field into "retina" space.
+    // So the input is a pixel coordinate - the physical pixel on the display itself.
+    // The output is the real-world direction of the ray from this pixel as it comes out of the lens and hits the eye.
+    // However we typically think of rays "coming from" the eye, so the direction (TanAngleX,TanAngleY,1) is the direction
+    //      that the pixel appears to be in real-world space, where AngleX and AngleY are relative to the straight-ahead vector.
+    // If your renderer is a raytracer, you can use this vector directly (normalize as appropriate).
+    // However in standard rasterisers, we have rendered a 2D image and are putting it in front of the eye,
+    //      so we then need a mapping from this space to the [-1,1] UV coordinate space, which depends on exactly
+    //      where "in space" the app wants to put that rendertarget.
+    //      Where in space, and how large this rendertarget is, is completely up to the app and/or user,
+    //      though of course we can provide some useful hints.
+
+    // TODO: Use IPD and eye relief to modify distortion (i.e. non-radial component)
+    // TODO: cope with lenses that don't produce collimated light.
+    //       This means that IPD relative to the lens separation changes the light vergence,
+    //       and so we actually need to change where the image is displayed.
+
+    const HmdRenderInfo::EyeConfig &hmdEyeConfig = ( eyeType == StereoEye_Left ) ? hmd.EyeLeft : hmd.EyeRight;
+
+    DistortionRenderDesc localDistortion;
+    localDistortion.Lens = hmdEyeConfig.Distortion;
+
+    if ( pLensOverride != NULL )
+    {
+        localDistortion.Lens = *pLensOverride;
+    }
+
+    Sizef pixelsPerMeter(hmd.ResolutionInPixels.w / ( hmd.ScreenSizeInMeters.w - hmd.ScreenGapSizeInMeters ),
+                         hmd.ResolutionInPixels.h / hmd.ScreenSizeInMeters.h);
+
+    localDistortion.PixelsPerTanAngleAtCenter = (pixelsPerMeter * localDistortion.Lens.MetersPerTanAngleAtCenter).ToVector();
+    // Same thing, scaled to [-1,1] for each eye, rather than pixels.
+
+    localDistortion.TanEyeAngleScale = Vector2f(0.25f, 0.5f).EntrywiseMultiply(
+                                       (hmd.ScreenSizeInMeters / localDistortion.Lens.MetersPerTanAngleAtCenter).ToVector());
+    
+    // <--------------left eye------------------><-ScreenGapSizeInMeters-><--------------right eye----------------->
+    // <------------------------------------------ScreenSizeInMeters.Width----------------------------------------->
+    //                            <----------------LensSeparationInMeters--------------->
+    // <--centerFromLeftInMeters->
+    //                            ^
+    //                      Center of lens
+
+    // Find the lens centers in scale of [-1,+1] (NDC) in left eye.
+    float visibleWidthOfOneEye = 0.5f * ( hmd.ScreenSizeInMeters.w - hmd.ScreenGapSizeInMeters );
+    float centerFromLeftInMeters = ( hmd.ScreenSizeInMeters.w - hmd.LensSeparationInMeters ) * 0.5f;
+    localDistortion.LensCenter.x = (     centerFromLeftInMeters / visibleWidthOfOneEye          ) * 2.0f - 1.0f;
+    localDistortion.LensCenter.y = ( hmd.CenterFromTopInMeters  / hmd.ScreenSizeInMeters.h ) * 2.0f - 1.0f;
+    if ( eyeType == StereoEye_Right )
+    {
+        localDistortion.LensCenter.x = -localDistortion.LensCenter.x;
+    }
+
+    return localDistortion;
+}
+
+FovPort CalculateFovFromEyePosition ( float eyeReliefInMeters,
+                                      float offsetToRightInMeters,
+                                      float offsetDownwardsInMeters,
+                                      float lensDiameterInMeters,
+                                      float extraEyeRotationInRadians /*= 0.0f*/ )
+{
+    // 2D view of things:
+    //       |-|            <--- offsetToRightInMeters (in this case, it is negative)
+    // |=======C=======|    <--- lens surface (C=center)
+    //  \    |       _/
+    //   \   R     _/
+    //    \  |   _/
+    //     \ | _/
+    //      \|/
+    //       O  <--- center of pupil
+
+    // (technically the lens is round rather than square, so it's not correct to
+    // separate vertical and horizontal like this, but it's close enough)
+    float halfLensDiameter = lensDiameterInMeters * 0.5f;
+    FovPort fovPort;
+    fovPort.UpTan    = ( halfLensDiameter + offsetDownwardsInMeters ) / eyeReliefInMeters;
+    fovPort.DownTan  = ( halfLensDiameter - offsetDownwardsInMeters ) / eyeReliefInMeters;
+    fovPort.LeftTan  = ( halfLensDiameter + offsetToRightInMeters   ) / eyeReliefInMeters;
+    fovPort.RightTan = ( halfLensDiameter - offsetToRightInMeters   ) / eyeReliefInMeters;
+
+    if ( extraEyeRotationInRadians > 0.0f )
+    {
+        // That's the basic looking-straight-ahead eye position relative to the lens.
+        // But if you look left, the pupil moves left as the eyeball rotates, which
+        // means you can see more to the right than this geometry suggests.
+        // So add in the bounds for the extra movement of the pupil.
+
+        // Beyond 30 degrees does not increase FOV because the pupil starts moving backwards more than sideways.
+        extraEyeRotationInRadians = Alg::Min ( DegreeToRad ( 30.0f ), Alg::Max ( 0.0f, extraEyeRotationInRadians ) );
+        
+        // The rotation of the eye is a bit more complex than a simple circle.  The center of rotation
+        // at 13.5mm from cornea is slightly further back than the actual center of the eye.
+        // Additionally the rotation contains a small lateral component as the muscles pull the eye
+        const float eyeballCenterToPupil = 0.0135f;  // center of eye rotation
+        const float eyeballLateralPull = 0.001f * (extraEyeRotationInRadians / DegreeToRad ( 30.0f));  // lateral motion as linear function 
+        float extraTranslation = eyeballCenterToPupil * sinf ( extraEyeRotationInRadians ) + eyeballLateralPull;
+        float extraRelief = eyeballCenterToPupil * ( 1.0f - cosf ( extraEyeRotationInRadians ) );
+
+        fovPort.UpTan    = Alg::Max ( fovPort.UpTan   , ( halfLensDiameter + offsetDownwardsInMeters + extraTranslation ) / ( eyeReliefInMeters + extraRelief ) );
+        fovPort.DownTan  = Alg::Max ( fovPort.DownTan , ( halfLensDiameter - offsetDownwardsInMeters + extraTranslation ) / ( eyeReliefInMeters + extraRelief ) );
+        fovPort.LeftTan  = Alg::Max ( fovPort.LeftTan , ( halfLensDiameter + offsetToRightInMeters   + extraTranslation ) / ( eyeReliefInMeters + extraRelief ) );
+        fovPort.RightTan = Alg::Max ( fovPort.RightTan, ( halfLensDiameter - offsetToRightInMeters   + extraTranslation ) / ( eyeReliefInMeters + extraRelief ) );
+    }
+
+    return fovPort;
+}
+
+
+
+FovPort CalculateFovFromHmdInfo ( StereoEye eyeType,
+                                  DistortionRenderDesc const &distortion,
+                                  HmdRenderInfo const &hmd,
+                                  float extraEyeRotationInRadians /*= 0.0f*/ )
+{
+    FovPort fovPort;
+    float eyeReliefInMeters;
+    float offsetToRightInMeters;
+    if ( eyeType == StereoEye_Right )
+    {
+        eyeReliefInMeters     = hmd.EyeRight.ReliefInMeters;
+        offsetToRightInMeters = hmd.EyeRight.NoseToPupilInMeters - 0.5f * hmd.LensSeparationInMeters;
+    }
+    else
+    {
+        eyeReliefInMeters     = hmd.EyeLeft.ReliefInMeters;
+        offsetToRightInMeters = -(hmd.EyeLeft.NoseToPupilInMeters - 0.5f * hmd.LensSeparationInMeters);
+    }
+
+    // Limit the eye-relief to 6 mm for FOV calculations since this just tends to spread off-screen
+    // and get clamped anyways on DK1 (but in Unity it continues to spreads and causes 
+    // unnecessarily large render targets)
+    eyeReliefInMeters = Alg::Max(eyeReliefInMeters, 0.006f);
+
+    // Central view.
+    fovPort = CalculateFovFromEyePosition ( eyeReliefInMeters,
+                                            offsetToRightInMeters,
+                                            0.0f,
+                                            hmd.LensDiameterInMeters,
+                                            extraEyeRotationInRadians );
+
+    // clamp to the screen
+    fovPort = ClampToPhysicalScreenFov ( eyeType, distortion, fovPort );
+       
+    return fovPort;
+}
+
+
+
+FovPort GetPhysicalScreenFov ( StereoEye eyeType, DistortionRenderDesc const &distortion )
+{
+    OVR_UNUSED1 ( eyeType );
+
+    FovPort resultFovPort;
+
+    // Figure out the boundaries of the screen. We take the middle pixel of the screen,
+    // move to each of the four screen edges, and transform those back into TanAngle space.
+    Vector2f dmiddle = distortion.LensCenter;
+
+    // The gotcha is that for some distortion functions, the map will "wrap around"
+    // for screen pixels that are not actually visible to the user (especially on DK1,
+    // which has a lot of invisible pixels), and map to pixels that are close to the middle.
+    // This means the edges of the screen will actually be
+    // "closer" than the visible bounds, so we'll clip too aggressively.
+
+    // Solution - step gradually towards the boundary, noting the maximum distance.
+    struct FunctionHider
+    {
+        static FovPort FindRange ( Vector2f from, Vector2f to, int numSteps,
+                                          DistortionRenderDesc const &distortion )
+        {
+            FovPort result;
+            result.UpTan    = 0.0f;
+            result.DownTan  = 0.0f;
+            result.LeftTan  = 0.0f;
+            result.RightTan = 0.0f;
+
+            float stepScale = 1.0f / ( numSteps - 1 );
+            for ( int step = 0; step < numSteps; step++ )
+            {
+                float    lerpFactor  = stepScale * (float)step;
+                Vector2f sample      = from + (to - from) * lerpFactor;
+                Vector2f tanEyeAngle = TransformScreenNDCToTanFovSpace ( distortion, sample );
+
+                result.LeftTan  = Alg::Max ( result.LeftTan,  -tanEyeAngle.x );
+                result.RightTan = Alg::Max ( result.RightTan,  tanEyeAngle.x );
+                result.UpTan    = Alg::Max ( result.UpTan,    -tanEyeAngle.y );
+                result.DownTan  = Alg::Max ( result.DownTan,   tanEyeAngle.y );
+            }
+            return result;
+        }
+    };
+
+    FovPort leftFovPort  = FunctionHider::FindRange( dmiddle, Vector2f( -1.0f, dmiddle.y ), 10, distortion );
+    FovPort rightFovPort = FunctionHider::FindRange( dmiddle, Vector2f( 1.0f, dmiddle.y ),  10, distortion );
+    FovPort upFovPort    = FunctionHider::FindRange( dmiddle, Vector2f( dmiddle.x, -1.0f ), 10, distortion );
+    FovPort downFovPort  = FunctionHider::FindRange( dmiddle, Vector2f( dmiddle.x, 1.0f ),  10, distortion );
+    
+    resultFovPort.LeftTan  = leftFovPort.LeftTan;
+    resultFovPort.RightTan = rightFovPort.RightTan;
+    resultFovPort.UpTan    = upFovPort.UpTan;
+    resultFovPort.DownTan  = downFovPort.DownTan;
+
+    return resultFovPort;
+}
+
+FovPort ClampToPhysicalScreenFov( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                         FovPort inputFovPort )
+{
+    FovPort resultFovPort;
+    FovPort phsyicalFovPort = GetPhysicalScreenFov ( eyeType, distortion );
+    resultFovPort.LeftTan  = Alg::Min ( inputFovPort.LeftTan,  phsyicalFovPort.LeftTan );
+    resultFovPort.RightTan = Alg::Min ( inputFovPort.RightTan, phsyicalFovPort.RightTan );
+    resultFovPort.UpTan    = Alg::Min ( inputFovPort.UpTan,    phsyicalFovPort.UpTan );
+    resultFovPort.DownTan  = Alg::Min ( inputFovPort.DownTan,  phsyicalFovPort.DownTan );
+
+    return resultFovPort;
+}
+
+Sizei CalculateIdealPixelSize ( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                FovPort tanHalfFov, float pixelsPerDisplayPixel )
+{
+    OVR_UNUSED(eyeType);   // might be useful in the future if we do overlapping fovs
+
+    Sizei result;    
+    // TODO: if the app passes in a FOV that doesn't cover the centre, use the distortion values for the nearest edge/corner to match pixel size.
+    result.w  = (int)(0.5f + pixelsPerDisplayPixel * distortion.PixelsPerTanAngleAtCenter.x * ( tanHalfFov.LeftTan + tanHalfFov.RightTan ) );
+    result.h = (int)(0.5f + pixelsPerDisplayPixel * distortion.PixelsPerTanAngleAtCenter.y * ( tanHalfFov.UpTan   + tanHalfFov.DownTan  ) );
+    return result;
+}
+
+Recti GetFramebufferViewport ( StereoEye eyeType, HmdRenderInfo const &hmd )
+{
+    Recti result;
+    result.w = hmd.ResolutionInPixels.w/2;
+    result.h = hmd.ResolutionInPixels.h;
+    result.x = 0;
+    result.y = 0;
+    if ( eyeType == StereoEye_Right )
+    {
+        result.x = (hmd.ResolutionInPixels.w+1)/2;      // Round up, not down.
+    }
+    return result;
+}
+
+
+ScaleAndOffset2D CreateNDCScaleAndOffsetFromFov ( FovPort tanHalfFov )
+{
+    float projXScale = 2.0f / ( tanHalfFov.LeftTan + tanHalfFov.RightTan );
+    float projXOffset = ( tanHalfFov.LeftTan - tanHalfFov.RightTan ) * projXScale * 0.5f;
+    float projYScale = 2.0f / ( tanHalfFov.UpTan + tanHalfFov.DownTan );
+    float projYOffset = ( tanHalfFov.UpTan - tanHalfFov.DownTan ) * projYScale * 0.5f;
+
+    ScaleAndOffset2D result;
+    result.Scale    = Vector2f(projXScale, projYScale);
+    result.Offset   = Vector2f(projXOffset, projYOffset);
+    // Hey - why is that Y.Offset negated?
+    // It's because a projection matrix transforms from world coords with Y=up,
+    // whereas this is from NDC which is Y=down.
+
+    return result;
+}
+
+
+ScaleAndOffset2D CreateUVScaleAndOffsetfromNDCScaleandOffset ( ScaleAndOffset2D scaleAndOffsetNDC,
+                                                               Recti renderedViewport,
+                                                               Sizei renderTargetSize )
+{
+    // scaleAndOffsetNDC takes you to NDC space [-1,+1] within the given viewport on the rendertarget.
+    // We want a scale to instead go to actual UV coordinates you can sample with,
+    // which need [0,1] and ignore the viewport.
+    ScaleAndOffset2D result;
+    // Scale [-1,1] to [0,1]
+    result.Scale  = scaleAndOffsetNDC.Scale * 0.5f;
+    result.Offset = scaleAndOffsetNDC.Offset * 0.5f + Vector2f(0.5f);
+    
+    // ...but we will have rendered to a subsection of the RT, so scale for that.
+    Vector2f scale(  (float)renderedViewport.w / (float)renderTargetSize.w,
+                     (float)renderedViewport.h / (float)renderTargetSize.h );
+    Vector2f offset( (float)renderedViewport.x / (float)renderTargetSize.w,
+                     (float)renderedViewport.y / (float)renderTargetSize.h );
+
+	result.Scale  = result.Scale.EntrywiseMultiply(scale);
+    result.Offset  = result.Offset.EntrywiseMultiply(scale) + offset;
+    return result;
+}
+
+
+
+Matrix4f CreateProjection( bool rightHanded, FovPort tanHalfFov,
+                           float zNear /*= 0.01f*/, float zFar /*= 10000.0f*/ )
+{
+    // A projection matrix is very like a scaling from NDC, so we can start with that.
+    ScaleAndOffset2D scaleAndOffset = CreateNDCScaleAndOffsetFromFov ( tanHalfFov );
+
+    float handednessScale = 1.0f;
+    if ( rightHanded )
+    {
+        handednessScale = -1.0f;
+    }
+
+    Matrix4f projection;
+    // Produces X result, mapping clip edges to [-w,+w]
+    projection.M[0][0] = scaleAndOffset.Scale.x;
+    projection.M[0][1] = 0.0f;
+    projection.M[0][2] = handednessScale * scaleAndOffset.Offset.x;
+    projection.M[0][3] = 0.0f;
+
+    // Produces Y result, mapping clip edges to [-w,+w]
+    // Hey - why is that YOffset negated?
+    // It's because a projection matrix transforms from world coords with Y=up,
+    // whereas this is derived from an NDC scaling, which is Y=down.
+    projection.M[1][0] = 0.0f;
+    projection.M[1][1] = scaleAndOffset.Scale.y;
+    projection.M[1][2] = handednessScale * -scaleAndOffset.Offset.y;
+    projection.M[1][3] = 0.0f;
+
+    // Produces Z-buffer result - app needs to fill this in with whatever Z range it wants.
+    // We'll just use some defaults for now.
+    projection.M[2][0] = 0.0f;
+    projection.M[2][1] = 0.0f;
+    projection.M[2][2] = -handednessScale * zFar / (zNear - zFar);
+    projection.M[2][3] = (zFar * zNear) / (zNear - zFar);
+
+    // Produces W result (= Z in)
+    projection.M[3][0] = 0.0f;
+    projection.M[3][1] = 0.0f;
+    projection.M[3][2] = handednessScale;
+    projection.M[3][3] = 0.0f;
+
+    return projection;
+}
+
+
+Matrix4f CreateOrthoSubProjection ( bool rightHanded, StereoEye eyeType,
+                                    float tanHalfFovX, float tanHalfFovY,
+                                    float unitsX, float unitsY,
+                                    float distanceFromCamera, float interpupillaryDistance,
+                                    Matrix4f const &projection,
+                                    float zNear /*= 0.0f*/, float zFar /*= 0.0f*/ )
+{
+    OVR_UNUSED1 ( rightHanded );
+
+    float orthoHorizontalOffset = interpupillaryDistance * 0.5f / distanceFromCamera;
+    switch ( eyeType )
+    {
+    case StereoEye_Center:
+        orthoHorizontalOffset = 0.0f;
+        break;
+    case StereoEye_Left:
+        break;
+    case StereoEye_Right:
+        orthoHorizontalOffset = -orthoHorizontalOffset;
+        break;
+    default: OVR_ASSERT ( false ); break;
+    }
+
+    // Current projection maps real-world vector (x,y,1) to the RT.
+    // We want to find the projection that maps the range [-FovPixels/2,FovPixels/2] to
+    // the physical [-orthoHalfFov,orthoHalfFov]
+    // Note moving the offset from M[0][2]+M[1][2] to M[0][3]+M[1][3] - this means
+    // we don't have to feed in Z=1 all the time.
+    // The horizontal offset math is a little hinky because the destination is
+    // actually [-orthoHalfFov+orthoHorizontalOffset,orthoHalfFov+orthoHorizontalOffset]
+    // So we need to first map [-FovPixels/2,FovPixels/2] to
+    //                         [-orthoHalfFov+orthoHorizontalOffset,orthoHalfFov+orthoHorizontalOffset]:
+    // x1 = x0 * orthoHalfFov/(FovPixels/2) + orthoHorizontalOffset;
+    //    = x0 * 2*orthoHalfFov/FovPixels + orthoHorizontalOffset;
+    // But then we need the sam mapping as the existing projection matrix, i.e.
+    // x2 = x1 * Projection.M[0][0] + Projection.M[0][2];
+    //    = x0 * (2*orthoHalfFov/FovPixels + orthoHorizontalOffset) * Projection.M[0][0] + Projection.M[0][2];
+    //    = x0 * Projection.M[0][0]*2*orthoHalfFov/FovPixels +
+    //      orthoHorizontalOffset*Projection.M[0][0] + Projection.M[0][2];
+    // So in the new projection matrix we need to scale by Projection.M[0][0]*2*orthoHalfFov/FovPixels and
+    // offset by orthoHorizontalOffset*Projection.M[0][0] + Projection.M[0][2].
+
+    float orthoScaleX = 2.0f * tanHalfFovX / unitsX;
+    float orthoScaleY = 2.0f * tanHalfFovY / unitsY;
+    Matrix4f ortho;
+    ortho.M[0][0] = projection.M[0][0] * orthoScaleX;
+    ortho.M[0][1] = 0.0f;
+    ortho.M[0][2] = 0.0f;
+    ortho.M[0][3] = -projection.M[0][2] + ( orthoHorizontalOffset * projection.M[0][0] );
+
+    ortho.M[1][0] = 0.0f;
+    ortho.M[1][1] = -projection.M[1][1] * orthoScaleY;       // Note sign flip (text rendering uses Y=down).
+    ortho.M[1][2] = 0.0f;
+    ortho.M[1][3] = -projection.M[1][2];
+
+    if ( fabsf ( zNear - zFar ) < 0.001f )
+    {
+        ortho.M[2][0] = 0.0f;
+        ortho.M[2][1] = 0.0f;
+        ortho.M[2][2] = 0.0f;
+        ortho.M[2][3] = zFar;
+    }
+    else
+    {
+        ortho.M[2][0] = 0.0f;
+        ortho.M[2][1] = 0.0f;
+        ortho.M[2][2] = zFar / (zNear - zFar);
+        ortho.M[2][3] = (zFar * zNear) / (zNear - zFar);
+    }
+
+    // No perspective correction for ortho.
+    ortho.M[3][0] = 0.0f;
+    ortho.M[3][1] = 0.0f;
+    ortho.M[3][2] = 0.0f;
+    ortho.M[3][3] = 1.0f;
+
+    return ortho;
+}
+
+
+//-----------------------------------------------------------------------------------
+// A set of "forward-mapping" functions, mapping from framebuffer space to real-world and/or texture space.
+
+// This mimics the first half of the distortion shader's function.
+Vector2f TransformScreenNDCToTanFovSpace( DistortionRenderDesc const &distortion,
+                                          const Vector2f &framebufferNDC )
+{
+    // Scale to TanHalfFov space, but still distorted.
+    Vector2f tanEyeAngleDistorted;
+    tanEyeAngleDistorted.x = ( framebufferNDC.x - distortion.LensCenter.x ) * distortion.TanEyeAngleScale.x;
+    tanEyeAngleDistorted.y = ( framebufferNDC.y - distortion.LensCenter.y ) * distortion.TanEyeAngleScale.y;
+    // Distort.
+    float radiusSquared = ( tanEyeAngleDistorted.x * tanEyeAngleDistorted.x )
+                        + ( tanEyeAngleDistorted.y * tanEyeAngleDistorted.y );
+    float distortionScale = distortion.Lens.DistortionFnScaleRadiusSquared ( radiusSquared );
+    Vector2f tanEyeAngle;
+    tanEyeAngle.x = tanEyeAngleDistorted.x * distortionScale;
+    tanEyeAngle.y = tanEyeAngleDistorted.y * distortionScale;
+
+    return tanEyeAngle;
+}
+
+// Same, with chromatic aberration correction.
+void TransformScreenNDCToTanFovSpaceChroma ( Vector2f *resultR, Vector2f *resultG, Vector2f *resultB, 
+                                             DistortionRenderDesc const &distortion,
+                                             const Vector2f &framebufferNDC )
+{
+    // Scale to TanHalfFov space, but still distorted.
+    Vector2f tanEyeAngleDistorted;
+    tanEyeAngleDistorted.x = ( framebufferNDC.x - distortion.LensCenter.x ) * distortion.TanEyeAngleScale.x;
+    tanEyeAngleDistorted.y = ( framebufferNDC.y - distortion.LensCenter.y ) * distortion.TanEyeAngleScale.y;
+    // Distort.
+    float radiusSquared = ( tanEyeAngleDistorted.x * tanEyeAngleDistorted.x )
+                        + ( tanEyeAngleDistorted.y * tanEyeAngleDistorted.y );
+    Vector3f distortionScales = distortion.Lens.DistortionFnScaleRadiusSquaredChroma ( radiusSquared );
+    *resultR = tanEyeAngleDistorted * distortionScales.x;
+    *resultG = tanEyeAngleDistorted * distortionScales.y;
+    *resultB = tanEyeAngleDistorted * distortionScales.z;
+}
+
+// This mimics the second half of the distortion shader's function.
+Vector2f TransformTanFovSpaceToRendertargetTexUV( ScaleAndOffset2D const &eyeToSourceUV,
+                                                  Vector2f const &tanEyeAngle )
+{
+    Vector2f textureUV;
+    textureUV.x = tanEyeAngle.x * eyeToSourceUV.Scale.x + eyeToSourceUV.Offset.x;
+    textureUV.y = tanEyeAngle.y * eyeToSourceUV.Scale.y + eyeToSourceUV.Offset.y;
+    return textureUV;
+}
+
+Vector2f TransformTanFovSpaceToRendertargetNDC( ScaleAndOffset2D const &eyeToSourceNDC,
+                                                Vector2f const &tanEyeAngle )
+{
+    Vector2f textureNDC;
+    textureNDC.x = tanEyeAngle.x * eyeToSourceNDC.Scale.x + eyeToSourceNDC.Offset.x;
+    textureNDC.y = tanEyeAngle.y * eyeToSourceNDC.Scale.y + eyeToSourceNDC.Offset.y;
+    return textureNDC;
+}
+
+Vector2f TransformScreenPixelToScreenNDC( Recti const &distortionViewport,
+                                          Vector2f const &pixel )
+{
+    // Move to [-1,1] NDC coords.
+    Vector2f framebufferNDC;
+    framebufferNDC.x = -1.0f + 2.0f * ( ( pixel.x - (float)distortionViewport.x ) / (float)distortionViewport.w );
+    framebufferNDC.y = -1.0f + 2.0f * ( ( pixel.y - (float)distortionViewport.y ) / (float)distortionViewport.h );
+    return framebufferNDC;
+}
+
+Vector2f TransformScreenPixelToTanFovSpace( Recti const &distortionViewport,
+                                            DistortionRenderDesc const &distortion,
+                                            Vector2f const &pixel )
+{
+    return TransformScreenNDCToTanFovSpace( distortion,
+                TransformScreenPixelToScreenNDC( distortionViewport, pixel ) );
+}
+
+Vector2f TransformScreenNDCToRendertargetTexUV( DistortionRenderDesc const &distortion,
+                                                StereoEyeParams const &eyeParams,
+                                                Vector2f const &pixel )
+{
+    return TransformTanFovSpaceToRendertargetTexUV ( eyeParams,
+                TransformScreenNDCToTanFovSpace ( distortion, pixel ) );
+}
+
+Vector2f TransformScreenPixelToRendertargetTexUV( Recti const &distortionViewport,
+                                                  DistortionRenderDesc const &distortion,
+                                                  StereoEyeParams const &eyeParams,
+                                                  Vector2f const &pixel )
+{
+    return TransformTanFovSpaceToRendertargetTexUV ( eyeParams,
+                TransformScreenPixelToTanFovSpace ( distortionViewport, distortion, pixel ) );
+}
+
+
+//-----------------------------------------------------------------------------------
+// A set of "reverse-mapping" functions, mapping from real-world and/or texture space back to the framebuffer.
+
+Vector2f TransformTanFovSpaceToScreenNDC( DistortionRenderDesc const &distortion,
+                                          const Vector2f &tanEyeAngle, bool usePolyApprox /*= false*/ )
+{
+    float tanEyeAngleRadius = tanEyeAngle.Length();
+    float tanEyeAngleDistortedRadius = distortion.Lens.DistortionFnInverseApprox ( tanEyeAngleRadius );
+    if ( !usePolyApprox )
+    {
+        tanEyeAngleDistortedRadius = distortion.Lens.DistortionFnInverse ( tanEyeAngleRadius );
+    }
+    Vector2f tanEyeAngleDistorted = tanEyeAngle;
+    if ( tanEyeAngleRadius > 0.0f )
+    {   
+        tanEyeAngleDistorted = tanEyeAngle * ( tanEyeAngleDistortedRadius / tanEyeAngleRadius );
+    }
+
+    Vector2f framebufferNDC;
+    framebufferNDC.x = ( tanEyeAngleDistorted.x / distortion.TanEyeAngleScale.x ) + distortion.LensCenter.x;
+    framebufferNDC.y = ( tanEyeAngleDistorted.y / distortion.TanEyeAngleScale.y ) + distortion.LensCenter.y;
+
+    return framebufferNDC;
+}
+
+Vector2f TransformRendertargetNDCToTanFovSpace( const ScaleAndOffset2D &eyeToSourceNDC,
+                                                const Vector2f &textureNDC )
+{
+    Vector2f tanEyeAngle = (textureNDC - eyeToSourceNDC.Offset) / eyeToSourceNDC.Scale;
+    return tanEyeAngle;
+}
+
+
+
+} //namespace OVR
+
+//Just want to make a copy disentangled from all these namespaces!
+float ExtEvalCatmullRom10Spline ( float const *K, float scaledVal )
+{
+	return(OVR::EvalCatmullRom10Spline ( K, scaledVal ));
+}
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,647 @@
+/************************************************************************************
+
+Filename    :   OVR_Stereo.h
+Content     :   Stereo rendering functions
+Created     :   November 30, 2013
+Authors     :   Tom Fosyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Stereo_h
+#define OVR_Stereo_h
+
+#include "Sensors/OVR_DeviceConstants.h"
+#include "Displays/OVR_Display.h"
+#include "OVR_Profile.h"
+
+// CAPI Forward declaration.
+typedef struct ovrFovPort_ ovrFovPort;
+typedef struct ovrRecti_ ovrRecti;
+
+namespace OVR {
+
+class SensorDevice; // Opaque forward declaration
+
+
+//-----------------------------------------------------------------------------------
+// ***** Stereo Enumerations
+
+// StereoEye specifies which eye we are rendering for; it is used to
+// retrieve StereoEyeParams.
+enum StereoEye
+{
+    StereoEye_Center,
+    StereoEye_Left,
+    StereoEye_Right    
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** FovPort
+
+// FovPort describes Field Of View (FOV) of a viewport.
+// This class has values for up, down, left and right, stored in 
+// tangent of the angle units to simplify calculations.
+//
+// As an example, for a standard 90 degree vertical FOV, we would 
+// have: { UpTan = tan(90 degrees / 2), DownTan = tan(90 degrees / 2) }.
+//
+// CreateFromRadians/Degrees helper functions can be used to
+// access FOV in different units.
+
+struct FovPort
+{
+    float UpTan;
+    float DownTan;
+    float LeftTan;
+    float RightTan;
+
+    FovPort ( float sideTan = 0.0f ) :
+        UpTan(sideTan), DownTan(sideTan), LeftTan(sideTan), RightTan(sideTan) { }
+    FovPort ( float u, float d, float l, float r ) :
+        UpTan(u), DownTan(d), LeftTan(l), RightTan(r) { }
+
+    // C-interop support: FovPort <-> ovrFovPort (implementation in OVR_CAPI.cpp).
+    FovPort(const ovrFovPort& src);
+    operator ovrFovPort () const;
+
+    static FovPort CreateFromRadians(float horizontalFov, float verticalFov)
+    {
+        FovPort result;
+        result.UpTan    = tanf (   verticalFov * 0.5f );
+        result.DownTan  = tanf (   verticalFov * 0.5f );
+        result.LeftTan  = tanf ( horizontalFov * 0.5f );
+        result.RightTan = tanf ( horizontalFov * 0.5f );
+        return result;
+    }
+
+    static FovPort CreateFromDegrees(float horizontalFovDegrees,
+                                     float verticalFovDegrees)
+    {
+        return CreateFromRadians(DegreeToRad(horizontalFovDegrees),
+                                 DegreeToRad(verticalFovDegrees));
+    }
+
+    //  Get Horizontal/Vertical components of Fov in radians.
+    float GetVerticalFovRadians() const     { return atanf(UpTan)    + atanf(DownTan); }
+    float GetHorizontalFovRadians() const   { return atanf(LeftTan)  + atanf(RightTan); }
+    //  Get Horizontal/Vertical components of Fov in degrees.
+    float GetVerticalFovDegrees() const     { return RadToDegree(GetVerticalFovRadians()); }
+    float GetHorizontalFovDegrees() const   { return RadToDegree(GetHorizontalFovRadians()); }
+
+    // Compute maximum tangent value among all four sides.
+    float GetMaxSideTan() const
+    {
+        return Alg::Max(Alg::Max(UpTan, DownTan), Alg::Max(LeftTan, RightTan));
+    }
+
+    // Converts Fov Tan angle units to [-1,1] render target NDC space
+    Vector2f TanAngleToRendertargetNDC(Vector2f const &tanEyeAngle);
+
+
+    // Compute per-channel minimum and maximum of Fov.
+    static FovPort Min(const FovPort& a, const FovPort& b)
+    {   
+        FovPort fov( Alg::Min( a.UpTan   , b.UpTan    ),   
+                     Alg::Min( a.DownTan , b.DownTan  ),
+                     Alg::Min( a.LeftTan , b.LeftTan  ),
+                     Alg::Min( a.RightTan, b.RightTan ) );
+        return fov;
+    }
+
+    static FovPort Max(const FovPort& a, const FovPort& b)
+    {   
+        FovPort fov( Alg::Max( a.UpTan   , b.UpTan    ),   
+                     Alg::Max( a.DownTan , b.DownTan  ),
+                     Alg::Max( a.LeftTan , b.LeftTan  ),
+                     Alg::Max( a.RightTan, b.RightTan ) );
+        return fov;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ScaleAndOffset
+
+struct ScaleAndOffset2D
+{
+    Vector2f Scale;
+    Vector2f Offset;
+
+    ScaleAndOffset2D(float sx = 0.0f, float sy = 0.0f, float ox = 0.0f, float oy = 0.0f)
+      : Scale(sx, sy), Offset(ox, oy)        
+    { }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Misc. utility functions.
+
+// Inputs are 4 points (pFitX[0],pFitY[0]) through (pFitX[3],pFitY[3])
+// Result is four coefficients in pResults[0] through pResults[3] such that
+//      y = pResult[0] + x * ( pResult[1] + x * ( pResult[2] + x * ( pResult[3] ) ) );
+// passes through all four input points.
+// Return is true if it succeeded, false if it failed (because two control points
+// have the same pFitX value).
+bool FitCubicPolynomial ( float *pResult, const float *pFitX, const float *pFitY );
+
+//-----------------------------------------------------------------------------------
+// ***** LensConfig
+
+// LensConfig describes the configuration of a single lens in an HMD.
+// - Eqn and K[] describe a distortion function.
+// - MetersPerTanAngleAtCenter is the relationship between distance on a
+//   screen (at the center of the lens), and the angle variance of the light after it
+//   has passed through the lens.
+// - ChromaticAberration is an array of parameters for controlling
+//   additional Red and Blue scaling in order to reduce chromatic aberration
+//   caused by the Rift lenses.
+struct LensConfig
+{
+    // The result is a scaling applied to the distance from the center of the lens.
+    float    DistortionFnScaleRadiusSquared (float rsq) const;
+    // x,y,z components map to r,g,b scales.
+    Vector3f DistortionFnScaleRadiusSquaredChroma (float rsq) const;
+
+    // DistortionFn applies distortion to the argument.
+    // Input: the distance in TanAngle/NIC space from the optical center to the input pixel.
+    // Output: the resulting distance after distortion.
+    float DistortionFn(float r) const
+    {
+        return r * DistortionFnScaleRadiusSquared ( r * r );
+    }
+
+    // DistortionFnInverse computes the inverse of the distortion function on an argument.
+    float DistortionFnInverse(float r) const;
+
+    // Also computes the inverse, but using a polynomial approximation. Warning - it's just an approximation!
+    float DistortionFnInverseApprox(float r) const;
+    // Sets up InvK[].
+    void SetUpInverseApprox();
+
+    // Sets a bunch of sensible defaults.
+    void SetToIdentity();
+
+
+
+    enum { NumCoefficients = 11 };
+
+    DistortionEqnType   Eqn;
+    float               K[NumCoefficients];
+    float               MaxR;       // The highest R you're going to query for - the curve is unpredictable beyond it.
+
+    float               MetersPerTanAngleAtCenter;
+
+    // Additional per-channel scaling is applied after distortion:
+    //  Index [0] - Red channel constant coefficient.
+    //  Index [1] - Red channel r^2 coefficient.
+    //  Index [2] - Blue channel constant coefficient.
+    //  Index [3] - Blue channel r^2 coefficient.
+    float               ChromaticAberration[4];
+
+    float               InvK[NumCoefficients];
+    float               MaxInvR;
+};
+
+
+// For internal use - storing and loading lens config data
+
+// Returns true on success.
+bool LoadLensConfig ( LensConfig *presult, uint8_t const *pbuffer, int bufferSizeInBytes );
+
+// Returns number of bytes needed.
+int SaveLensConfigSizeInBytes ( LensConfig const &config );
+// Returns true on success.
+bool SaveLensConfig ( uint8_t *pbuffer, int bufferSizeInBytes, LensConfig const &config );
+
+
+//-----------------------------------------------------------------------------------
+// ***** DistortionRenderDesc
+
+// This describes distortion for a single eye in an HMD with a display, not just the lens by itself.
+struct DistortionRenderDesc
+{
+    // The raw lens values.
+    LensConfig          Lens;
+
+    // These map from [-1,1] across the eye being rendered into TanEyeAngle space (but still distorted)
+    Vector2f            LensCenter;
+    Vector2f            TanEyeAngleScale;
+    // Computed from device characteristics, IPD and eye-relief.
+    // (not directly used for rendering, but very useful)
+    Vector2f            PixelsPerTanAngleAtCenter;
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDInfo 
+
+// This structure describes various aspects of the HMD allowing us to configure rendering.
+//
+//  Currently included data:
+//   - Physical screen dimensions, resolution, and eye distances.
+//     (some of these will be configurable with a tool in the future).
+//     These arguments allow us to properly setup projection across HMDs.
+//   - DisplayDeviceName for identifying HMD screen; system-specific interpretation.
+//
+// TBD:
+//  - Power on/ off?
+//  - Sensor rates and capabilities
+//  - Distortion radius/variables    
+//  - Screen update frequency
+//  - Distortion needed flag
+//  - Update modes:
+//      Set update mode: Stereo (both sides together), mono (same in both eyes),
+//                       Alternating, Alternating scan-lines.
+
+// Win32 Oculus VR Display Driver Shim Information
+struct Win32ShimInfo
+{
+	int DeviceNumber;
+	int NativeWidth;
+	int NativeHeight;
+	int Rotation;
+	int UseMirroring;
+
+	Win32ShimInfo() :
+		DeviceNumber(-1),
+		NativeWidth(-1),
+		NativeHeight(-1),
+		Rotation(-1),
+		UseMirroring(1)
+	{
+	}
+};
+
+class HMDInfo
+{
+public:
+	// Name string describing the product: "Oculus Rift DK1", etc.
+	String      ProductName;
+	String      Manufacturer;
+
+	unsigned    Version;
+
+	// Characteristics of the HMD screen and enclosure
+	HmdTypeEnum HmdType;
+	Size<int>   ResolutionInPixels;
+	Size<float> ScreenSizeInMeters;
+	float       ScreenGapSizeInMeters;
+	float       CenterFromTopInMeters;
+	float       LensSeparationInMeters;
+
+	// Timing & shutter data. All values in seconds.
+	struct ShutterInfo
+	{
+		HmdShutterTypeEnum  Type;
+		float   VsyncToNextVsync;                // 1/framerate
+		float   VsyncToFirstScanline;            // for global shutter, vsync->shutter open.
+		float   FirstScanlineToLastScanline;     // for global shutter, will be zero.
+		float   PixelSettleTime;                 // estimated.
+		float   PixelPersistence;                // Full persistence = 1/framerate.
+	}           Shutter;
+
+	// Desktop coordinate position of the screen (can be negative; may not be present on all platforms)
+	int         DesktopX;
+	int         DesktopY;
+
+	// Windows:
+	// "\\\\.\\DISPLAY3", etc. Can be used in EnumDisplaySettings/CreateDC.
+	String      DisplayDeviceName;
+	Win32ShimInfo ShimInfo;
+
+	// MacOS:
+	int         DisplayId;
+
+	bool	    InCompatibilityMode;
+
+	// Printed serial number for the HMD; should match external sticker
+    String      PrintedSerial;
+
+    // Tracker descriptor information:
+    int         VendorId;
+    int         ProductId;
+    int         FirmwareMajor;
+    int         FirmwareMinor;
+
+    float   CameraFrustumHFovInRadians;
+    float   CameraFrustumVFovInRadians;
+    float   CameraFrustumNearZInMeters;
+    float   CameraFrustumFarZInMeters;
+
+	// Constructor initializes all values to 0s.
+	// To create a "virtualized" HMDInfo, use CreateDebugHMDInfo instead.
+	HMDInfo() :
+		Version(0),
+		HmdType(HmdType_None),
+		ResolutionInPixels(0),
+		ScreenSizeInMeters(0.0f),
+		ScreenGapSizeInMeters(0.0f),
+		CenterFromTopInMeters(0),
+		LensSeparationInMeters(0),
+		DisplayId(-1),
+		InCompatibilityMode(false)
+	{
+		DesktopX = 0;
+		DesktopY = 0;
+		Shutter.Type = HmdShutter_LAST;
+		Shutter.VsyncToNextVsync = 0.0f;
+		Shutter.VsyncToFirstScanline = 0.0f;
+		Shutter.FirstScanlineToLastScanline = 0.0f;
+		Shutter.PixelSettleTime = 0.0f;
+		Shutter.PixelPersistence = 0.0f;
+
+        CameraFrustumHFovInRadians = 0;
+        CameraFrustumVFovInRadians = 0;
+        CameraFrustumNearZInMeters = 0;
+        CameraFrustumFarZInMeters = 0;
+    }
+
+	// Operator = copies local fields only (base class must be correct already)
+	void operator=(const HMDInfo& src)
+	{
+		ProductName = src.ProductName;
+		Manufacturer = src.Manufacturer;
+		Version = src.Version;
+		HmdType = src.HmdType;
+		ResolutionInPixels = src.ResolutionInPixels;
+		ScreenSizeInMeters = src.ScreenSizeInMeters;
+		ScreenGapSizeInMeters = src.ScreenGapSizeInMeters;
+		CenterFromTopInMeters = src.CenterFromTopInMeters;
+		LensSeparationInMeters = src.LensSeparationInMeters;
+		DesktopX = src.DesktopX;
+		DesktopY = src.DesktopY;
+		Shutter = src.Shutter;
+		DisplayDeviceName = src.DisplayDeviceName;
+		ShimInfo = src.ShimInfo;
+		DisplayId = src.DisplayId;
+		InCompatibilityMode = src.InCompatibilityMode;
+        VendorId = src.VendorId;
+        ProductId = src.ProductId;
+        FirmwareMajor = src.FirmwareMajor;
+        FirmwareMinor = src.FirmwareMinor;
+        PrintedSerial = src.PrintedSerial;
+        CameraFrustumHFovInRadians = src.CameraFrustumHFovInRadians;
+        CameraFrustumVFovInRadians = src.CameraFrustumVFovInRadians;
+        CameraFrustumNearZInMeters = src.CameraFrustumNearZInMeters;
+        CameraFrustumFarZInMeters = src.CameraFrustumFarZInMeters;
+    }
+
+	void SetScreenParameters(int hres, int vres,
+							 float hsize, float vsize,
+							 float vCenterFromTopInMeters, float lensSeparationInMeters,
+							 bool compatibilityMode)
+	{
+		ResolutionInPixels = Sizei(hres, vres);
+		ScreenSizeInMeters = Sizef(hsize, vsize);
+		CenterFromTopInMeters = vCenterFromTopInMeters;
+		LensSeparationInMeters = lensSeparationInMeters;
+		InCompatibilityMode = compatibilityMode;
+	}
+
+	bool IsSameDisplay(const HMDInfo& o) const
+	{
+		return DisplayId == o.DisplayId &&
+			DisplayDeviceName.CompareNoCase(o.DisplayDeviceName) == 0;
+	}
+
+	static bool CreateFromSensorAndDisplay(SensorDevice* sensor, Display* display, HMDInfo* hmdi);
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** HmdRenderInfo
+
+// All the parts of the HMD info that are needed to set up the rendering system.
+
+struct HmdRenderInfo
+{
+    // The start of this structure is intentionally very similar to HMDInfo in OVER_Device.h
+    // However to reduce interdependencies, one does not simply #include the other.
+
+    HmdTypeEnum HmdType;
+
+    // Size of the entire screen
+    Size<int>   ResolutionInPixels;
+    Size<float> ScreenSizeInMeters;
+    float       ScreenGapSizeInMeters;
+
+    // Characteristics of the lenses.
+    float       CenterFromTopInMeters;
+    float       LensSeparationInMeters;
+    float       LensDiameterInMeters;
+    float       LensSurfaceToMidplateInMeters;
+    EyeCupType  EyeCups;
+
+    // Timing & shutter data. All values in seconds.
+    struct ShutterInfo
+    {
+        HmdShutterTypeEnum  Type;
+        float               VsyncToNextVsync;                // 1/framerate
+        float               VsyncToFirstScanline;            // for global shutter, vsync->shutter open.
+        float               FirstScanlineToLastScanline;     // for global shutter, will be zero.
+        float               PixelSettleTime;                 // estimated.
+        float               PixelPersistence;                // Full persistence = 1/framerate.
+    }           Shutter;
+
+
+    // These are all set from the user's profile.
+    struct EyeConfig
+    {
+        // Distance from center of eyeball to front plane of lens.
+        float               ReliefInMeters;
+        // Distance from nose (technically, center of Rift) to the middle of the eye.
+        float               NoseToPupilInMeters;
+
+        LensConfig          Distortion;
+    } EyeLeft, EyeRight;
+
+
+    HmdRenderInfo()
+    {
+        HmdType = HmdType_None;
+        ResolutionInPixels.w = 0;
+        ResolutionInPixels.h = 0;
+        ScreenSizeInMeters.w = 0.0f;
+        ScreenSizeInMeters.h = 0.0f;
+        ScreenGapSizeInMeters = 0.0f;
+        CenterFromTopInMeters = 0.0f;
+        LensSeparationInMeters = 0.0f;
+        LensDiameterInMeters = 0.0f;
+        LensSurfaceToMidplateInMeters = 0.0f;
+        Shutter.Type = HmdShutter_LAST;
+        Shutter.VsyncToNextVsync = 0.0f;
+        Shutter.VsyncToFirstScanline = 0.0f;
+        Shutter.FirstScanlineToLastScanline = 0.0f;
+        Shutter.PixelSettleTime = 0.0f;
+        Shutter.PixelPersistence = 0.0f;
+        EyeCups = EyeCup_DK1A;
+        EyeLeft.ReliefInMeters = 0.0f;
+        EyeLeft.NoseToPupilInMeters = 0.0f;
+        EyeLeft.Distortion.SetToIdentity();
+        EyeRight = EyeLeft;
+    }
+
+    // The "center eye" is the position the HMD tracking returns,
+    // and games will also usually use it for audio, aiming reticles, some line-of-sight tests, etc.
+    EyeConfig GetEyeCenter() const
+    {
+        EyeConfig result;
+        result.ReliefInMeters = 0.5f * ( EyeLeft.ReliefInMeters + EyeRight.ReliefInMeters );
+        result.NoseToPupilInMeters = 0.0f;
+        result.Distortion.SetToIdentity();
+        return result;
+    }
+
+};
+
+
+//-----------------------------------------------------------------------------------
+
+// Stateless computation functions, in somewhat recommended execution order.
+// For examples on how to use many of them, see the StereoConfig::UpdateComputedState function.
+
+const float OVR_DEFAULT_EXTRA_EYE_ROTATION = 30.0f * MATH_FLOAT_DEGREETORADFACTOR;
+
+// Creates a dummy debug HMDInfo matching a particular HMD model.
+// Useful for development without an actual HMD attached.
+HMDInfo             CreateDebugHMDInfo(HmdTypeEnum hmdType);
+
+
+// profile may be NULL, in which case it uses the hard-coded defaults.
+// distortionType should be left at the default unless you require something specific for your distortion shaders.
+// eyeCupOverride can be EyeCup_LAST, in which case it uses the one in the profile.
+HmdRenderInfo       GenerateHmdRenderInfoFromHmdInfo ( HMDInfo const &hmdInfo,
+                                                       Profile const *profile = NULL,
+                                                       DistortionEqnType distortionType = Distortion_CatmullRom10,
+                                                       EyeCupType eyeCupOverride = EyeCup_LAST );
+
+LensConfig          GenerateLensConfigFromEyeRelief ( float eyeReliefInMeters, HmdRenderInfo const &hmd,
+                                                      DistortionEqnType distortionType = Distortion_CatmullRom10 );
+
+DistortionRenderDesc CalculateDistortionRenderDesc ( StereoEye eyeType, HmdRenderInfo const &hmd,
+                                                     LensConfig const *pLensOverride = NULL );
+
+FovPort             CalculateFovFromEyePosition ( float eyeReliefInMeters,
+                                                  float offsetToRightInMeters,
+                                                  float offsetDownwardsInMeters,
+                                                  float lensDiameterInMeters,
+                                                  float extraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION);
+
+FovPort             CalculateFovFromHmdInfo ( StereoEye eyeType,
+                                              DistortionRenderDesc const &distortion,
+                                              HmdRenderInfo const &hmd,
+                                              float extraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION );
+
+FovPort             GetPhysicalScreenFov ( StereoEye eyeType, DistortionRenderDesc const &distortion );
+
+FovPort             ClampToPhysicalScreenFov ( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                               FovPort inputFovPort );
+
+Sizei               CalculateIdealPixelSize ( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                              FovPort fov, float pixelsPerDisplayPixel );
+
+Recti               GetFramebufferViewport ( StereoEye eyeType, HmdRenderInfo const &hmd );
+
+Matrix4f            CreateProjection ( bool rightHanded, FovPort fov,
+                                       float zNear = 0.01f, float zFar = 10000.0f );
+
+Matrix4f            CreateOrthoSubProjection ( bool rightHanded, StereoEye eyeType,
+                                               float tanHalfFovX, float tanHalfFovY,
+                                               float unitsX, float unitsY, float distanceFromCamera,
+                                               float interpupillaryDistance, Matrix4f const &projection,
+                                               float zNear = 0.0f, float zFar = 0.0f );
+
+ScaleAndOffset2D    CreateNDCScaleAndOffsetFromFov ( FovPort fov );
+
+ScaleAndOffset2D    CreateUVScaleAndOffsetfromNDCScaleandOffset ( ScaleAndOffset2D scaleAndOffsetNDC,
+                                                                  Recti renderedViewport,
+                                                                  Sizei renderTargetSize );
+
+
+//-----------------------------------------------------------------------------------
+// ***** StereoEyeParams
+
+// StereoEyeParams describes RenderDevice configuration needed to render
+// the scene for one eye. 
+struct StereoEyeParams
+{
+    StereoEye               Eye;
+    Matrix4f                ViewAdjust;             // Translation to be applied to view matrix.
+
+    // Distortion and the VP on the physical display - the thing to run the distortion shader on.
+    DistortionRenderDesc    Distortion;
+    Recti                   DistortionViewport;
+
+    // Projection and VP of a particular view (you could have multiple of these).
+    Recti                   RenderedViewport;       // Viewport that we render the standard scene to.
+    FovPort                 Fov;                    // The FOVs of this scene.
+    Matrix4f                RenderedProjection;     // Projection matrix used with this eye.
+    ScaleAndOffset2D        EyeToSourceNDC;         // Mapping from TanEyeAngle space to [-1,+1] on the rendered image.
+    ScaleAndOffset2D        EyeToSourceUV;          // Mapping from TanEyeAngle space to actual texture UV coords.
+};
+
+
+//-----------------------------------------------------------------------------------
+// A set of "forward-mapping" functions, mapping from framebuffer space to real-world and/or texture space.
+Vector2f TransformScreenNDCToTanFovSpace ( DistortionRenderDesc const &distortion,
+                                           const Vector2f &framebufferNDC );
+void TransformScreenNDCToTanFovSpaceChroma ( Vector2f *resultR, Vector2f *resultG, Vector2f *resultB, 
+                                             DistortionRenderDesc const &distortion,
+                                             const Vector2f &framebufferNDC );
+Vector2f TransformTanFovSpaceToRendertargetTexUV ( ScaleAndOffset2D const &eyeToSourceUV,
+                                                   Vector2f const &tanEyeAngle );
+Vector2f TransformTanFovSpaceToRendertargetNDC ( ScaleAndOffset2D const &eyeToSourceNDC,
+                                                 Vector2f const &tanEyeAngle );
+Vector2f TransformScreenPixelToScreenNDC( Recti const &distortionViewport,
+                                          Vector2f const &pixel );
+Vector2f TransformScreenPixelToTanFovSpace ( Recti const &distortionViewport,
+                                             DistortionRenderDesc const &distortion,
+                                             Vector2f const &pixel );
+Vector2f TransformScreenNDCToRendertargetTexUV( DistortionRenderDesc const &distortion,
+                                                StereoEyeParams const &eyeParams,
+                                                Vector2f const &pixel );
+Vector2f TransformScreenPixelToRendertargetTexUV( Recti const &distortionViewport,
+                                                  DistortionRenderDesc const &distortion,
+                                                  StereoEyeParams const &eyeParams,
+                                                  Vector2f const &pixel );
+
+// A set of "reverse-mapping" functions, mapping from real-world and/or texture space back to the framebuffer.
+// Be aware that many of these are significantly slower than their forward-mapping counterparts.
+Vector2f TransformTanFovSpaceToScreenNDC( DistortionRenderDesc const &distortion,
+                                          const Vector2f &tanEyeAngle, bool usePolyApprox = false );
+Vector2f TransformRendertargetNDCToTanFovSpace( const ScaleAndOffset2D &eyeToSourceNDC,
+                                                const Vector2f &textureNDC );
+
+// Handy wrappers.
+inline Vector2f TransformTanFovSpaceToRendertargetTexUV ( StereoEyeParams const &eyeParams,
+                                                          Vector2f const &tanEyeAngle )
+{
+    return TransformTanFovSpaceToRendertargetTexUV ( eyeParams.EyeToSourceUV, tanEyeAngle );
+}
+inline Vector2f TransformTanFovSpaceToRendertargetNDC ( StereoEyeParams const &eyeParams,
+                                                        Vector2f const &tanEyeAngle )
+{
+    return TransformTanFovSpaceToRendertargetNDC ( eyeParams.EyeToSourceNDC, tanEyeAngle );
+}
+
+} //namespace OVR
+
+#endif // OVR_Stereo_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Sensors/OVR_DeviceConstants.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Sensors/OVR_DeviceConstants.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,182 @@
+/************************************************************************************
+
+Filename    :   OVR_DeviceConstants.h
+Content     :   Device constants
+Created     :   February 5, 2013
+Authors     :   Lee Cooper
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_DeviceConstants_h
+#define OVR_DeviceConstants_h
+
+#include "../Kernel/OVR_Math.h"
+
+// CAPI forward declarations.
+struct ovrSensorData_;
+typedef struct ovrSensorData_ ovrSensorData;
+
+namespace OVR {
+
+
+//-------------------------------------------------------------------------------------
+// Different device types supported by OVR; this type is reported by DeviceBase::GetType.
+// 
+enum DeviceType
+{
+    Device_None,
+    Device_Manager,
+    Device_Sensor,
+    Device_LatencyTester,
+    Device_BootLoader,
+    Device_All              = 0xFF // Set for enumeration only, to enumerate all device types.
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// Different lens distortion types supported by devices.
+// 
+enum DistortionEqnType
+{
+    Distortion_No_Override  = -1,    
+	// These two are leagcy and deprecated.
+    Distortion_Poly4        = 0,    // scale = (K0 + K1*r^2 + K2*r^4 + K3*r^6)
+    Distortion_RecipPoly4   = 1,    // scale = 1/(K0 + K1*r^2 + K2*r^4 + K3*r^6)
+
+    // CatmullRom10 is the preferred distortion format.
+    Distortion_CatmullRom10 = 2,    // scale = Catmull-Rom spline through points (1.0, K[1]...K[9])
+
+    Distortion_LAST                 // For ease of enumeration.
+};
+
+
+//-------------------------------------------------------------------------------------
+// HMD types.
+//
+enum HmdTypeEnum
+{
+    HmdType_None,
+
+    HmdType_DKProto,            // First duct-tape model, never sold.
+    HmdType_DK1,                // DevKit1 - on sale to developers.
+    HmdType_DKHDProto,          // DKHD - shown at various shows, never sold.
+    HmdType_DKHD2Proto,         // DKHD2, 5.85-inch panel, never sold.
+    HmdType_DKHDProto566Mi,     // DKHD, 5.66-inch panel, never sold.
+    HmdType_CrystalCoveProto,   // Crystal Cove, 5.66-inch panel, shown at shows but never sold.
+    HmdType_DK2,
+
+    // Reminder - this header file is public - codenames only!
+
+    HmdType_Unknown,            // Used for unnamed HW lab experiments.
+
+    HmdType_LAST
+};
+
+
+//-------------------------------------------------------------------------------------
+// HMD shutter types.
+//
+enum HmdShutterTypeEnum
+{
+    HmdShutter_Global,
+    HmdShutter_RollingTopToBottom,
+    HmdShutter_RollingLeftToRight,
+    HmdShutter_RollingRightToLeft,
+    // TODO:
+    // color-sequential e.g. LCOS?
+    // alternate eyes?
+    // alternate columns?
+    // outside-in?
+
+    HmdShutter_LAST
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// For headsets that use eye cups
+//
+enum EyeCupType
+{
+    // Public lenses
+    EyeCup_DK1A = 0,
+    EyeCup_DK1B = 1,
+    EyeCup_DK1C = 2,
+
+    EyeCup_DK2A = 3,
+
+    // Internal R&D codenames.
+    // Reminder - this header file is public - codenames only!
+    EyeCup_DKHD2A,
+    EyeCup_OrangeA,
+    EyeCup_RedA,
+    EyeCup_PinkA,
+    EyeCup_BlueA,
+    EyeCup_Delilah1A,
+    EyeCup_Delilah2A,
+    EyeCup_JamesA,
+    EyeCup_SunMandalaA,
+
+    EyeCup_LAST
+};
+
+
+//-----------------------------------------------------------------------------
+// BodyFrameState
+//
+#pragma pack(push, 8)
+
+class SensorDataType
+{
+public:
+
+    SensorDataType() : Temperature(0.0f), AbsoluteTimeSeconds(0.0) { }
+
+    // C-interop support
+    SensorDataType(const ovrSensorData& s);
+    operator ovrSensorData () const;
+
+    Vector3f Acceleration;     // in m/s^2
+    Vector3f RotationRate;     // in rad/s
+    Vector3f MagneticField;    // in Gauss
+
+    float    Temperature;      // in degrees Celsius
+
+    // The absolute time from the host computers perspective that the message should be
+    // interpreted as. This is based on incoming timestamp and processed by a filter
+    // that syncs the clocks while attempting to keep the distance between messages
+    // device clock matching.
+    //
+    // Integration should use TimeDelta, but prediction into the future should derive
+    // the delta time from PredictToSeconds - AbsoluteTimeSeconds.
+    //
+    // This value will generally be <= the return from a call to ovr_GetTimeInSeconds(),
+    // but could be greater by under 1 ms due to system time update interrupt delays.
+    //
+    double   AbsoluteTimeSeconds;
+};
+
+#pragma pack(pop)
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,719 @@
+/************************************************************************************
+
+Filename    :   Service_NetClient.cpp
+Content     :   Client for service interface
+Created     :   June 12, 2014
+Authors     :   Michael Antonov, Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "Service_NetClient.h"
+#include "../Net/OVR_MessageIDTypes.h"
+
+OVR_DEFINE_SINGLETON(OVR::Service::NetClient);
+
+namespace OVR { namespace Service {
+
+using namespace OVR::Net;
+
+
+//// NetClient
+
+NetClient::NetClient() :
+    LatencyTesterAvailable(false)
+{
+    GetSession()->AddSessionListener(this);
+
+    // Register RPC functions
+    registerRPC();
+
+    Start();
+
+    PushDestroyCallbacks();
+}
+
+NetClient::~NetClient()
+{
+}
+
+void NetClient::OnSystemDestroy()
+{
+    onSystemDestroy();
+}
+
+void NetClient::OnThreadDestroy()
+{
+    onThreadDestroy();
+}
+
+int NetClient::Run()
+{
+    SetThreadName("NetClient");
+
+    while (!Terminated)
+    {
+        if (GetSession()->GetActiveSocketsCount()==0)
+            Thread::MSleep(10);
+
+        GetSession()->Poll(false);
+    }
+
+    return 0;
+}
+
+void NetClient::OnReceive(ReceivePayload* pPayload, ListenerReceiveResult* lrrOut)
+{
+    OVR_UNUSED(lrrOut);
+    OVR_UNUSED(pPayload);
+
+}
+
+void NetClient::OnDisconnected(Connection* conn)
+{
+    OVR_UNUSED(conn);
+
+    OVR_DEBUG_LOG(("[NetClient] Disconnected"));
+}
+
+void NetClient::OnConnectionAttemptFailed(Net::Connection* conn)
+{
+    OVR_UNUSED(conn);
+
+    OVR_DEBUG_LOG(("[NetClient] OnConnectionAttemptFailed"));
+}
+
+void NetClient::OnConnected(Connection* conn)
+{
+    OVR_UNUSED(conn);
+
+    OVR_DEBUG_LOG(("[NetClient] Connected to a server running version %d.%d.%d (my version=%d.%d.%d)",
+        conn->RemoteMajorVersion, conn->RemoteMinorVersion, conn->RemotePatchVersion,
+        RPCVersion_Major, RPCVersion_Minor, RPCVersion_Patch));
+}
+
+bool NetClient::Connect()
+{
+    // Set up bind parameters
+	OVR::Net::BerkleyBindParameters bbp;
+	bbp.Address = "::1"; // Bind to localhost only!
+    bbp.blockingTimeout = 5000;
+	OVR::Net::SockAddr sa;
+	sa.Set("::1", VRServicePort, SOCK_STREAM);
+
+    // Attempt to connect
+    return GetSession()->ConnectPTCP(&bbp, &sa, true) == Net::SessionResult_OK;
+}
+
+void NetClient::Disconnect()
+{
+    GetSession()->Shutdown();
+}
+
+bool NetClient::IsConnected(bool attemptReconnect)
+{
+    // If it was able to connect,
+    if (GetSession()->GetConnectionCount() > 0)
+    {
+        return true;
+    }
+    else if (attemptReconnect)
+    {
+        // Attempt to connect here
+        Connect();
+
+        // If it connected,
+        if (GetSession()->GetConnectionCount() > 0)
+        {
+            return true;
+        }
+    }
+
+    // No connections
+    return false;
+}
+
+void NetClient::GetLocalProtocolVersion(int& major, int& minor, int& patch)
+{
+    major = RPCVersion_Major;
+    minor = RPCVersion_Minor;
+    patch = RPCVersion_Patch;
+}
+
+bool NetClient::GetRemoteProtocolVersion(int& major, int& minor, int& patch)
+{
+    Ptr<Connection> conn = GetSession()->GetConnectionAtIndex(0);
+
+    if (conn)
+    {
+        major = conn->RemoteMajorVersion;
+        minor = conn->RemoteMinorVersion;
+        patch = conn->RemotePatchVersion;
+        return true;
+    }
+
+    return false;
+}
+
+
+//// NetClient API
+
+const char* NetClient::GetStringValue(VirtualHmdId hmd, const char* key, const char* default_val)
+{
+    if (!IsConnected(true))
+        return "";
+
+    ProfileGetValue1_Str = default_val;
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+    bsOut.Write(default_val);
+    if (!GetRPC1()->CallBlocking("GetStringValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+    }
+    if (!returnData.Read(ProfileGetValue1_Str))
+    {
+        OVR_ASSERT(false);
+    }
+    return ProfileGetValue1_Str.ToCStr();
+}
+bool NetClient::GetBoolValue(VirtualHmdId hmd, const char* key, bool default_val)
+{
+    if (!IsConnected(true))
+        return default_val;
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+    bsOut.Write(default_val);
+    if (!GetRPC1()->CallBlocking("GetBoolValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+    }
+    uint8_t out = 0;
+    if (!returnData.Read(out))
+    {
+        OVR_ASSERT(false);
+    }
+    return out != 0;
+}
+int NetClient::GetIntValue(VirtualHmdId hmd, const char* key, int default_val)
+{
+    if (!IsConnected(true))
+        return default_val;
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+    bsOut.Write(default_val);
+    if (!GetRPC1()->CallBlocking("GetIntValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+    }
+    int32_t out = (int32_t)default_val;
+    if (!returnData.Read(out))
+    {
+        OVR_ASSERT(false);
+    }
+    return out;
+}
+double NetClient::GetNumberValue(VirtualHmdId hmd, const char* key, double default_val)
+{
+    if (!IsConnected(true))
+        return default_val;
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+    bsOut.Write(default_val);
+    if (!GetRPC1()->CallBlocking("GetNumberValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+    }
+    double out = 0.;
+    returnData.Read(out);
+    return out;
+}
+int NetClient::GetNumberValues(VirtualHmdId hmd, const char* key, double* values, int num_vals)
+{
+    if (!IsConnected(true))
+        return 0;
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    int32_t w = (int32_t)num_vals;
+    bsOut.Write(w);
+
+    if (!GetRPC1()->CallBlocking("GetNumberValues_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+    }
+
+    int32_t out = 0;
+    if (!returnData.Read(out))
+    {
+        OVR_ASSERT(false);
+    }
+    OVR_ASSERT(out >= 0 && out <= num_vals);
+    if (out < 0)
+    {
+        out = 0;
+    }
+    else if (out > num_vals)
+    {
+        out = num_vals;
+    }
+
+    for (int i = 0; i < out && i < num_vals; i++)
+    {
+        if (!returnData.Read(values[i]))
+        {
+            return i;
+        }
+    }
+
+    return out;
+}
+void NetClient::SetStringValue(VirtualHmdId hmd, const char* key, const char* val)
+{
+    if (!IsConnected(true))
+        return;
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    bsOut.Write(val);
+
+    if (!GetRPC1()->Signal("SetStringValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+void NetClient::SetBoolValue(VirtualHmdId hmd, const char* key, bool val)
+{
+    if (!IsConnected(true))
+        return;
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    uint8_t b = val ? 1 : 0;
+    bsOut.Write(b);
+
+    if (!GetRPC1()->Signal("SetBoolValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+void NetClient::SetIntValue(VirtualHmdId hmd, const char* key, int val)
+{
+    if (!IsConnected(true))
+        return;
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    int32_t w = (int32_t)val;
+    bsOut.Write(w);
+
+    if (!GetRPC1()->Signal("SetIntValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+void NetClient::SetNumberValue(VirtualHmdId hmd, const char* key, double val)
+{
+    if (!IsConnected(true))
+        return;
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    bsOut.Write(val);
+
+    if (!GetRPC1()->Signal("SetNumberValue_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+void NetClient::SetNumberValues(VirtualHmdId hmd, const char* key, const double* vals, int num_vals)
+{
+    if (!IsConnected(true))
+    {
+        return;
+    }
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+    bsOut.Write(key);
+
+    int32_t w_count = (int32_t)num_vals;
+    bsOut.Write(w_count);
+
+    for (int i = 0; i < num_vals; i++)
+    {
+        bsOut.Write(vals[i]);
+    }
+
+    if (!GetRPC1()->Signal("SetNumberValues_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+
+int NetClient::Hmd_Detect()
+{
+    if (!IsConnected(true))
+    {
+        return 0;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+
+	if (!GetRPC1()->CallBlocking("Hmd_Detect_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return 0;
+	}
+
+    int32_t out = 0;
+    if (!returnData.Read(out))
+    {
+        OVR_ASSERT(false);
+    }
+	return out;
+}
+
+bool NetClient::Hmd_Create(int index, HMDNetworkInfo* netInfo)
+{
+    if (!IsConnected(true))
+    {
+        return false;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+
+    int32_t w = (int32_t)index;
+	bsOut.Write(w);
+
+#ifdef OVR_OS_WIN32
+    // Need the Pid for driver mode
+    DWORD pid = GetCurrentProcessId();
+    bsOut.Write(pid);
+#endif
+
+	if (!GetRPC1()->CallBlocking("Hmd_Create_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return false;
+	}
+
+	return netInfo->Deserialize(&returnData);
+}
+
+void NetClient::Hmd_AttachToWindow(VirtualHmdId hmd, void* hWindow)
+{
+    if (!IsConnected())
+        return;
+
+    OVR::Net::BitStream bsOut;
+    bsOut.Write(hmd);
+
+    UInt64 hWinWord = (UPInt)hWindow;
+    bsOut.Write(hWinWord);
+
+    if (!GetRPC1()->CallBlocking("Hmd_AttachToWindow_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+    {
+        OVR_ASSERT(false);
+    }
+}
+
+void NetClient::Hmd_Release(VirtualHmdId hmd)
+{
+	if (!IsConnected())
+		return;
+
+	OVR::Net::BitStream bsOut;
+	bsOut.Write(hmd);
+	if (!GetRPC1()->CallBlocking("Hmd_Release_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+	{
+		OVR_ASSERT(false);
+	}
+}
+
+// Last string is cached locally.
+const char* NetClient::Hmd_GetLastError(VirtualHmdId hmd)
+{
+    if (!IsConnected())
+    {
+        return Hmd_GetLastError_Str.ToCStr();
+    }
+
+	OVR::Net::BitStream bsOut;
+	bsOut.Write(hmd);
+	if (!GetRPC1()->CallBlocking("Hmd_GetLastError_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+	{
+		OVR_ASSERT(false);
+		return Hmd_GetLastError_Str.ToCStr();
+	}
+    if (!bsOut.Read(Hmd_GetLastError_Str))
+    {
+        OVR_ASSERT(false);
+    }
+	return Hmd_GetLastError_Str.ToCStr();
+}
+
+
+// Fills in description about HMD; this is the same as filled in by ovrHmd_Create.
+// The actual descriptor is a par
+bool NetClient::Hmd_GetHmdInfo(VirtualHmdId hmd, HMDInfo* hmdInfo)
+{
+    if (!IsConnected())
+    {
+        return false;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+	bsOut.Write(hmd);
+	if (!GetRPC1()->CallBlocking("Hmd_GetHmdInfo_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return false;
+	}
+
+    return NetSessionCommon::DeserializeHMDInfo(&returnData, hmdInfo);
+}
+
+
+//-------------------------------------------------------------------------------------
+unsigned int NetClient::Hmd_GetEnabledCaps(VirtualHmdId hmd)
+{
+	if (!IsConnected())
+    {
+        return 0;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+	bsOut.Write(hmd);
+	if (!GetRPC1()->CallBlocking("Hmd_GetEnabledCaps_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return 0;
+	}
+
+    uint32_t c = 0;
+    if (!returnData.Read(c))
+    {
+        OVR_ASSERT(false);
+    }
+	return c;
+}
+
+// Returns new caps after modification
+unsigned int NetClient::Hmd_SetEnabledCaps(VirtualHmdId hmd, unsigned int hmdCaps)
+{
+	if (!IsConnected())
+    {
+        return 0;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+	bsOut.Write(hmd);
+
+    uint32_t c = (uint32_t)hmdCaps;
+	bsOut.Write(c);
+
+	if (!GetRPC1()->CallBlocking("Hmd_SetEnabledCaps_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return 0;
+	}
+
+    c = 0;
+    if (!returnData.Read(c))
+    {
+        OVR_ASSERT(false);
+    }
+    return c;
+}
+
+
+//-------------------------------------------------------------------------------------
+// *** Tracking Setup
+
+bool NetClient::Hmd_ConfigureTracking(VirtualHmdId hmd, unsigned supportedCaps, unsigned requiredCaps)
+{
+	if (!IsConnected())
+    {
+        return false;
+    }
+
+	OVR::Net::BitStream bsOut, returnData;
+	bsOut.Write(hmd);
+
+    uint32_t w_sc = supportedCaps;
+    bsOut.Write(w_sc);
+    uint32_t w_rc = requiredCaps;
+    bsOut.Write(w_rc);
+
+	if (!GetRPC1()->CallBlocking("Hmd_ConfigureTracking_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+	{
+		OVR_ASSERT(false);
+		return false;
+	}
+
+    uint8_t b;
+    if (!returnData.Read(b))
+    {
+        OVR_ASSERT(false);
+    }
+
+	return b != 0;
+}
+
+
+void NetClient::Hmd_ResetTracking(VirtualHmdId hmd)
+{
+	if (!IsConnected())
+    {
+        return;
+    }
+
+	OVR::Net::BitStream bsOut;
+	bsOut.Write(hmd);
+	if (!GetRPC1()->CallBlocking("Hmd_ResetTracking_1", &bsOut, GetSession()->GetConnectionAtIndex(0)))
+	{
+		OVR_ASSERT(false);
+		return;
+	}
+}
+
+bool NetClient::LatencyUtil_ProcessInputs(double startTestSeconds, unsigned char rgbColorOut[3])
+{
+    if (!IsConnected())
+    {
+        return false;
+    }
+
+    if (!LatencyTesterAvailable)
+    {
+        return false;
+    }
+
+    OVR::Net::BitStream bsOut, returnData;
+    bsOut.Write(startTestSeconds);
+    if (!GetRPC1()->CallBlocking("LatencyUtil_ProcessInputs_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+        return false;
+    }
+
+    uint8_t u;
+    returnData.Read(u);
+    rgbColorOut[0] = u;
+    returnData.Read(u);
+    rgbColorOut[1] = u;
+    if (!returnData.Read(u))
+    {
+        return false;
+    }
+    rgbColorOut[2] = u;
+
+    return true;
+}
+
+const char* NetClient::LatencyUtil_GetResultsString()
+{
+    if (!IsConnected())
+    {
+        return NULL;
+    }
+
+    OVR::Net::BitStream bsOut, returnData;
+    if (!GetRPC1()->CallBlocking("LatencyUtil_GetResultsString_1", &bsOut, GetSession()->GetConnectionAtIndex(0), &returnData))
+    {
+        OVR_ASSERT(false);
+        return NULL;
+    }
+
+    if (!returnData.Read(LatencyUtil_GetResultsString_Str))
+    {
+        OVR_ASSERT(false);
+    }
+
+    return LatencyUtil_GetResultsString_Str.ToCStr();
+}
+
+bool NetClient::ShutdownServer()
+{
+    if (!IsConnected())
+    {
+        return false;
+    }
+
+    OVR::Net::BitStream bsOut;
+    GetRPC1()->BroadcastSignal("Shutdown_1", &bsOut);
+
+    return true;
+}
+
+
+//// Push Notifications:
+
+void NetClient::registerRPC()
+{
+#define RPC_REGISTER_SLOT(observerScope, functionName) \
+    observerScope.SetHandler(OVR::Net::Plugins::RPCSlot::FromMember<NetClient, &NetClient::functionName>(this)); pRPC->RegisterSlot(OVR_STRINGIZE(functionName), observerScope);
+
+    // Register RPC functions:
+    RPC_REGISTER_SLOT(InitialServerStateScope, InitialServerState_1);
+    RPC_REGISTER_SLOT(LatencyTesterAvailableScope, LatencyTesterAvailable_1);
+
+}
+
+void NetClient::InitialServerState_1(BitStream* userData, ReceivePayload* pPayload)
+{
+    LatencyTesterAvailable_1(userData, pPayload);
+}
+
+void NetClient::LatencyTesterAvailable_1(BitStream* userData, ReceivePayload* pPayload)
+{
+    OVR_UNUSED(pPayload);
+
+    uint8_t b = 0;
+    if (!userData->Read(b))
+    {
+        OVR_ASSERT(false);
+        return;
+    }
+
+    LatencyTesterAvailable = (b != 0);
+}
+
+
+
+}} // namespace OVR::Service
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,136 @@
+/************************************************************************************
+
+Filename    :   Service_NetClient.h
+Content     :   Client for service interface
+Created     :   June 12, 2014
+Authors     :   Michael Antonov, Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Service_NetClient_h
+#define OVR_Service_NetClient_h
+
+#include "../Net/OVR_NetworkTypes.h"
+#include "Service_NetSessionCommon.h"
+#include "../Kernel/OVR_System.h"
+#include "../OVR_CAPI.h"
+#include "../Util/Util_Render_Stereo.h"
+
+namespace OVR { namespace Service {
+
+using namespace OVR::Net;
+
+
+//-------------------------------------------------------------------------------------
+// NetClient
+
+class NetClient : public NetSessionCommon,
+                  public Net::Plugins::NetworkPlugin,
+                  public SystemSingletonBase<NetClient>
+{
+    OVR_DECLARE_SINGLETON(NetClient);
+    virtual void OnThreadDestroy();
+
+    // Status
+    bool          LatencyTesterAvailable;
+
+    virtual void OnReceive(Net::ReceivePayload* pPayload, Net::ListenerReceiveResult* lrrOut);
+    virtual void OnDisconnected(Net::Connection* conn);
+    virtual void OnConnected(Net::Connection* conn);
+    virtual void OnConnectionAttemptFailed(Net::Connection* conn);
+
+    virtual int  Run();
+
+public:
+	bool         Connect();
+	bool         IsConnected(bool attemptReconnect = false);
+    void         Disconnect();
+
+    void         GetLocalProtocolVersion(int& major, int& minor, int& patch);
+    // This function may fail if it is not connected
+    bool         GetRemoteProtocolVersion(int& major, int& minor, int& patch);
+
+public:
+    // Key-value storage
+    const char*  GetStringValue(VirtualHmdId hmd, const char* key, const char* default_val);
+    bool         GetBoolValue(VirtualHmdId hmd, const char* key, bool default_val);
+    int          GetIntValue(VirtualHmdId hmd, const char* key, int default_val);
+    double       GetNumberValue(VirtualHmdId hmd, const char* key, double default_val);
+    int          GetNumberValues(VirtualHmdId hmd, const char* key, double* values, int num_vals);
+    void         SetStringValue(VirtualHmdId hmd, const char* key, const char* val);
+    void         SetBoolValue(VirtualHmdId hmd, const char* key, bool val);
+    void         SetIntValue(VirtualHmdId hmd, const char* key, int val);
+    void         SetNumberValue(VirtualHmdId hmd, const char* key, double val);
+    void         SetNumberValues(VirtualHmdId hmd, const char* key, const double* vals, int num_vals);
+
+	int          Hmd_Detect();
+	bool         Hmd_Create(int index, HMDNetworkInfo* netInfo);
+	void         Hmd_Release(VirtualHmdId hmd);
+
+	// Last string is cached locally.
+	const char*  Hmd_GetLastError(VirtualHmdId hmd);
+
+	// TBD: Replace with a function to return internal, original HMDInfo?
+
+	// Fills in description about HMD; this is the same as filled in by ovrHmd_Create.
+	// The actual descriptor is a par
+	bool         Hmd_GetHmdInfo(VirtualHmdId hmd, HMDInfo* hmdInfo);
+
+	//-------------------------------------------------------------------------------------
+	unsigned int Hmd_GetEnabledCaps(VirtualHmdId hmd);
+	// Returns new caps after modification
+	unsigned int Hmd_SetEnabledCaps(VirtualHmdId hmd, unsigned int hmdCaps);
+
+    // Updates driver render target
+    void         Hmd_AttachToWindow(VirtualHmdId hmd, void* hWindow);
+
+	//-------------------------------------------------------------------------------------
+	// *** Tracking Setup
+
+	bool         Hmd_ConfigureTracking(VirtualHmdId hmd, unsigned supportedCaps, unsigned requiredCaps);	
+	void         Hmd_ResetTracking(VirtualHmdId hmd);
+
+	// TBD: Camera frames
+    bool         LatencyUtil_ProcessInputs(double startTestSeconds, unsigned char rgbColorOut[3]);
+    const char*  LatencyUtil_GetResultsString();
+
+    bool         ShutdownServer();
+
+protected:
+    String       Hmd_GetLastError_Str;
+    String       LatencyUtil_GetResultsString_Str;
+    String       ProfileGetValue1_Str, ProfileGetValue3_Str;
+
+protected:
+    //// Push Notifications:
+
+    void registerRPC();
+
+    ObserverScope<OVR::Net::Plugins::RPCSlot>   InitialServerStateScope;
+    void InitialServerState_1(BitStream* userData, ReceivePayload* pPayload);
+
+    ObserverScope<OVR::Net::Plugins::RPCSlot>   LatencyTesterAvailableScope;
+    void LatencyTesterAvailable_1(BitStream* userData, ReceivePayload* pPayload);
+};
+
+
+}} // namespace OVR::Service
+
+#endif // OVR_Service_NetClient_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,304 @@
+/************************************************************************************
+
+Filename    :   Service_NetSessionCommon.cpp
+Content     :   Server for service interface
+Created     :   June 12, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "Service_NetSessionCommon.h"
+#include "../OVR_Stereo.h"
+
+namespace OVR { namespace Service {
+
+
+//// NetSessionCommon
+
+NetSessionCommon::NetSessionCommon() :
+    Terminated(false)
+{
+    pSession = new Net::Session;
+    OVR_ASSERT(pSession != NULL);
+
+    pRPC = new Net::Plugins::RPC1;
+    OVR_ASSERT(pRPC != NULL);
+
+    pSession->AddSessionListener(pRPC);
+}
+
+NetSessionCommon::~NetSessionCommon()
+{
+    if (pSession)
+    {
+        delete pSession;
+        pSession = NULL;
+    }
+    if (pRPC)
+    {
+        delete pRPC;
+        pRPC = NULL;
+    }
+
+    Terminated = true;
+
+    OVR_ASSERT(IsFinished());
+}
+
+void NetSessionCommon::onSystemDestroy()
+{
+    Terminated = true;
+
+    Join();
+
+    Release();
+}
+
+void NetSessionCommon::onThreadDestroy()
+{
+    Terminated = true;
+    if (pSession)
+    {
+        pSession->Shutdown();
+    }
+}
+
+void NetSessionCommon::SerializeHMDInfo(Net::BitStream *bitStream, HMDInfo* hmdInfo)
+{
+    bitStream->Write(hmdInfo->ProductName);
+    bitStream->Write(hmdInfo->Manufacturer);
+
+    int32_t w = hmdInfo->Version;
+    bitStream->Write(w);
+
+    w = hmdInfo->HmdType;
+    bitStream->Write(w);
+
+    w = hmdInfo->ResolutionInPixels.w;
+    bitStream->Write(w);
+
+    w = hmdInfo->ResolutionInPixels.h;
+    bitStream->Write(w);
+
+    w = hmdInfo->ShimInfo.DeviceNumber;
+    bitStream->Write(w);
+
+    w = hmdInfo->ShimInfo.NativeWidth;
+    bitStream->Write(w);
+
+    w = hmdInfo->ShimInfo.NativeHeight;
+    bitStream->Write(w);
+
+    w = hmdInfo->ShimInfo.Rotation;
+    bitStream->Write(w);
+
+    bitStream->Write(hmdInfo->ScreenSizeInMeters.w);
+    bitStream->Write(hmdInfo->ScreenSizeInMeters.h);
+    bitStream->Write(hmdInfo->ScreenGapSizeInMeters);
+    bitStream->Write(hmdInfo->CenterFromTopInMeters);
+    bitStream->Write(hmdInfo->LensSeparationInMeters);
+
+    w = hmdInfo->DesktopX;
+    bitStream->Write(w);
+
+    w = hmdInfo->DesktopY;
+    bitStream->Write(w);
+
+    w = hmdInfo->Shutter.Type;
+    bitStream->Write(w);
+
+    bitStream->Write(hmdInfo->Shutter.VsyncToNextVsync);
+    bitStream->Write(hmdInfo->Shutter.VsyncToFirstScanline);
+    bitStream->Write(hmdInfo->Shutter.FirstScanlineToLastScanline);
+    bitStream->Write(hmdInfo->Shutter.PixelSettleTime);
+    bitStream->Write(hmdInfo->Shutter.PixelPersistence);
+    bitStream->Write(hmdInfo->DisplayDeviceName);
+
+    w = hmdInfo->DisplayId;
+    bitStream->Write(w);
+
+    bitStream->Write(hmdInfo->PrintedSerial);
+
+    uint8_t b = hmdInfo->InCompatibilityMode ? 1 : 0;
+    bitStream->Write(b);
+
+    w = hmdInfo->VendorId;
+    bitStream->Write(w);
+
+    w = hmdInfo->ProductId;
+    bitStream->Write(w);
+
+    bitStream->Write(hmdInfo->CameraFrustumFarZInMeters);
+    bitStream->Write(hmdInfo->CameraFrustumHFovInRadians);
+    bitStream->Write(hmdInfo->CameraFrustumNearZInMeters);
+    bitStream->Write(hmdInfo->CameraFrustumVFovInRadians);
+
+    w = hmdInfo->FirmwareMajor;
+    bitStream->Write(w);
+
+    w = hmdInfo->FirmwareMinor;
+    bitStream->Write(w);
+}
+
+bool NetSessionCommon::DeserializeHMDInfo(Net::BitStream *bitStream, HMDInfo* hmdInfo)
+{
+    bitStream->Read(hmdInfo->ProductName);
+    bitStream->Read(hmdInfo->Manufacturer);
+
+    int32_t w = 0;
+    if (!bitStream->Read(w))
+    {
+        // This indicates that no HMD could be found
+        return false;
+    }
+    hmdInfo->Version = w;
+
+    bitStream->Read(w);
+    hmdInfo->HmdType = (HmdTypeEnum)w;
+
+    bitStream->Read(w);
+    hmdInfo->ResolutionInPixels.w = w;
+
+    bitStream->Read(w);
+    hmdInfo->ResolutionInPixels.h = w;
+
+    bitStream->Read(w);
+    hmdInfo->ShimInfo.DeviceNumber = w;
+
+    bitStream->Read(w);
+    hmdInfo->ShimInfo.NativeWidth = w;
+
+    bitStream->Read(w);
+    hmdInfo->ShimInfo.NativeHeight = w;
+
+    bitStream->Read(w);
+    hmdInfo->ShimInfo.Rotation = w;
+
+    bitStream->Read(hmdInfo->ScreenSizeInMeters.w);
+    bitStream->Read(hmdInfo->ScreenSizeInMeters.h);
+    bitStream->Read(hmdInfo->ScreenGapSizeInMeters);
+    bitStream->Read(hmdInfo->CenterFromTopInMeters);
+    bitStream->Read(hmdInfo->LensSeparationInMeters);
+
+    bitStream->Read(w);
+    hmdInfo->DesktopX = w;
+
+    bitStream->Read(w);
+    hmdInfo->DesktopY = w;
+
+    bitStream->Read(w);
+    hmdInfo->Shutter.Type = (HmdShutterTypeEnum)w;
+
+    bitStream->Read(hmdInfo->Shutter.VsyncToNextVsync);
+    bitStream->Read(hmdInfo->Shutter.VsyncToFirstScanline);
+    bitStream->Read(hmdInfo->Shutter.FirstScanlineToLastScanline);
+    bitStream->Read(hmdInfo->Shutter.PixelSettleTime);
+    bitStream->Read(hmdInfo->Shutter.PixelPersistence);
+    bitStream->Read(hmdInfo->DisplayDeviceName);
+
+    bitStream->Read(w);
+    hmdInfo->DisplayId = w;
+
+    bitStream->Read(hmdInfo->PrintedSerial);
+
+    uint8_t b = 0;
+    bitStream->Read(b);
+    hmdInfo->InCompatibilityMode = (b != 0);
+
+    bitStream->Read(w);
+    hmdInfo->VendorId = w;
+
+    bitStream->Read(w);
+    hmdInfo->ProductId = w;
+
+    bitStream->Read(hmdInfo->CameraFrustumFarZInMeters);
+    bitStream->Read(hmdInfo->CameraFrustumHFovInRadians);
+    bitStream->Read(hmdInfo->CameraFrustumNearZInMeters);
+    bitStream->Read(hmdInfo->CameraFrustumVFovInRadians);
+
+    bitStream->Read(w);
+    hmdInfo->FirmwareMajor = w;
+
+    if (!bitStream->Read(w))
+    {
+        OVR_ASSERT(false);
+        return false;
+    }
+    hmdInfo->FirmwareMinor = w;
+
+    return true;
+}
+
+// Prefix key names with this to pass through to server
+static const char* BypassPrefix = "server:";
+
+static const char* KeyNames[][NetSessionCommon::ENumTypes] = {
+    /* EGetStringValue */ { "CameraSerial", "CameraUUID", 0 },
+    /* EGetBoolValue */ { "ReleaseDK2Sensors", "ReleaseLegacySensors", 0 },
+    /* EGetIntValue */ { 0 },
+    /* EGetNumberValue */{ "CenterPupilDepth", 0 },
+    /* EGetNumberValues */{ "NeckModelVector3f", 0 },
+    /* ESetStringValue */ { 0 },
+    /* ESetBoolValue */ { "ReleaseDK2Sensors", "ReleaseLegacySensors", 0 },
+    /* ESetIntValue */ { 0 },
+    /* ESetNumberValue */{ "CenterPupilDepth", 0 },
+    /* ESetNumberValues */{ "NeckModelVector3f", 0 }
+};
+
+bool IsInStringArray(const char* a[], const char* key)
+{
+    for (int i = 0; a[i]; ++i)
+    {
+        if (OVR_strcmp(a[i], key) == 0)
+            return true;
+    }
+
+    return false;
+}
+
+const char *NetSessionCommon::FilterKeyPrefix(const char* key)
+{
+    // If key starts with BypassPrefix,
+    if (strstr(key, BypassPrefix) == key)
+    {
+        key += strlen(BypassPrefix);
+    }
+
+    return key;
+}
+
+bool NetSessionCommon::IsServiceProperty(EGetterSetters e, const char* key)
+{
+    if ((e >= 0 && e < ENumTypes) && IsInStringArray(KeyNames[e], key))
+    {
+        return true;
+    }
+
+    // If key starts with BypassPrefix,
+    if (strstr(key, BypassPrefix) == key)
+    {
+        return true;
+    }
+
+    return false;
+}
+
+
+}} // namespace OVR::Service
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,142 @@
+/************************************************************************************
+
+Filename    :   Service_NetSessionCommon.h
+Content     :   Shared networking for service
+Created     :   June 12, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Service_NetSessionCommon_h
+#define OVR_Service_NetSessionCommon_h
+
+#include "../OVR_CAPI.h"
+#include "../Net/OVR_RPC1.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Net/OVR_BitStream.h"
+#include "../Kernel/OVR_System.h"
+
+namespace OVR {
+
+class HMDInfo;
+
+namespace Service {
+
+
+//-----------------------------------------------------------------------------
+// VirtualHmdId
+
+// This is an identifier that is unique to each VirtualHmd object on the server
+// side.  The client side uses this to opaquely reference those objects.
+
+typedef int32_t VirtualHmdId;
+static const int32_t InvalidVirtualHmdId = -1;
+
+// Localhost-bound TCP port that the service listens on for VR apps
+static const int VRServicePort = 30322; // 0x7672 = "vr" little-endian
+
+// HMDInfo section related to networking
+struct HMDNetworkInfo
+{
+	HMDNetworkInfo() :
+		NetId(InvalidVirtualHmdId)
+	{
+	}
+
+	// Network identifier for HMD
+	VirtualHmdId NetId;
+
+	// Name of the shared memory object
+	String       SharedMemoryName;
+
+	void Serialize(Net::BitStream* bs)
+	{
+		bs->Write(NetId);
+		bs->Write(SharedMemoryName);
+	}
+	bool Deserialize(Net::BitStream* bs)
+	{
+		bs->Read(NetId);
+		return bs->Read(SharedMemoryName);
+	}
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** NetSessionCommon
+
+// Common part networking session/RPC implementation shared between client and server.
+
+class NetSessionCommon : public Thread
+{
+protected:
+    virtual void onSystemDestroy();
+    virtual void onThreadDestroy();
+
+public:
+    NetSessionCommon();
+    virtual ~NetSessionCommon();
+
+	Net::Plugins::RPC1* GetRPC1() const
+    {
+        return pRPC;
+    }
+	Net::Session* GetSession() const
+    {
+        return pSession;
+    }
+
+	static void SerializeHMDInfo(Net::BitStream* bitStream, HMDInfo* hmdInfo);
+	static bool DeserializeHMDInfo(Net::BitStream* bitStream, HMDInfo* hmdInfo);
+
+public:
+    // Getter/setter tools
+    enum EGetterSetters
+    {
+        // Note: If this enumeration changes, then the Servce_NetSessionCommon.cpp
+        // IsServiceProperty() function should be updated.
+
+        EGetStringValue,
+        EGetBoolValue,
+        EGetIntValue,
+        EGetNumberValue,
+        EGetNumberValues,
+        ESetStringValue,
+        ESetBoolValue,
+        ESetIntValue,
+        ESetNumberValue,
+        ESetNumberValues,
+
+        ENumTypes
+    };
+
+    static const char* FilterKeyPrefix(const char* key);
+    static bool IsServiceProperty(EGetterSetters e, const char* key);
+
+protected:
+    bool                Terminated; // Thread termination flag
+    Net::Session*       pSession;   // Networking session
+	Net::Plugins::RPC1* pRPC;       // Remote procedure calls object
+};
+
+
+}} // namespace OVR::Service
+
+#endif // OVR_Service_NetSessionCommon_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_PoseState.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_PoseState.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,125 @@
+/************************************************************************************
+
+Filename    :   Tracking_PoseState.h
+Content     :   Describes the complete pose at a point in time, including derivatives
+Created     :   May 13, 2014
+Authors     :   Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_PoseState_h
+#define Tracking_PoseState_h
+
+#include "../Kernel/OVR_Math.h"
+
+namespace OVR {
+
+// PoseState describes the complete pose, or a rigid body configuration, at a
+// point in time, including first and second derivatives. It is used to specify
+// instantaneous location and movement of the headset.
+// SensorState is returned as a part of the sensor state.
+
+template<class T>
+class PoseState
+{
+public:
+	typedef typename CompatibleTypes<Pose<T> >::Type CompatibleType;
+
+	PoseState() : TimeInSeconds(0.0) { }
+    PoseState(Pose<T> pose, double time) : TimeInSeconds(time), ThePose(pose) { }
+
+	// float <-> double conversion constructor.
+	explicit PoseState(const PoseState<typename Math<T>::OtherFloatType> &src)
+		: ThePose(src.ThePose),
+		AngularVelocity(src.AngularVelocity), LinearVelocity(src.LinearVelocity),
+		AngularAcceleration(src.AngularAcceleration), LinearAcceleration(src.LinearAcceleration),
+		TimeInSeconds(src.TimeInSeconds)
+	{ }
+
+	// C-interop support: PoseStatef <-> ovrPoseStatef
+	PoseState(const typename CompatibleTypes<PoseState<T> >::Type& src)
+		: ThePose(src.ThePose),
+		AngularVelocity(src.AngularVelocity), LinearVelocity(src.LinearVelocity),
+		AngularAcceleration(src.AngularAcceleration), LinearAcceleration(src.LinearAcceleration),
+		TimeInSeconds(src.TimeInSeconds)
+	{ }
+
+	operator typename CompatibleTypes<PoseState<T> >::Type() const
+	{
+		typename CompatibleTypes<PoseState<T> >::Type result;
+		result.ThePose = ThePose;
+		result.AngularVelocity = AngularVelocity;
+		result.LinearVelocity = LinearVelocity;
+		result.AngularAcceleration = AngularAcceleration;
+		result.LinearAcceleration = LinearAcceleration;
+		result.TimeInSeconds = TimeInSeconds;
+		return result;
+	}
+
+	Pose<T> ThePose;
+	Vector3<T>  AngularVelocity;
+	Vector3<T>  LinearVelocity;
+	Vector3<T>  AngularAcceleration;
+	Vector3<T>  LinearAcceleration;
+	// Absolute time of this state sample; always a double measured in seconds.
+	double      TimeInSeconds;
+
+	// ***** Helpers for Pose integration
+
+	// Stores and integrates gyro angular velocity reading for a given time step.
+	void StoreAndIntegrateGyro(Vector3d angVel, double dt);
+	// Stores and integrates position/velocity from accelerometer reading for a given time step.
+	void StoreAndIntegrateAccelerometer(Vector3d linearAccel, double dt);
+
+	// Performs integration of state by adding next state delta to it
+	// to produce a combined state change
+	void AdvanceByDelta(const PoseState<T>& delta);
+};
+
+
+template<class T>
+PoseState<T> operator*(const OVR::Pose<T>& trans, const PoseState<T>& poseState)
+{
+	PoseState<T> result;
+	result.ThePose = trans * poseState.ThePose;
+	result.LinearVelocity = trans.Rotate(poseState.LinearVelocity);
+	result.LinearAcceleration = trans.Rotate(poseState.LinearAcceleration);
+	result.AngularVelocity = trans.Rotate(poseState.AngularVelocity);
+	result.AngularAcceleration = trans.Rotate(poseState.AngularAcceleration);
+	return result;
+}
+
+
+// External API returns pose as float, but uses doubles internally for quaternion precision.
+typedef PoseState<float>  PoseStatef;
+typedef PoseState<double> PoseStated;
+
+
+} // namespace OVR::Vision
+
+
+namespace OVR {
+
+	template<> struct CompatibleTypes<OVR::PoseState<float> > { typedef ovrPoseStatef Type; };
+	template<> struct CompatibleTypes<OVR::PoseState<double> > { typedef ovrPoseStated Type; };
+
+}
+
+#endif // Tracking_PoseState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorState.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorState.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,182 @@
+/************************************************************************************
+
+Filename    :   Tracking_SensorState.h
+Content     :   Sensor state information shared by tracking system with games
+Created     :   May 13, 2014
+Authors     :   Dov Katz, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_SensorState_h
+#define Tracking_SensorState_h
+
+#include "Tracking_PoseState.h"
+#include "../Kernel/OVR_SharedMemory.h"
+#include "../Kernel/OVR_Lockless.h"
+#include "../Kernel/OVR_String.h"
+#include "../Util/Util_LatencyTest2State.h"
+#include "../Sensors/OVR_DeviceConstants.h"
+
+// CAPI forward declarations.
+struct ovrTrackingState_;
+typedef struct ovrTrackingState_ ovrTrackingState;
+struct ovrPoseStatef_;
+typedef struct ovrPoseStatef_ ovrPoseStatef;
+
+namespace OVR { namespace Tracking {
+
+
+//-------------------------------------------------------------------------------------
+// ***** Sensor State
+// These values are reported as compatible with C API.
+
+// Bit flags describing the current status of sensor tracking.
+enum StatusBits
+{
+    // Tracked bits: Toggled by SensorFusion
+	Status_OrientationTracked = 0x0001, // Orientation is currently tracked (connected and in use)
+	Status_PositionTracked    = 0x0002, // Position is currently tracked (false if out of range)
+    Status_CameraPoseTracked  = 0x0004, // Camera pose is currently tracked
+
+    // Connected bits: Toggled by TrackingManager
+    Status_PositionConnected  = 0x0020, // Position tracking HW is connected
+	Status_HMDConnected       = 0x0080, // HMD is available & connected
+
+    // Masks
+    Status_AllMask = 0xffff,
+    Status_TrackingMask = Status_PositionTracked | Status_OrientationTracked | Status_CameraPoseTracked,
+    Status_ConnectedMask = Status_PositionConnected | Status_HMDConnected,
+};
+
+
+// Full state of of the sensor reported by GetSensorState() at a given absolute time.
+class TrackingState
+{
+public:
+	TrackingState() : StatusFlags(0) { }
+
+	// C-interop support
+	TrackingState(const ovrTrackingState& s);
+	operator ovrTrackingState () const;
+
+	// HMD pose information for the requested time.
+	PoseStatef   HeadPose;
+
+    // Orientation and position of the external camera, if present.
+    Posef        CameraPose;
+    // Orientation and position of the camera after alignment with gravity 
+    Posef        LeveledCameraPose;
+
+    // Most recent sensor data received from the HMD
+    SensorDataType RawSensorData;
+
+    // Sensor status described by ovrStatusBits.
+	uint32_t     StatusFlags;
+};
+
+
+// -----------------------------------------------
+
+#pragma pack(push, 8)
+
+struct LocklessSensorStatePadding;
+
+// State version stored in lockless updater "queue" and used for 
+// prediction by GetPoseAtTime/GetSensorStateAtTime
+struct LocklessSensorState
+{
+	PoseState<double> WorldFromImu;
+    SensorDataType    RawSensorData;
+    Pose<double>      WorldFromCamera;
+	uint32_t          StatusFlags;
+    uint32_t          _PAD_0_;
+
+	// ImuFromCpf for HMD pose tracking
+	Posed             ImuFromCpf;
+
+	// Initialized to invalid state
+	LocklessSensorState() :
+		StatusFlags(0)
+	{
+	}
+
+    LocklessSensorState& operator = (const LocklessSensorStatePadding& rhs);
+};
+
+// Padded out version stored in the updater slots
+// Designed to be a larger fixed size to allow the data to grow in the future
+// without breaking older compiled code.
+struct LocklessSensorStatePadding
+{
+    uint64_t words[64];
+
+    static const int DataWords = (sizeof(LocklessSensorState) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
+
+    // Just copy the low data words
+    inline LocklessSensorStatePadding& operator=(const LocklessSensorState& rhs)
+    {
+        const uint64_t* src = (const uint64_t*)&rhs;
+
+        // if this fires off, then increase words' array size
+        OVR_ASSERT(sizeof(words) > sizeof(LocklessSensorState));
+
+        for (int i = 0; i < DataWords; ++i)
+        {
+            words[i] = src[i];
+        }
+
+        return *this;
+    }
+};
+
+// Just copy the low data words
+inline LocklessSensorState& LocklessSensorState::operator = (const LocklessSensorStatePadding& rhs)
+{
+    uint64_t* dest = (uint64_t*)this;
+
+    for (int i = 0; i < LocklessSensorStatePadding::DataWords; ++i)
+    {
+        dest[i] = rhs.words[i];
+    }
+
+    return *this;
+}
+
+#pragma pack(pop)
+
+// A lockless updater for sensor state
+typedef LocklessUpdater<LocklessSensorState, LocklessSensorStatePadding> SensorStateUpdater;
+
+
+//// Combined state
+
+struct CombinedSharedStateUpdater
+{
+    SensorStateUpdater         SharedSensorState;
+    Util::LockessRecordUpdater SharedLatencyTestState;
+};
+
+typedef SharedObjectWriter< CombinedSharedStateUpdater > CombinedSharedStateWriter;
+typedef SharedObjectReader< CombinedSharedStateUpdater > CombinedSharedStateReader;
+
+
+}} // namespace OVR::Tracking
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,207 @@
+/************************************************************************************
+
+Filename    :   Tracking_SensorStateReader.cpp
+Content     :   Separate reader component that is able to recover sensor pose
+Created     :   June 4, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "Tracking_SensorStateReader.h"
+#include "Tracking_PoseState.h"
+
+namespace OVR { namespace Tracking {
+
+
+//-------------------------------------------------------------------------------------
+
+// This is a "perceptually tuned predictive filter", which means that it is optimized
+// for improvements in the VR experience, rather than pure error.  In particular,
+// jitter is more perceptible at lower speeds whereas latency is more perceptible
+// after a high-speed motion.  Therefore, the prediction interval is dynamically
+// adjusted based on speed.  Significant more research is needed to further improve
+// this family of filters.
+static Pose<double> calcPredictedPose(const PoseState<double>& poseState, double predictionDt)
+{
+	Pose<double> pose = poseState.ThePose;
+	const double linearCoef = 1.0;
+	Vector3d angularVelocity = poseState.AngularVelocity;
+	double angularSpeed = angularVelocity.Length();
+
+	// This could be tuned so that linear and angular are combined with different coefficients
+	double speed = angularSpeed + linearCoef * poseState.LinearVelocity.Length();
+
+	const double slope = 0.2; // The rate at which the dynamic prediction interval varies
+	double candidateDt = slope * speed; // TODO: Replace with smoothstep function
+
+	double dynamicDt = predictionDt;
+
+	// Choose the candidate if it is shorter, to improve stability
+	if (candidateDt < predictionDt)
+	{
+		dynamicDt = candidateDt;
+	}
+
+	if (angularSpeed > 0.001)
+	{
+		pose.Rotation = pose.Rotation * Quatd(angularVelocity, angularSpeed * dynamicDt);
+	}
+
+	pose.Translation += poseState.LinearVelocity * dynamicDt;
+
+	return pose;
+}
+
+
+//// SensorStateReader
+
+SensorStateReader::SensorStateReader() :
+	Updater(NULL),
+    LastLatWarnTime(0.)
+{
+}
+
+void SensorStateReader::SetUpdater(const CombinedSharedStateUpdater* updater)
+{
+	Updater = updater;
+}
+
+void SensorStateReader::RecenterPose()
+{
+	if (!Updater)
+	{
+		return;
+	}
+
+	/*
+		This resets position to center in x, y, z, and resets yaw to center.
+		Other rotation components are not affected.
+	*/
+
+	const LocklessSensorState lstate = Updater->SharedSensorState.GetState();
+
+	Posed worldFromCpf = lstate.WorldFromImu.ThePose * lstate.ImuFromCpf;
+
+	double hmdYaw, hmdPitch, hmdRoll;
+	worldFromCpf.Rotation.GetEulerAngles<Axis_Y, Axis_X, Axis_Z>(&hmdYaw, &hmdPitch, &hmdRoll);
+
+	Posed worldFromCentered(Quatd(Axis_Y, hmdYaw), worldFromCpf.Translation);
+
+	CenteredFromWorld = worldFromCentered.Inverted();
+}
+
+bool SensorStateReader::GetSensorStateAtTime(double absoluteTime, TrackingState& ss) const
+{
+	if (!Updater)
+	{
+        ss.StatusFlags = 0;
+        return false;
+	}
+
+	const LocklessSensorState lstate = Updater->SharedSensorState.GetState();
+
+    // Update time
+	ss.HeadPose.TimeInSeconds = absoluteTime;
+
+	// Update the status flags
+	ss.StatusFlags = lstate.StatusFlags;
+	// If no hardware is connected, override the tracking flags
+	if (0 == (ss.StatusFlags & Status_HMDConnected))
+	{
+		ss.StatusFlags &= ~Status_TrackingMask;
+	}
+	if (0 == (ss.StatusFlags & Status_PositionConnected))
+	{
+		ss.StatusFlags &= ~(Status_PositionTracked | Status_CameraPoseTracked);
+	}
+
+	// If tracking info is invalid,
+    if (0 == (ss.StatusFlags & Status_TrackingMask))
+	{
+        return false;
+	}
+
+	// Delta time from the last available data
+	double pdt = absoluteTime - lstate.WorldFromImu.TimeInSeconds;
+	static const double maxPdt = 0.1;
+
+	// If delta went negative due to synchronization problems between processes or just a lag spike,
+	if (pdt < 0.)
+	{
+		pdt = 0.;
+	}
+	else if (pdt > maxPdt)
+	{
+        if (LastLatWarnTime != lstate.WorldFromImu.TimeInSeconds)
+        {
+            LastLatWarnTime = lstate.WorldFromImu.TimeInSeconds;
+            LogText("[SensorStateReader] Prediction interval too high: %f s, clamping at %f s\n", pdt, maxPdt);
+        }
+		pdt = maxPdt;
+	}
+
+	ss.HeadPose = PoseStatef(lstate.WorldFromImu);
+	// Do prediction logic and ImuFromCpf transformation
+	ss.HeadPose.ThePose = Posef(CenteredFromWorld * calcPredictedPose(lstate.WorldFromImu, pdt) * lstate.ImuFromCpf);
+
+    ss.CameraPose = Posef(CenteredFromWorld * lstate.WorldFromCamera);
+
+    Posed worldFromLeveledCamera = Posed(Quatd(), lstate.WorldFromCamera.Translation);
+    ss.LeveledCameraPose = Posef(CenteredFromWorld * worldFromLeveledCamera);
+
+    ss.RawSensorData = lstate.RawSensorData;
+
+	return true;
+}
+
+bool SensorStateReader::GetPoseAtTime(double absoluteTime, Posef& transform) const
+{
+	TrackingState ss;
+	if (!GetSensorStateAtTime(absoluteTime, ss))
+	{
+		return false;
+	}
+
+	transform = ss.HeadPose.ThePose;
+
+	return true;
+}
+
+uint32_t SensorStateReader::GetStatus() const
+{
+	if (!Updater)
+	{
+		return 0;
+	}
+
+	const LocklessSensorState lstate = Updater->SharedSensorState.GetState();
+
+	// If invalid,
+	if (0 == (lstate.StatusFlags & Status_TrackingMask))
+	{
+		// Return 0 indicating no orientation nor position tracking
+		return 0;
+	}
+
+	return lstate.StatusFlags;
+}
+
+
+}} // namespace OVR::Tracking
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,74 @@
+/************************************************************************************
+
+Filename    :   Tracking_SensorStateReader.h
+Content     :   Separate reader component that is able to recover sensor pose
+Created     :   June 4, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_SensorStateReader_h
+#define Tracking_SensorStateReader_h
+
+#include "../Kernel/OVR_Lockless.h"
+#include "Tracking_SensorState.h"
+
+namespace OVR { namespace Tracking {
+
+
+//-----------------------------------------------------------------------------
+// SensorStateReader
+
+// User interface to retrieve pose from the sensor fusion subsystem
+class SensorStateReader : public NewOverrideBase
+{
+protected:
+	const CombinedSharedStateUpdater *Updater;
+
+	// Transform from real-world coordinates to centered coordinates
+	Posed CenteredFromWorld;
+
+    // Last latency warning time
+    mutable double LastLatWarnTime;
+
+public:
+	SensorStateReader();
+
+	// Initialize the updater
+    void         SetUpdater(const CombinedSharedStateUpdater *updater);
+
+	// Re-centers on the current yaw (optionally pitch) and translation
+	void		 RecenterPose();
+
+	// Get the full dynamical system state of the CPF, which includes velocities and accelerations,
+	// predicted at a specified absolute point in time.
+	bool		 GetSensorStateAtTime(double absoluteTime, Tracking::TrackingState& state) const;
+
+	// Get the predicted pose (orientation, position) of the center pupil frame (CPF) at a specific point in time.
+	bool		 GetPoseAtTime(double absoluteTime, Posef& transform) const;
+
+	// Get the sensor status (same as GetSensorStateAtTime(...).Status)
+	uint32_t     GetStatus() const;
+};
+
+
+}} // namespace OVR::Tracking
+
+#endif // Tracking_SensorStateReader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,529 @@
+/************************************************************************************
+
+Filename    :   Util_ImageWindow.cpp
+Content     :   An output object for windows that can display raw images for testing
+Created     :   March 13, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+#include "../../Include/OVR_Kernel.h"
+
+#include "Util_ImageWindow.h"
+
+#if defined(OVR_OS_WIN32)
+
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+
+#include "DWrite.h"
+
+typedef HRESULT (WINAPI *D2D1CreateFactoryFn)(
+	_In_      D2D1_FACTORY_TYPE,
+	_In_      REFIID,
+	_In_opt_  const D2D1_FACTORY_OPTIONS*,
+	_Out_     ID2D1Factory **
+	);
+
+typedef HRESULT (WINAPI *DWriteCreateFactoryFn)(
+	_In_   DWRITE_FACTORY_TYPE factoryType,
+	_In_   REFIID iid,
+	_Out_  IUnknown **factory
+	);
+
+
+namespace OVR { namespace Util {
+	
+ID2D1Factory* ImageWindow::pD2DFactory = NULL;
+IDWriteFactory* ImageWindow::pDWriteFactory = NULL;
+
+
+// TODO(review): This appears to be (at present) necessary, the global list is accessed by the
+// render loop in Samples.  In the current version, windows will just be lost when windowCount
+// exceeds MaxWindows; I've left that in place, since this is unfamiliar code. I'm not sure what
+// thread-safety guarantees this portion of the code needs to satisfy, so I don't want to
+// change it to a list or whatever.  Asserts added to catch the error.
+ImageWindow* ImageWindow::globalWindow[ImageWindow::MaxWindows];
+int ImageWindow::windowCount = 0;
+
+LRESULT CALLBACK MainWndProc(
+	HWND hwnd,
+	UINT uMsg,
+	WPARAM wParam,
+	LPARAM lParam)
+{
+	switch (uMsg) 
+	{ 
+	case WM_CREATE: 
+		return 0; 
+
+	case WM_PAINT: 
+		{
+			LONG_PTR ptr = GetWindowLongPtr( hwnd, GWLP_USERDATA );
+			if( ptr )
+			{
+				ImageWindow* iw = (ImageWindow*)ptr;
+				iw->OnPaint();
+			}
+		}
+		
+		return 0; 
+
+	case WM_SIZE: 
+		// Set the size and position of the window. 
+		return 0; 
+
+	case WM_DESTROY: 
+		// Clean up window-specific data objects. 
+		return 0; 
+
+		// 
+		// Process other messages. 
+		// 
+
+	default: 
+		return DefWindowProc(hwnd, uMsg, wParam, lParam); 
+	} 
+	//return 0; 
+}
+
+ImageWindow::ImageWindow( uint32_t width, uint32_t height ) :
+	frontBufferMutex( new Mutex() )
+{
+
+	HINSTANCE hInst = LoadLibrary( L"d2d1.dll" );
+	HINSTANCE hInstWrite = LoadLibrary( L"Dwrite.dll" );
+
+	D2D1CreateFactoryFn createFactory = NULL;
+	DWriteCreateFactoryFn writeFactory = NULL;
+
+	if( hInst )
+	{
+		createFactory = (D2D1CreateFactoryFn)GetProcAddress( hInst, "D2D1CreateFactory" );
+	}
+
+	if( hInstWrite )
+	{
+		writeFactory = (DWriteCreateFactoryFn)GetProcAddress( hInstWrite, "DWriteCreateFactory" );
+	}
+
+    // TODO: see note where globalWindow is declared.
+	globalWindow[windowCount++ % MaxWindows] = this;
+    OVR_ASSERT(windowCount < MaxWindows);
+
+	if( pD2DFactory == NULL && createFactory && writeFactory )
+	{
+		createFactory( 
+			D2D1_FACTORY_TYPE_MULTI_THREADED,
+			__uuidof(ID2D1Factory),
+			NULL,
+			&pD2DFactory
+			);
+
+		// Create a DirectWrite factory.
+		writeFactory(
+			DWRITE_FACTORY_TYPE_SHARED,
+			__uuidof(pDWriteFactory),
+			reinterpret_cast<IUnknown **>(&pDWriteFactory)
+			);
+
+	}
+
+	resolution = D2D1::SizeU( width, height );
+
+	SetWindowLongPtr( hWindow, GWLP_USERDATA, (LONG_PTR)this );
+
+	pRT = NULL;
+	greyBitmap = NULL;
+	colorBitmap = NULL;
+}
+
+ImageWindow::~ImageWindow()
+{
+	for( int i = 0; i < MaxWindows; ++i )
+	{
+		if( globalWindow[i] == this )
+		{
+			globalWindow[i] = NULL;
+			break;
+		}
+    }
+
+	if( greyBitmap )
+		greyBitmap->Release();
+
+	if( colorBitmap )
+		colorBitmap->Release();
+
+	if( pRT )
+		pRT->Release();
+
+	{
+		Mutex::Locker locker( frontBufferMutex  );
+
+		while( frames.GetSize() )
+		{
+			Ptr<Frame> aFrame = frames.PopBack();
+		}
+	}
+
+	delete frontBufferMutex;
+
+	ShowWindow( hWindow, SW_HIDE );
+	DestroyWindow( hWindow );
+}
+
+void ImageWindow::AssociateSurface( void* surface )
+{
+	// Assume an IUnknown
+	IUnknown* unknown = (IUnknown*)surface;
+
+	IDXGISurface *pDxgiSurface = NULL;
+	HRESULT hr = unknown->QueryInterface(&pDxgiSurface);
+	if( hr == S_OK )
+	{
+		D2D1_RENDER_TARGET_PROPERTIES props =
+			D2D1::RenderTargetProperties(
+			D2D1_RENDER_TARGET_TYPE_DEFAULT,
+			D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
+			96,
+			96
+			);
+
+
+		pRT = NULL;			
+		ID2D1RenderTarget* tmpTarget;
+
+		hr = pD2DFactory->CreateDxgiSurfaceRenderTarget( pDxgiSurface, &props, &tmpTarget );
+
+		if( hr == S_OK )
+		{
+			DXGI_SURFACE_DESC desc = {0};
+			pDxgiSurface->GetDesc( &desc );
+			int width = desc.Width;
+			int height = desc.Height;
+
+			D2D1_SIZE_U size = D2D1::SizeU( width, height );
+
+			D2D1_PIXEL_FORMAT pixelFormat = D2D1::PixelFormat(
+				DXGI_FORMAT_A8_UNORM,
+				D2D1_ALPHA_MODE_PREMULTIPLIED
+				);
+
+			D2D1_PIXEL_FORMAT colorPixelFormat = D2D1::PixelFormat(
+				DXGI_FORMAT_B8G8R8A8_UNORM,
+				D2D1_ALPHA_MODE_PREMULTIPLIED
+				);
+
+			D2D1_BITMAP_PROPERTIES bitmapProps;
+			bitmapProps.dpiX = 96;
+			bitmapProps.dpiY = 96;
+			bitmapProps.pixelFormat = pixelFormat;
+
+			D2D1_BITMAP_PROPERTIES colorBitmapProps;
+			colorBitmapProps.dpiX = 96;
+			colorBitmapProps.dpiY = 96;
+			colorBitmapProps.pixelFormat = colorPixelFormat;
+
+			HRESULT result = tmpTarget->CreateBitmap( size, bitmapProps, &greyBitmap );
+			if( result != S_OK )
+			{
+				tmpTarget->Release();
+				tmpTarget = NULL;
+			}
+
+			if (tmpTarget)
+			{
+				result = tmpTarget->CreateBitmap(size, colorBitmapProps, &colorBitmap);
+				if (result != S_OK)
+				{
+					tmpTarget->Release();
+					tmpTarget = NULL;
+				}
+			}
+			pRT = tmpTarget;
+		}
+	}
+}
+
+void ImageWindow::Process()
+{
+	if( pRT && greyBitmap )
+	{
+		OnPaint();
+
+		pRT->Flush();
+	}
+}
+
+void ImageWindow::Complete()
+{
+	Mutex::Locker locker( frontBufferMutex  );
+
+	if( frames.IsEmpty() )
+		return;
+
+	if( frames.PeekBack(0)->ready )
+		return;
+
+	Ptr<Frame> frame = frames.PeekBack(0);
+
+	frame->ready = true;
+}
+
+void ImageWindow::OnPaint()
+{
+	Mutex::Locker locker( frontBufferMutex  );
+
+	// Nothing to do
+	if( frames.IsEmpty() )
+		return;
+
+	if( !frames.PeekFront(0)->ready )
+		return;
+
+	Ptr<Frame> currentFrame = frames.PopFront();
+
+	Ptr<Frame> nextFrame = NULL;
+
+	if( !frames.IsEmpty() )
+		nextFrame = frames.PeekFront(0);
+	
+	while( nextFrame && nextFrame->ready )
+	{
+		// Free up the current frame since it's been removed from the deque
+		currentFrame = frames.PopFront();
+
+		if( frames.IsEmpty() )
+			break;
+
+		nextFrame = frames.PeekFront(0);
+	}
+
+	if( currentFrame->imageData )
+		greyBitmap->CopyFromMemory( NULL, currentFrame->imageData, currentFrame->width );
+
+	if( currentFrame->colorImageData )
+		colorBitmap->CopyFromMemory( NULL, currentFrame->colorImageData, currentFrame->colorPitch );
+
+	pRT->BeginDraw();
+
+	pRT->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED); 
+
+	pRT->Clear( D2D1::ColorF(D2D1::ColorF::Black) );
+
+	// This will mirror our image
+	D2D1_MATRIX_3X2_F m;
+	m._11 = -1; m._12 = 0;
+	m._21 = 0; m._22 = 1;
+	m._31 = 0; m._32 = 0;
+	pRT->SetTransform( m );
+
+	ID2D1SolidColorBrush* whiteBrush;
+
+	pRT->CreateSolidColorBrush( D2D1::ColorF(D2D1::ColorF::White, 1.0f), &whiteBrush );
+
+	if( currentFrame->imageData )
+	{
+		pRT->FillOpacityMask( greyBitmap, whiteBrush, 
+			D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL, 
+			D2D1::RectF( -(FLOAT)resolution.width, 0.0f, (FLOAT)0.0f, (FLOAT)resolution.height ), 
+			//D2D1::RectF( 0.0f, 0.0f, (FLOAT)0.0f, (FLOAT)resolution.height ), 
+			D2D1::RectF( 0.0f, 0.0f, (FLOAT)resolution.width, (FLOAT)resolution.height ) );
+	}
+	else if( currentFrame->colorImageData )
+	{
+		pRT->DrawBitmap( colorBitmap,
+			D2D1::RectF( -(FLOAT)resolution.width, 0.0f, (FLOAT)0.0f, (FLOAT)resolution.height ) );
+
+	}
+
+	pRT->SetTransform(D2D1::Matrix3x2F::Identity());
+
+	whiteBrush->Release();
+
+	Array<CirclePlot>::Iterator it;
+
+	for( it = currentFrame->plots.Begin(); it != currentFrame->plots.End(); ++it )
+	{
+		ID2D1SolidColorBrush* aBrush;
+
+		pRT->CreateSolidColorBrush( D2D1::ColorF( it->r, it->g, it->b), &aBrush );
+
+		D2D1_ELLIPSE ellipse;
+		ellipse.point.x = it->x;
+		ellipse.point.y = it->y;
+		ellipse.radiusX = it->radius;
+		ellipse.radiusY = it->radius;
+
+		if( it->fill )
+			pRT->FillEllipse( &ellipse, aBrush );
+		else
+			pRT->DrawEllipse( &ellipse, aBrush );
+
+		aBrush->Release();
+	}
+
+	static const WCHAR msc_fontName[] = L"Verdana";
+	static const FLOAT msc_fontSize = 20;
+
+	IDWriteTextFormat* textFormat = NULL;
+
+	// Create a DirectWrite text format object.
+	pDWriteFactory->CreateTextFormat(
+		msc_fontName,
+		NULL,
+		DWRITE_FONT_WEIGHT_NORMAL,
+		DWRITE_FONT_STYLE_NORMAL,
+		DWRITE_FONT_STRETCH_NORMAL,
+		msc_fontSize,
+		L"", //locale
+		&textFormat
+		);
+
+	D2D1_SIZE_F renderTargetSize = pRT->GetSize();
+
+	Array<TextPlot>::Iterator textIt;
+	for( textIt = currentFrame->textLines.Begin(); textIt != currentFrame->textLines.End(); ++textIt )
+	{
+		ID2D1SolidColorBrush* aBrush;
+
+		pRT->CreateSolidColorBrush( D2D1::ColorF( textIt->r, textIt->g, textIt->b), &aBrush );
+
+		WCHAR* tmpString = (WCHAR*)calloc( textIt->text.GetLength(),  sizeof( WCHAR ) );
+		for( unsigned i = 0; i < textIt->text.GetLength(); ++i )
+		{
+			tmpString[i] = (WCHAR)textIt->text.GetCharAt( i );
+		}
+					
+		pRT->DrawTextW( tmpString, (UINT32)textIt->text.GetLength(), textFormat,
+			D2D1::RectF(textIt->x, textIt->y, renderTargetSize.width, renderTargetSize.height), aBrush );
+
+		free( tmpString );
+
+		aBrush->Release();
+	}
+
+	if( textFormat )
+		textFormat->Release();
+
+	pRT->EndDraw();
+
+	pRT->Flush();
+}
+
+Ptr<Frame> ImageWindow::lastUnreadyFrame()
+{
+	static int framenumber = 0;
+
+	if( frames.GetSize() && !frames.PeekBack( 0 )->ready )
+		return frames.PeekBack( 0 );
+
+	// Create a new frame if an unready one doesn't already exist
+	Ptr<Frame> tmpFrame = *new Frame( framenumber );
+	frames.PushBack( tmpFrame );
+
+	++framenumber;
+
+	return tmpFrame;
+}
+
+void ImageWindow::UpdateImageBW( const uint8_t* imageData, uint32_t width, uint32_t height )
+{
+	if( pRT && greyBitmap )
+	{
+		Mutex::Locker locker( frontBufferMutex );
+
+		Ptr<Frame> frame = lastUnreadyFrame();
+		frame->imageData = malloc( width * height );
+		frame->width = width;
+		frame->height = height;
+		memcpy( frame->imageData, imageData, width * height );
+	}
+}
+
+void ImageWindow::UpdateImageRGBA( const uint8_t* imageData, uint32_t width, uint32_t height, uint32_t pitch )
+{
+	if( pRT && colorBitmap )
+	{
+		Mutex::Locker locker( frontBufferMutex );
+
+		Ptr<Frame> frame = lastUnreadyFrame();
+		frame->colorImageData = malloc( pitch * height );
+		frame->width = width;
+		frame->height = height;
+		frame->colorPitch = pitch;
+		memcpy( frame->colorImageData, imageData, pitch * height );
+	}
+}
+
+void ImageWindow::addCircle( float x, float y, float radius, float r, float g, float b, bool fill )
+{
+	if( pRT )
+	{
+		CirclePlot cp;
+
+		cp.x = x;
+		cp.y = y;
+		cp.radius = radius;
+		cp.r = r;
+		cp.g = g;
+		cp.b = b;
+		cp.fill = fill;
+
+		Mutex::Locker locker( frontBufferMutex );
+
+		Ptr<Frame> frame = lastUnreadyFrame();
+		frame->plots.PushBack( cp );
+	}
+
+}
+
+void ImageWindow::addText( float x, float y, float r, float g, float b, OVR::String text )
+{
+	if( pRT )
+	{
+		TextPlot tp;
+
+		tp.x = x;
+		tp.y = y;
+		tp.r = r;
+		tp.g = g;
+		tp.b = b;
+		tp.text = text;
+
+		Mutex::Locker locker( frontBufferMutex );
+		Ptr<Frame> frame = lastUnreadyFrame();
+		frame->textLines.PushBack( tp );
+	}
+}
+
+}}
+
+#else //defined(OVR_OS_WIN32)
+
+namespace OVR { namespace Util {
+
+ImageWindow* ImageWindow::globalWindow[4];
+int ImageWindow::windowCount = 0;
+
+}}
+
+#endif //#else //defined(OVR_OS_WIN32)
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,201 @@
+/************************************************************************************
+
+Filename    :   Util_ImageWindow.h
+Content     :   An output object for windows that can display raw images for testing
+Created     :   March 13, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef UTIL_IMAGEWINDOW_H
+#define UTIL_IMAGEWINDOW_H
+
+#if defined(OVR_OS_WIN32)
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <d2d1.h>
+#include <dwrite.h>
+#endif
+
+#include "../Kernel/OVR_Hash.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Deque.h"
+
+#include <stdint.h>
+
+namespace OVR { namespace Util {
+
+	typedef struct 
+	{
+		float x;
+		float y;
+		float radius;
+		float r;
+		float g;
+		float b;
+		bool  fill;
+	} CirclePlot;
+
+	typedef struct  
+	{
+		float x;
+		float y;
+		float r;
+		float g;
+		float b;
+	OVR::String text;
+	} TextPlot;
+
+class Frame : virtual public RefCountBaseV<Frame>
+	{
+public:
+
+	Frame( int frame ) :
+		frameNumber( frame ),
+		imageData( NULL ),
+		colorImageData( NULL ),
+		plots(),
+		textLines(),
+		width( 0 ),
+		height( 0 ),
+		colorPitch( 0 ),
+		ready( false )
+	{
+
+	}
+
+	~Frame()
+	{
+		if( imageData )
+			free( imageData );
+		if( colorImageData )
+			free( colorImageData );
+
+		plots.ClearAndRelease();
+		textLines.ClearAndRelease();
+	}
+
+	int						frameNumber;
+
+		Array<CirclePlot> plots;
+	Array<TextPlot>			textLines;
+		void*			  imageData;
+		void*			  colorImageData;
+		int				  width;
+		int				  height;
+		int				  colorPitch;
+		bool			  ready;
+};
+
+#if defined(OVR_OS_WIN32)
+class ImageWindow
+{
+	HWND hWindow;
+	ID2D1RenderTarget* pRT;
+	D2D1_SIZE_U resolution;
+
+	Mutex*						frontBufferMutex;
+
+	InPlaceMutableDeque< Ptr<Frame> >	frames;
+
+	ID2D1Bitmap*				greyBitmap;
+	ID2D1Bitmap*				colorBitmap;
+    
+public:
+	// constructors
+	ImageWindow();
+	ImageWindow( uint32_t width, uint32_t height );
+	virtual ~ImageWindow();
+
+	void GetResolution( size_t& width, size_t& height ) { width = resolution.width; height = resolution.height; }
+
+	void OnPaint(); // Called by Windows when it receives a WM_PAINT message
+
+	void UpdateImage( const uint8_t* imageData, uint32_t width, uint32_t height ) { UpdateImageBW( imageData, width, height ); }
+	void UpdateImageBW( const uint8_t* imageData, uint32_t width, uint32_t height );
+	void UpdateImageRGBA( const uint8_t* imageData, uint32_t width, uint32_t height, uint32_t pitch );
+	void Complete(); // Called by drawing thread to submit a frame
+
+	void Process(); // Called by rendering thread to do window processing
+
+	void AssociateSurface( void* surface );
+
+	void addCircle( float x , float y, float radius, float r, float g, float b, bool fill );
+	void addText( float x, float y, float r, float g, float b, OVR::String text );
+
+	static ImageWindow*			GlobalWindow( int window ) { return globalWindow[window]; }
+	static int					WindowCount() { return windowCount; }
+
+private:
+
+	Ptr<Frame>					lastUnreadyFrame();
+
+	static const int			MaxWindows = 4;
+	static ImageWindow*			globalWindow[MaxWindows];
+	static int					windowCount;
+	static ID2D1Factory*		pD2DFactory;
+	static IDWriteFactory*		pDWriteFactory;
+};
+
+#else
+
+class ImageWindow
+{
+public:
+	// constructors
+	ImageWindow() {}
+	ImageWindow( uint32_t width, uint32_t height ) { OVR_UNUSED( width ); OVR_UNUSED( height ); }
+	virtual ~ImageWindow() { }
+
+	void GetResolution( size_t& width, size_t& height ) { width = 0; height = 0; }
+
+	void OnPaint() { }
+
+	void UpdateImage( const uint8_t* imageData, uint32_t width, uint32_t height ) { UpdateImageBW( imageData, width, height ); }
+	void UpdateImageBW( const uint8_t* imageData, uint32_t width, uint32_t height ) { OVR_UNUSED( imageData ); OVR_UNUSED( width ); OVR_UNUSED( height ); }
+	void UpdateImageRGBA( const uint8_t* imageData, uint32_t width, uint32_t height, uint32_t pitch ) { OVR_UNUSED( imageData ); OVR_UNUSED( width ); OVR_UNUSED( height ); OVR_UNUSED( pitch ); }
+	void Complete() { }
+
+	void Process() { }
+
+	void AssociateSurface( void* surface ) { OVR_UNUSED(surface); }
+
+	void addCircle( float x , float y, float radius, float r, float g, float b, bool fill ) { OVR_UNUSED( x ); OVR_UNUSED( y ); OVR_UNUSED( radius ); OVR_UNUSED( r ); OVR_UNUSED( g ); OVR_UNUSED( b ); OVR_UNUSED( fill ); }
+	void addText( float x, float y, float r, float g, float b, OVR::String text ) { OVR_UNUSED( x ); OVR_UNUSED( y ); OVR_UNUSED( r ); OVR_UNUSED( g ); OVR_UNUSED( b ); OVR_UNUSED( text ); }
+
+	static ImageWindow*			GlobalWindow( int window ) { return globalWindow[window]; }
+	static int					WindowCount() { return windowCount; }
+
+private:
+
+	static const int			MaxWindows = 4;
+	static ImageWindow*			globalWindow[4];
+	static int					windowCount;
+};
+
+#endif
+
+}} // namespace OVR::Util
+
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,34 @@
+/************************************************************************************
+
+Filename    :   Util_Interface.cpp
+Content     :   Simple interface, utilised by internal demos,
+				with access to wider SDK as needed. 
+				Located in the body of the SDK to ensure updated
+				when new SDK features are added.
+Created     :   February 20, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "Util_Interface.h"
+
+
+
+//Files left in to ease its possible return......
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,36 @@
+/************************************************************************************
+
+Filename    :   Util_Interface.h
+Content     :   Simple interface, utilised by internal demos,
+				with access to wider SDK as needed. 
+				Located in the body of the SDK to ensure updated
+				when new SDK features are added.
+Created     :   February 20, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_Interface_h
+#define OVR_Util_Interface_h
+#include "../OVR_CAPI.h"
+
+//Files left in to ease its possible return......
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,118 @@
+/************************************************************************************
+
+Filename    :   Util_LatencyTest2Reader.cpp
+Content     :   Shared functionality for the DK2 latency tester
+Created     :   July 8, 2014
+Authors     :   Volga Aksoy, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "Util_LatencyTest2Reader.h"
+
+namespace OVR { namespace Util {
+
+
+//// FrameTimeRecord
+
+bool FrameTimeRecord::ColorToReadbackIndex(int *readbackIndex, unsigned char color)
+{
+    int compareColor = color - LT2_ColorIncrement/2;
+    int index        = color / LT2_ColorIncrement;  // Use color without subtraction due to rounding.
+    int delta        = compareColor - index * LT2_ColorIncrement;
+
+    if ((delta < LT2_PixelTestThreshold) && (delta > -LT2_PixelTestThreshold))
+    {
+        *readbackIndex = index;
+        return true;
+    }
+    return false;
+}
+
+unsigned char FrameTimeRecord::ReadbackIndexToColor(int readbackIndex)
+{
+    OVR_ASSERT(readbackIndex < LT2_IncrementCount);
+    return (unsigned char)(readbackIndex * LT2_ColorIncrement + LT2_ColorIncrement/2);
+}
+
+
+//// FrameTimeRecordSet
+
+FrameTimeRecordSet::FrameTimeRecordSet()
+{
+    NextWriteIndex = 0;
+    memset(this, 0, sizeof(FrameTimeRecordSet));
+}
+
+void FrameTimeRecordSet::AddValue(int readValue, double timeSeconds)
+{
+    Records[NextWriteIndex].ReadbackIndex = readValue;
+    Records[NextWriteIndex].TimeSeconds = timeSeconds;
+    NextWriteIndex++;
+    if (NextWriteIndex == RecordCount)
+        NextWriteIndex = 0;
+}
+// Matching should be done starting from NextWrite index 
+// until wrap-around
+
+const FrameTimeRecord& FrameTimeRecordSet::operator [] (int i) const
+{
+    return Records[(NextWriteIndex + i) & RecordMask];
+}
+
+const FrameTimeRecord& FrameTimeRecordSet::GetMostRecentFrame()
+{
+    return Records[(NextWriteIndex - 1) & RecordMask];
+}
+
+// Advances I to  absolute color index
+bool FrameTimeRecordSet::FindReadbackIndex(int* i, int readbackIndex) const
+{
+    for (; *i < RecordCount; (*i)++)
+    {
+        if ((*this)[*i].ReadbackIndex == readbackIndex)
+            return true;
+    }
+    return false;
+}
+
+bool FrameTimeRecordSet::IsAllZeroes() const
+{
+    for (int i = 0; i < RecordCount; i++)
+        if (Records[i].ReadbackIndex != 0)
+            return false;
+    return true;
+}
+
+
+//// RecordStateReader
+
+void RecordStateReader::GetRecordSet(FrameTimeRecordSet& recordset)
+{
+    if(!Updater)
+    {
+        return;
+    }
+        
+    recordset = Updater->SharedLatencyTestState.GetState();
+    return;
+}
+
+
+}} // namespace OVR::Util
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,63 @@
+/************************************************************************************
+
+Filename    :   Util_LatencyTest2Reader.h
+Content     :   Shared functionality for the DK2 latency tester
+Created     :   July 8, 2014
+Authors     :   Volga Aksoy, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_LatencyTest2Reader_h
+#define OVR_Util_LatencyTest2Reader_h
+
+#include "../Tracking/Tracking_SensorState.h"
+#include "Util_LatencyTest2State.h"
+
+namespace OVR { namespace Util {
+
+
+//-----------------------------------------------------------------------------
+// RecordStateReader
+
+// User interface to retrieve pose from the sensor fusion subsystem
+class RecordStateReader : public NewOverrideBase
+{
+protected:
+    const Tracking::CombinedSharedStateUpdater* Updater;
+
+public:
+    RecordStateReader()
+        : Updater(NULL)
+    {
+    }
+
+    // Initialize the updater
+    void SetUpdater(const Tracking::CombinedSharedStateUpdater *updater)
+    {
+        Updater = updater;
+    }
+
+    void GetRecordSet(FrameTimeRecordSet& recordset);
+};
+
+
+}} // namespace OVR::Util
+
+#endif // OVR_Util_LatencyTest2Reader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2State.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2State.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,96 @@
+/************************************************************************************
+
+Filename    :   Util_LatencyTest2Reader.h
+Content     :   Shared functionality for the DK2 latency tester
+Created     :   July 8, 2014
+Authors     :   Volga Aksoy, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_LatencyTest2_State_h
+#define OVR_Util_LatencyTest2_State_h
+
+#include "../Kernel/OVR_Lockless.h"
+
+namespace OVR { namespace Util {
+
+
+enum LatencyTester2Constants
+{
+    LT2_ColorIncrement                  = 32,
+    LT2_PixelTestThreshold              = LT2_ColorIncrement / 3,
+    LT2_IncrementCount                  = 256 / LT2_ColorIncrement,
+    LT2_TimeoutWaitingForColorDetected  = 1000  // 1 second
+};
+
+
+//-------------------------------------------------------------------------------------
+// FrameTimeRecord
+
+// Describes frame scan-out time used for latency testing.
+struct FrameTimeRecord
+{
+    int    ReadbackIndex;
+    double TimeSeconds;
+
+    // Utility functions to convert color to readBack indices and back.
+    // The purpose of ReadbackIndex is to allow direct comparison by value.
+
+    static bool ColorToReadbackIndex(int *readbackIndex, unsigned char color);
+    static unsigned char ReadbackIndexToColor(int readbackIndex);
+};
+
+
+//-----------------------------------------------------------------------------
+// FrameTimeRecordSet
+
+// FrameTimeRecordSet is a container holding multiple consecutive frame timing records
+// returned from the lock-less state. Used by FrameTimeManager. 
+struct FrameTimeRecordSet
+{
+    enum {
+        RecordCount = 4,
+        RecordMask  = RecordCount - 1
+    };
+    FrameTimeRecord Records[RecordCount];    
+    int             NextWriteIndex;
+
+    FrameTimeRecordSet();
+
+    void AddValue(int readValue, double timeSeconds);
+    // Matching should be done starting from NextWrite index 
+    // until wrap-around
+
+    const FrameTimeRecord& operator [] (int i) const;
+
+    const FrameTimeRecord& GetMostRecentFrame();
+
+    // Advances I to  absolute color index
+    bool FindReadbackIndex(int* i, int readbackIndex) const;
+
+    bool IsAllZeroes() const;
+};
+
+typedef LocklessUpdater<FrameTimeRecordSet, FrameTimeRecordSet> LockessRecordUpdater;
+
+
+}} // namespace OVR::Util
+
+#endif // OVR_Util_LatencyTest2_State_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.cpp	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,1486 @@
+/************************************************************************************
+
+Filename    :   Util_Render_Stereo.cpp
+Content     :   Stereo rendering configuration implementation
+Created     :   October 22, 2012
+Authors     :   Michael Antonov, Andrew Reisse, Tom Forsyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#include "Util_Render_Stereo.h"
+
+namespace OVR { namespace Util { namespace Render {
+
+using namespace OVR::Tracking;
+
+
+//-----------------------------------------------------------------------------------
+// **** Useful debug functions.
+
+char const* GetDebugNameEyeCupType ( EyeCupType eyeCupType )
+{
+    switch ( eyeCupType )
+    {
+    case EyeCup_DK1A:           return "DK1 A";             break;
+    case EyeCup_DK1B:           return "DK1 B";             break;
+    case EyeCup_DK1C:           return "DK1 C";             break;
+    case EyeCup_DKHD2A:         return "DKHD2 A";           break;
+    case EyeCup_OrangeA:        return "Orange A";          break;
+    case EyeCup_RedA:           return "Red A";             break;
+    case EyeCup_PinkA:          return "Pink A";            break;
+    case EyeCup_BlueA:          return "Blue A";            break;
+    case EyeCup_Delilah1A:      return "Delilah 1 A";       break;
+    case EyeCup_Delilah2A:      return "Delilah 2 A";       break;
+    case EyeCup_JamesA:         return "James A";           break;
+    case EyeCup_SunMandalaA:    return "Sun Mandala A";     break;
+    case EyeCup_DK2A:           return "DK2 A";             break;
+    case EyeCup_LAST:           return "LAST";              break;
+    default: OVR_ASSERT ( false ); return "Error"; break;
+    }
+}
+
+char const* GetDebugNameHmdType ( HmdTypeEnum hmdType )
+{
+    switch ( hmdType )
+    {
+    case HmdType_None:              return "None";                   break;
+    case HmdType_DK1:               return "DK1";                    break;
+    case HmdType_DKProto:           return "DK1 prototype";          break;
+    case HmdType_DKHDProto:         return "DK HD prototype 1";      break;
+    case HmdType_DKHDProto566Mi:    return "DK HD prototype 566 Mi"; break;
+    case HmdType_DKHD2Proto:        return "DK HD prototype 585";    break;
+    case HmdType_CrystalCoveProto:  return "Crystal Cove";           break;
+    case HmdType_DK2:               return "DK2";                    break;
+    case HmdType_Unknown:           return "Unknown";                break;
+    case HmdType_LAST:              return "LAST";                   break;
+    default: OVR_ASSERT ( false ); return "Error"; break;
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+// **** Internal pipeline functions.
+
+struct DistortionAndFov
+{
+    DistortionRenderDesc    Distortion;
+    FovPort                 Fov; 
+};
+
+static DistortionAndFov CalculateDistortionAndFovInternal ( StereoEye eyeType, HmdRenderInfo const &hmd,
+                                                            LensConfig const *pLensOverride = NULL,
+                                                            FovPort const *pTanHalfFovOverride = NULL,
+                                                            float extraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION )
+{
+    // pLensOverride can be NULL, which means no override.
+
+    DistortionRenderDesc localDistortion  = CalculateDistortionRenderDesc ( eyeType, hmd, pLensOverride );
+    FovPort              fov              = CalculateFovFromHmdInfo ( eyeType, localDistortion, hmd, extraEyeRotationInRadians );
+    // Here the app or the user would optionally clamp this visible fov to a smaller number if
+    // they want more perf or resolution and are willing to give up FOV.
+    // They may also choose to clamp UDLR differently e.g. to get cinemascope-style views.
+    if ( pTanHalfFovOverride != NULL )
+    {
+        fov = *pTanHalfFovOverride;
+    }
+
+    // Here we could call ClampToPhysicalScreenFov(), but we do want people
+    // to be able to play with larger-than-screen views.
+    // The calling app can always do the clamping itself.
+    DistortionAndFov result;
+    result.Distortion = localDistortion;
+    result.Fov        = fov;
+
+    return result;
+}
+
+
+static Recti CalculateViewportInternal ( StereoEye eyeType,
+                                            Sizei const actualRendertargetSurfaceSize,
+                                            Sizei const requestedRenderedPixelSize,
+                                            bool bRendertargetSharedByBothEyes,
+                                            bool bMonoRenderingMode = false )
+{
+    Recti renderedViewport;
+    if ( bMonoRenderingMode || !bRendertargetSharedByBothEyes || (eyeType == StereoEye_Center) )
+    {
+        // One eye per RT.
+        renderedViewport.x = 0;
+        renderedViewport.y = 0;
+        renderedViewport.w = Alg::Min ( actualRendertargetSurfaceSize.w, requestedRenderedPixelSize.w );
+        renderedViewport.h = Alg::Min ( actualRendertargetSurfaceSize.h, requestedRenderedPixelSize.h );
+    }
+    else
+    {
+        // Both eyes share the RT.
+        renderedViewport.x = 0;
+        renderedViewport.y = 0;
+        renderedViewport.w = Alg::Min ( actualRendertargetSurfaceSize.w/2, requestedRenderedPixelSize.w );
+        renderedViewport.h = Alg::Min ( actualRendertargetSurfaceSize.h,  requestedRenderedPixelSize.h );
+        if ( eyeType == StereoEye_Right )
+        {
+            renderedViewport.x = (actualRendertargetSurfaceSize.w+1)/2;      // Round up, not down.
+        }
+    }
+    return renderedViewport;
+}
+
+static Recti CalculateViewportDensityInternal ( StereoEye eyeType,
+                                                   DistortionRenderDesc const &distortion,
+                                                   FovPort const &fov,
+                                                   Sizei const &actualRendertargetSurfaceSize,
+                                                   bool bRendertargetSharedByBothEyes,
+                                                   float desiredPixelDensity = 1.0f,
+                                                   bool bMonoRenderingMode = false )
+{
+    OVR_ASSERT ( actualRendertargetSurfaceSize.w > 0 );
+    OVR_ASSERT ( actualRendertargetSurfaceSize.h > 0 );
+
+    // What size RT do we need to get 1:1 mapping?
+    Sizei idealPixelSize = CalculateIdealPixelSize ( eyeType, distortion, fov, desiredPixelDensity );
+    // ...but we might not actually get that size.
+    return CalculateViewportInternal ( eyeType,
+                                       actualRendertargetSurfaceSize,
+                                       idealPixelSize,
+                                       bRendertargetSharedByBothEyes, bMonoRenderingMode );
+}
+
+static ViewportScaleAndOffset CalculateViewportScaleAndOffsetInternal (
+                                                          ScaleAndOffset2D const &eyeToSourceNDC,
+                                                          Recti const &renderedViewport,
+                                                          Sizei const &actualRendertargetSurfaceSize )
+{
+    ViewportScaleAndOffset result;
+    result.RenderedViewport = renderedViewport;
+    result.EyeToSourceUV = CreateUVScaleAndOffsetfromNDCScaleandOffset(
+                                            eyeToSourceNDC, renderedViewport, actualRendertargetSurfaceSize );
+    return result;
+}
+
+
+static StereoEyeParams CalculateStereoEyeParamsInternal ( StereoEye eyeType, HmdRenderInfo const &hmd,
+                                                          DistortionRenderDesc const &distortion,
+                                                          FovPort const &fov,
+                                                          Sizei const &actualRendertargetSurfaceSize,
+                                                          Recti const &renderedViewport,
+                                                          bool bRightHanded = true, float zNear = 0.01f, float zFar = 10000.0f,
+                                                          bool bMonoRenderingMode = false,
+                                                          float zoomFactor = 1.0f )
+{
+    // Generate the projection matrix for intermediate rendertarget.
+    // Z range can also be inserted later by the app (though not in this particular case)
+    float fovScale = 1.0f / zoomFactor;
+    FovPort zoomedFov = fov;
+    zoomedFov.LeftTan  *= fovScale;
+    zoomedFov.RightTan *= fovScale;
+    zoomedFov.UpTan    *= fovScale;
+    zoomedFov.DownTan  *= fovScale;
+    Matrix4f projection = CreateProjection ( bRightHanded, zoomedFov, zNear, zFar );
+
+    // Find the mapping from TanAngle space to target NDC space.
+    // Note this does NOT take the zoom factor into account because
+    // this is the mapping of actual physical eye FOV (and our eyes do not zoom!)
+    // to screen space.
+    ScaleAndOffset2D eyeToSourceNDC = CreateNDCScaleAndOffsetFromFov ( fov );
+    
+    // The size of the final FB, which is fixed and determined by the physical size of the device display.
+    Recti distortedViewport   = GetFramebufferViewport ( eyeType, hmd );
+    Vector3f virtualCameraOffset = CalculateEyeVirtualCameraOffset(hmd, eyeType, bMonoRenderingMode);
+
+    StereoEyeParams result;
+    result.Eye                  = eyeType;
+    result.ViewAdjust           = Matrix4f::Translation(virtualCameraOffset);
+    result.Distortion           = distortion;
+    result.DistortionViewport   = distortedViewport;
+    result.Fov                  = fov;
+    result.RenderedProjection   = projection;
+    result.EyeToSourceNDC       = eyeToSourceNDC;
+    ViewportScaleAndOffset vsao = CalculateViewportScaleAndOffsetInternal ( eyeToSourceNDC, renderedViewport, actualRendertargetSurfaceSize );
+    result.RenderedViewport     = vsao.RenderedViewport;
+    result.EyeToSourceUV        = vsao.EyeToSourceUV;
+
+    return result;
+}
+
+
+Vector3f CalculateEyeVirtualCameraOffset(HmdRenderInfo const &hmd,
+                                         StereoEye eyeType, bool bmonoRenderingMode)
+{
+    Vector3f virtualCameraOffset(0);
+
+    if (!bmonoRenderingMode)
+    {
+        float eyeCenterRelief = hmd.GetEyeCenter().ReliefInMeters;
+
+        if (eyeType == StereoEye_Left)
+        {
+            virtualCameraOffset.x = hmd.EyeLeft.NoseToPupilInMeters;
+            virtualCameraOffset.z = eyeCenterRelief - hmd.EyeLeft.ReliefInMeters;
+        }
+        else if (eyeType == StereoEye_Right)
+        {
+            virtualCameraOffset.x = -hmd.EyeRight.NoseToPupilInMeters;
+            virtualCameraOffset.z = eyeCenterRelief - hmd.EyeRight.ReliefInMeters;
+        }
+    }
+
+    return virtualCameraOffset;
+}
+
+
+//-----------------------------------------------------------------------------------
+// **** Higher-level utility functions.
+
+Sizei CalculateRecommendedTextureSize ( HmdRenderInfo const &hmd,
+                                        bool bRendertargetSharedByBothEyes,
+                                        float pixelDensityInCenter /*= 1.0f*/ )
+{
+    Sizei idealPixelSize[2];
+    for ( int eyeNum = 0; eyeNum < 2; eyeNum++ )
+    {
+        StereoEye eyeType = ( eyeNum == 0 ) ? StereoEye_Left : StereoEye_Right;
+
+        DistortionAndFov distortionAndFov = CalculateDistortionAndFovInternal ( eyeType, hmd, NULL, NULL, OVR_DEFAULT_EXTRA_EYE_ROTATION );
+
+        idealPixelSize[eyeNum] = CalculateIdealPixelSize ( eyeType,
+                                        distortionAndFov.Distortion,
+                                        distortionAndFov.Fov,
+                                        pixelDensityInCenter );
+    }
+
+    Sizei result;
+    result.w = Alg::Max ( idealPixelSize[0].w, idealPixelSize[1].w );
+    result.h = Alg::Max ( idealPixelSize[0].h, idealPixelSize[1].h );
+    if ( bRendertargetSharedByBothEyes )
+    {
+        result.w *= 2;
+    }
+    return result;
+}
+
+StereoEyeParams CalculateStereoEyeParams ( HmdRenderInfo const &hmd,
+                                           StereoEye eyeType,
+                                           Sizei const &actualRendertargetSurfaceSize,
+                                           bool bRendertargetSharedByBothEyes,
+                                           bool bRightHanded /*= true*/,
+                                           float zNear /*= 0.01f*/, float zFar /*= 10000.0f*/,
+										   Sizei const *pOverrideRenderedPixelSize /* = NULL*/,
+                                           FovPort const *pOverrideFovport /*= NULL*/,
+                                           float zoomFactor /*= 1.0f*/ )
+{
+    DistortionAndFov distortionAndFov = CalculateDistortionAndFovInternal ( eyeType, hmd, NULL, NULL, OVR_DEFAULT_EXTRA_EYE_ROTATION );
+    if ( pOverrideFovport != NULL )
+    {
+        distortionAndFov.Fov = *pOverrideFovport;
+    }
+
+    Recti viewport;
+    if ( pOverrideRenderedPixelSize != NULL )
+    {
+        viewport = CalculateViewportInternal ( eyeType, actualRendertargetSurfaceSize, *pOverrideRenderedPixelSize, bRendertargetSharedByBothEyes, false );
+    }
+    else
+    {
+        viewport = CalculateViewportDensityInternal ( eyeType,
+                                                      distortionAndFov.Distortion,
+                                                      distortionAndFov.Fov,
+                                                      actualRendertargetSurfaceSize, bRendertargetSharedByBothEyes, 1.0f, false );
+    }
+
+    return CalculateStereoEyeParamsInternal (
+                                eyeType, hmd,
+                                distortionAndFov.Distortion,
+                                distortionAndFov.Fov,
+                                actualRendertargetSurfaceSize, viewport,
+                                bRightHanded, zNear, zFar, false, zoomFactor );
+}
+
+
+FovPort CalculateRecommendedFov ( HmdRenderInfo const &hmd,
+                                  StereoEye eyeType,
+                                  bool bMakeFovSymmetrical /* = false */ )
+{
+    DistortionAndFov distortionAndFov = CalculateDistortionAndFovInternal ( eyeType, hmd, NULL, NULL, OVR_DEFAULT_EXTRA_EYE_ROTATION );
+    FovPort fov = distortionAndFov.Fov;
+    if ( bMakeFovSymmetrical )
+    {
+        // Deal with engines that cannot support an off-center projection.
+        // Unfortunately this means they will be rendering pixels that the user can't actually see.
+        float fovTanH = Alg::Max ( fov.LeftTan, fov.RightTan );
+        float fovTanV = Alg::Max ( fov.UpTan, fov.DownTan );
+        fov.LeftTan = fovTanH;
+        fov.RightTan = fovTanH;
+        fov.UpTan = fovTanV;
+        fov.DownTan = fovTanV;
+    }
+    return fov;
+}
+
+ViewportScaleAndOffset ModifyRenderViewport ( StereoEyeParams const &params,
+                                              Sizei const &actualRendertargetSurfaceSize,
+                                              Recti const &renderViewport )
+{
+    return CalculateViewportScaleAndOffsetInternal ( params.EyeToSourceNDC, renderViewport, actualRendertargetSurfaceSize );
+}
+
+ViewportScaleAndOffset ModifyRenderSize ( StereoEyeParams const &params,
+                                          Sizei const &actualRendertargetSurfaceSize,
+                                          Sizei const &requestedRenderSize,
+                                          bool bRendertargetSharedByBothEyes /*= false*/ )
+{
+    Recti renderViewport = CalculateViewportInternal ( params.Eye, actualRendertargetSurfaceSize, requestedRenderSize, bRendertargetSharedByBothEyes, false );
+    return CalculateViewportScaleAndOffsetInternal ( params.EyeToSourceNDC, renderViewport, actualRendertargetSurfaceSize );
+}
+
+ViewportScaleAndOffset ModifyRenderDensity ( StereoEyeParams const &params,
+                                             Sizei const &actualRendertargetSurfaceSize,
+                                             float pixelDensity /*= 1.0f*/,
+                                             bool bRendertargetSharedByBothEyes /*= false*/ )
+{
+    Recti renderViewport = CalculateViewportDensityInternal ( params.Eye, params.Distortion, params.Fov, actualRendertargetSurfaceSize, bRendertargetSharedByBothEyes, pixelDensity, false );
+    return CalculateViewportScaleAndOffsetInternal ( params.EyeToSourceNDC, renderViewport, actualRendertargetSurfaceSize );
+}
+
+
+//-----------------------------------------------------------------------------------
+// **** StereoConfig Implementation
+
+StereoConfig::StereoConfig(StereoMode mode)
+    : Mode(mode),
+      DirtyFlag(true)
+{
+    // Initialize "fake" default HMD values for testing without HMD plugged in.
+    // These default values match those returned by DK1
+    // (at least they did at time of writing - certainly good enough for debugging)
+    Hmd.HmdType                                         = HmdType_None;
+    Hmd.ResolutionInPixels                              = Sizei(1280, 800);
+    Hmd.ScreenSizeInMeters                              = Sizef(0.1498f, 0.0936f);
+    Hmd.ScreenGapSizeInMeters                           = 0.0f;
+    Hmd.CenterFromTopInMeters                           = 0.0468f;
+    Hmd.LensSeparationInMeters                          = 0.0635f;
+    Hmd.LensDiameterInMeters                            = 0.035f;
+    Hmd.LensSurfaceToMidplateInMeters                   = 0.025f;
+    Hmd.EyeCups                                         = EyeCup_DK1A;
+    Hmd.Shutter.Type                                    = HmdShutter_RollingTopToBottom;
+    Hmd.Shutter.VsyncToNextVsync                        = ( 1.0f / 60.0f );
+    Hmd.Shutter.VsyncToFirstScanline                    = 0.000052f;
+    Hmd.Shutter.FirstScanlineToLastScanline             = 0.016580f;
+    Hmd.Shutter.PixelSettleTime                         = 0.015f;
+    Hmd.Shutter.PixelPersistence                        = ( 1.0f / 60.0f );
+    Hmd.EyeLeft.Distortion.SetToIdentity();
+    Hmd.EyeLeft.Distortion.MetersPerTanAngleAtCenter    = 0.043875f;
+    Hmd.EyeLeft.Distortion.Eqn                          = Distortion_RecipPoly4;
+    Hmd.EyeLeft.Distortion.K[0]                         = 1.0f;
+    Hmd.EyeLeft.Distortion.K[1]                         = -0.3999f;
+    Hmd.EyeLeft.Distortion.K[2]                         = 0.2408f;
+    Hmd.EyeLeft.Distortion.K[3]                         = -0.4589f;
+    Hmd.EyeLeft.Distortion.MaxR                         = 1.0f;
+	Hmd.EyeLeft.Distortion.ChromaticAberration[0]		= 0.006f;
+	Hmd.EyeLeft.Distortion.ChromaticAberration[1]		= 0.0f;
+	Hmd.EyeLeft.Distortion.ChromaticAberration[2]		= -0.014f;
+	Hmd.EyeLeft.Distortion.ChromaticAberration[3]		= 0.0f;
+    Hmd.EyeLeft.NoseToPupilInMeters                     = 0.62f;
+    Hmd.EyeLeft.ReliefInMeters                          = 0.013f;
+    Hmd.EyeRight = Hmd.EyeLeft;
+
+    SetViewportMode = SVPM_Density;
+    SetViewportPixelsPerDisplayPixel = 1.0f;
+    // Not used in this mode, but init them anyway.
+    SetViewportSize[0] = Sizei(0,0);
+    SetViewportSize[1] = Sizei(0,0);
+    SetViewport[0] = Recti(0,0,0,0);
+    SetViewport[1] = Recti(0,0,0,0);
+
+    OverrideLens = false;
+    OverrideTanHalfFov = false;
+    OverrideZeroIpd = false;
+    ExtraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION;
+    IsRendertargetSharedByBothEyes = true;
+    RightHandedProjection = true;
+
+    // This should cause an assert if the app does not call SetRendertargetSize()
+    RendertargetSize = Sizei ( 0, 0 );
+
+    ZNear = 0.01f;
+    ZFar = 10000.0f;
+
+    Set2DAreaFov(DegreeToRad(85.0f));
+}
+
+void StereoConfig::SetHmdRenderInfo(const HmdRenderInfo& hmd)
+{
+    Hmd = hmd;
+    DirtyFlag = true;
+}
+
+void StereoConfig::Set2DAreaFov(float fovRadians)
+{
+    Area2DFov = fovRadians;
+    DirtyFlag = true;
+}
+
+const StereoEyeParamsWithOrtho& StereoConfig::GetEyeRenderParams(StereoEye eye)
+{
+    if ( DirtyFlag )
+    {
+        UpdateComputedState();
+    }
+
+    static const uint8_t eyeParamIndices[3] = { 0, 0, 1 };
+
+    OVR_ASSERT(eye < sizeof(eyeParamIndices));
+    return EyeRenderParams[eyeParamIndices[eye]];
+}
+
+void StereoConfig::SetLensOverride ( LensConfig const *pLensOverrideLeft  /*= NULL*/,
+                                     LensConfig const *pLensOverrideRight /*= NULL*/ )
+{
+    if ( pLensOverrideLeft == NULL )
+    {
+        OverrideLens = false;
+    }
+    else
+    {
+        OverrideLens = true;
+        LensOverrideLeft = *pLensOverrideLeft;
+        LensOverrideRight = *pLensOverrideLeft;
+        if ( pLensOverrideRight != NULL )
+        {
+            LensOverrideRight = *pLensOverrideRight;
+        }
+    }
+    DirtyFlag = true;
+}
+
+void StereoConfig::SetRendertargetSize (Size<int> const rendertargetSize,
+                                        bool rendertargetIsSharedByBothEyes )
+{
+    RendertargetSize = rendertargetSize;
+    IsRendertargetSharedByBothEyes = rendertargetIsSharedByBothEyes;
+    DirtyFlag = true;
+}
+
+void StereoConfig::SetFov ( FovPort const *pfovLeft  /*= NULL*/,
+                            FovPort const *pfovRight /*= NULL*/ )
+{
+    DirtyFlag = true;
+    if ( pfovLeft == NULL )
+    {
+        OverrideTanHalfFov = false;
+    }
+    else
+    {
+        OverrideTanHalfFov = true;
+        FovOverrideLeft  = *pfovLeft;
+        FovOverrideRight = *pfovLeft;
+        if ( pfovRight != NULL )
+        {
+            FovOverrideRight = *pfovRight;
+        }
+    }
+}
+
+
+void StereoConfig::SetZeroVirtualIpdOverride ( bool enableOverride )
+{
+    DirtyFlag = true;
+    OverrideZeroIpd = enableOverride;
+}
+
+
+void StereoConfig::SetZClipPlanesAndHandedness ( float zNear /*= 0.01f*/, float zFar /*= 10000.0f*/, bool rightHandedProjection /*= true*/ )
+{
+    DirtyFlag = true;
+    ZNear = zNear;
+    ZFar = zFar;
+    RightHandedProjection = rightHandedProjection;
+}
+
+void StereoConfig::SetExtraEyeRotation ( float extraEyeRotationInRadians )
+{
+    DirtyFlag = true;
+    ExtraEyeRotationInRadians = extraEyeRotationInRadians;
+}
+
+Sizei StereoConfig::CalculateRecommendedTextureSize ( bool rendertargetSharedByBothEyes,
+                                                      float pixelDensityInCenter /*= 1.0f*/ )
+{
+    return Render::CalculateRecommendedTextureSize ( Hmd, rendertargetSharedByBothEyes, pixelDensityInCenter );
+}
+
+
+
+void StereoConfig::UpdateComputedState()
+{
+    int numEyes = 2;
+    StereoEye eyeTypes[2];
+
+    switch ( Mode )
+    {
+    case Stereo_None:
+        numEyes         = 1;
+        eyeTypes[0]     = StereoEye_Center;
+        break;
+
+    case Stereo_LeftRight_Multipass:
+        numEyes         = 2;
+        eyeTypes[0]     = StereoEye_Left;
+        eyeTypes[1]     = StereoEye_Right;
+        break;
+
+    default:        
+        OVR_ASSERT( false ); break;
+    }
+
+    // If either of these fire, you've probably forgotten to call SetRendertargetSize()
+    OVR_ASSERT ( RendertargetSize.w > 0 );
+    OVR_ASSERT ( RendertargetSize.h > 0 );
+
+    for ( int eyeNum = 0; eyeNum < numEyes; eyeNum++ )
+    {
+        StereoEye eyeType = eyeTypes[eyeNum];
+        LensConfig *pLensOverride = NULL;
+        if ( OverrideLens )
+        {
+            if ( eyeType == StereoEye_Right )
+            {
+                pLensOverride = &LensOverrideRight;
+            }
+            else
+            {
+                pLensOverride = &LensOverrideLeft;
+            }
+        }
+
+        FovPort *pTanHalfFovOverride = NULL;
+        if ( OverrideTanHalfFov )
+        {
+            if ( eyeType == StereoEye_Right )
+            {
+                pTanHalfFovOverride = &FovOverrideRight;
+            }
+            else
+            {
+                pTanHalfFovOverride = &FovOverrideLeft;
+            }
+        }
+
+        DistortionAndFov distortionAndFov =
+            CalculateDistortionAndFovInternal ( eyeType, Hmd,
+                                                pLensOverride, pTanHalfFovOverride,
+                                                ExtraEyeRotationInRadians );
+
+        EyeRenderParams[eyeNum].StereoEye.Distortion = distortionAndFov.Distortion;
+        EyeRenderParams[eyeNum].StereoEye.Fov        = distortionAndFov.Fov;
+    }
+
+    if ( OverrideZeroIpd )
+    {
+        // Take the union of the calculated eye FOVs.
+        FovPort fov;
+        fov.UpTan    = Alg::Max ( EyeRenderParams[0].StereoEye.Fov.UpTan   , EyeRenderParams[1].StereoEye.Fov.UpTan    );
+        fov.DownTan  = Alg::Max ( EyeRenderParams[0].StereoEye.Fov.DownTan , EyeRenderParams[1].StereoEye.Fov.DownTan  );
+        fov.LeftTan  = Alg::Max ( EyeRenderParams[0].StereoEye.Fov.LeftTan , EyeRenderParams[1].StereoEye.Fov.LeftTan  );
+        fov.RightTan = Alg::Max ( EyeRenderParams[0].StereoEye.Fov.RightTan, EyeRenderParams[1].StereoEye.Fov.RightTan );
+        EyeRenderParams[0].StereoEye.Fov = fov;
+        EyeRenderParams[1].StereoEye.Fov = fov;
+    }
+
+    for ( int eyeNum = 0; eyeNum < numEyes; eyeNum++ )
+    {
+        StereoEye eyeType = eyeTypes[eyeNum];
+
+        DistortionRenderDesc localDistortion = EyeRenderParams[eyeNum].StereoEye.Distortion;
+        FovPort              fov             = EyeRenderParams[eyeNum].StereoEye.Fov;
+
+        // Use a placeholder - will be overridden later.
+        Recti tempViewport = Recti ( 0, 0, 1, 1 );
+
+        EyeRenderParams[eyeNum].StereoEye = CalculateStereoEyeParamsInternal (
+                                        eyeType, Hmd, localDistortion, fov,
+                                        RendertargetSize, tempViewport,
+                                        RightHandedProjection, ZNear, ZFar,
+                                        OverrideZeroIpd );
+
+        // We want to create a virtual 2D surface we can draw debug text messages to.
+        // We'd like it to be a fixed distance (OrthoDistance) away,
+        // and to cover a specific FOV (Area2DFov). We need to find the projection matrix for this,
+        // and also to know how large it is in pixels to achieve a 1:1 mapping at the center of the screen.
+        float orthoDistance = 0.8f;
+        float orthoHalfFov = tanf ( Area2DFov * 0.5f );
+        Vector2f unityOrthoPixelSize = localDistortion.PixelsPerTanAngleAtCenter * ( orthoHalfFov * 2.0f );
+        float localInterpupillaryDistance = Hmd.EyeLeft.NoseToPupilInMeters + Hmd.EyeRight.NoseToPupilInMeters;
+        if ( OverrideZeroIpd )
+        {
+            localInterpupillaryDistance = 0.0f;
+        }
+        Matrix4f ortho = CreateOrthoSubProjection ( true, eyeType,
+                                                    orthoHalfFov, orthoHalfFov,
+                                                    unityOrthoPixelSize.x, unityOrthoPixelSize.y,
+                                                    orthoDistance, localInterpupillaryDistance,
+                                                    EyeRenderParams[eyeNum].StereoEye.RenderedProjection );
+        EyeRenderParams[eyeNum].OrthoProjection = ortho;
+    }
+
+    // ...and now set up the viewport, scale & offset the way the app wanted.
+    setupViewportScaleAndOffsets();
+
+    if ( OverrideZeroIpd )
+    {
+        // Monocular rendering has some fragile parts... don't break any by accident.
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.Fov.UpTan                   == EyeRenderParams[1].StereoEye.Fov.UpTan    );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.Fov.DownTan                 == EyeRenderParams[1].StereoEye.Fov.DownTan  );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.Fov.LeftTan                 == EyeRenderParams[1].StereoEye.Fov.LeftTan  );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.Fov.RightTan                == EyeRenderParams[1].StereoEye.Fov.RightTan );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.RenderedProjection.M[0][0]  == EyeRenderParams[1].StereoEye.RenderedProjection.M[0][0] );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.RenderedProjection.M[1][1]  == EyeRenderParams[1].StereoEye.RenderedProjection.M[1][1] );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.RenderedProjection.M[0][2]  == EyeRenderParams[1].StereoEye.RenderedProjection.M[0][2] );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.RenderedProjection.M[1][2]  == EyeRenderParams[1].StereoEye.RenderedProjection.M[1][2] );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.RenderedViewport            == EyeRenderParams[1].StereoEye.RenderedViewport      );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.EyeToSourceUV.Offset        == EyeRenderParams[1].StereoEye.EyeToSourceUV.Offset  );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.EyeToSourceUV.Scale         == EyeRenderParams[1].StereoEye.EyeToSourceUV.Scale   );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.EyeToSourceNDC.Offset       == EyeRenderParams[1].StereoEye.EyeToSourceNDC.Offset );
+        OVR_ASSERT ( EyeRenderParams[0].StereoEye.EyeToSourceNDC.Scale        == EyeRenderParams[1].StereoEye.EyeToSourceNDC.Scale  );
+        OVR_ASSERT ( EyeRenderParams[0].OrthoProjection.M[0][0]               == EyeRenderParams[1].OrthoProjection.M[0][0] );
+        OVR_ASSERT ( EyeRenderParams[0].OrthoProjection.M[1][1]               == EyeRenderParams[1].OrthoProjection.M[1][1] );
+        OVR_ASSERT ( EyeRenderParams[0].OrthoProjection.M[0][2]               == EyeRenderParams[1].OrthoProjection.M[0][2] );
+        OVR_ASSERT ( EyeRenderParams[0].OrthoProjection.M[1][2]               == EyeRenderParams[1].OrthoProjection.M[1][2] );
+    }
+
+    DirtyFlag = false;
+}
+
+
+
+ViewportScaleAndOffsetBothEyes StereoConfig::setupViewportScaleAndOffsets()
+{
+    for ( int eyeNum = 0; eyeNum < 2; eyeNum++ )
+    {
+        StereoEye eyeType = ( eyeNum == 0 ) ? StereoEye_Left : StereoEye_Right;
+
+        DistortionRenderDesc localDistortion = EyeRenderParams[eyeNum].StereoEye.Distortion;
+        FovPort              fov             = EyeRenderParams[eyeNum].StereoEye.Fov;
+
+        Recti renderedViewport;
+        switch ( SetViewportMode )
+        {
+        case SVPM_Density:
+            renderedViewport = CalculateViewportDensityInternal (
+                                    eyeType, localDistortion, fov,
+                                    RendertargetSize, IsRendertargetSharedByBothEyes,
+                                    SetViewportPixelsPerDisplayPixel, OverrideZeroIpd );
+            break;
+        case SVPM_Size:
+            if ( ( eyeType == StereoEye_Right ) && !OverrideZeroIpd )
+            {
+                renderedViewport = CalculateViewportInternal (
+                                        eyeType, RendertargetSize,
+                                        SetViewportSize[1],
+                                        IsRendertargetSharedByBothEyes, OverrideZeroIpd );
+            }
+            else
+            {
+                renderedViewport = CalculateViewportInternal (
+                                        eyeType, RendertargetSize,
+                                        SetViewportSize[0],
+                                        IsRendertargetSharedByBothEyes, OverrideZeroIpd );
+            }
+            break;
+        case SVPM_Viewport:
+            if ( ( eyeType == StereoEye_Right ) && !OverrideZeroIpd )
+            {
+                renderedViewport = SetViewport[1];
+            }
+            else
+            {
+                renderedViewport = SetViewport[0];
+            }
+            break;
+        default: OVR_ASSERT ( false ); break;
+        }
+
+        ViewportScaleAndOffset vpsao = CalculateViewportScaleAndOffsetInternal (
+                                                EyeRenderParams[eyeNum].StereoEye.EyeToSourceNDC,
+                                                renderedViewport,
+                                                RendertargetSize );
+        EyeRenderParams[eyeNum].StereoEye.RenderedViewport = vpsao.RenderedViewport;
+        EyeRenderParams[eyeNum].StereoEye.EyeToSourceUV    = vpsao.EyeToSourceUV;
+    }
+
+    ViewportScaleAndOffsetBothEyes result;
+    result.Left.EyeToSourceUV     = EyeRenderParams[0].StereoEye.EyeToSourceUV;
+    result.Left.RenderedViewport  = EyeRenderParams[0].StereoEye.RenderedViewport;
+    result.Right.EyeToSourceUV    = EyeRenderParams[1].StereoEye.EyeToSourceUV;
+    result.Right.RenderedViewport = EyeRenderParams[1].StereoEye.RenderedViewport;
+    return result;
+}
+
+// Specify a pixel density - how many rendered pixels per pixel in the physical display.
+ViewportScaleAndOffsetBothEyes StereoConfig::SetRenderDensity ( float pixelsPerDisplayPixel )
+{
+    SetViewportMode  = SVPM_Density;
+    SetViewportPixelsPerDisplayPixel = pixelsPerDisplayPixel;
+    return setupViewportScaleAndOffsets();
+}
+
+// Supply the size directly. Will be clamped to the physical rendertarget size.
+ViewportScaleAndOffsetBothEyes StereoConfig::SetRenderSize ( Sizei const &renderSizeLeft, Sizei const &renderSizeRight )
+{
+    SetViewportMode  = SVPM_Size;
+    SetViewportSize[0] = renderSizeLeft;
+    SetViewportSize[1] = renderSizeRight;
+    return setupViewportScaleAndOffsets();
+}
+
+// Supply the viewport directly. This is not clamped to the physical rendertarget - careful now!
+ViewportScaleAndOffsetBothEyes StereoConfig::SetRenderViewport ( Recti const &renderViewportLeft, Recti const &renderViewportRight )
+{
+    SetViewportMode  = SVPM_Viewport;
+    SetViewport[0] = renderViewportLeft;
+    SetViewport[1] = renderViewportRight;
+    return setupViewportScaleAndOffsets();
+}
+
+Matrix4f StereoConfig::GetProjectionWithZoom ( StereoEye eye, float fovZoom ) const
+{
+    int eyeNum = ( eye == StereoEye_Right ) ? 1 : 0;
+    float fovScale = 1.0f / fovZoom;
+    FovPort fovPort = EyeRenderParams[eyeNum].StereoEye.Fov;
+    fovPort.LeftTan  *= fovScale;
+    fovPort.RightTan *= fovScale;
+    fovPort.UpTan    *= fovScale;
+    fovPort.DownTan  *= fovScale;
+    return CreateProjection ( RightHandedProjection, fovPort, ZNear, ZFar );
+}
+
+
+
+
+//-----------------------------------------------------------------------------------
+// *****  Distortion Mesh Rendering
+
+
+// Pow2 for the Morton order to work!
+// 4 is too low - it is easy to see the "wobbles" in the HMD.
+// 5 is realllly close but you can see pixel differences with even/odd frame checking.
+// 6 is indistinguishable on a monitor on even/odd frames.
+static const int DMA_GridSizeLog2   = 6;
+static const int DMA_GridSize       = 1<<DMA_GridSizeLog2;
+static const int DMA_NumVertsPerEye = (DMA_GridSize+1)*(DMA_GridSize+1);
+static const int DMA_NumTrisPerEye  = (DMA_GridSize)*(DMA_GridSize)*2;
+
+
+
+void DistortionMeshDestroy ( DistortionMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices )
+{
+    OVR_FREE ( pVertices );
+    OVR_FREE ( pTriangleMeshIndices );
+}
+
+void DistortionMeshCreate ( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                            int *pNumVertices, int *pNumTriangles,
+                            const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo )
+{
+    bool    rightEye      = ( stereoParams.Eye == StereoEye_Right );
+    int     vertexCount   = 0;
+    int     triangleCount = 0;
+
+    // Generate mesh into allocated data and return result.
+    DistortionMeshCreate(ppVertices, ppTriangleListIndices, &vertexCount, &triangleCount,
+                         rightEye, hmdRenderInfo, stereoParams.Distortion, stereoParams.EyeToSourceNDC);
+    
+    *pNumVertices  = vertexCount;
+    *pNumTriangles = triangleCount;
+}
+
+
+// Generate distortion mesh for a eye.
+void DistortionMeshCreate( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                           int *pNumVertices, int *pNumTriangles,
+                           bool rightEye,
+                           const HmdRenderInfo &hmdRenderInfo, 
+                           const DistortionRenderDesc &distortion, const ScaleAndOffset2D &eyeToSourceNDC )
+{
+    *pNumVertices  = DMA_NumVertsPerEye;
+    *pNumTriangles = DMA_NumTrisPerEye;
+
+    *ppVertices = (DistortionMeshVertexData*)
+                      OVR_ALLOC( sizeof(DistortionMeshVertexData) * (*pNumVertices) );
+    *ppTriangleListIndices  = (uint16_t*) OVR_ALLOC( sizeof(uint16_t) * (*pNumTriangles) * 3 );
+
+    if (!*ppVertices || !*ppTriangleListIndices)
+    {
+        if (*ppVertices)
+        {
+            OVR_FREE(*ppVertices);
+        }
+        if (*ppTriangleListIndices)
+        {
+            OVR_FREE(*ppTriangleListIndices);
+        }
+        *ppVertices             = NULL;
+        *ppTriangleListIndices  = NULL;
+        *pNumTriangles          = 0;
+        *pNumVertices           = 0;
+        return;
+    }
+
+    // When does the fade-to-black edge start? Chosen heuristically.
+    const float fadeOutBorderFraction = 0.075f;
+      
+    
+    // Populate vertex buffer info
+    float xOffset = 0.0f;
+    float uOffset = 0.0f;
+    OVR_UNUSED(uOffset);
+
+    if (rightEye)
+    {
+        xOffset = 1.0f;
+        uOffset = 0.5f;
+    }
+
+    // First pass - build up raw vertex data.
+    DistortionMeshVertexData* pcurVert = *ppVertices;
+
+    for ( int y = 0; y <= DMA_GridSize; y++ )
+    {
+        for ( int x = 0; x <= DMA_GridSize; x++ )
+        {
+
+            Vector2f sourceCoordNDC;
+            // NDC texture coords [-1,+1]
+            sourceCoordNDC.x = 2.0f * ( (float)x / (float)DMA_GridSize ) - 1.0f;
+            sourceCoordNDC.y = 2.0f * ( (float)y / (float)DMA_GridSize ) - 1.0f;
+            Vector2f tanEyeAngle = TransformRendertargetNDCToTanFovSpace ( eyeToSourceNDC, sourceCoordNDC );
+
+            // Find a corresponding screen position.
+            // Note - this function does not have to be precise - we're just trying to match the mesh tessellation
+            // with the shape of the distortion to minimise the number of trianlges needed.
+            Vector2f screenNDC = TransformTanFovSpaceToScreenNDC ( distortion, tanEyeAngle, false );
+            // ...but don't let verts overlap to the other eye.
+            screenNDC.x = Alg::Max ( -1.0f, Alg::Min ( screenNDC.x, 1.0f ) );
+            screenNDC.y = Alg::Max ( -1.0f, Alg::Min ( screenNDC.y, 1.0f ) );
+
+            // From those screen positions, we then need (effectively) RGB UVs.
+            // This is the function that actually matters when doing the distortion calculation.
+            Vector2f tanEyeAnglesR, tanEyeAnglesG, tanEyeAnglesB;
+            TransformScreenNDCToTanFovSpaceChroma ( &tanEyeAnglesR, &tanEyeAnglesG, &tanEyeAnglesB,
+                                                    distortion, screenNDC );
+			
+			pcurVert->TanEyeAnglesR = tanEyeAnglesR;
+			pcurVert->TanEyeAnglesG = tanEyeAnglesG;
+			pcurVert->TanEyeAnglesB = tanEyeAnglesB;
+			
+            HmdShutterTypeEnum shutterType = hmdRenderInfo.Shutter.Type;
+            switch ( shutterType )
+            {
+            case HmdShutter_Global:
+                pcurVert->TimewarpLerp = 0.0f;
+                break;
+            case HmdShutter_RollingLeftToRight:
+                // Retrace is left to right - left eye goes 0.0 -> 0.5, then right goes 0.5 -> 1.0
+                pcurVert->TimewarpLerp = screenNDC.x * 0.25f + 0.25f;
+                if (rightEye)
+                {
+                    pcurVert->TimewarpLerp += 0.5f;
+                }
+                break;
+            case HmdShutter_RollingRightToLeft:
+                // Retrace is right to left - right eye goes 0.0 -> 0.5, then left goes 0.5 -> 1.0
+                pcurVert->TimewarpLerp = 0.75f - screenNDC.x * 0.25f;
+                if (rightEye)
+                {
+                    pcurVert->TimewarpLerp -= 0.5f;
+                }
+                break;
+            case HmdShutter_RollingTopToBottom:
+                // Retrace is top to bottom on both eyes at the same time.
+                pcurVert->TimewarpLerp = screenNDC.y * 0.5f + 0.5f;
+                break;
+            default: OVR_ASSERT ( false ); break;
+            }
+
+            // Fade out at texture edges.
+            // The furthest out will be the blue channel, because of chromatic aberration (true of any standard lens)
+            Vector2f sourceTexCoordBlueNDC = TransformTanFovSpaceToRendertargetNDC ( eyeToSourceNDC, tanEyeAnglesB );
+            float edgeFadeIn       = ( 1.0f / fadeOutBorderFraction ) *
+                                     ( 1.0f - Alg::Max ( Alg::Abs ( sourceTexCoordBlueNDC.x ), Alg::Abs ( sourceTexCoordBlueNDC.y ) ) );
+            // Also fade out at screen edges.
+            float edgeFadeInScreen = ( 2.0f / fadeOutBorderFraction ) *
+                                     ( 1.0f - Alg::Max ( Alg::Abs ( screenNDC.x ), Alg::Abs ( screenNDC.y ) ) );
+            edgeFadeIn = Alg::Min ( edgeFadeInScreen, edgeFadeIn );
+
+            pcurVert->Shade = Alg::Max ( 0.0f, Alg::Min ( edgeFadeIn, 1.0f ) );
+            pcurVert->ScreenPosNDC.x = 0.5f * screenNDC.x - 0.5f + xOffset;
+            pcurVert->ScreenPosNDC.y = -screenNDC.y;
+
+            pcurVert++;
+        }
+    }
+
+
+    // Populate index buffer info  
+    uint16_t *pcurIndex = *ppTriangleListIndices;
+
+    for ( int triNum = 0; triNum < DMA_GridSize * DMA_GridSize; triNum++ )
+    {
+        // Use a Morton order to help locality of FB, texture and vertex cache.
+        // (0.325ms raster order -> 0.257ms Morton order)
+        OVR_ASSERT ( DMA_GridSize <= 256 );
+        int x = ( ( triNum & 0x0001 ) >> 0 ) |
+                ( ( triNum & 0x0004 ) >> 1 ) |
+                ( ( triNum & 0x0010 ) >> 2 ) |
+                ( ( triNum & 0x0040 ) >> 3 ) |
+                ( ( triNum & 0x0100 ) >> 4 ) |
+                ( ( triNum & 0x0400 ) >> 5 ) |
+                ( ( triNum & 0x1000 ) >> 6 ) |
+                ( ( triNum & 0x4000 ) >> 7 );
+        int y = ( ( triNum & 0x0002 ) >> 1 ) |
+                ( ( triNum & 0x0008 ) >> 2 ) |
+                ( ( triNum & 0x0020 ) >> 3 ) |
+                ( ( triNum & 0x0080 ) >> 4 ) |
+                ( ( triNum & 0x0200 ) >> 5 ) |
+                ( ( triNum & 0x0800 ) >> 6 ) |
+                ( ( triNum & 0x2000 ) >> 7 ) |
+                ( ( triNum & 0x8000 ) >> 8 );
+        int FirstVertex = x * (DMA_GridSize+1) + y;
+        // Another twist - we want the top-left and bottom-right quadrants to
+        // have the triangles split one way, the other two split the other.
+        // +---+---+---+---+
+        // |  /|  /|\  |\  |
+        // | / | / | \ | \ |
+        // |/  |/  |  \|  \|
+        // +---+---+---+---+
+        // |  /|  /|\  |\  |
+        // | / | / | \ | \ |
+        // |/  |/  |  \|  \|
+        // +---+---+---+---+
+        // |\  |\  |  /|  /|
+        // | \ | \ | / | / |
+        // |  \|  \|/  |/  |
+        // +---+---+---+---+
+        // |\  |\  |  /|  /|
+        // | \ | \ | / | / |
+        // |  \|  \|/  |/  |
+        // +---+---+---+---+
+        // This way triangle edges don't span long distances over the distortion function,
+        // so linear interpolation works better & we can use fewer tris.
+        if ( ( x < DMA_GridSize/2 ) != ( y < DMA_GridSize/2 ) )       // != is logical XOR
+        {
+            *pcurIndex++ = (uint16_t)FirstVertex;
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1)+1;
+
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1)+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1);
+            *pcurIndex++ = (uint16_t)FirstVertex;
+        }
+        else
+        {
+            *pcurIndex++ = (uint16_t)FirstVertex;
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1);
+
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1)+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(DMA_GridSize+1);
+        }
+    }
+}
+
+//-----------------------------------------------------------------------------------
+// *****  Heightmap Mesh Rendering
+
+
+static const int HMA_GridSizeLog2   = 7;
+static const int HMA_GridSize       = 1<<HMA_GridSizeLog2;
+static const int HMA_NumVertsPerEye = (HMA_GridSize+1)*(HMA_GridSize+1);
+static const int HMA_NumTrisPerEye  = (HMA_GridSize)*(HMA_GridSize)*2;
+
+
+void HeightmapMeshDestroy ( HeightmapMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices )
+{
+    OVR_FREE ( pVertices );
+    OVR_FREE ( pTriangleMeshIndices );
+}
+
+void HeightmapMeshCreate ( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles,
+    const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo )
+{
+    bool    rightEye      = ( stereoParams.Eye == StereoEye_Right );
+    int     vertexCount   = 0;
+    int     triangleCount = 0;
+
+    // Generate mesh into allocated data and return result.
+    HeightmapMeshCreate(ppVertices, ppTriangleListIndices, &vertexCount, &triangleCount,
+        rightEye, hmdRenderInfo, stereoParams.EyeToSourceNDC);
+
+    *pNumVertices  = vertexCount;
+    *pNumTriangles = triangleCount;
+}
+
+
+// Generate heightmap mesh for one eye.
+void HeightmapMeshCreate( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles, bool rightEye,
+    const HmdRenderInfo &hmdRenderInfo,
+    const ScaleAndOffset2D &eyeToSourceNDC )
+{
+    *pNumVertices  = HMA_NumVertsPerEye;
+    *pNumTriangles = HMA_NumTrisPerEye;
+
+    *ppVertices = (HeightmapMeshVertexData*) OVR_ALLOC( sizeof(HeightmapMeshVertexData) * (*pNumVertices) );
+    *ppTriangleListIndices  = (uint16_t*) OVR_ALLOC( sizeof(uint16_t) * (*pNumTriangles) * 3 );
+
+    if (!*ppVertices || !*ppTriangleListIndices)
+    {
+        if (*ppVertices)
+        {
+            OVR_FREE(*ppVertices);
+        }
+        if (*ppTriangleListIndices)
+        {
+            OVR_FREE(*ppTriangleListIndices);
+        }
+        *ppVertices             = NULL;
+        *ppTriangleListIndices  = NULL;
+        *pNumTriangles          = 0;
+        *pNumVertices           = 0;
+        return;
+    }
+
+    // Populate vertex buffer info
+    float xOffset = 0.0f;
+    float uOffset = 0.0f;
+
+    if (rightEye)
+    {
+        xOffset = 1.0f;
+        uOffset = 0.5f;
+    }
+
+    // First pass - build up raw vertex data.
+    HeightmapMeshVertexData* pcurVert = *ppVertices;
+
+    for ( int y = 0; y <= HMA_GridSize; y++ )
+    {
+        for ( int x = 0; x <= HMA_GridSize; x++ )
+        {
+            Vector2f sourceCoordNDC;
+            // NDC texture coords [-1,+1]
+            sourceCoordNDC.x = 2.0f * ( (float)x / (float)HMA_GridSize ) - 1.0f;
+            sourceCoordNDC.y = 2.0f * ( (float)y / (float)HMA_GridSize ) - 1.0f;
+            Vector2f tanEyeAngle = TransformRendertargetNDCToTanFovSpace ( eyeToSourceNDC, sourceCoordNDC );
+            
+            pcurVert->TanEyeAngles = tanEyeAngle;
+
+            HmdShutterTypeEnum shutterType = hmdRenderInfo.Shutter.Type;
+            switch ( shutterType )
+            {
+            case HmdShutter_Global:
+                pcurVert->TimewarpLerp = 0.0f;
+                break;
+            case HmdShutter_RollingLeftToRight:
+                // Retrace is left to right - left eye goes 0.0 -> 0.5, then right goes 0.5 -> 1.0
+                pcurVert->TimewarpLerp = sourceCoordNDC.x * 0.25f + 0.25f;
+                if (rightEye)
+                {
+                    pcurVert->TimewarpLerp += 0.5f;
+                }
+                break;
+            case HmdShutter_RollingRightToLeft:
+                // Retrace is right to left - right eye goes 0.0 -> 0.5, then left goes 0.5 -> 1.0
+                pcurVert->TimewarpLerp = 0.75f - sourceCoordNDC.x * 0.25f;
+                if (rightEye)
+                {
+                    pcurVert->TimewarpLerp -= 0.5f;
+                }
+                break;
+            case HmdShutter_RollingTopToBottom:
+                // Retrace is top to bottom on both eyes at the same time.
+                pcurVert->TimewarpLerp = sourceCoordNDC.y * 0.5f + 0.5f;
+                break;
+            default: OVR_ASSERT ( false ); break;
+            }
+
+            // Don't let verts overlap to the other eye.
+            //sourceCoordNDC.x = Alg::Max ( -1.0f, Alg::Min ( sourceCoordNDC.x, 1.0f ) );
+            //sourceCoordNDC.y = Alg::Max ( -1.0f, Alg::Min ( sourceCoordNDC.y, 1.0f ) );
+
+            //pcurVert->ScreenPosNDC.x = 0.5f * sourceCoordNDC.x - 0.5f + xOffset;
+            pcurVert->ScreenPosNDC.x = sourceCoordNDC.x;
+            pcurVert->ScreenPosNDC.y = -sourceCoordNDC.y;
+
+            pcurVert++;
+        }
+    }
+
+
+    // Populate index buffer info  
+    uint16_t *pcurIndex = *ppTriangleListIndices;
+
+    for ( int triNum = 0; triNum < HMA_GridSize * HMA_GridSize; triNum++ )
+    {
+        // Use a Morton order to help locality of FB, texture and vertex cache.
+        // (0.325ms raster order -> 0.257ms Morton order)
+        OVR_ASSERT ( HMA_GridSize < 256 );
+        int x = ( ( triNum & 0x0001 ) >> 0 ) |
+                ( ( triNum & 0x0004 ) >> 1 ) |
+                ( ( triNum & 0x0010 ) >> 2 ) |
+                ( ( triNum & 0x0040 ) >> 3 ) |
+                ( ( triNum & 0x0100 ) >> 4 ) |
+                ( ( triNum & 0x0400 ) >> 5 ) |
+                ( ( triNum & 0x1000 ) >> 6 ) |
+                ( ( triNum & 0x4000 ) >> 7 );
+        int y = ( ( triNum & 0x0002 ) >> 1 ) |
+                ( ( triNum & 0x0008 ) >> 2 ) |
+                ( ( triNum & 0x0020 ) >> 3 ) |
+                ( ( triNum & 0x0080 ) >> 4 ) |
+                ( ( triNum & 0x0200 ) >> 5 ) |
+                ( ( triNum & 0x0800 ) >> 6 ) |
+                ( ( triNum & 0x2000 ) >> 7 ) |
+                ( ( triNum & 0x8000 ) >> 8 );
+        int FirstVertex = x * (HMA_GridSize+1) + y;
+        // Another twist - we want the top-left and bottom-right quadrants to
+        // have the triangles split one way, the other two split the other.
+        // +---+---+---+---+
+        // |  /|  /|\  |\  |
+        // | / | / | \ | \ |
+        // |/  |/  |  \|  \|
+        // +---+---+---+---+
+        // |  /|  /|\  |\  |
+        // | / | / | \ | \ |
+        // |/  |/  |  \|  \|
+        // +---+---+---+---+
+        // |\  |\  |  /|  /|
+        // | \ | \ | / | / |
+        // |  \|  \|/  |/  |
+        // +---+---+---+---+
+        // |\  |\  |  /|  /|
+        // | \ | \ | / | / |
+        // |  \|  \|/  |/  |
+        // +---+---+---+---+
+        // This way triangle edges don't span long distances over the distortion function,
+        // so linear interpolation works better & we can use fewer tris.
+        if ( ( x < HMA_GridSize/2 ) != ( y < HMA_GridSize/2 ) )       // != is logical XOR
+        {
+            *pcurIndex++ = (uint16_t)FirstVertex;
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1)+1;
+
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1)+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1);
+            *pcurIndex++ = (uint16_t)FirstVertex;
+        }
+        else
+        {
+            *pcurIndex++ = (uint16_t)FirstVertex;
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1);
+
+            *pcurIndex++ = (uint16_t)FirstVertex+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1)+1;
+            *pcurIndex++ = (uint16_t)FirstVertex+(HMA_GridSize+1);
+        }
+    }
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Prediction and timewarp.
+//
+
+// Calculates the values from the HMD info.
+PredictionValues PredictionGetDeviceValues ( const HmdRenderInfo &hmdRenderInfo,
+                                             bool withTimewarp /*= true*/,
+                                             bool withVsync /*= true*/ )
+{
+    PredictionValues result;
+
+    result.WithTimewarp = withTimewarp;
+    result.WithVsync = withVsync;
+
+    // For unclear reasons, most graphics systems add an extra frame of latency
+    // somewhere along the way. In time we'll debug this and figure it out, but
+    // for now this gets prediction a little bit better.
+    const float extraFramesOfBufferingKludge = 1.0f;
+
+    if ( withVsync )
+    {
+        // These are the times from the Present+Flush to when the middle of the scene is "averagely visible" (without timewarp)
+        // So if you had no timewarp, this, plus the time until the next vsync, is how much to predict by.
+        result.PresentFlushToRenderedScene  = extraFramesOfBufferingKludge * hmdRenderInfo.Shutter.FirstScanlineToLastScanline;
+        // Predict to the middle of the screen being scanned out.
+        result.PresentFlushToRenderedScene += hmdRenderInfo.Shutter.VsyncToFirstScanline + 0.5f * hmdRenderInfo.Shutter.FirstScanlineToLastScanline;
+        // Time for pixels to get half-way to settling.
+        result.PresentFlushToRenderedScene += hmdRenderInfo.Shutter.PixelSettleTime * 0.5f;
+        // Predict to half-way through persistence
+        result.PresentFlushToRenderedScene += hmdRenderInfo.Shutter.PixelPersistence * 0.5f;
+
+        // The time from the Present+Flush to when the first scanline is "averagely visible".
+        result.PresentFlushToTimewarpStart  = extraFramesOfBufferingKludge * hmdRenderInfo.Shutter.FirstScanlineToLastScanline;
+        // Predict to the first line being scanned out.
+        result.PresentFlushToTimewarpStart += hmdRenderInfo.Shutter.VsyncToFirstScanline;
+        // Time for pixels to get half-way to settling.
+        result.PresentFlushToTimewarpStart += hmdRenderInfo.Shutter.PixelSettleTime * 0.5f;
+        // Predict to half-way through persistence
+        result.PresentFlushToTimewarpStart += hmdRenderInfo.Shutter.PixelPersistence * 0.5f;
+
+        // Time to the the last scanline.
+        result.PresentFlushToTimewarpEnd    = result.PresentFlushToTimewarpStart + hmdRenderInfo.Shutter.FirstScanlineToLastScanline;
+
+        // Ideal framerate.
+        result.PresentFlushToPresentFlush   = hmdRenderInfo.Shutter.VsyncToNextVsync;
+    }
+    else
+    {
+        // Timewarp without vsync is a little odd.
+        // Currently, we assume that without vsync, we have no idea which scanline
+        // is currently being sent to the display. So we can't do lerping timewarp,
+        // we can just do a full-screen late-stage fixup.
+
+        // "PresentFlushToRenderedScene" means the time from the Present+Flush to when the middle of the scene is "averagely visible" (without timewarp)
+        // So if you had no timewarp, this, plus the time until the next flush (which is usually the time to render the frame), is how much to predict by.
+        // Time for pixels to get half-way to settling.
+        result.PresentFlushToRenderedScene  = hmdRenderInfo.Shutter.PixelSettleTime * 0.5f;
+        // Predict to half-way through persistence
+        result.PresentFlushToRenderedScene += hmdRenderInfo.Shutter.PixelPersistence * 0.5f;
+
+        // Without vsync, you don't know timings, and so can't do anything useful with lerped warping.
+        result.PresentFlushToTimewarpStart  = result.PresentFlushToRenderedScene;
+        result.PresentFlushToTimewarpEnd    = result.PresentFlushToRenderedScene;
+
+        // There's no concept of "ideal" when vsync is off.
+        result.PresentFlushToPresentFlush   = 0.0f;
+    }
+
+    return result;
+}
+
+Matrix4f TimewarpComputePoseDelta ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust )
+{
+    Matrix4f worldFromPredictedView = (eyeViewAdjust * predictedViewFromWorld).InvertedHomogeneousTransform();
+    Matrix4f matRenderFromNowStart = (eyeViewAdjust * renderedViewFromWorld) * worldFromPredictedView;
+
+    // The sensor-predicted orientations have:                           X=right, Y=up,   Z=backwards.
+    // The vectors inside the mesh are in NDC to keep the shader simple: X=right, Y=down, Z=forwards.
+    // So we need to perform a similarity transform on this delta matrix.
+    // The verbose code would look like this:
+    /*
+    Matrix4f matBasisChange;
+    matBasisChange.SetIdentity();
+    matBasisChange.M[0][0] =  1.0f;
+    matBasisChange.M[1][1] = -1.0f;
+    matBasisChange.M[2][2] = -1.0f;
+    Matrix4f matBasisChangeInv = matBasisChange.Inverted();
+    matRenderFromNow = matBasisChangeInv * matRenderFromNow * matBasisChange;
+    */
+    // ...but of course all the above is a constant transform and much more easily done.
+    // We flip the signs of the Y&Z row, then flip the signs of the Y&Z column,
+    // and of course most of the flips cancel:
+    // +++                        +--                     +--
+    // +++ -> flip Y&Z columns -> +-- -> flip Y&Z rows -> -++
+    // +++                        +--                     -++
+    matRenderFromNowStart.M[0][1] = -matRenderFromNowStart.M[0][1];
+    matRenderFromNowStart.M[0][2] = -matRenderFromNowStart.M[0][2];
+    matRenderFromNowStart.M[1][0] = -matRenderFromNowStart.M[1][0];
+    matRenderFromNowStart.M[2][0] = -matRenderFromNowStart.M[2][0];
+    matRenderFromNowStart.M[1][3] = -matRenderFromNowStart.M[1][3];
+    matRenderFromNowStart.M[2][3] = -matRenderFromNowStart.M[2][3];
+
+    return matRenderFromNowStart;
+}
+
+Matrix4f TimewarpComputePoseDeltaPosition ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust )
+{
+    Matrix4f worldFromPredictedView = (eyeViewAdjust * predictedViewFromWorld).InvertedHomogeneousTransform();
+    Matrix4f matRenderXform = (eyeViewAdjust * renderedViewFromWorld) * worldFromPredictedView;
+
+    return matRenderXform.Inverted();
+}
+
+TimewarpMachine::TimewarpMachine()
+{    
+    for ( int i = 0; i < 2; i++ )
+    {
+        EyeRenderPoses[i] = Posef();
+    }
+    DistortionTimeCount = 0;
+    VsyncEnabled = false;
+}
+
+void TimewarpMachine::Reset(HmdRenderInfo& renderInfo, bool vsyncEnabled, double timeNow)
+{
+    RenderInfo = renderInfo;
+    VsyncEnabled = vsyncEnabled;
+    CurrentPredictionValues = PredictionGetDeviceValues ( renderInfo, true, VsyncEnabled );
+    PresentFlushToPresentFlushSeconds = 0.0f;
+    DistortionTimeCount = 0;
+    DistortionTimeAverage = 0.0f;
+    LastFramePresentFlushTime = timeNow;
+    AfterPresentAndFlush(timeNow);
+}
+
+void TimewarpMachine::AfterPresentAndFlush(double timeNow)
+{
+    PresentFlushToPresentFlushSeconds = (float)(timeNow - LastFramePresentFlushTime);
+    LastFramePresentFlushTime = timeNow;
+    NextFramePresentFlushTime = timeNow + (double)PresentFlushToPresentFlushSeconds;
+}
+
+double TimewarpMachine::GetViewRenderPredictionTime()
+{
+    // Note that PredictionGetDeviceValues() did all the vsync-dependent thinking for us.
+    return NextFramePresentFlushTime + CurrentPredictionValues.PresentFlushToRenderedScene;
+}
+
+bool TimewarpMachine::GetViewRenderPredictionPose(SensorStateReader* reader, Posef& pose)
+{
+	return reader->GetPoseAtTime(GetViewRenderPredictionTime(), pose);
+}
+
+double TimewarpMachine::GetVisiblePixelTimeStart()
+{
+    // Note that PredictionGetDeviceValues() did all the vsync-dependent thinking for us.
+    return NextFramePresentFlushTime + CurrentPredictionValues.PresentFlushToTimewarpStart;
+}
+double TimewarpMachine::GetVisiblePixelTimeEnd()
+{
+    // Note that PredictionGetDeviceValues() did all the vsync-dependent thinking for us.
+    return NextFramePresentFlushTime + CurrentPredictionValues.PresentFlushToTimewarpEnd;
+}
+bool TimewarpMachine::GetPredictedVisiblePixelPoseStart(SensorStateReader* reader, Posef& pose)
+{
+	return reader->GetPoseAtTime(GetVisiblePixelTimeStart(), pose);
+}
+bool TimewarpMachine::GetPredictedVisiblePixelPoseEnd(SensorStateReader* reader, Posef& pose)
+{
+	return reader->GetPoseAtTime(GetVisiblePixelTimeEnd(), pose);
+}
+bool TimewarpMachine::GetTimewarpDeltaStart(SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform)
+{
+	Posef visiblePose;
+	if (!GetPredictedVisiblePixelPoseStart(reader, visiblePose))
+	{
+		return false;
+	}
+
+    Matrix4f visibleMatrix(visiblePose);
+    Matrix4f renderedMatrix(renderedPose);
+    Matrix4f identity;  // doesn't matter for orientation-only timewarp
+    transform = TimewarpComputePoseDelta ( renderedMatrix, visibleMatrix, identity );
+
+	return true;
+}
+bool TimewarpMachine::GetTimewarpDeltaEnd(SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform)
+{
+	Posef visiblePose;
+	if (!GetPredictedVisiblePixelPoseEnd(reader, visiblePose))
+	{
+		return false;
+	}
+
+    Matrix4f visibleMatrix(visiblePose);
+    Matrix4f renderedMatrix(renderedPose);
+    Matrix4f identity;  // doesn't matter for orientation-only timewarp
+    transform = TimewarpComputePoseDelta ( renderedMatrix, visibleMatrix, identity );
+
+	return true;
+}
+
+
+// What time should the app wait until before starting distortion?
+double  TimewarpMachine::JustInTime_GetDistortionWaitUntilTime()
+{
+    if ( !VsyncEnabled || ( DistortionTimeCount < NumDistortionTimes ) )
+    {
+        // Don't wait.
+        return LastFramePresentFlushTime;
+    }
+
+    const float fudgeFactor = 0.002f;      // Found heuristically - 1ms is too short because of timing granularity - may need further tweaking!
+    float howLongBeforePresent = DistortionTimeAverage + fudgeFactor;
+    // Subtlety here. Technically, the correct time is NextFramePresentFlushTime - howLongBeforePresent.
+    // However, if the app drops a frame, this then perpetuates it,
+    // i.e. if the display is running at 60fps, but the last frame was slow,
+    // (e.g. because of swapping or whatever), then NextFramePresentFlushTime is
+    // 33ms in the future, not 16ms. Since this function supplies the 
+    // time to wait until, the app will indeed wait until 32ms, so the framerate
+    // drops to 30fps and never comes back up!
+    // So we return the *ideal* framerate, not the *actual* framerate.
+    return LastFramePresentFlushTime + (float)( CurrentPredictionValues.PresentFlushToPresentFlush - howLongBeforePresent );
+}
+
+
+bool    TimewarpMachine::JustInTime_NeedDistortionTimeMeasurement() const
+{
+    if (!VsyncEnabled)
+    {
+        return false;
+    }
+    return ( DistortionTimeCount < NumDistortionTimes );
+}
+
+void    TimewarpMachine::JustInTime_BeforeDistortionTimeMeasurement(double timeNow)
+{
+    DistortionTimeCurrentStart = timeNow;
+}
+
+void    TimewarpMachine::JustInTime_AfterDistortionTimeMeasurement(double timeNow)
+{
+    float timeDelta = (float)( timeNow - DistortionTimeCurrentStart );
+    if ( DistortionTimeCount < NumDistortionTimes )
+    {
+        DistortionTimes[DistortionTimeCount] = timeDelta;
+        DistortionTimeCount++;
+        if ( DistortionTimeCount == NumDistortionTimes )
+        {
+            // Median.
+            float distortionTimeMedian = 0.0f;
+            for ( int i = 0; i < NumDistortionTimes/2; i++ )
+            {
+                // Find the maximum time of those remaining.
+                float maxTime = DistortionTimes[0];
+                int maxIndex = 0;
+                for ( int j = 1; j < NumDistortionTimes; j++ )
+                {
+                    if ( maxTime < DistortionTimes[j] )
+                    {
+                        maxTime = DistortionTimes[j];
+                        maxIndex = j;
+                    }
+                }
+                // Zero that max time, so we'll find the next-highest time.
+                DistortionTimes[maxIndex] = 0.0f;
+                distortionTimeMedian = maxTime;
+            }
+            DistortionTimeAverage = distortionTimeMedian;
+        }
+    }
+    else
+    {
+        OVR_ASSERT ( !"Really didn't need more measurements, thanks" );
+    }
+}
+
+
+}}}  // OVR::Util::Render
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.h	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.h	2014-08-11 16:10:26.000000000 -0700
@@ -0,0 +1,490 @@
+/************************************************************************************
+
+Filename    :   Util_Render_Stereo.h
+Content     :   Sample stereo rendering configuration classes.
+Created     :   October 22, 2012
+Authors     :   Michael Antonov, Tom Forsyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_Render_Stereo_h
+#define OVR_Util_Render_Stereo_h
+
+#include "../OVR_Stereo.h"
+#include "../Tracking/Tracking_SensorStateReader.h"
+
+namespace OVR { namespace Util { namespace Render {
+
+
+
+//-----------------------------------------------------------------------------------
+// **** Useful debug functions.
+//
+// Purely for debugging - the results are not very end-user-friendly.
+char const* GetDebugNameEyeCupType ( EyeCupType eyeCupType );
+char const* GetDebugNameHmdType ( HmdTypeEnum hmdType );
+
+
+
+//-----------------------------------------------------------------------------------
+// **** Higher-level utility functions.
+
+Sizei CalculateRecommendedTextureSize    ( HmdRenderInfo const &hmd,
+                                           bool bRendertargetSharedByBothEyes,
+                                           float pixelDensityInCenter = 1.0f );
+
+FovPort CalculateRecommendedFov          ( HmdRenderInfo const &hmd,
+                                           StereoEye eyeType,
+                                           bool bMakeFovSymmetrical = false);
+
+StereoEyeParams CalculateStereoEyeParams ( HmdRenderInfo const &hmd,
+                                           StereoEye eyeType,
+                                           Sizei const &actualRendertargetSurfaceSize,
+                                           bool bRendertargetSharedByBothEyes,
+                                           bool bRightHanded = true,
+                                           float zNear = 0.01f, float zFar = 10000.0f,
+										   Sizei const *pOverrideRenderedPixelSize = NULL,
+                                           FovPort const *pOverrideFovport = NULL,
+                                           float zoomFactor = 1.0f );
+
+Vector3f CalculateEyeVirtualCameraOffset(HmdRenderInfo const &hmd,
+                                         StereoEye eyeType, bool bMonoRenderingMode );
+
+
+// These are two components from StereoEyeParams that can be changed
+// very easily without full recomputation of everything.
+struct ViewportScaleAndOffset
+{
+    Recti               RenderedViewport;
+    ScaleAndOffset2D    EyeToSourceUV;
+};
+
+// Three ways to override the size of the render view dynamically.
+// None of these require changing the distortion parameters or the regenerating the distortion mesh,
+// and can be called every frame if desired.
+ViewportScaleAndOffset ModifyRenderViewport ( StereoEyeParams const &params,
+                                              Sizei const &actualRendertargetSurfaceSize,
+                                              Recti const &renderViewport );
+
+ViewportScaleAndOffset ModifyRenderSize ( StereoEyeParams const &params,
+                                          Sizei const &actualRendertargetSurfaceSize,
+                                          Sizei const &requestedRenderSize,
+                                          bool bRendertargetSharedByBothEyes = false );
+
+ViewportScaleAndOffset ModifyRenderDensity ( StereoEyeParams const &params,
+                                             Sizei const &actualRendertargetSurfaceSize,
+                                             float pixelDensity = 1.0f,
+                                             bool bRendertargetSharedByBothEyes = false );
+
+
+//-----------------------------------------------------------------------------------
+// *****  StereoConfig
+
+// StereoConfig maintains a scene stereo state and allow switching between different
+// stereo rendering modes. To support rendering, StereoConfig keeps track of HMD
+// variables such as screen size, eye-to-screen distance and distortion, and computes
+// extra data such as FOV and distortion center offsets based on it. Rendering
+// parameters are returned though StereoEyeParams for each eye.
+//
+// Beyond regular 3D projection, this class supports rendering a 2D orthographic
+// surface for UI and text. The 2D surface will be defined by CreateOrthoSubProjection().
+// The (0,0) coordinate corresponds to eye center location.
+// 
+// Applications are not required to use this class, but they should be doing very
+// similar sequences of operations, and it may be useful to start with this class
+// and modify it.
+
+struct StereoEyeParamsWithOrtho
+{
+    StereoEyeParams         StereoEye;
+    Matrix4f                OrthoProjection;
+};
+
+struct ViewportScaleAndOffsetBothEyes
+{
+    ViewportScaleAndOffset  Left;
+    ViewportScaleAndOffset  Right;
+};
+
+class StereoConfig
+{
+public:
+
+    // StereoMode describes rendering modes that can be used by StereoConfig.
+    // These modes control whether stereo rendering is used or not (Stereo_None),
+    // and how it is implemented.
+    enum StereoMode
+    {
+        Stereo_None                     = 0,        // Single eye
+        Stereo_LeftRight_Multipass      = 1,        // One frustum per eye
+    };
+
+
+    StereoConfig(StereoMode mode = Stereo_LeftRight_Multipass);
+ 
+    //---------------------------------------------------------------------------------------------
+    // *** Core functions - every app MUST call these functions at least once.
+
+    // Sets HMD parameters; also initializes distortion coefficients.
+    void        SetHmdRenderInfo(const HmdRenderInfo& hmd);
+
+    // Set the physical size of the rendertarget surface the app created,
+    // and whether one RT is shared by both eyes, or each eye has its own RT:
+    // true: both eyes are rendered to the same RT. Left eye starts at top-left, right eye starts at top-middle.
+    // false: each eye is rendered to its own RT. Some GPU architectures prefer this arrangement.
+    // Typically, the app would call CalculateRecommendedTextureSize() to suggest the choice of RT size.
+    // This setting must be exactly the size of the actual RT created, or the UVs produced will be incorrect.
+    // If the app wants to render to a subsection of the RT, it should use SetRenderSize()
+    void        SetRendertargetSize (Size<int> const rendertargetSize,
+                                     bool rendertargetIsSharedByBothEyes );
+
+    // Returns full set of Stereo rendering parameters for the specified eye.
+    const StereoEyeParamsWithOrtho& GetEyeRenderParams(StereoEye eye);
+
+
+
+    //---------------------------------------------------------------------------------------------
+    // *** Optional functions - an app may call these to override default behaviours.
+
+    const HmdRenderInfo& GetHmdRenderInfo() const { return Hmd; }
+
+    // Returns the recommended size of rendertargets.
+    // If rendertargetIsSharedByBothEyes is true, this is the size of the combined buffer.
+    // If rendertargetIsSharedByBothEyes is false, this is the size of each individual buffer.
+    // pixelDensityInCenter may be set to any number - by default it will match the HMD resolution in the center of the image.
+    // After creating the rendertargets, the application MUST call SetRendertargetSize() with the actual size created
+    // (which can be larger or smaller as the app wishes, but StereoConfig needs to know either way)
+    Sizei       CalculateRecommendedTextureSize ( bool rendertargetSharedByBothEyes,
+                                                  float pixelDensityInCenter = 1.0f );
+
+    // Sets a stereo rendering mode and updates internal cached
+    // state (matrices, per-eye view) based on it.
+    void        SetStereoMode(StereoMode mode)  { Mode = mode; DirtyFlag = true; }
+    StereoMode  GetStereoMode() const           { return Mode; }
+
+    // Sets the fieldOfView that the 2D coordinate area stretches to.
+    void        Set2DAreaFov(float fovRadians);
+
+    // Really only for science experiments - no normal app should ever need to override
+    // the HMD's lens descriptors. Passing NULL removes the override.
+    // Supply both = set left and right.
+    // Supply just left = set both to the same.
+    // Supply neither = remove override.
+    void        SetLensOverride ( LensConfig const *pLensOverrideLeft  = NULL,
+                                  LensConfig const *pLensOverrideRight = NULL );
+ 
+    // Override the rendered FOV in various ways. All angles in tangent units.
+    // This is not clamped to the physical FOV of the display - you'll need to do that yourself!
+    // Supply both = set left and right.
+    // Supply just left = set both to the same.
+    // Supply neither = remove override.
+    void        SetFov ( FovPort const *pfovLeft  = NULL,
+					     FovPort const *pfovRight = NULL );
+    
+    void        SetFovPortRadians ( float horizontal, float vertical )
+    {
+        FovPort fov = FovPort::CreateFromRadians(horizontal, vertical);
+        SetFov( &fov, &fov );
+    }
+
+
+    // This forces a "zero IPD" mode where there is just a single render with an FOV that
+    //   is the union of the two calculated FOVs.
+    // The calculated render is for the left eye. Any size & FOV overrides for the right
+    //   eye will be ignored.
+    // If you query the right eye's size, you will get the same render
+    //   size & position as the left eye - you should not actually do the render of course!
+    //   The distortion values will be different, because it goes to a different place on the framebuffer.
+    // Note that if you do this, the rendertarget does not need to be twice the width of
+    //   the render size any more.
+    void        SetZeroVirtualIpdOverride ( bool enableOverride );
+
+    // Allows the app to specify near and far clip planes and the right/left-handedness of the projection matrix.
+    void        SetZClipPlanesAndHandedness ( float zNear = 0.01f, float zFar = 10000.0f,
+                                              bool rightHandedProjection = true );
+
+    // Allows the app to specify how much extra eye rotation to allow when determining the visible FOV.
+    void        SetExtraEyeRotation ( float extraEyeRotationInRadians = 0.0f );
+
+    // The dirty flag is set by any of the above calls. Just handy for the app to know
+    // if e.g. the distortion mesh needs regeneration.
+    void        SetDirty() { DirtyFlag = true; }
+    bool        IsDirty() { return DirtyFlag; }
+
+    // An app never needs to call this - GetEyeRenderParams will call it internally if
+    // the state is dirty. However apps can call this explicitly to control when and where
+    // computation is performed (e.g. not inside critical loops)
+    void        UpdateComputedState();
+
+    // This returns the projection matrix with a "zoom". Does not modify any internal state.
+    Matrix4f    GetProjectionWithZoom ( StereoEye eye, float fovZoom ) const;
+
+
+    //---------------------------------------------------------------------------------------------
+    // The SetRender* functions are special.
+    //
+    // They do not require a full recalculation of state, and they do not change anything but the
+    // ViewportScaleAndOffset data for the eyes (which they return), and do not set the dirty flag!
+    // This means they can be called without regenerating the distortion mesh, and thus 
+    // can happily be called every frame without causing performance problems. Dynamic rescaling 
+    // of the rendertarget can help keep framerate up in demanding VR applications.
+    // See the documentation for more details on their use.
+
+    // Specify a pixel density - how many rendered pixels per pixel in the physical display.
+    ViewportScaleAndOffsetBothEyes SetRenderDensity ( float pixelsPerDisplayPixel );
+
+    // Supply the size directly. Will be clamped to the physical rendertarget size.
+    ViewportScaleAndOffsetBothEyes SetRenderSize ( Sizei const &renderSizeLeft, Sizei const &renderSizeRight );
+
+    // Supply the viewport directly. This is not clamped to the physical rendertarget - careful now!
+    ViewportScaleAndOffsetBothEyes SetRenderViewport ( Recti const &renderViewportLeft, Recti const &renderViewportRight );
+
+private:
+
+    // *** Modifiable State
+
+    StereoMode         Mode;
+    HmdRenderInfo      Hmd;
+
+    float              Area2DFov;           // FOV range mapping to the 2D area.
+
+    // Only one of these three overrides can be true!
+    enum SetViewportModeEnum
+    {
+        SVPM_Density,
+        SVPM_Size,
+        SVPM_Viewport,
+    }                  SetViewportMode;
+    // ...and depending which it is, one of the following are used.
+    float              SetViewportPixelsPerDisplayPixel;
+    Sizei              SetViewportSize[2];
+    Recti           SetViewport[2];
+
+    // Other overrides.
+    bool               OverrideLens;
+    LensConfig         LensOverrideLeft;
+    LensConfig         LensOverrideRight;
+    Sizei              RendertargetSize;
+    bool               OverrideTanHalfFov;
+    FovPort            FovOverrideLeft;
+    FovPort            FovOverrideRight;
+    bool               OverrideZeroIpd;
+    float              ZNear;
+    float              ZFar;
+    float              ExtraEyeRotationInRadians;
+    bool               IsRendertargetSharedByBothEyes;
+    bool               RightHandedProjection;
+
+    bool               DirtyFlag;   // Set when any if the modifiable state changed. Does NOT get set by SetRender*()
+
+    // Utility function.
+    ViewportScaleAndOffsetBothEyes setupViewportScaleAndOffsets();
+
+    // *** Computed State
+
+public:     // Small hack for the config tool. Normal code should never read EyeRenderParams directly - use GetEyeRenderParams() instead.
+    // 0/1 = left/right main views.
+    StereoEyeParamsWithOrtho    EyeRenderParams[2];
+};
+
+
+//-----------------------------------------------------------------------------------
+// *****  Distortion Mesh Rendering
+//
+
+// Stores both texture UV coords, or tan(angle) values.
+// Use whichever set of data the specific distortion algorithm requires.
+// This struct *must* be binary compatible with CAPI ovrDistortionVertex.
+struct DistortionMeshVertexData
+{
+    // [-1,+1],[-1,+1] over the entire framebuffer.
+    Vector2f    ScreenPosNDC;
+    // [0.0-1.0] interpolation value for timewarping - see documentation for details.
+    float       TimewarpLerp;
+    // [0.0-1.0] fade-to-black at the edges to reduce peripheral vision noise.
+    float       Shade;        
+    // The red, green, and blue vectors in tan(angle) space.
+    // Scale and offset by the values in StereoEyeParams.EyeToSourceUV.Scale
+    // and StereoParams.EyeToSourceUV.Offset to get to real texture UV coords.
+    Vector2f    TanEyeAnglesR;
+    Vector2f    TanEyeAnglesG;
+    Vector2f    TanEyeAnglesB;    
+};
+
+
+void DistortionMeshCreate ( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                            int *pNumVertices, int *pNumTriangles,
+                            const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo );
+
+// Generate distortion mesh for a eye. This version requires less data then stereoParms, supporting
+// dynamic change in render target viewport.
+void DistortionMeshCreate( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                           int *pNumVertices, int *pNumTriangles,
+                           bool rightEye,
+                           const HmdRenderInfo &hmdRenderInfo, 
+                           const DistortionRenderDesc &distortion, const ScaleAndOffset2D &eyeToSourceNDC );
+
+void DistortionMeshDestroy ( DistortionMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices );
+
+
+//-----------------------------------------------------------------------------------
+// *****  Heightmap Mesh Rendering
+//
+
+// Stores both texture UV coords, or tan(angle) values.
+// This struct *must* be binary compatible with CAPI ovrHeightmapVertex.
+struct HeightmapMeshVertexData
+{
+    // [-1,+1],[-1,+1] over the entire framebuffer.
+    Vector2f    ScreenPosNDC;
+    // [0.0-1.0] interpolation value for timewarping - see documentation for details.
+    float       TimewarpLerp;
+    // The vectors in tan(angle) space.
+    // Scale and offset by the values in StereoEyeParams.EyeToSourceUV.Scale
+    // and StereoParams.EyeToSourceUV.Offset to get to real texture UV coords.
+    Vector2f    TanEyeAngles;    
+};
+
+
+void HeightmapMeshCreate ( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles,
+    const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo );
+
+// Generate heightmap mesh for a eye. This version requires less data then stereoParms, supporting
+// dynamic change in render target viewport.
+void HeightmapMeshCreate( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles, bool rightEye,
+    const HmdRenderInfo &hmdRenderInfo, const ScaleAndOffset2D &eyeToSourceNDC );
+
+void HeightmapMeshDestroy ( HeightmapMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices );
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Prediction and timewarp.
+//
+
+struct PredictionValues
+{
+    // All values in seconds.
+    // These are the times in seconds from a present+flush to the relevant display element.
+    // The time is measured to the middle of that element's visibility window,
+    // e.g. if the device is a full-persistence display, the element will be visible for
+    // an entire frame, so the time measures to the middle of that period, i.e. half the frame time.
+    float PresentFlushToRenderedScene;        // To the overall rendered 3D scene being visible.
+    float PresentFlushToTimewarpStart;        // To when the first timewarped scanline will be visible.
+    float PresentFlushToTimewarpEnd;          // To when the last timewarped scanline will be visible.
+    float PresentFlushToPresentFlush;         // To the next present+flush, i.e. the ideal framerate.
+
+    bool  WithTimewarp;
+    bool  WithVsync;
+};
+
+// Calculates the values from the HMD info.
+PredictionValues PredictionGetDeviceValues ( const HmdRenderInfo &hmdRenderInfo,
+                                             bool withTimewarp = true,
+                                             bool withVsync = true );
+
+// Pass in an orientation used to render the scene, and then the predicted orientation
+// (which may have been computed later on, and thus is more accurate), and this
+// will return the matrix to pass to the timewarp distortion shader.
+// TODO: deal with different handedness?
+Matrix4f TimewarpComputePoseDelta ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust );
+Matrix4f TimewarpComputePoseDeltaPosition ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust );
+
+
+
+// TimewarpMachine helps keep track of rendered frame timing and
+// handles predictions for time-warp rendering.
+class TimewarpMachine
+{
+public:
+    TimewarpMachine();
+   
+    // Call this on and every time something about the setup changes.
+    void        Reset ( HmdRenderInfo& renderInfo, bool vsyncEnabled, double timeNow );
+
+    // The only reliable time in most engines is directly after the frame-present and GPU flush-and-wait.
+    // This call should be done right after that to give this system the timing info it needs.
+    void        AfterPresentAndFlush(double timeNow);
+
+    // The "average" time the rendered frame will show up,
+    // and the predicted pose of the HMD at that time.
+    // You usually only need to call one of these functions.
+    double      GetViewRenderPredictionTime();
+    bool        GetViewRenderPredictionPose(Tracking::SensorStateReader* reader, Posef& transform);
+
+
+    // Timewarp prediction functions. You usually only need to call one of these three sets of functions.
+
+    // The predicted times that the first and last pixel will be visible on-screen.
+    double      GetVisiblePixelTimeStart();
+    double      GetVisiblePixelTimeEnd();
+    // Predicted poses of the HMD at those first and last pixels.
+	bool        GetPredictedVisiblePixelPoseStart(Tracking::SensorStateReader* reader, Posef& transform);
+	bool        GetPredictedVisiblePixelPoseEnd(Tracking::SensorStateReader* reader, Posef& transform);
+    // The delta matrices to feed to the timewarp distortion code,
+    // given the pose that was used for rendering.
+    // (usually the one returned by GetViewRenderPredictionPose() earlier)
+	bool        GetTimewarpDeltaStart(Tracking::SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform);
+	bool        GetTimewarpDeltaEnd(Tracking::SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform);
+
+    // Just-In-Time distortion aims to delay the second sensor reading & distortion
+    // until the very last moment to improve prediction. However, it is a little scary,
+    // since the delay might wait too long and miss the vsync completely!
+    // Use of the JustInTime_* functions is entirely optional, and we advise allowing
+    // users to turn it off in their video options to cope with odd machine configurations.
+
+    // What time should the app wait until before starting distortion?
+    double      JustInTime_GetDistortionWaitUntilTime();
+
+    // Used to time the distortion rendering
+    bool        JustInTime_NeedDistortionTimeMeasurement() const;
+    void        JustInTime_BeforeDistortionTimeMeasurement(double timeNow);
+    void        JustInTime_AfterDistortionTimeMeasurement(double timeNow);
+
+private:
+    bool                VsyncEnabled;
+    HmdRenderInfo       RenderInfo;
+    PredictionValues    CurrentPredictionValues;
+
+    enum { NumDistortionTimes = 10 };
+    int                 DistortionTimeCount;
+    double              DistortionTimeCurrentStart;
+    float               DistortionTimes[NumDistortionTimes];
+    float               DistortionTimeAverage;
+
+    // Pose at which last time the eye was rendered.
+    Posef               EyeRenderPoses[2];
+
+    // Absolute time of the last present+flush
+    double              LastFramePresentFlushTime;
+    // Seconds between present+flushes
+    float               PresentFlushToPresentFlushSeconds;
+    // Predicted absolute time of the next present+flush
+    double              NextFramePresentFlushTime;
+
+};
+
+
+
+}}}  // OVR::Util::Render
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LICENSE.txt	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/LICENSE.txt	2014-08-05 19:08:40.000000000 -0700
@@ -0,0 +1,266 @@
+Oculus VR Rift SDK Software License
+
+Oculus VR, LLC Software Development Kit License Agreement
+
+Copyright  2014 Oculus VR, LLC. All rights reserved.
+
+The text of this may be found at: http://www.oculusvr.com/licenses/LICENSE-3.2
+
+Human-Readable Summary*:
+
+You are Free to:
+
+Use, modify, and distribute the Oculus VR Rift SDK in source and binary 
+form with your applications/software.
+
+With the Following Restrictions:
+
+You can only distribute or re-distribute the source code to LibOVR in 
+whole, not in part. 
+
+Modifications to the Oculus VR Rift SDK in source or binary form must 
+be shared with Oculus VR.
+
+If your applications cause health and safety issues, you may lose your 
+right to use the Oculus VR Rift SDK, including LibOVR.
+
+The Oculus VR Rift SDK may not be used to interface with unapproved commercial 
+virtual reality mobile or non-mobile products or hardware.
+
+* - This human-readable Summary is not a license. It is simply a convenient 
+reference for understanding the full Oculus VR Rift SDK License Agreement. 
+The Summary is written as a user-friendly interface to the full Oculus VR Rift 
+SDK License below. This Summary itself has no legal value, and its contents do 
+not appear in the actual license.
+
+Full-length Legal Copy:
+
+1. Subject to the terms and conditions of this License Agreement (the "License"), 
+Oculus VR, LLC ("Oculus VR") hereby grants to you a perpetual, worldwide, 
+non-exclusive, no-charge, royalty-free, sublicenseable copyright license to use, 
+reproduce, redistribute (subject to restrictions below), modify, and improve the 
+software contained in this Oculus VR Rift Software Development Kit ("RIFT SDK"), 
+including, but not limited to, the samples, headers, LibOVR headers, and LibOVR 
+source.  This license is subject to the following terms and conditions:
+
+1.1. This license includes the non-exclusive license and right to use (i) the RIFT
+SDK to make applications, content, games and demos (collectively and generally 
+referred to as "Developer Content") that run on the Oculus VR approved mobile hardware 
+and software products ("Oculus Approved Rift Products") and which may incorporate 
+the RIFT SDK in whole or in part in binary or object code; and (ii) to use the 
+RIFT SDK to create derivative works of the RIFT SDK itself ("RIFT SDK Derivatives"), 
+whether in source, binary, or object form, in whole or in part, including third 
+party software unless otherwise noted.
+  
+1.2.  RIFT SDK Derivatives are further defined as source, binary or object code 
+derived exclusively from the RIFT SDK by you; provided, however, that RIFT SDK 
+Derivatives do not include the Developer Content (engines, utilities, applications, 
+content, games or demos) which may be developed using the RIFT SDK.  By way of example 
+a mobile application or game or demo that is developed using the RIFT SDK would not 
+be a RIFT SDK Derivative , nor would a utility or tool set in a pre-existing game 
+engine that is adapted to work with the RIFT SDK be a RIFT SDK Derivative. 
+By way of example, but not limitation, a RIFT SDK Derivative is or would be: either (i) 
+an adaptation of a utility or piece of code from the RIFT SDK to improve efficiency; 
+or (ii) an addition of code or improvement to the RIFT SDK that adds functionality. 
+
+1.3  For the sake of clarification when you use the RIFT SDK (including RIFT SDK 
+Derivatives) in or with Developer Content, you retain all rights to your Developer 
+Content, and you have no obligations to share or license Developer Content (including 
+your source and object code) to Oculus VR or any third parties; provided, however, 
+Oculus VR retains all rights to the RIFT SDK and the RIFT SDK Derivatives that may 
+be incorporated into your Developer Content.
+
+1.4  You agree to and you will use  the Flash Screen Warning and the Health and 
+Safety Warnings (collectively the "Oculus Warnings") and the Oculus VR health and 
+safety protocols found in the Oculus Best Practices Guide ("Oculus H&S Protocols"), 
+and your use of the Oculus Warnings and the Oculus end user license agreement 
+("Oculus EULA") with your Developer Content as provided for in the Oculus Developer 
+Center, all of which can be found at the following link:  
+https://developer.oculusvr.com/?action=doc.
+
+2. You, the recipient and user of the RIFT SDK, hereby agree and accept that that
+Oculus VR shall own all right, title and interest to the intellectual property 
+rights, including, but limited to copyright, trademark and patent rights, to any 
+RIFT SDK Derivatives that you may create, and you hereby assign any and all such 
+rights to such RIFT SDK Derivatives to Oculus VR, subject to the following.
+
+2.1  We hereby grant to you the a fully paid up, no-charge, royalty-free, 
+world-wide, in perpetuity, non-exclusive right and license back to use these RIFT 
+SDK Derivatives solely in conjunction with the RIFT SDK (or any components of the 
+RIFT SDK) and/or Developer Content on Oculus Rift Products as set forth herein.
+
+2.2  Furthermore, for the sake of clarification, Oculus VR and its assignees and 
+licensees shall be free to use such RIFT SDK Derivatives without any approval 
+from you and without compensation or attribution to you.
+
+2.3  You also agree upon Oculus VR's request to provide the source and binary code 
+of any RIFT SDK Derivatives to Oculus VR. FAILURE TO COMPLY WITH THIS REQUEST 
+IS THE BASIS FOR AUTOMATIC TERMINATION OF THIS LICENSE BY OCULUS VR.
+
+3. Subject to the terms and conditions of this License, your license to redistribute 
+and sublicense the RIFT SDK and RIFT SDK Derivatives is also expressly made 
+subject to the following conditions:
+
+3.1. You may sublicense and redistribute the source, binary, or object code of 
+the RIFT SDK in whole or in part by itself for no charge or as part of a for charge 
+piece of Developer Content; provided, however, you may only license, sublicense 
+or redistribute the source, binary or object code of LibOVR in whole, and you may 
+not license, sublicense or redistribute any portion or element of LibOVR separately 
+or in part (in either source, binary or object form). If you license, sublicense 
+or redistribute RIFT SDK Derivatives in and of themselves (not as a part of a 
+piece of Developer Content) then you may only do that solely with and in conjunction 
+with either the RIFT SDK or LibOVR. The RIFT SDK (including, but not limited to 
+LibOVR), any RIFT SDK Derivatives, and any Developer Content may only be used 
+with Oculus Approved Rift Products and may not be used, licensed, or sublicensed 
+to interface with mobile software or hardware or other commercial headsets, 
+mobile tablets or phones that are not authorized and approved by Oculus VR;
+
+3.2. You must include with all such redistributed or sublicensed RIFT SDK 
+or RIFT SDK Derivatives code the following copyright notice: 
+"Copyright  2014 Oculus VR, LLC. All rights reserved," and include the 
+list of conditions contained in this Section 3, including the full text of 
+the disclaimer in Section 3.6 below;
+
+3.3. Neither the name of Oculus VR, LLC nor the names of Oculus VR, LLC's 
+contributors, licensors, employees, or contractors, may be used to endorse or promote 
+products derived from this RIFT SDK without specific prior written permission 
+of Oculus VR, LLC;
+
+3.4. You must give any other recipients of the RIFT SDK or any elements thereof, 
+including LibOVR or RIFT SDK Derivatives, a copy of this License as such recipients, 
+licensees or sublicensees may only use the RIFT SDK or any RIFT SDK Derivatives 
+or any elements thereof subject to the terms of this Licence and such recipients, 
+licensees or sublicensees agreement and acceptance of this License with Oculus VR 
+(which will convey all rights to the recipients or licensees or sublicensees 
+RIFT SDK Derivatives to Oculus VR),  and you must cause any modified files to 
+carry prominent notices stating that you changed the files;
+
+3.5. If the RIFT SDK or a specific element thereof such as LibOVR includes a 
+"LICENSE" text file as part of its distribution (the "License Notice"), then 
+any RIFT SDK Derivatives that you distribute with the RIFT SDK in whole or in 
+part must include a readable copy of such attribution notices as are contained 
+within the applicable License Notice file (excluding those notices that do not 
+pertain to any part of the RIFT SDK Derivatives), in at least one of the following 
+places: within a License Notice text file distributed as part of the RIFT SDK 
+Derivatives; within the source form or documentation, if provided along with 
+the RIFT SDK Derivatives; or, within a display generated by the RIFT SDK Derivatives, 
+if and wherever such third-party notices normally appear.  You must also include 
+in the License Notice file for all RIFT SDK Derivatives a copy of all notices 
+(including any product liability or health and safety notices).  The contents 
+of the License Notice file are for informational purposes only and do not modify
+the License. You may add your own attribution notices within RIFT SDK Derivatives 
+that you distribute, alongside or as an addendum to the License Notice text from 
+the RIFT SDK or any part thereof, provided that such additional attribution notices 
+cannot be construed as modifying the License.
+
+3.6. THIS RIFT SDK AND ANY COMPONENT THEREOF IS PROVIDED BY OCULUS VR AND 
+ITS CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
+BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL OCULUS VR AS THE 
+COPYRIGHT OWNER OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
+OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS RIFT 
+SDK OR THE RIFT SDK DERIVATIVES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+4. This License does not grant permission to use the trade names, trademarks, 
+service marks, or product names of Oculus VR, except as required for reasonable 
+and customary use in describing the origin of the RIFT SDK, LibOVR, or any 
+element thereof, and reproducing the content of the License Notice file. 
+Oculus VR reserves all rights not expressly granted to you under this License.
+
+5. In no event and under no legal theory, whether in tort (including negligence), 
+contract, or otherwise, unless required by applicable law (such as 
+deliberate and grossly negligent acts) or agreed to in writing, shall Oculus VR 
+or any contributor be liable to you or your licensees or sublicensees for 
+damages, including any direct, indirect, special, incidental, or consequential 
+damages of any character arising as a result of this License or out of the use 
+or inability to use the RIFT SDK, LibOVR, any element thereof or any RIFT SDK 
+Derivatives (including but not limited to damages for loss of goodwill, work 
+stoppage, computer failure or malfunction, or any and all other commercial 
+damages or losses), even if you or such contributor has been advised of the 
+possibility of such damages.
+
+6.  Your acceptance of the terms and conditions of this License in and of 
+itself and for all Developer Content created as of March 1, 2014, may be 
+evidenced by any of the following: your usage of the RIFT SDK or any element 
+thereof, acceptance of the click-through agreement, or opening the packaging 
+of the CD-ROM containing the RIFT SDK or any element thereof, including LibOVR.  
+As this License is updated for future releases of the RIFT SDK and/or LibOVR, 
+you agree to abide by and meet all requirements of future updates of this 
+License for those future RIFT SDK releases as evidenced by the same usage of 
+the RIFT SDK or any element thereof and the future updates of this License 
+will apply for that future Developer Content that may developed for or with 
+that future RIFT SDK or any element thereof (i.e., you cannot sidestep out 
+of the requirements of future updates of the License by developing against 
+an older release of the RIFT SDK or License).
+ 
+7.  Oculus VR reserves the right to terminate this License and all your 
+rights hereunder in the event you materially breach this License and fail 
+to cure such breach within ten (10) business days after notice of breach 
+from Oculus VR.  
+
+8.  Furthermore, Oculus VR also reserves the right to cancel or terminate 
+this License for any of the following reasons upon notice to you, subject 
+to the appeal process set forth in Section 14 for a wrongful termination: 
+
+	a) Intellectual property infringement by you with Developer Content 
+	or RIFT SDK Derivatives created by you that is used with or by the 
+	RIFT SDK or any part thereof, or any of the RIFT SDK Derivatives;
+	
+	b) Developer Content that violates or infringes upon applicable law;
+	
+	c) Health and safety issues associated with your Developer Content;
+	
+	d) Failure to comply with or use properly the Oculus Warnings, 
+	Oculus H&S Protocols, or Oculus EULA; 
+	
+	e) Use of the RIFT SDK, RIFT SDK Derivatives or LibOVR with a 
+	commercial product other than an Oculus Approved Product; and
+	
+	f) Failure to provide required notices or deliver source code 
+	and/or binary of RIFT SDK Derivatives as set forth above.
+	
+If you believe that you have been wrongfully terminated under this Section 8 
+with respect to material breach or with respect to these above conditions, 
+you have the right to appeal the termination of this License under Section 14. 
+
+9.  This License may be amended by Oculus VR on a prospective basis, and your 
+usage of the License after such amendments or changes signifies your consent 
+to and acceptance of any such amendments or changes on a going forward basis.
+
+10.   In the event any provision of this License is determined to be invalid, 
+prohibited or unenforceable by a court or other body of competent jurisdiction, 
+this License shall be construed as if such invalid, prohibited or unenforceable 
+provision has been more narrowly drawn so as not to be invalid, prohibited or 
+unenforceable.  
+
+11.   You may not assign any rights or obligations under this License without 
+the advance written consent of Oculus VR, which may be withheld in its sole 
+discretion.  Oculus VR may assign its rights or obligations under this License 
+in its sole discretion.
+
+12.   Failure of either party at any time to enforce any of the provisions of 
+this License will not be construed as a waiver of such provisions or in any way 
+affect the validity of this License or parts thereof.
+
+13.   Your remedies under this License shall be limited to the right to collect 
+money damages, if any, and you hereby waive your right to injunctive or other 
+equitable relief.
+
+14.   This License shall be governed by the laws of the State of California, 
+without giving effect to choice of law principles.  All disputes relating to 
+this License shall be resolved by binding non-appearance-based arbitration 
+before a neutral arbitrator in Orange County, California.  If your License 
+has been terminated hereunder by Oculus, you may appeal your termination 
+through this arbitration process on an expedited basis with an arbitration 
+within thirty days of your giving Oculus VR notice of the appeal.  The 
+arbitration shall be conducted in accordance with the rules and procedures 
+of JAMS then in effect, and the judgment of the arbitrator shall be final 
+and capable of entry in any court of competent jurisdiction.  You agree 
+to submit to the personal jurisdiction of the courts located within Orange 
+County, California in connection with any entrance of an arbitrators judgment 
+or decision or any dispute with respect to the arbitration process or procedure 
+or Oculus VRs exercise of its equitable rights or remedies.
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/readme.txt	1969-12-31 16:00:00.000000000 -0800
+++ ./Engine/Source/ThirdParty/Oculus/readme.txt	2014-07-20 12:52:17.000000000 -0700
@@ -0,0 +1,6 @@
+Oculus SDK
+(C) Oculus VR, Inc. 2014. All Rights Reserved.
+
+The latest version of the Oculus SDK is available at http://developer.oculusvr.com.
+
+Please see the Oculus SDK Overview in the OculusSDK/Doc/ directory for more information.
\ No newline at end of file
