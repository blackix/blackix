--- ../../../../UE4-QA/Engine/Plugins/OculusRift/OculusRift.uplugin	2014-09-05 02:22:09.012674700 -0400
+++ ./Engine/Plugins/OculusRift/OculusRift.uplugin	2014-08-18 16:16:29.528218900 -0400
@@ -16,7 +16,8 @@
 		{
 			"Name" : "OculusRift",
 			"Type" : "Runtime",
-			"WhitelistPlatforms" : [ "Win64", "Win32", "Mac" ]
+			"WhitelistPlatforms" : [ "Win64", "Win32", "Mac" ],
+			"LoadingPhase" : "PostConfigInit"
 		}
 	]
 }
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/OculusRift.Build.cs	2014-09-05 02:22:09.054714900 -0400
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/OculusRift.Build.cs	2014-08-26 15:38:38.863668800 -0400
@@ -10,8 +10,6 @@
 				new string[] {
 					"OculusRift/Private",
  					"../../../Source/Runtime/Renderer/Private",
-// 					"../../../Runtime/Windows/D3D11RHI/Private",
-// 					"Runtime/OpenGLDrv/Private",
 					// ... add other private include paths required here ...
 				}
 				);
@@ -22,6 +20,7 @@
 					"Core",
 					"CoreUObject",
 					"Engine",
+					"InputCore",
 					"RHI",
 					"RenderCore",
 					"Renderer",
@@ -40,6 +39,10 @@
                 {
                     PrivateDependencyModuleNames.AddRange(new string[] { "D3D11RHI" });
                 }
+                if (Target.Platform == UnrealTargetPlatform.Mac)
+                {
+               		AddThirdPartyPrivateStaticDependencies(Target, "OpenGL");
+                }
             }
 		}
 	}
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.cpp	2014-09-05 02:22:09.078738000 -0400
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.cpp	2014-09-04 18:47:03.272166100 -0400
@@ -5,8 +5,6 @@
 #include "EngineAnalytics.h"
 #include "Runtime/Analytics/Analytics/Public/Interfaces/IAnalyticsProvider.h"
 
-#define DEFAULT_PREDICTION_IN_SECONDS 0.035
-
 #if !UE_BUILD_SHIPPING
 // Should be changed to CAPI when available.
 #if PLATFORM_SUPPORTS_PRAGMA_PACK
@@ -16,30 +14,6 @@
 #if PLATFORM_SUPPORTS_PRAGMA_PACK
 #pragma pack (pop)
 #endif
-//////////////////////////////////////////////////////////////////////////
-class OculusLog : public OVR::Log
-{
-public:
-	OculusLog()
-	{
-		SetLoggingMask(OVR::LogMask_Debug | OVR::LogMask_Regular);
-	}
-
-	// This virtual function receives all the messages,
-	// developers should override this function in order to do custom logging
-	virtual void    LogMessageVarg(LogMessageType messageType, const char* fmt, va_list argList)
-	{
-		if ((messageType & GetLoggingMask()) == 0)
-			return;
-
-		ANSICHAR buf[1024];
-		int32 len = FCStringAnsi::GetVarArgs(buf, sizeof(buf), sizeof(buf)/sizeof(ANSICHAR), fmt, argList);
-		if (len > 0 && buf[len - 1] == '\n') // truncate the trailing new-line char, since Logf adds its own
-			buf[len - 1] = '\0';
-		TCHAR* tbuf = ANSI_TO_TCHAR(buf);
-		GLog->Logf(TEXT("OCULUS: %s"), tbuf);
-	}
-};
 #endif // #if !UE_BUILD_SHIPPING
 
 //---------------------------------------------------
@@ -50,6 +24,9 @@
 {
 	/** IHeadMountedDisplayModule implementation */
 	virtual TSharedPtr< class IHeadMountedDisplay > CreateHeadMountedDisplay() override;
+
+	// Pre-init the HMD module (optional).
+	virtual void PreInit() override;
 };
 
 IMPLEMENT_MODULE( FOculusRiftPlugin, OculusRift )
@@ -66,6 +43,45 @@
 	return NULL;
 }
 
+void FOculusRiftPlugin::PreInit()
+{
+	FOculusRiftHMD::PreInit();
+}
+
+//---------------------------------------------------
+// Oculus Rift IHeadMountedDisplay Implementation
+//---------------------------------------------------
+
+#if OCULUS_RIFT_SUPPORTED_PLATFORMS
+
+#if !UE_BUILD_SHIPPING
+//////////////////////////////////////////////////////////////////////////
+class OculusLog : public OVR::Log
+{
+public:
+	OculusLog()
+	{
+		SetLoggingMask(OVR::LogMask_Debug | OVR::LogMask_Regular);
+	}
+
+	// This virtual function receives all the messages,
+	// developers should override this function in order to do custom logging
+	virtual void    LogMessageVarg(LogMessageType messageType, const char* fmt, va_list argList)
+	{
+		if ((messageType & GetLoggingMask()) == 0)
+			return;
+
+		ANSICHAR buf[1024];
+		int32 len = FCStringAnsi::GetVarArgs(buf, sizeof(buf), sizeof(buf) / sizeof(ANSICHAR), fmt, argList);
+		if (len > 0 && buf[len - 1] == '\n') // truncate the trailing new-line char, since Logf adds its own
+			buf[len - 1] = '\0';
+		TCHAR* tbuf = ANSI_TO_TCHAR(buf);
+		GLog->Logf(TEXT("OCULUS: %s"), tbuf);
+	}
+};
+
+#endif
+
 //////////////////////////////////////////////////////////////////////////
 class ConditionalLocker
 {
@@ -86,11 +102,10 @@
 	OVR::Lock*	pLock;
 };
 
-//---------------------------------------------------
-// Oculus Rift IHeadMountedDisplay Implementation
-//---------------------------------------------------
-
-#if OCULUS_RIFT_SUPPORTED_PLATFORMS
+void FOculusRiftHMD::PreInit()
+{
+	ovr_Initialize();
+}
 
 bool FOculusRiftHMD::IsHMDEnabled() const
 {
@@ -112,14 +127,14 @@
 
 bool FOculusRiftHMD::GetHMDMonitorInfo(MonitorInfo& MonitorDesc) const
 {
-	if (IsInitialized())
+	if (IsInitialized() && Hmd)
 	{
-		MonitorDesc.MonitorName = HmdDesc.DisplayDeviceName;
-		MonitorDesc.MonitorId	= HmdDesc.DisplayId;
-		MonitorDesc.DesktopX	= HmdDesc.WindowsPos.x;
-		MonitorDesc.DesktopY	= HmdDesc.WindowsPos.y;
-		MonitorDesc.ResolutionX = HmdDesc.Resolution.w;
-		MonitorDesc.ResolutionY = HmdDesc.Resolution.h;
+		MonitorDesc.MonitorName = Hmd->DisplayDeviceName;
+		MonitorDesc.MonitorId	= Hmd->DisplayId;
+		MonitorDesc.DesktopX	= Hmd->WindowsPos.x;
+		MonitorDesc.DesktopY	= Hmd->WindowsPos.y;
+		MonitorDesc.ResolutionX = Hmd->Resolution.w;
+		MonitorDesc.ResolutionY = Hmd->Resolution.h;
 		return true;
 	}
 	else
@@ -131,10 +146,15 @@
 	return false;
 }
 
+bool FOculusRiftHMD::IsFullScreenAllowed() const
+{
+	return (Hmd && (Hmd->HmdCaps & ovrHmdCap_ExtendDesktop) != 0) ? true : false;
+}
+
 bool FOculusRiftHMD::DoesSupportPositionalTracking() const
 {
 #ifdef OVR_VISION_ENABLED
-	 return bHmdPosTracking && (SupportedSensorCaps & ovrSensorCap_Position) != 0;
+	 return bHmdPosTracking && (SupportedTrackingCaps & ovrTrackingCap_Position) != 0;
 #else
 	return false;
 #endif //OVR_VISION_ENABLED
@@ -218,16 +238,32 @@
 
 void FOculusRiftHMD::GetCurrentOrientationAndPosition(FQuat& CurrentOrientation, FVector& CurrentPosition) const
 {
-	const ovrSensorState ss = ovrHmd_GetSensorState(Hmd, ovr_GetTimeInSeconds() + MotionPredictionInSeconds);
-	const ovrPosef& pose = ss.Predicted.Pose;
-	PoseToOrientationAndPosition(pose, CurrentOrientation, CurrentPosition);
+	// only supposed to be used from the game thread
+	checkf(IsInGameThread());
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
+	CurrentOrientation = LastHmdOrientation = CurHmdOrientation;
+
+	CurrentPosition = CurHmdPosition;
+	
+	// @TODO: we can't actually return just CurHmdPosition here, it should be rotated by CurrentOrientation.
+	// Another problem: if we return rotated position here, we shouldn't apply position in CalculateStereoViewOffset, otherwise the
+	// position will be applied twice.
+	// Currently, position will be applied automatically in CalculateStereoViewOffset and adjusted on Render Thread by UpdatePlayerViewPoint()
+	//CurrentPosition = FVector::ZeroVector; 
+}
+
+void FOculusRiftHMD::GetCurrentPose(FQuat& CurrentOrientation, FVector& CurrentPosition) const
+{
+	const ovrTrackingState ts = ovrHmd_GetTrackingState(Hmd, ovr_GetTimeInSeconds() + MotionPredictionInSeconds);
+	const ovrPosef& ThePose = ts.HeadPose.ThePose;
+	PoseToOrientationAndPosition(ThePose, CurrentOrientation, CurrentPosition);
 	//UE_LOG(LogHMD, Log, TEXT("P: %.3f %.3f %.3f"), CurrentPosition.X, CurrentPosition.Y, CurrentPosition.Y);
 #ifdef OVR_VISION_ENABLED
 	if (bHmdPosTracking)
 	{
 #if !UE_BUILD_SHIPPING
 		bool hadVisionTracking = bHaveVisionTracking;
-		bHaveVisionTracking = (ss.StatusFlags & ovrStatus_PositionTracked) != 0;
+		bHaveVisionTracking = (ts.StatusFlags & ovrStatus_PositionTracked) != 0;
 		if (bHaveVisionTracking && !hadVisionTracking)
 			UE_LOG(LogHMD, Warning, TEXT("Vision Tracking Acquired"));
 		if (!bHaveVisionTracking && hadVisionTracking)
@@ -264,7 +300,7 @@
 
 	ViewRotation.Normalize();
 
-	GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
 	LastHmdOrientation = CurHmdOrientation;
 
 	const FRotator DeltaRot = ViewRotation - PC->GetControlRotation();
@@ -294,7 +330,7 @@
 #endif
 	ConditionalLocker lock(bUpdateOnRT, &UpdateOnRTLock);
 
-	GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
+	GetCurrentPose(CurHmdOrientation, CurHmdPosition);
 	LastHmdOrientation = CurHmdOrientation;
 
 	static const FName NAME_Fixed = FName(TEXT("Fixed"));
@@ -575,6 +611,32 @@
 			Ar.Logf(TEXT("Low Persistence is currently %s"), (bLowPersistenceMode) ? TEXT("ON") : TEXT("OFF"));
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("MIRROR"))) // to mirror or not to mirror?...
+		{
+			FString CmdName = FParse::Token(Cmd, 0);
+			if (!CmdName.IsEmpty())
+			{
+				if (!FCString::Stricmp(*CmdName, TEXT("ON")))
+				{
+					bMirrorToWindow = true;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("OFF")))
+				{
+					bMirrorToWindow = false;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("TOGGLE"))) 
+				{
+					bMirrorToWindow = !bMirrorToWindow;
+				}
+			}
+			else
+			{
+				bMirrorToWindow = !bMirrorToWindow;
+			}
+			UpdateHmdCaps();
+			Ar.Logf(TEXT("Mirroring is currently %s"), (bMirrorToWindow) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 		else if (FParse::Command(&Cmd, TEXT("UPDATEONRT"))) // update on renderthread
 		{
 			FString CmdName = FParse::Token(Cmd, 0);
@@ -604,6 +666,36 @@
 			Ar.Logf(TEXT("Update on render thread is currently %s"), (bUpdateOnRT) ? TEXT("ON") : TEXT("OFF"));
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("OVERDRIVE"))) // 2 frame raise overdrive
+		{
+			FString CmdName = FParse::Token(Cmd, 0);
+			if (!CmdName.IsEmpty())
+			{
+				if (!FCString::Stricmp(*CmdName, TEXT("ON")))
+				{
+					bOverdrive = true;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("OFF")))
+				{
+					bOverdrive = false;
+				}
+				else if (!FCString::Stricmp(*CmdName, TEXT("TOGGLE")))
+				{
+					bOverdrive = !bOverdrive;
+				}
+				else
+				{
+					return false;
+				}
+			}
+			else
+			{
+				bOverdrive = !bOverdrive;
+			}
+			UpdateDistortionCaps();
+			Ar.Logf(TEXT("Overdrive is currently %s"), (bOverdrive) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 #ifdef OVR_DIRECT_RENDERING
 		else if (FParse::Command(&Cmd, TEXT("TIMEWARP"))) 
 		{
@@ -631,13 +723,8 @@
 			{
 				bTimeWarp = !bTimeWarp;
 			}
+			UpdateDistortionCaps();
 			Ar.Logf(TEXT("TimeWarp is currently %s"), (bTimeWarp) ? TEXT("ON") : TEXT("OFF"));
-#ifdef OVR_DIRECT_RENDERING 
-			if (GetActiveRHIBridgeImpl())
-			{
-				GetActiveRHIBridgeImpl()->SetNeedReinitRendererAPI();
-			}
-#endif // OVR_DIRECT_RENDERING
 			return true;
 		}
 #endif // #ifdef OVR_DIRECT_RENDERING
@@ -681,6 +768,13 @@
 			bDrawGrid = !bDrawGrid;
 			return true;
 		}
+		else if (FParse::Command(&Cmd, TEXT("PROFILE"))) // profile
+		{
+			bProfiling = !bProfiling;
+			UpdateDistortionCaps();
+			Ar.Logf(TEXT("Profiling mode is currently %s"), (bProfiling) ? TEXT("ON") : TEXT("OFF"));
+			return true;
+		}
 #endif //UE_BUILD_SHIPPING
 	}
 	else if (FParse::Command(&Cmd, TEXT("HMDMAG")))
@@ -705,37 +799,50 @@
 		}
 		return false;
 	}
-	else if (FParse::Command(&Cmd, TEXT("HMDTILT")))
+	else if (FParse::Command(&Cmd, TEXT("HMDWARP")))
 	{
-		if (FParse::Command(&Cmd, TEXT("ON")))
+#ifndef OVR_DIRECT_RENDERING
+        if (FParse::Command( &Cmd, TEXT("ON") ))
 		{
-			bTiltCorrectionEnabled = true;
+            bHmdDistortion = true;
 			return true;
 		}
-		else if (FParse::Command(&Cmd, TEXT("OFF")))
+        else if (FParse::Command( &Cmd, TEXT("OFF") ))
 		{
-			bTiltCorrectionEnabled = false;
+            bHmdDistortion = false;
 			return true;
 		}
-		else if (FParse::Command(&Cmd, TEXT("SHOW")))
+#endif //OVR_DIRECT_RENDERING
+		if (FParse::Command(&Cmd, TEXT("CHA")))
 		{
- 			Ar.Logf(TEXT("tilt correction %s"), bTiltCorrectionEnabled ? 
- 				TEXT("on") : TEXT("off"));
+			bChromaAbCorrectionEnabled = true;
+			UpdateDistortionCaps();
  			return true;
 		}
-		return false;
+		else if (FParse::Command(&Cmd, TEXT("NOCHA")))
+		{
+			bChromaAbCorrectionEnabled = false;
+			UpdateDistortionCaps();
+			return true;
 	}
-#ifndef OVR_DIRECT_RENDERING
-	else if (FParse::Command(&Cmd, TEXT("HMDWARP")))
+		else if (FParse::Command( &Cmd, TEXT("HQ") ))
     {
+			// High quality distortion
         if (FParse::Command( &Cmd, TEXT("ON") ))
         {
-            bHmdDistortion = true;
-            return true;
+				bHQDistortion = true;
         }
-        else if (FParse::Command( &Cmd, TEXT("OFF") ))
+			else if (FParse::Command(&Cmd, TEXT("OFF")))
         {
-            bHmdDistortion = false;
+				bHQDistortion = false;
+			}
+			else
+			{
+				bHQDistortion = !bHQDistortion;
+			}
+			Ar.Logf(TEXT("High quality distortion is currently %s"), (bHQDistortion) ? TEXT("ON") : TEXT("OFF") ?
+				TEXT("on") : TEXT("off"));
+			UpdateDistortionCaps();
             return true;
         }
 
@@ -747,7 +854,6 @@
 		}
 		return true;
     }
-#endif //OVR_DIRECT_RENDERING
 	else if (FParse::Command(&Cmd, TEXT("HMDPOS")))
 	{
 		if (FParse::Command(&Cmd, TEXT("RESET")))
@@ -877,10 +983,6 @@
 			{
 				MotionPredictionInSeconds = 0.0;
 			}
-			else if (!FCString::Stricmp(*Value, TEXT("OFF")))
-			{
-				MotionPredictionInSeconds = DEFAULT_PREDICTION_IN_SECONDS;
-			}
 			else
 			{
 				MotionPredictionInSeconds = FCString::Atod(*Value);
@@ -889,6 +991,7 @@
 		}
 		return false;
 	}
+#ifndef OVR_DIRECT_RENDERING
 	else if (FParse::Command(&Cmd, TEXT("SETFINISHFRAME")))
 	{
 		static IConsoleVariable* CFinishFrameVar = IConsoleManager::Get().FindConsoleVariable(TEXT("r.FinishCurrentFrame"));
@@ -913,6 +1016,7 @@
 		}
 		return false;
 	}
+#endif
 	else if (FParse::Command(&Cmd, TEXT("UNCAPFPS")))
 	{
 		GEngine->bSmoothFrameRate = false;
@@ -920,7 +1024,7 @@
 	}
 	else if (FParse::Command(&Cmd, TEXT("OVRVERSION")))
 	{
-		static const char* Results = OVR_VERSION_STRING;
+		static const char* Results = ovr_GetVersionString();
 		Ar.Logf(TEXT("%s, LibOVR: %s, built %s, %s"), *GEngineVersion.ToString(), UTF8_TO_TCHAR(Results), 
 			UTF8_TO_TCHAR(__DATE__), UTF8_TO_TCHAR(__TIME__));
 		return true;
@@ -944,7 +1048,10 @@
 
 		IHeadMountedDisplay::MonitorInfo MonitorInfo;
 		GetHMDMonitorInfo(MonitorInfo);
-		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("DeviceName"), FString::Printf(TEXT("%s - %s"), ANSI_TO_TCHAR(HmdDesc.Manufacturer), ANSI_TO_TCHAR(HmdDesc.ProductName))));
+		if (Hmd)
+		{
+			EventAttributes.Add(FAnalyticsEventAttribute(TEXT("DeviceName"), FString::Printf(TEXT("%s - %s"), ANSI_TO_TCHAR(Hmd->Manufacturer), ANSI_TO_TCHAR(Hmd->ProductName))));
+		}
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("DisplayDeviceName"), MonitorInfo.MonitorName));
 #if PLATFORM_MAC // On OS X MonitorId is the CGDirectDisplayID aka uint64, not a string
 		FString DisplayId(FString::Printf(TEXT("%llu"), MonitorInfo.MonitorId));
@@ -959,7 +1066,6 @@
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("MagEnabled"), bYawDriftCorrectionEnabled));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("DevSettingsEnabled"), bDevSettingsEnabled));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("MotionPredictionEnabled"), (MotionPredictionInSeconds > 0)));
-		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("TiltCorrectionEnabled"), bTiltCorrectionEnabled));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("AccelGain"), AccelGain));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("OverrideInterpupillaryDistance"), bOverrideIPD));
 		if (bOverrideIPD)
@@ -982,12 +1088,20 @@
 		{
 			EventAttributes.Add(FAnalyticsEventAttribute(TEXT("ScreenPercentage"), ScreenPercentage));
 		}
+		if (bWorldToMetersOverride)
+		{
+			EventAttributes.Add(FAnalyticsEventAttribute(TEXT("WorldToMetersScale"), WorldToMetersScale));
+		}
+		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("InterpupillaryDistance"), InterpupillaryDistance));
+		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("TimeWarp"), bTimeWarp));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("AllowFinishCurrentFrame"), bAllowFinishCurrentFrame));
 #ifdef OVR_VISION_ENABLED
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("HmdPosTracking"), bHmdPosTracking));
-		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("LowPersistenceMode"), bLowPersistenceMode));
 #endif		
+		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("LowPersistenceMode"), bLowPersistenceMode));
 		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("UpdateOnRT"), bUpdateOnRT));
+		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("Overdrive"), bOverdrive));
+		EventAttributes.Add(FAnalyticsEventAttribute(TEXT("MirrorToWindow"), bMirrorToWindow));
 
 		FString OutStr(TEXT("Editor.VR.DeviceInitialised"));
 		FEngineAnalytics::GetProvider().RecordEvent(OutStr, EventAttributes);
@@ -1174,8 +1288,8 @@
 
 void FOculusRiftHMD::ResetOrientationAndPosition(float yaw)
 {
-	const ovrSensorState ss = ovrHmd_GetSensorState(Hmd, ovr_GetTimeInSeconds());
-	const ovrPosef& pose = ss.Recorded.Pose;
+	const ovrTrackingState ss = ovrHmd_GetTrackingState(Hmd, ovr_GetTimeInSeconds());
+	const ovrPosef& pose = ss.HeadPose.ThePose;
 	const OVR::Quatf orientation = OVR::Quatf(pose.Orientation);
 
 	// Reset position
@@ -1365,30 +1479,33 @@
 	, SavedScrPerc(100.f)
 	, bOverrideScreenPercentage(false)
 	, ScreenPercentage(100.f)
-	, bAllowFinishCurrentFrame(false)
+	, bAllowFinishCurrentFrame(true)
 	, InterpupillaryDistance(OVR_DEFAULT_IPD)
 	, WorldToMetersScale(100.f)
 	, bWorldToMetersOverride(false)
 	, UserDistanceToScreenModifier(0.f)
-	, VFOVInRadians(FMath::DegreesToRadians(90.f))
 	, HFOVInRadians(FMath::DegreesToRadians(90.f))
-	, MotionPredictionInSeconds(DEFAULT_PREDICTION_IN_SECONDS)
+	, VFOVInRadians(FMath::DegreesToRadians(90.f))
+	, MotionPredictionInSeconds(0)
 	, AccelGain(0.f)
 	, bHmdDistortion(true)
 	, bChromaAbCorrectionEnabled(true)
 	, bYawDriftCorrectionEnabled(true)
-	, bTiltCorrectionEnabled(true)
 	, bOverride2D(false)
 	, HudOffset(0.f)
 	, CanvasCenterOffset(0.f)
 	, bLowPersistenceMode(true) // on by default (DK2+ only)
 	, bUpdateOnRT(true)
+	, bOverdrive(true)
+	, bHQDistortion(true)
 	, bHeadTrackingEnforced(false)
+	, bMirrorToWindow(true)
 #if !UE_BUILD_SHIPPING
-	, bDoNotUpdateOnGT(false)
 	, bDrawTrackingCameraFrustum(false)
+	, bDoNotUpdateOnGT(false)
 	, bShowStats(false)
 	, bDrawGrid(false)
+	, bProfiling(false)
 #endif
 	, bTimeWarp(true)
 	, NearClippingPlane(0)
@@ -1402,7 +1519,7 @@
 	, BaseOffset(0, 0, 0)
 	, BaseOrientation(FQuat::Identity)
 	, Hmd(nullptr)
-	, SensorCaps(0)
+	, TrackingCaps(0)
 	, DistortionCaps(0)
 	, HmdCaps(0)
 	, EyeViewportSize(0, 0)
@@ -1416,7 +1533,8 @@
 #ifndef OVR_DIRECT_RENDERING
 	bTimeWarp = false;
 #endif
-	SupportedSensorCaps = SupportedDistortionCaps = SupportedHmdCaps = 0;
+	SupportedTrackingCaps = SupportedDistortionCaps = SupportedHmdCaps = 0;
+	OSWindowHandle = nullptr;
 	Startup();
 }
 
@@ -1441,6 +1559,7 @@
 
 	// Initializes LibOVR. This LogMask_All enables maximum logging.
 	// Custom allocator can also be specified here.
+	// Actually, most likely, the ovr_Initialize is already called from PreInit.
 	ovr_Initialize();
 
 #if !UE_BUILD_SHIPPING
@@ -1454,20 +1573,46 @@
 	{
 		InitStatus |= eInitialized;
 
-		ovrHmd_GetDesc(Hmd, &HmdDesc);
-		SupportedDistortionCaps = HmdDesc.DistortionCaps;
-		SupportedHmdCaps		= HmdDesc.HmdCaps;
-		SupportedSensorCaps		= HmdDesc.SensorCaps;
+		// one frame prediction for the game thread. TODO: fugure out a better way to do this.
+		// In any case, the pose will be corrected by timewarp.
+		if (Hmd->Type >= ovrHmd_DK2)
+		{
+			MotionPredictionInSeconds = 1. / 75;
+		}
+		else
+		{
+			MotionPredictionInSeconds = 1. / 60;
+		}
+		SupportedDistortionCaps = Hmd->DistortionCaps;
+		SupportedHmdCaps		= Hmd->HmdCaps;
+		SupportedTrackingCaps	= Hmd->TrackingCaps;
 
+#ifndef OVR_DIRECT_RENDERING
+		SupportedDistortionCaps &= ~ovrDistortionCap_Overdrive;
+#endif
 #ifndef OVR_VISION_ENABLED
-		SupportedSensorCaps &= ~ovrSensorCap_Position;
+		SupportedTrackingCaps &= ~ovrTrackingCap_Position;
 #endif
 
-		DistortionCaps	= SupportedDistortionCaps | ovrDistortionCap_TimeWarp;
-		SensorCaps		= SupportedSensorCaps;
-		HmdCaps			= SupportedHmdCaps & ~ovrHmdCap_NoVSync;
+		DistortionCaps	= SupportedDistortionCaps & (ovrDistortionCap_Chromatic | ovrDistortionCap_TimeWarp | ovrDistortionCap_Vignette | ovrDistortionCap_Overdrive);
+		TrackingCaps	= SupportedTrackingCaps & (ovrTrackingCap_Orientation | ovrTrackingCap_MagYawCorrection | ovrTrackingCap_Position);
+		HmdCaps			= SupportedHmdCaps & (ovrHmdCap_DynamicPrediction | ovrHmdCap_LowPersistence);
 		HmdCaps |= (bVSync ? 0 : ovrHmdCap_NoVSync);
 
+		if (!(SupportedDistortionCaps & ovrDistortionCap_TimeWarp))
+		{
+			bTimeWarp = false;
+		}
+
+		if (!bTimeWarp)
+		{
+			// Without Timewarp we may safely multiply the prediction by two.
+			MotionPredictionInSeconds *= 2;
+		}
+
+		bHmdPosTracking = (SupportedTrackingCaps & ovrTrackingCap_Position) != 0;
+
+		UpdateDistortionCaps();
 		UpdateHmdRenderInfo();
 		UpdateStereoRenderingParams();
 		UE_LOG(LogHMD, Log, TEXT("Oculus initialized."));
@@ -1477,7 +1622,7 @@
 	}
 	else
 	{
-		UE_LOG(LogHMD, Warning, TEXT("No Oculus HMD detected!"));
+		UE_LOG(LogHMD, Warning, TEXT("No Oculus HMD detected! Is Oculus Run-Time installed and service is running?"));
 	}
 
 	LoadFromIni();
@@ -1503,6 +1648,8 @@
 
 void FOculusRiftHMD::Shutdown()
 {
+	ovrHmd_AttachToWindow(Hmd, NULL, NULL, NULL);
+
 	if (!(InitStatus & eStartupExecuted))
 	{
 		return;
@@ -1537,26 +1684,49 @@
 	UE_LOG(LogHMD, Log, TEXT("Oculus shutdown."));
 }
 
+void FOculusRiftHMD::UpdateDistortionCaps()
+{
+	if (IsOpenGLPlatform(GRHIShaderPlatform))
+	{
+		DistortionCaps &= ~ovrDistortionCap_SRGB;
+		DistortionCaps |= ovrDistortionCap_FlipInput;
+	}
+	(bTimeWarp) ? DistortionCaps |= ovrDistortionCap_TimeWarp : DistortionCaps &= ~ovrDistortionCap_TimeWarp;
+	(bOverdrive) ? DistortionCaps |= ovrDistortionCap_Overdrive : DistortionCaps &= ~ovrDistortionCap_Overdrive;
+	//(bHQDistortion) ? DistortionCaps |= ovrDistortionCap_HqDistortion : DistortionCaps &= ~ovrDistortionCap_HqDistortion;
+	(bChromaAbCorrectionEnabled) ? DistortionCaps |= ovrDistortionCap_Chromatic : DistortionCaps &= ~ovrDistortionCap_Chromatic;
+#if !UE_BUILD_SHIPPING
+	(bProfiling) ? DistortionCaps |= ovrDistortionCap_ProfileNoTimewarpSpinWaits : DistortionCaps &= ~ovrDistortionCap_ProfileNoTimewarpSpinWaits;
+#endif // #if !UE_BUILD_SHIPPING
+
+#ifdef OVR_DIRECT_RENDERING 
+	if (GetActiveRHIBridgeImpl())
+	{
+		GetActiveRHIBridgeImpl()->SetNeedReinitRendererAPI();
+	}
+#endif // OVR_DIRECT_RENDERING
+}
+
 void FOculusRiftHMD::UpdateHmdCaps()
 {
 	if (Hmd)
 	{
-		SensorCaps = ovrSensorCap_Orientation;
+		TrackingCaps = ovrTrackingCap_Orientation;
 		if (bYawDriftCorrectionEnabled)
 		{
-			SensorCaps |= ovrSensorCap_YawCorrection;
+			TrackingCaps |= ovrTrackingCap_MagYawCorrection;
 		}
 		else
 		{
-			SensorCaps &= ~ovrSensorCap_YawCorrection;
+			TrackingCaps &= ~ovrTrackingCap_MagYawCorrection;
 		}
 		if (bHmdPosTracking)
 		{
-			SensorCaps |= ovrSensorCap_Position;
+			TrackingCaps |= ovrTrackingCap_Position;
 		}
 		else
 		{
-			SensorCaps &= ~ovrSensorCap_Position;
+			TrackingCaps &= ~ovrTrackingCap_Position;
 		}
 
 		if (bLowPersistenceMode)
@@ -1567,7 +1737,6 @@
 		{
 			HmdCaps &= ~ovrHmdCap_LowPersistence;
 		}
-		HmdCaps |= ovrHmdCap_LatencyTest;
 
 		if (bVSync) 
 		{
@@ -1578,22 +1747,20 @@
 			HmdCaps |= ovrHmdCap_NoVSync;
 		}
 
+		if (bMirrorToWindow)
+		{
+			HmdCaps &= ~ovrHmdCap_NoMirrorToWindow;
+		}
+		else
+		{
+			HmdCaps |= ovrHmdCap_NoMirrorToWindow;
+		}
 		ovrHmd_SetEnabledCaps(Hmd, HmdCaps);
 
-		ovrHmd_StartSensor(Hmd, SensorCaps, 0);
+		ovrHmd_ConfigureTracking(Hmd, TrackingCaps, 0);
 	}
 }
 
-static ovrFovPort SymmetricalFOV(const ovrFovPort& fov)
-{
-	ovrFovPort newFov;
-	const float VHalfTan = FMath::Max(fov.DownTan, fov.UpTan);
-	const float HHalfTan = FMath::Max(fov.LeftTan, fov.RightTan);
-	newFov.DownTan = newFov.UpTan		= VHalfTan; //FMath::Max(VHalfTan, HHalfTan);
-	newFov.LeftTan = newFov.RightTan	= HHalfTan; //FMath::Max(VHalfTan, HHalfTan);
-	return newFov;
-}
-
 FORCEINLINE static float GetVerticalFovRadians(const ovrFovPort& fov)
 {
 	return FMath::Atan(fov.UpTan) + FMath::Atan(fov.DownTan);
@@ -1608,18 +1775,15 @@
 {
 	check(Hmd);
 
-	// Assuming we've successfully grabbed the device, read the configuration data from it, which we'll use for projection
-	ovrHmd_GetDesc(Hmd, &HmdDesc);
-
-	UE_LOG(LogHMD, Warning, TEXT("HMD %s, Monitor %s, res = %d x %d, windowPos = {%d, %d}"), ANSI_TO_TCHAR(HmdDesc.ProductName), 
-		ANSI_TO_TCHAR(HmdDesc.DisplayDeviceName), HmdDesc.Resolution.w, HmdDesc.Resolution.h, HmdDesc.WindowsPos.x, HmdDesc.WindowsPos.y); 
+	UE_LOG(LogHMD, Warning, TEXT("HMD %s, Monitor %s, res = %d x %d, windowPos = {%d, %d}"), ANSI_TO_TCHAR(Hmd->ProductName), 
+		ANSI_TO_TCHAR(Hmd->DisplayDeviceName), Hmd->Resolution.w, Hmd->Resolution.h, Hmd->WindowsPos.x, Hmd->WindowsPos.y); 
 
 	// Calc FOV
 	if (!bOverrideFOV)
 	{
 		// Calc FOV, symmetrical, for each eye. 
-		EyeFov[0] = SymmetricalFOV(HmdDesc.DefaultEyeFov[0]);
-		EyeFov[1] = SymmetricalFOV(HmdDesc.DefaultEyeFov[1]);
+		EyeFov[0] = Hmd->DefaultEyeFov[0];
+		EyeFov[1] = Hmd->DefaultEyeFov[1];
 
 		// Calc FOV in radians
 		VFOVInRadians = FMath::Max(GetVerticalFovRadians(EyeFov[0]), GetVerticalFovRadians(EyeFov[1]));
@@ -1633,8 +1797,8 @@
 	idealRenderTargetSize.w = recommenedTex0Size.w + recommenedTex1Size.w;
 	idealRenderTargetSize.h = FMath::Max(recommenedTex0Size.h, recommenedTex1Size.h);
 
-	IdealScreenPercentage = FMath::Max(float(idealRenderTargetSize.w) / float(HmdDesc.Resolution.w) * 100.f,
-									   float(idealRenderTargetSize.h) / float(HmdDesc.Resolution.h) * 100.f);
+	IdealScreenPercentage = FMath::Max(float(idealRenderTargetSize.w) / float(Hmd->Resolution.w) * 100.f,
+									   float(idealRenderTargetSize.h) / float(Hmd->Resolution.h) * 100.f);
 
 	// Override eye distance by the value from HMDInfo (stored in Profile).
 	if (!bOverrideIPD)
@@ -1643,7 +1807,7 @@
 	}
 
 	// Default texture size (per eye) is equal to half of W x H resolution. Will be overridden in SetupView.
-	EyeViewportSize = FIntPoint(HmdDesc.Resolution.w / 2, HmdDesc.Resolution.h);
+	EyeViewportSize = FIntPoint(Hmd->Resolution.w / 2, Hmd->Resolution.h);
 
 	bNeedUpdateStereoRenderingParams = true;
 }
@@ -1692,8 +1856,8 @@
 			// Recenter projection (normalized)
 			const float LensRecenter = 4.0f * LensRecenterM / ScreenSizeInMeters[0];
 
-			HudOffset = 0.25f * InterpupillaryDistance * (HmdDesc.Resolution.w / ScreenSizeInMeters[0]) / 15.0f;
-			CanvasCenterOffset = (0.25f * LensRecenter) * HmdDesc.Resolution.w;
+			HudOffset = 0.25f * InterpupillaryDistance * (Hmd->Resolution.w / ScreenSizeInMeters[0]) / 15.0f;
+			CanvasCenterOffset = (0.25f * LensRecenter) * Hmd->Resolution.w;
 		}
 
 		PrecalculatePostProcess_NoLock();
@@ -1725,14 +1889,6 @@
 	{
 		bDevSettingsEnabled = v;
 	}
-	if (GConfig->GetBool(OculusSettings, TEXT("bTiltCorrectionEnabled"), v, GEngineIni))
-	{
-		bTiltCorrectionEnabled = v;
-	}
-	if (GConfig->GetFloat(OculusSettings, TEXT("MotionPrediction"), f, GEngineIni))
-	{
-		MotionPredictionInSeconds = f;
-	}
 	if (GConfig->GetBool(OculusSettings, TEXT("bOverrideIPD"), v, GEngineIni))
 	{
 		bOverrideIPD = v;
@@ -1779,12 +1935,6 @@
 	{
 		bAllowFinishCurrentFrame = v;
 	}
-#ifdef OVR_VISION_ENABLED
-	if (GConfig->GetBool(OculusSettings, TEXT("bHmdPosTracking"), v, GEngineIni))
-	{
-		bHmdPosTracking = v;
-	}
-#endif // #ifdef OVR_VISION_ENABLED
 	if (GConfig->GetBool(OculusSettings, TEXT("bLowPersistenceMode"), v, GEngineIni))
 	{
 		bLowPersistenceMode = v;
@@ -1809,8 +1959,6 @@
 	GConfig->SetBool(OculusSettings, TEXT("bChromaAbCorrectionEnabled"), bChromaAbCorrectionEnabled, GEngineIni);
 	GConfig->SetBool(OculusSettings, TEXT("bYawDriftCorrectionEnabled"), bYawDriftCorrectionEnabled, GEngineIni);
 	GConfig->SetBool(OculusSettings, TEXT("bDevSettingsEnabled"), bDevSettingsEnabled, GEngineIni);
-	GConfig->SetBool(OculusSettings, TEXT("bTiltCorrectionEnabled"), bTiltCorrectionEnabled, GEngineIni);
-	GConfig->SetFloat(OculusSettings, TEXT("MotionPrediction"), float(MotionPredictionInSeconds), GEngineIni);
 
 	GConfig->SetBool(OculusSettings, TEXT("bOverrideIPD"), bOverrideIPD, GEngineIni);
 	if (bOverrideIPD)
@@ -1838,9 +1986,6 @@
 	}
 	GConfig->SetBool(OculusSettings, TEXT("bAllowFinishCurrentFrame"), bAllowFinishCurrentFrame, GEngineIni);
 
-#ifdef OVR_VISION_ENABLED
-	GConfig->SetBool(OculusSettings, TEXT("bHmdPosTracking"), bHmdPosTracking, GEngineIni);
-#endif
 	GConfig->SetBool(OculusSettings, TEXT("bLowPersistenceMode"), bLowPersistenceMode, GEngineIni);
 
 	GConfig->SetBool(OculusSettings, TEXT("bUpdateOnRT"), bUpdateOnRT, GEngineIni);
@@ -1849,5 +1994,18 @@
 	GConfig->SetFloat(OculusSettings, TEXT("NearClippingPlane"), NearClippingPlane, GEngineIni);
 }
 
+bool FOculusRiftHMD::HandleInputKey(UPlayerInput* pPlayerInput,
+	const FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)
+{
+	if (EventType == IE_Pressed && Hmd && IsStereoEnabled())
+	{
+		if (!Key.IsMouseButton())
+		{
+			ovrHmd_DismissHSWDisplay(Hmd);
+		}
+	}
+	return false;
+}
+
 #endif //OCULUS_RIFT_SUPPORTED_PLATFORMS
 
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.h	2014-09-05 02:22:27.646572000 -0400
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftHMD.h	2014-08-26 15:38:38.970769600 -0400
@@ -18,6 +18,10 @@
 	#define OVR_DIRECT_RENDERING
 	#define OVR_D3D_VERSION 11
 	#define OVR_GL
+#elif PLATFORM_MAC
+	#define OVR_VISION_ENABLED
+    #define OVR_DIRECT_RENDERING
+    #define OVR_GL
 #endif
 
 #ifdef OVR_VISION_ENABLED
@@ -28,16 +32,16 @@
 
 #if OCULUS_RIFT_SUPPORTED_PLATFORMS
 	
-	#include "OVRVersion.h"
+	#include "OVR.h"
+	#include "OVR_Version.h"
+	#include "OVR_Kernel.h"
 
-	#include "../Src/Kernel/OVR_Math.h"
 	#include "../Src/Kernel/OVR_Threads.h"
-	#include "../Src/OVR_CAPI.h"
-	#include "../Src/Kernel/OVR_Color.h"
-	#include "../Src/Kernel/OVR_Timer.h"
 
 #ifdef OVR_DIRECT_RENDERING
+    #if PLATFORM_WINDOWS
 	#include "AllowWindowsPlatformTypes.h"
+    #endif
 	#ifdef OVR_D3D_VERSION
 		#include "../Src/OVR_CAPI_D3D.h"
 	#endif // OVR_D3D_VERSION
@@ -60,8 +64,9 @@
  */
 class FOculusRiftHMD : public IHeadMountedDisplay, public ISceneViewExtension
 {
-
 public:
+	static void PreInit();
+
 	/** IHeadMountedDisplay interface */
 	virtual bool IsHMDEnabled() const override;
 	virtual void EnableHMD(bool allow = true) override;
@@ -87,6 +92,7 @@
 	virtual bool Exec( UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar ) override;
 	virtual void OnScreenModeChange(EWindowMode::Type WindowMode) override;
 
+	virtual bool IsFullScreenAllowed() const override;
 	virtual void RecordAnalytics() override;
 
 	/** IStereoRendering interface */
@@ -102,8 +108,9 @@
 	virtual void GetEyeRenderParams_RenderThread(EStereoscopicPass StereoPass, FVector2D& EyeToSrcUVScaleValue, FVector2D& EyeToSrcUVOffsetValue) const override;
 	virtual void GetTimewarpMatrices_RenderThread(EStereoscopicPass StereoPass, FMatrix& EyeRotationStart, FMatrix& EyeRotationEnd) const override;
 
-#ifdef OVR_DIRECT_RENDERING
 	virtual void UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& Viewport) override;
+
+#ifdef OVR_DIRECT_RENDERING
 	virtual void CalculateRenderTargetSize(uint32& InOutSizeX, uint32& InOutSizeY) const override;
 	virtual bool NeedReAllocateViewportRenderTarget(const FViewport& Viewport) const override;
 #endif//OVR_DIRECT_RENDERING
@@ -141,8 +148,13 @@
 	virtual void DrawDistortionMesh_RenderThread(struct FRenderingCompositePassContext& Context, const FSceneView& View, const FIntPoint& TextureSize) override;
 	virtual void UpdateScreenSettings(const FViewport*) override;
 
+	virtual bool HandleInputKey(class UPlayerInput*, const FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad) override;
+
 	virtual void DrawDebug(UCanvas* Canvas, EStereoscopicPass StereoPass) override;
 
+	void GetCurrentPose(FQuat& CurrentOrientation, FVector& CurrentPosition) const;
+	void BeginRendering_RenderThread();
+
 #ifdef OVR_DIRECT_RENDERING
 	class BridgeBaseImpl : public FRHICustomPresent
 	{
@@ -239,13 +251,11 @@
 #endif // OVR_GL
 	BridgeBaseImpl* GetActiveRHIBridgeImpl();
 
-	void BeginRendering_RenderThread();
-	void FinishRendering_RenderThread();
 	void ShutdownRendering();
 
 #else
 
-virtual void FinishRenderingFrame_RenderThread(FRHICommandListImmediate& RHICmdList) override;
+	virtual void FinishRenderingFrame_RenderThread(FRHICommandListImmediate& RHICmdList) override;
 
 #endif // #ifdef OVR_DIRECT_RENDERING
 
@@ -370,6 +380,7 @@
 
 	void PrecalculatePostProcess_NoLock();
 
+	void UpdateDistortionCaps();
 	void UpdateHmdCaps();
 
 	void PoseToOrientationAndPosition(const ovrPosef& InPose, FQuat& OutOrientation, FVector& OutPosition) const;
@@ -464,9 +475,6 @@
 	/** Yaw drift correction on/off */
 	bool bYawDriftCorrectionEnabled;
 
-	/** HMD tilt correction on/off */
-	bool bTiltCorrectionEnabled;
-
 	/** Whether or not 2D stereo settings overridden. */
 	bool bOverride2D;
 	/** HUD stereo offset */
@@ -484,10 +492,19 @@
 	bool				bUpdateOnRT;
 	mutable OVR::Lock	UpdateOnRTLock;
 
+	/** Overdrive brightness transitions to reduce artifacts on DK2+ displays */
+	bool bOverdrive;
+
+	/** High-quality sampling of distortion buffer for anti-aliasing */
+	bool bHQDistortion;
+
 	/** Enforces headtracking to work even in non-stereo mode (for debugging or screenshots). 
 	    See 'MOTION ENFORCE' console command. */
 	bool bHeadTrackingEnforced;
 
+	/** Is mirroring enabled or not (see 'HMD MIRROR' console cmd) */
+	bool bMirrorToWindow;
+
 #if !UE_BUILD_SHIPPING
 	/** Draw tracking camera frustum, for debugging purposes. 
 	 *  See 'HMDPOS SHOWCAMERA ON|OFF' console command.
@@ -502,6 +519,9 @@
 
 	/** Draw lens centered grid */
 	bool				bDrawGrid;
+
+	/** Profiling mode, removed extra waits in Present (Direct Rendering). See 'hmd profile' cmd */
+	bool				bProfiling;
 #endif
 
 	/** Whether timewarp is enabled or not */
@@ -513,14 +533,14 @@
 	float					FarClippingPlane;
 
 	/** Player's orientation tracking */
-	FQuat					CurHmdOrientation;
+	mutable FQuat			CurHmdOrientation;
 
 	FRotator				DeltaControlRotation;    // same as DeltaControlOrientation but as rotator
 	FQuat					DeltaControlOrientation; // same as DeltaControlRotation but as quat
 
-	FVector					CurHmdPosition;
+	mutable FVector			CurHmdPosition;
 
-	FQuat					LastHmdOrientation; // contains last APPLIED ON GT HMD orientation
+	mutable FQuat			LastHmdOrientation; // contains last APPLIED ON GT HMD orientation
 	FVector					LastHmdPosition;	// contains last APPLIED ON GT HMD position 
 
 	/** HMD base values, specify forward orientation and zero pos offset */
@@ -528,7 +548,6 @@
 	FQuat					BaseOrientation; // base orientation
 
 	ovrHmd					Hmd;
-	ovrHmdDesc				HmdDesc;
 	ovrEyeRenderDesc		EyeRenderDesc[2];			// 0 - left, 1 - right, same as Views
 	ovrMatrix4f				EyeProjectionMatrices[2];	// 0 - left, 1 - right, same as Views
 	ovrFovPort				EyeFov[2];					// 0 - left, 1 - right, same as Views
@@ -536,11 +555,11 @@
 	ovrRecti				EyeRenderViewport[2];		// 0 - left, 1 - right, same as Views
 	ovrSizei				TextureSize; // texture size (for both eyes)
 
-	unsigned				SensorCaps;
+	unsigned				TrackingCaps;
 	unsigned				DistortionCaps;
 	unsigned				HmdCaps;
 
-	unsigned				SupportedSensorCaps;
+	unsigned				SupportedTrackingCaps;
 	unsigned				SupportedDistortionCaps;
 	unsigned				SupportedHmdCaps;
 
@@ -610,6 +629,8 @@
 	/** True, if pos tracking is enabled */
 	bool						bHmdPosTracking;
 	mutable bool				bHaveVisionTracking;
+
+	void*						OSWindowHandle;
 };
 
 DEFINE_LOG_CATEGORY_STATIC(LogHMD, Log, All);
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftRender.cpp	2014-09-05 02:22:27.660585600 -0400
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Private/OculusRiftRender.cpp	2014-08-26 15:38:39.045840000 -0400
@@ -2,6 +2,9 @@
 //
 #include "OculusRiftPrivate.h"
 #include "OculusRiftHMD.h"
+
+#if OCULUS_RIFT_SUPPORTED_PLATFORMS
+
 #include "../Src/OVR_Stereo.h"
 
 #include "RendererPrivate.h"
@@ -161,22 +164,6 @@
 		RenderParams_RenderThread.pDistortionMesh[1] = pDistortionMesh[1];
 		RenderParams_RenderThread.bTimeWarp = bTimeWarp;
 	}
-	RenderParams_RenderThread.bFrameBegun = true;
-
-	// get latest orientation/position and cache it
-	if (bUpdateOnRT)
-	{
-		Lock::Locker lock(&UpdateOnRTLock);
-		if (!RenderParams_RenderThread.bTimeWarp)
-		{
-			GetCurrentOrientationAndPosition(CurHmdOrientation, CurHmdPosition);
-			RenderParams_RenderThread.CurHmdOrientation = CurHmdOrientation;
-			RenderParams_RenderThread.CurHmdPosition = CurHmdPosition;
-		}
-
-		RenderParams_RenderThread.LastHmdPosition = LastHmdPosition;
-		RenderParams_RenderThread.DeltaControlOrientation = DeltaControlOrientation;
-	}
 #else
 	{
 		// make a copy of StereoParams to access from the RenderThread.
@@ -187,6 +174,7 @@
 		RenderParams_RenderThread.EyeFov[1] = EyeFov[1];
 		RenderParams_RenderThread.bTimeWarp = bTimeWarp;
 	}
+#endif
 	// get latest orientation/position and cache it
 	if (bUpdateOnRT)
 	{
@@ -196,7 +184,6 @@
 	}
 
 	BeginRendering_RenderThread();
-#endif
 }
 
 void FOculusRiftHMD::PreRenderView_RenderThread(FSceneView& View)
@@ -207,37 +194,13 @@
 		return;
 
 	const ovrEyeType eyeIdx = (View.StereoPass == eSSP_LEFT_EYE) ? ovrEye_Left : ovrEye_Right;
-#ifdef OVR_DIRECT_RENDERING
-	FQuat		CurrentHmdOrientation;
-	FVector		CurrentHmdPosition;
-	if (RenderParams_RenderThread.bFrameBegun)
-	{
-		// Get new predicted pose to corresponding eye.
-		RenderParams_RenderThread.EyeRenderPose[eyeIdx] = ovrHmd_BeginEyeRender(Hmd, eyeIdx);
-		PoseToOrientationAndPosition(RenderParams_RenderThread.EyeRenderPose[eyeIdx], CurrentHmdOrientation, CurrentHmdPosition);
-	}
-	else
-	{
-		CurrentHmdOrientation = FQuat::Identity;
-		CurrentHmdPosition    = FVector::ZeroVector;
-	}
-#else
 	FQuat	CurrentHmdOrientation;
 	FVector	CurrentHmdPosition;
 
-	if (RenderParams_RenderThread.bTimeWarp)
-	{
 		// Get new predicted pose to corresponding eye.
 		ovrPosef eyeRenderPose = ovrHmd_GetEyePose(Hmd, eyeIdx);
 		PoseToOrientationAndPosition(eyeRenderPose, CurrentHmdOrientation, CurrentHmdPosition);
 		RenderParams_RenderThread.EyeRenderPose[eyeIdx] = eyeRenderPose;
-	}
-	else
-	{
-		CurrentHmdOrientation = RenderParams_RenderThread.CurHmdOrientation;
-		CurrentHmdPosition    = RenderParams_RenderThread.CurHmdPosition;
-	}
-#endif
 
 	if (bUpdateOnRT)
 	{
@@ -250,27 +213,15 @@
 	}
 }
 
-#ifdef OVR_DIRECT_RENDERING 
-FOculusRiftHMD::BridgeBaseImpl* FOculusRiftHMD::GetActiveRHIBridgeImpl()
+void FOculusRiftHMD::BeginRendering_RenderThread()
 {
-#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
-	if (pD3D11Bridge)
-	{
-		return pD3D11Bridge;
-	}
-#endif
-#if defined(OVR_GL)
-	if (pOGLBridge)
+	check(IsInRenderingThread());
+	if (RenderParams_RenderThread.bFrameBegun)
 	{
-		return pOGLBridge;
+		return;
 	}
-#endif
-	return nullptr;
-}
 
-void FOculusRiftHMD::BeginRendering_RenderThread()
-{
-	check(IsInRenderingThread());
+#ifdef OVR_DIRECT_RENDERING 
 	{
 		Lock::Locker lock(&StereoParamsLock);
 
@@ -278,23 +229,29 @@
 	}
 
 	ovrHmd_BeginFrame(Hmd, 0);
+#else
+	ovrHmd_BeginFrameTiming(Hmd, 0);
+#endif
 	RenderParams_RenderThread.bFrameBegun = true;
 }
 
-void FOculusRiftHMD::FinishRendering_RenderThread()
-{
-	check(IsInRenderingThread())
 
-	if (RenderParams_RenderThread.bFrameBegun)
+#ifdef OVR_DIRECT_RENDERING 
+FOculusRiftHMD::BridgeBaseImpl* FOculusRiftHMD::GetActiveRHIBridgeImpl()
+{
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+	if (pD3D11Bridge)
 	{
-		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
-		ovrHmd_EndFrame(Hmd); // This function will present
-		RenderParams_RenderThread.bFrameBegun = false;
+		return pD3D11Bridge;
 	}
-	else
+#endif
+#if defined(OVR_GL)
+	if (pOGLBridge)
 	{
-		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
+		return pOGLBridge;
 	}
+#endif
+	return nullptr;
 }
 
 void FOculusRiftHMD::CalculateRenderTargetSize(uint32& InOutSizeX, uint32& InOutSizeY) const
@@ -382,6 +339,17 @@
 	{
 		if (bDrawGrid)
 		{
+			bool bPopTransform = false;
+			if (EyeRenderDesc[0].DistortedViewport.Size.w != FMath::CeilToInt(Canvas->ClipX / 2) ||
+				EyeRenderDesc[0].DistortedViewport.Size.h != Canvas->ClipY)
+			{
+				bPopTransform = true;
+				Canvas->Canvas->PushAbsoluteTransform(FScaleMatrix(
+					FVector((Canvas->ClipX * 0.5f) / float(EyeRenderDesc[0].DistortedViewport.Size.w),
+					Canvas->ClipY / float(EyeRenderDesc[0].DistortedViewport.Size.h),
+					1.0f)));
+			}
+
 			const FColor cNormal(255, 0, 0);
 			const FColor cSpacer(255, 255, 0);
 			const FColor cMid(0, 128, 255);
@@ -405,7 +373,7 @@
 				limitX = Alg::Max(renderViewportW - midX, midX);
 				limitY = Alg::Max(renderViewportH - midY, midY);
 
-				int spacerMask = (lineStep << 2) - 1;
+				int spacerMask = (lineStep << 1) - 1;
 
 				for (int xp = 0; xp < limitX; xp += lineStep)
 				{
@@ -458,6 +426,10 @@
 					}
 				}
 			}
+			if (bPopTransform)
+			{
+				Canvas->Canvas->PopTransform();
+			}
 		}
 		return;
 	}
@@ -514,7 +486,7 @@
 		Str = FString::Printf(TEXT("W-to-m scale: %.2f uu/m"), WorldToMetersScale);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
 
-		if ((HmdDesc.HmdCaps & ovrHmdCap_LatencyTest) != 0)
+		if ((SupportedHmdCaps & ovrHmdCap_DynamicPrediction) != 0)
 		{
 			float latencies[3] = { 0.0f, 0.0f, 0.0f };
 			if (ovrHmd_GetFloatArray(Hmd, "DK2Latency", latencies, 3) == 3)
@@ -538,7 +510,7 @@
 		X = (int32)LeftPos + 200;
 		Y = (int32)TopPos;
 
-		StatusStr = ((SupportedSensorCaps & ovrSensorCap_Position) != 0) ?
+		StatusStr = ((SupportedTrackingCaps & ovrTrackingCap_Position) != 0) ?
 			((bHmdPosTracking) ? TEXT("ON") : TEXT("OFF")) : TEXT("UNSUP");
 		Str = FString::Printf(TEXT("PosTr: %s"), *StatusStr);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
@@ -557,49 +529,55 @@
 		Str = FString::Printf(TEXT("LowPers: %s"), *StatusStr);
 		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
 		Y += RowHeight;
+
+		StatusStr = ((SupportedDistortionCaps & ovrDistortionCap_Overdrive) != 0) ?
+			((bOverdrive) ? TEXT("ON") : TEXT("OFF")) : TEXT("UNSUP");
+		Str = FString::Printf(TEXT("Overdrive: %s"), *StatusStr);
+		Canvas->Canvas->DrawShadowedString(X, Y, *Str, Font, TextColor);
+		Y += RowHeight;
 	}
 #endif // #if !UE_BUILD_SHIPPING
 }
 
-#ifdef OVR_DIRECT_RENDERING
-void FOculusRiftHMD::ShutdownRendering()
+void FOculusRiftHMD::UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& InViewport)
 {
-#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
-	if (pD3D11Bridge)
+	check(IsInGameThread());
+
+	FRHIViewport* const ViewportRHI = InViewport.GetViewportRHI().GetReference();
+
+	if (!IsStereoEnabled())
 	{
-		pD3D11Bridge->Shutdown();
-		pD3D11Bridge = NULL;
+		if (!bUseSeparateRenderTarget)
+		{
+			ViewportRHI->SetCustomPresent(nullptr);
 	}
-#endif
-#if defined(OVR_GL)
-	if (pOGLBridge)
+#if PLATFORM_WINDOWS
+		if (OSWindowHandle)
 	{
-		pOGLBridge->Shutdown();
-		pOGLBridge = NULL;
+			ovrHmd_AttachToWindow(Hmd, NULL, NULL, NULL);
+			OSWindowHandle = nullptr;
 	}
 #endif
+		return;
+	}
 
-	ovrHmd_Destroy(Hmd);
-	Hmd = nullptr;
-}
-
-void FOculusRiftHMD::UpdateViewport(bool bUseSeparateRenderTarget, const FViewport& Viewport)
-{
-	check(IsInGameThread());
-
-	FRHIViewport* const ViewportRHI = Viewport.GetViewportRHI().GetReference();
-	
-	if (!bUseSeparateRenderTarget || !IsStereoEnabled())
+#if PLATFORM_WINDOWS
+	void *wnd = ViewportRHI->GetNativeWindow();
+	if (wnd && wnd != OSWindowHandle)
 	{
-		ViewportRHI->SetCustomPresent(nullptr);
-		return;
+		OSWindowHandle = wnd;
+		HWND Window = *(HWND*)wnd;
+		ovrHmd_AttachToWindow(Hmd, Window, NULL, NULL);
 	}
+#endif
+
+#ifdef OVR_DIRECT_RENDERING
 
 	check(GetActiveRHIBridgeImpl());
 
-	const FTexture2DRHIRef& RT   = Viewport.GetRenderTargetTexture();
+	const FTexture2DRHIRef& RT = InViewport.GetRenderTargetTexture();
 	check(IsValidRef(RT));
-	const FIntPoint NewEyeRTSize = FIntPoint((RT->GetSizeX() + 1)/2, RT->GetSizeY());
+	const FIntPoint NewEyeRTSize = FIntPoint((RT->GetSizeX() + 1) / 2, RT->GetSizeY());
 	if (EyeViewportSize != NewEyeRTSize)
 	{
 		EyeViewportSize.X = NewEyeRTSize.X;
@@ -610,7 +588,31 @@
 	{
 		UpdateStereoRenderingParams();
 	}
-	GetActiveRHIBridgeImpl()->UpdateViewport(Viewport, ViewportRHI);
+	GetActiveRHIBridgeImpl()->UpdateViewport(InViewport, ViewportRHI);
+#endif // #ifdef OVR_DIRECT_RENDERING
+}
+
+#ifdef OVR_DIRECT_RENDERING
+void FOculusRiftHMD::ShutdownRendering()
+{
+	check(IsInRenderingThread());
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+	if (pD3D11Bridge)
+	{
+		pD3D11Bridge->Shutdown();
+		pD3D11Bridge = NULL;
+	}
+#endif
+#if defined(OVR_GL)
+	if (pOGLBridge)
+	{
+		pOGLBridge->Shutdown();
+		pOGLBridge = NULL;
+	}
+#endif
+
+	ovrHmd_Destroy(Hmd);
+	Hmd = nullptr;
 }
 
 #if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
@@ -632,7 +634,7 @@
 		{
 			OVR::Lock::Locker lock(&ModifyLock);
 			check(Cfg.D3D11.pSwapChain); // make sure Config is initialized
-			(Plugin->bTimeWarp) ? Plugin->DistortionCaps |= ovrDistortionCap_TimeWarp : Plugin->DistortionCaps &= ~ovrDistortionCap_TimeWarp;
+			Plugin->UpdateDistortionCaps();
 			if (!ovrHmd_ConfigureRendering(Plugin->Hmd, &Cfg.Config, Plugin->DistortionCaps, 
 				Plugin->RenderParams_RenderThread.EyeFov, Plugin->RenderParams_RenderThread.EyeRenderDesc))
 			{
@@ -693,14 +695,18 @@
 void FOculusRiftHMD::D3D11Bridge::FinishRendering()
 {
 	check(IsInRenderingThread());
-	if (Plugin->RenderParams_RenderThread.bFrameBegun)
-	{
-		if (Plugin->RenderParams_RenderThread.ShowFlags.Rendering)
+
+	if (Plugin->RenderParams_RenderThread.bFrameBegun && !bNeedReinitEyeTextures) 
 		{
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Left, Plugin->RenderParams_RenderThread.EyeRenderPose[0], &EyeTexture_RenderThread[0].Texture);
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Right, Plugin->RenderParams_RenderThread.EyeRenderPose[1], &EyeTexture_RenderThread[1].Texture);
+		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
+		const ovrTexture eyeTextures[2] = { EyeTexture_RenderThread[0].Texture, EyeTexture_RenderThread[1].Texture };
+		ovrHmd_EndFrame(Plugin->Hmd, Plugin->RenderParams_RenderThread.EyeRenderPose, eyeTextures); // This function will present
 		}
+	else
+	{
+		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
 	}
+	Plugin->RenderParams_RenderThread.bFrameBegun = false;
 }
 
 void FOculusRiftHMD::D3D11Bridge::Reset_RenderThread()
@@ -902,8 +908,6 @@
 
 	FinishRendering();
 
-	Plugin->FinishRendering_RenderThread();
-
 	return false; // indicates that we are presenting here, UE shouldn't do Present.
 }
 #endif // #if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
@@ -927,9 +931,7 @@
 		if (bNeedReinitRendererAPI)
 		{
 			OVR::Lock::Locker lock(&ModifyLock);
-			Plugin->DistortionCaps &= ~ovrDistortionCap_SRGB;
-			Plugin->DistortionCaps |= ovrDistortionCap_FlipInput;
-			(Plugin->bTimeWarp) ? Plugin->DistortionCaps |= ovrDistortionCap_TimeWarp : Plugin->DistortionCaps &= ~ovrDistortionCap_TimeWarp;
+			Plugin->UpdateDistortionCaps();
 			if (!ovrHmd_ConfigureRendering(Plugin->Hmd, &Cfg.Config, Plugin->DistortionCaps, 
 				Plugin->RenderParams_RenderThread.EyeFov, Plugin->RenderParams_RenderThread.EyeRenderDesc))
 			{
@@ -951,13 +953,29 @@
 
 void FOculusRiftHMD::OGLBridge::FinishRendering()
 {
-	if (Plugin->RenderParams_RenderThread.bFrameBegun)
+	check(IsInRenderingThread());
+
+	if (bNeedReinitEyeTextures)
 	{
-		if (Plugin->RenderParams_RenderThread.ShowFlags.Rendering)
+		// make sure we use most recent textures, otherwise there will 
+		// be an assertion.
+		OVR::Lock::Locker lock(&ModifyEyeTexturesLock);
+
+		EyeTexture_RenderThread[0] = EyeTexture[0];
+		EyeTexture_RenderThread[1] = EyeTexture[1];
+		bNeedReinitEyeTextures = false;
+	}
+
+	if (Plugin->RenderParams_RenderThread.bFrameBegun)
 		{
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Left, Plugin->RenderParams_RenderThread.EyeRenderPose[0], &EyeTexture_RenderThread[0].Texture);
-			ovrHmd_EndEyeRender(Plugin->Hmd, ovrEye_Right, Plugin->RenderParams_RenderThread.EyeRenderPose[1], &EyeTexture_RenderThread[1].Texture);
+		// Finish the frame and let OVR do buffer swap (Present) and flush/sync.
+		const ovrTexture eyeTextures[2] = { EyeTexture_RenderThread[0].Texture, EyeTexture_RenderThread[1].Texture };
+		ovrHmd_EndFrame(Plugin->Hmd, Plugin->RenderParams_RenderThread.EyeRenderPose, eyeTextures); // This function will present
+		Plugin->RenderParams_RenderThread.bFrameBegun = false;
 		}
+	else
+	{
+		UE_LOG(LogHMD, Warning, TEXT("Skipping frame: FinishRendering called with no corresponding BeginRendering (was BackBuffer re-allocated?)"));
 	}
 }
 
@@ -971,6 +989,8 @@
 
 void FOculusRiftHMD::OGLBridge::Reset()
 {
+	check(IsInRenderingThread());
+
 	EyeTexture[0].OGL.TexId = 0;
 	EyeTexture[1].OGL.TexId = 0;
 	EyeTexture_RenderThread[0].OGL.TexId = 0;
@@ -1056,11 +1076,10 @@
 
 	FinishRendering();
 
-	Plugin->FinishRendering_RenderThread();
-
 	return false; // indicates that we are presenting here, UE shouldn't do Present.
 }
 #endif // #if defined(OVR_GL)
 #endif // OVR_DIRECT_RENDERING
 
 
+#endif // OCULUS_RIFT_SUPPORTED_PLATFORMS
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Plugins/OculusRift/Source/OculusRift/Public/IOculusRiftPlugin.h	2014-09-05 02:22:09.101760500 -0400
+++ ./Engine/Plugins/OculusRift/Source/OculusRift/Public/IOculusRiftPlugin.h	2014-08-18 16:16:29.539227900 -0400
@@ -5,7 +5,8 @@
 #include "ModuleManager.h"
 #include "IHeadMountedDisplayModule.h"
 
-#define OCULUS_RIFT_SUPPORTED_PLATFORMS PLATFORM_WINDOWS || PLATFORM_MAC
+// Oculus support is not available on windows xp
+#define OCULUS_RIFT_SUPPORTED_PLATFORMS (PLATFORM_WINDOWS && WINVER > 0x0502) || PLATFORM_MAC
 
 /**
  * The public interface to this module.  In most cases, this interface is only public to sibling modules 
--- ../../../../UE4-QA/Engine/Source/Developer/iOS/IOSTargetPlatform/Private/IOSTargetPlatform.cpp	2014-09-05 02:13:41.447174600 -0400
+++ ./Engine/Source/Developer/iOS/IOSTargetPlatform/Private/IOSTargetPlatform.cpp	2014-08-26 15:41:41.739734300 -0400
@@ -99,6 +99,13 @@
 	return biOSSDKInstalled;
 }
 
+static FString OutputMessage;
+static void OnOutput(FString Message)
+{
+	OutputMessage += Message;
+	UE_LOG(LogTemp, Display, TEXT("%s"), *Message);
+}
+
 int FIOSTargetPlatform::DoesntHaveRequirements(const FString& ProjectPath, bool bProjectHasCode, FString& OutDocumentationPath) const
 {
 	int bReadyToBuild = ETargetPlatformReadyStatus::Ready; // @todo How do we check that the iOS SDK is installed when building from Windows? Is that even possible?
@@ -122,8 +129,10 @@
 
 	// shell to IPP and get the status of the provision and cert
 	FString CmdExe = FPaths::ConvertRelativePathToFull(FPaths::EngineDir() / TEXT("Binaries/DotNet/IOS/IPhonePackager.exe"));
-	FString CommandLine = FString::Printf(TEXT("Validate Engine -project %s"), *ProjectPath);
+	FString CommandLine = FString::Printf(TEXT("Validate Engine -project \"%s\""), *ProjectPath);
 	TSharedPtr<FMonitoredProcess> IPPProcess = MakeShareable(new FMonitoredProcess(CmdExe, CommandLine, true));
+	OutputMessage = TEXT("");
+	IPPProcess->OnOutput().BindStatic(&OnOutput);
 	IPPProcess->Launch();
 	while(IPPProcess->IsRunning())
 	{
--- ../../../../UE4-QA/Engine/Source/Editor/Persona/Private/Persona.cpp	2014-09-05 02:14:06.019775700 -0400
+++ ./Engine/Source/Editor/Persona/Private/Persona.cpp	2014-08-26 15:40:14.422578300 -0400
@@ -658,6 +658,9 @@
 		}
 	}
 
+	// Force validation of preview attached assets (catch case of never doing it if we dont have a valid preview mesh)
+	ValidatePreviewAttachedAssets(NULL);
+
 	UAnimBlueprint* AnimBlueprint = GetAnimBlueprint();
 	PreviewComponent->SetAnimInstanceClass(AnimBlueprint ? AnimBlueprint->GeneratedClass : NULL);
 
--- ../../../../UE4-QA/Engine/Source/Programs/AutomationTool/IOS/IOSPlatform.Automation.cs	2014-09-05 02:14:22.747842500 -0400
+++ ./Engine/Source/Programs/AutomationTool/IOS/IOSPlatform.Automation.cs	2014-08-26 15:40:14.468621700 -0400
@@ -341,13 +341,13 @@
 
 		// copy the appropriate plist file over
 		string SourcePListFile = CombinePaths(LocalRoot, "Engine", "Build", "IOS", "UE4Game-Info.plist");
-		if (File.Exists(ProjectRoot + "/Build/IOS/" + ShortProjectName + "-Info.plist"))
+		if (File.Exists(ProjectRoot + "/Build/IOS/Info.plist"))
 		{
-			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", ShortProjectName + "-Info.plist");
+			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", "Info.plist");
 		}
-		else if (File.Exists(ProjectRoot + "/Build/IOS/Info.plist"))
+		else if (File.Exists(ProjectRoot + "/Build/IOS/" + ShortProjectName + "-Info.plist"))
 		{
-			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", "Info.plist");
+			SourcePListFile = CombinePaths(ProjectRoot, "Build", "IOS", ShortProjectName + "-Info.plist");
 		}
 		else if (Directory.Exists(ProjectRoot + "/Build/IOS"))
 		{
@@ -703,13 +703,13 @@
 			if (GetCodeSignDesirability(Params))
 			{
 				string SourcePListFile = CombinePaths(SC.LocalRoot, "Engine", "Build", "IOS", "UE4Game-Info.plist");
-				if (File.Exists(SC.ProjectRoot + "/Build/IOS/" + SC.ShortProjectName + "-Info.plist"))
+				if (File.Exists(SC.ProjectRoot + "/Build/IOS/Info.plist"))
 				{
-					SourcePListFile = CombinePaths(SC.ProjectRoot, "Build", "IOS", SC.ShortProjectName + "-Info.plist");
+					SourcePListFile = CombinePaths(SC.ProjectRoot, "Build", "IOS", "Info.plist");
 				}
-				else if (File.Exists(SC.ProjectRoot + "/Build/IOS/Info.plist"))
+				else if (File.Exists(SC.ProjectRoot + "/Build/IOS/" + SC.ShortProjectName + "-Info.plist"))
 				{
-					SourcePListFile = CombinePaths(SC.ProjectRoot, "Build", "IOS", "Info.plist");
+					SourcePListFile = CombinePaths(SC.ProjectRoot, "Build", "IOS", SC.ShortProjectName + "-Info.plist");
 				}
 				else if (Directory.Exists(SC.ProjectRoot + "/Build/IOS"))
 				{
--- ../../../../UE4-QA/Engine/Source/Programs/AutomationTool/MCPPublic.cs	2014-09-05 02:14:23.253327900 -0400
+++ ./Engine/Source/Programs/AutomationTool/MCPPublic.cs	2014-08-26 15:40:14.542691600 -0400
@@ -1,12 +1,14 @@
 // Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using System.Text;
 using System.IO;
 using AutomationTool;
 using System.Runtime.Serialization;
 using System.Net;
 using System.Reflection;
+using System.Text.RegularExpressions;
 using UnrealBuildTool;
 
 namespace EpicGames.MCP.Automation
@@ -143,7 +145,8 @@
         {
             get
             {
-                return AppName + BuildVersion + "-" + Platform.ToString() + ".manifest";
+                var BaseFilename = AppName + BuildVersion + "-" + Platform.ToString() + ".manifest";
+                return Regex.Replace(BaseFilename, @"\s+", ""); // Strip out whitespace in order to be compatible with BuildPatchTool
             }
         }
 
@@ -581,6 +584,35 @@
             CommandUtils.Log("ClientId : {0}", ClientId);
             // we don't really want this in logs CommandUtils.Log("ClientSecret : {0}", ClientSecret);
         }
+
+		/// <summary>
+		/// Returns Base Urls of build info service(s).
+		/// Will only return properties which have been populated.
+		/// </summary>
+		public IEnumerable<string> BuildInfoBaseUrls
+		{
+			get
+			{
+				return new List<string> { BuildInfoBaseUrl, BuildInfoV2BaseUrl }.Where(x => !string.IsNullOrEmpty(x)).Distinct();
+			}
+		}
+
+		/// <summary>
+		/// Returns the build info base URL to use for get requests.
+		/// Switching to version 2 can be achieved by overriding UseV2BuildInfoService in concrete subclasses and setting
+		/// it to true.
+		/// </summary>
+		public string DefaultBuildInfoBaseUrl
+		{
+			get
+			{
+				return UseV2BuildInfoService ? BuildInfoV2BaseUrl : BuildInfoBaseUrl;
+			}
+		}
+		protected virtual bool UseV2BuildInfoService
+		{
+			get { return false; }
+		}
     }
 
     public class McpConfigMapper
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/Configuration/UEBuildModule.cs	2014-09-05 02:14:32.531239000 -0400
+++ ./Engine/Source/Programs/UnrealBuildTool/Configuration/UEBuildModule.cs	2014-09-04 18:44:04.549277700 -0400
@@ -1656,11 +1656,15 @@
 			Result.Config.OutputDirectory                        = Path.Combine(Binary.Config.IntermediateDirectory, Name);
 
 			// Switch the optimization flag if we're building a game module. Also pass the definition for building in DebugGame along (see ModuleManager.h for notes).
-			if (Target.Configuration == UnrealTargetConfiguration.DebugGame && Type == UEBuildModuleType.Game)
+			if (Target.Configuration == UnrealTargetConfiguration.DebugGame)
+			{
+				PluginInfo Plugin = Plugins.GetPluginInfoForModule(Name);
+				if((Plugin != null && Plugin.LoadedFrom == PluginInfo.LoadedFromType.GameProject) || Type == UEBuildModuleType.Game)
 			{
 				Result.Config.Target.Configuration = CPPTargetConfiguration.Debug;
 				Result.Config.Definitions.Add("UE_BUILD_DEVELOPMENT_WITH_DEBUGGAME=1");
 			}
+			}
 
 			// Add the module's private definitions.
 			Result.Config.Definitions.AddRange(Definitions);
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/Mac/MacToolChain.cs	2014-09-05 02:14:32.941633300 -0400
+++ ./Engine/Source/Programs/UnrealBuildTool/Mac/MacToolChain.cs	2014-08-26 15:41:41.943925800 -0400
@@ -536,9 +536,26 @@
 			return LauncherVersionMajor + "." + LauncherVersionMinor + "." + LauncherVersionPatch;
 		}
 
+		private int LoadBuiltFromChangelistValue()
+		{
+			string[] VersionHeader = Utils.ReadAllText("../Source/Runtime/Launch/Resources/Version.h").Replace("\r\n", "\n").Replace("\t", " ").Split('\n');
+			foreach (string Line in VersionHeader)
+			{
+				if (Line.StartsWith("#define BUILT_FROM_CHANGELIST "))
+				{
+					return int.Parse(Line.Split(' ')[2]);
+				}
+			}
+			return 0;
+		}
+
 		private string LoadEngineAPIVersion()
 		{
 			int CL = 0;
+			// @todo: Temp solution to work around a problem with parsing ModuleVersion.h updated for 4.4.1 hotfix
+			int BuiltFromChangelist = LoadBuiltFromChangelistValue();
+			if (BuiltFromChangelist > 0)
+			{
 			foreach (string Line in File.ReadAllLines("../Source/Runtime/Core/Public/Modules/ModuleVersion.h"))
 			{
 				string[] Tokens = Line.Split(' ', '\t');
@@ -555,6 +572,7 @@
 					break;
 				}
 			}
+			}
 			return String.Format("{0}.{1}.{2}", CL / (100 * 100), (CL / 100) % 100, CL % 100);
 		}
 
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool.csproj	2014-09-05 02:14:33.505174400 -0400
+++ ./Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool.csproj	2014-09-04 18:44:04.567294000 -0400
@@ -257,6 +257,7 @@
     <Compile Include="Configuration\EngineConfiguration.cs" />
     <Compile Include="Utilities\XmlConfigLoader.cs" />
     <Compile Include="Windows\UEBuildWindows.cs" />
+    <Compile Include="Windows\VCEnvironment.cs" />
     <Compile Include="Windows\VCToolChain.cs" />
     <Compile Include="Windows\WindowsProjectGenerator.cs" />
   </ItemGroup>
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool_Mono.csproj	2014-09-05 02:14:33.513182300 -0400
+++ ./Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool_Mono.csproj	2014-09-04 18:44:04.570297500 -0400
@@ -162,6 +162,7 @@
       <SubType>Code</SubType>
     </Compile>
     <Compile Include="Windows\UEBuildWindows.cs" />
+    <Compile Include="Windows\VCEnvironment.cs" />
     <Compile Include="Windows\VCToolChain.cs" />
     <Compile Include="Windows\WindowsProjectGenerator.cs" />
     <Compile Include="Mac\MacToolChain.cs" />
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/Windows/VCEnvironment.cs	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/Programs/UnrealBuildTool/Windows/VCEnvironment.cs	2014-09-04 18:44:04.574300900 -0400
@@ -0,0 +1,224 @@
+// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.
+
+using System;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Win32;
+using System.Text;
+
+namespace UnrealBuildTool
+{
+	class VCEnvironment
+	{
+		public readonly CPPTargetPlatform Platform;             // The platform the envvars have been initialized for
+		public readonly string            BaseVSToolPath;       // The path to Visual Studio's /Common7/Tools directory.
+		public readonly string            PlatformVSToolPath;   // The path to the platform tool binaries.
+		public readonly string            WindowsSDKDir;        // Installation folder of the Windows SDK, e.g. C:\Program Files\Microsoft SDKs\Windows\v6.0A\
+		public readonly string            CompilerPath;         // The path to the linker for linking executables
+		public readonly Version           CLExeVersion;         // The version of cl.exe we're running
+		public readonly string            LinkerPath;           // The path to the linker for linking executables
+		public readonly string            LibraryLinkerPath;    // The path to the linker for linking libraries
+		public readonly string            ResourceCompilerPath; // The path to the resource compiler
+		public readonly string            MSBuildPath;          // The path to MSBuild
+
+		/**
+		 * Initializes environment variables required by toolchain. Different for 32 and 64 bit.
+		 */
+		public static VCEnvironment SetEnvironment(CPPTargetPlatform Platform)
+		{
+			if (EnvVars != null && EnvVars.Platform == Platform)
+			{
+				return EnvVars;
+			}
+
+			EnvVars = new VCEnvironment(Platform);
+			return EnvVars;
+		}
+
+		private VCEnvironment(CPPTargetPlatform InPlatform)
+		{
+			Platform = InPlatform;
+
+			// If Visual Studio is not installed, the Windows SDK path will be used, which also happens to be the same
+			// directory. (It installs the toolchain into the folder where Visual Studio would have installed it to).
+			BaseVSToolPath = WindowsPlatform.GetVSComnToolsPath();
+			if (string.IsNullOrEmpty(BaseVSToolPath))
+			{
+				throw new BuildException("Visual Studio 2012 or Visual Studio 2013 must be installed in order to build this target.");
+			}
+
+			WindowsSDKDir        = FindWindowsSDKInstallationFolder();
+			PlatformVSToolPath   = GetPlatformVSToolPath      (Platform, BaseVSToolPath);
+			CompilerPath         = GetCompilerToolPath        (PlatformVSToolPath);
+			CLExeVersion         = FindCLExeVersion           (CompilerPath);
+			LinkerPath           = GetLinkerToolPath          (PlatformVSToolPath);
+			LibraryLinkerPath    = GetLibraryLinkerToolPath   (PlatformVSToolPath);
+			ResourceCompilerPath = GetResourceCompilerToolPath(Platform, WindowsSDKDir);
+
+			var VCVarsBatchFile = Path.Combine(BaseVSToolPath, (Platform == CPPTargetPlatform.Win64) ? "../../VC/bin/x86_amd64/vcvarsx86_amd64.bat" : "vsvars32.bat");
+			Utils.SetEnvironmentVariablesFromBatchFile(VCVarsBatchFile);
+
+			MSBuildPath = GetMSBuildToolPath();
+
+			// When targeting Windows XP on Visual Studio 2012+, we need to override the Windows SDK include and lib path set
+			// by the batch file environment (http://blogs.msdn.com/b/vcblog/archive/2012/10/08/10357555.aspx)
+			if (WindowsPlatform.SupportWindowsXP)
+			{
+				// Lib and bin folders have a x64 subfolder for 64 bit development.
+				var ConfigSuffix = (Platform == CPPTargetPlatform.Win64) ? "\\x64" : "";
+
+				Environment.SetEnvironmentVariable("PATH",    Utils.ResolveEnvironmentVariable(WindowsSDKDir + "bin" + ConfigSuffix + ";%PATH%"));
+				Environment.SetEnvironmentVariable("LIB",     Utils.ResolveEnvironmentVariable(WindowsSDKDir + "lib" + ConfigSuffix + ";%LIB%"));
+				Environment.SetEnvironmentVariable("INCLUDE", Utils.ResolveEnvironmentVariable(WindowsSDKDir + "include;%INCLUDE%"));
+			}
+		}
+
+		/// <returns>The path to Windows SDK directory for the specified version.</returns>
+		private static string FindWindowsSDKInstallationFolder()
+		{
+			// When targeting Windows XP on Visual Studio 2012+, we need to point at the older Windows SDK 7.1A that comes
+			// installed with Visual Studio 2012 Update 1. (http://blogs.msdn.com/b/vcblog/archive/2012/10/08/10357555.aspx)
+			string Version;
+			if (WindowsPlatform.SupportWindowsXP)
+			{
+				Version = "v7.1A";
+			}
+			else switch (WindowsPlatform.Compiler)
+			{
+				case WindowsCompiler.VisualStudio2013:
+					Version = "v8.1";
+					break;
+
+				case WindowsCompiler.VisualStudio2012:
+					Version = "v8.0";
+					break;
+
+				default:
+					throw new BuildException("Unexpected compiler setting when trying to determine Windows SDK folder");
+			}
+
+			// Based on VCVarsQueryRegistry
+			var Result =
+					Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\SOFTWARE\Microsoft\Microsoft SDKs\Windows\"              + Version, "InstallationFolder", null)
+				?? Microsoft.Win32.Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\" + Version, "InstallationFolder", null)
+				?? Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\"  + Version, "InstallationFolder", null);
+
+			if (Result == null)
+			{
+				throw new BuildException("Windows SDK {0} must be installed in order to build this target.", Version);
+			}
+
+			return (string)Result;
+		}
+
+		/** Gets the path to the tool binaries for the specified platform. */
+		static string GetPlatformVSToolPath(CPPTargetPlatform Platform, string BaseVSToolPath)
+		{
+			// Regardless of the target, if we're linking on a 64 bit machine, we want to use the 64 bit linker (it's faster than the 32 bit linker)
+			//@todo.WIN32: Using the 64-bit linker appears to be broken at the moment.
+			if (Platform == CPPTargetPlatform.Win64)
+			{
+				// Use the native 64-bit compiler if present, otherwise use the amd64-on-x86 compiler. VS2012 Express only includes the latter.
+				var Result = Path.Combine(BaseVSToolPath, "../../VC/bin/amd64");
+				if (Directory.Exists(Result))
+				{
+					return Result;
+				}
+
+				return Path.Combine(BaseVSToolPath, "../../VC/bin/x86_amd64");
+			}
+
+			return Path.Combine(BaseVSToolPath, "../../VC/bin");
+		}
+
+		/** Gets the path to the compiler. */
+		static string GetCompilerToolPath(string PlatformVSToolPath)
+		{
+			// If we were asked to use Clang, then we'll redirect the path to the compiler to the LLVM installation directory
+			if (WindowsPlatform.bCompileWithClang)
+			{
+				var Result = Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.ProgramFilesX86 ), "LLVM", "msbuild-bin", "cl.exe" );
+				if (!File.Exists(Result))
+				{
+					throw new BuildException( "Clang was selected as the Windows compiler, but LLVM/Clang does not appear to be installed.  Could not find: " + Result );
+				}
+
+				return Result;
+			}
+
+			return Path.Combine(PlatformVSToolPath, "cl.exe");
+		}
+
+		/// <returns>The version of the compiler.</returns>
+		private static Version FindCLExeVersion(string CompilerExe)
+		{
+			var ExeVersionInfo = FileVersionInfo.GetVersionInfo(CompilerExe);
+			if (ExeVersionInfo == null)
+			{
+				throw new BuildException("Failed to read the version number of: " + CompilerExe);
+			}
+
+			return new Version(ExeVersionInfo.FileMajorPart, ExeVersionInfo.FileMinorPart, ExeVersionInfo.FileBuildPart, ExeVersionInfo.FilePrivatePart);
+		}
+
+		/** Gets the path to the linker. */
+		static string GetLinkerToolPath(string PlatformVSToolPath)
+		{
+			// If we were asked to use Clang, then we'll redirect the path to the compiler to the LLVM installation directory
+			if( WindowsPlatform.bCompileWithClang )
+			{
+				var Result = Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.ProgramFilesX86 ), "LLVM", "bin", "lld.exe" );
+				if( !File.Exists( Result ) )
+				{
+					throw new BuildException( "Clang was selected as the Windows compiler, but LLVM/Clang does not appear to be installed.  Could not find: " + Result );
+				}
+
+				return Result;
+			}
+
+			return Path.Combine(PlatformVSToolPath, "link.exe");
+		}
+
+		/** Gets the path to the library linker. */
+		static string GetLibraryLinkerToolPath(string PlatformVSToolPath)
+		{
+			// Regardless of the target, if we're linking on a 64 bit machine, we want to use the 64 bit linker (it's faster than the 32 bit linker)
+			//@todo.WIN32: Using the 64-bit linker appears to be broken at the moment.
+			return Path.Combine(PlatformVSToolPath, "lib.exe");
+		}
+
+		/** Gets the path to the resource compiler's rc.exe for the specified platform. */
+		static string GetResourceCompilerToolPath(CPPTargetPlatform Platform, string WindowsSDKDir)
+		{
+			// 64 bit -- we can use the 32 bit version to target 64 bit on 32 bit OS.
+			if (Platform == CPPTargetPlatform.Win64)
+			{
+				return Path.Combine(WindowsSDKDir, "bin/x64/rc.exe");
+			}
+
+			if( !WindowsPlatform.SupportWindowsXP )	// Windows XP requires use to force Windows SDK 7.1 even on the newer compiler, so we need the old path RC.exe
+			{
+				return Path.Combine(WindowsSDKDir, "bin/x86/rc.exe");
+			}
+
+			return Path.Combine(WindowsSDKDir, "bin/rc.exe");
+		}
+
+		/** Gets the path to MSBuild. */
+		static string GetMSBuildToolPath()
+		{
+			string FrameworkDirectory = Environment.GetEnvironmentVariable("FrameworkDir");
+			string FrameworkVersion   = Environment.GetEnvironmentVariable("FrameworkVersion");
+			if (FrameworkDirectory == null || FrameworkVersion == null)
+			{
+				throw new BuildException( "NOTE: Please ensure that 64bit Tools are installed with DevStudio - there is usually an option to install these during install" );
+			}
+
+			return Path.Combine(FrameworkDirectory, FrameworkVersion, "MSBuild.exe");
+		}
+
+		static VCEnvironment EnvVars = null;
+	}
+}
--- ../../../../UE4-QA/Engine/Source/Programs/UnrealBuildTool/Windows/VCToolChain.cs	2014-09-05 02:14:33.596261900 -0400
+++ ./Engine/Source/Programs/UnrealBuildTool/Windows/VCToolChain.cs	2014-09-04 18:44:04.647369900 -0400
@@ -20,7 +20,7 @@
 			UEToolChain.RegisterPlatformToolChain(CPPTargetPlatform.Win32, this);
 		}
 
-		static string GetCLArguments_Global(CPPEnvironment CompileEnvironment)
+		static string GetCLArguments_Global(CPPEnvironment CompileEnvironment, VCEnvironment EnvVars)
 		{
 			string Result = "";
 
@@ -190,8 +190,16 @@
 
 					// Allow optimized code to be debugged more easily.  This makes PDBs a bit larger, but doesn't noticeably affect
 					// compile times.  The executable code is not affected at all by this switch, only the debugging information.
+					if (EnvVars.CLExeVersion >= new Version("18.0.30723"))
+					{
+						// VC2013 Update 3 has a new flag for doing this
+						Result += " /Zo";
+					}
+					else
+					{
 					Result += " /d2Zi+";
 				}
+				}
 				
 				// Favor code speed.
 				Result += " /Ot";
@@ -641,7 +649,8 @@
 
 		public override CPPOutput CompileCPPFiles(CPPEnvironment CompileEnvironment, List<FileItem> SourceFiles, string ModuleName)
 		{
-			string Arguments = GetCLArguments_Global(CompileEnvironment);
+			var EnvVars = VCEnvironment.SetEnvironment(CompileEnvironment.Config.Target.Platform);
+			string Arguments = GetCLArguments_Global(CompileEnvironment, EnvVars);
 
 			// Add include paths to the argument list.
 			foreach (string IncludePath in CompileEnvironment.Config.IncludePaths)
@@ -905,7 +914,7 @@
 				}
 
 				CompileAction.WorkingDirectory = Path.GetFullPath(".");
-				CompileAction.CommandPath = GetVCToolPath(CompileEnvironment.Config.Target.Platform, CompileEnvironment.Config.Target.Configuration, "cl");
+				CompileAction.CommandPath      = EnvVars.CompilerPath;
 
 				if( !WindowsPlatform.bCompileWithClang )
 				{
@@ -953,13 +962,15 @@
 
 		public override CPPOutput CompileRCFiles(CPPEnvironment Environment, List<FileItem> RCFiles)
 		{
+			var EnvVars = VCEnvironment.SetEnvironment(Environment.Config.Target.Platform);
+
 			CPPOutput Result = new CPPOutput();
 
 			foreach (FileItem RCFile in RCFiles)
 			{
 				Action CompileAction = new Action(ActionType.Compile);
 				CompileAction.WorkingDirectory = Path.GetFullPath(".");
-				CompileAction.CommandPath = GetVCToolPath(Environment.Config.Target.Platform, Environment.Config.Target.Configuration, "rc");
+				CompileAction.CommandPath       = EnvVars.ResourceCompilerPath;
 				CompileAction.StatusDescription = Path.GetFileName(RCFile.AbsolutePath);
 
 				// Suppress header spew
@@ -1034,6 +1045,8 @@
 
 		public override FileItem LinkFiles(LinkEnvironment LinkEnvironment, bool bBuildImportLibraryOnly)
 		{
+			var EnvVars = VCEnvironment.SetEnvironment(LinkEnvironment.Config.Target.Platform);
+
 			if (LinkEnvironment.Config.bIsBuildingDotNetAssembly)
 			{
 				return FileItem.GetItemByPath(LinkEnvironment.Config.OutputFilePath);
@@ -1045,10 +1058,7 @@
 			// Create an action that invokes the linker.
 			Action LinkAction = new Action(ActionType.Link);
 			LinkAction.WorkingDirectory = Path.GetFullPath(".");
-			LinkAction.CommandPath = GetVCToolPath(
-				LinkEnvironment.Config.Target.Platform,
-				LinkEnvironment.Config.Target.Configuration,
-				bIsBuildingLibrary ? "lib" : "link");
+			LinkAction.CommandPath      = bIsBuildingLibrary ? EnvVars.LibraryLinkerPath : EnvVars.LinkerPath;
 
 			// Get link arguments.
 			LinkAction.CommandArguments = bIsBuildingLibrary ?
@@ -1230,6 +1240,9 @@
 
 		public override void CompileCSharpProject(CSharpEnvironment CompileEnvironment, string ProjectFileName, string DestinationFile)
 		{
+			// Initialize environment variables required for spawned tools.
+			var EnvVars = VCEnvironment.SetEnvironment(CompileEnvironment.EnvironmentTargetPlatform);
+
 			var BuildProjectAction = new Action(ActionType.BuildProject);
 
 			// Specify the source file (prerequisite) for the action
@@ -1261,7 +1274,7 @@
 			// Setup execution via MSBuild.
 			BuildProjectAction.WorkingDirectory = Path.GetFullPath(".");
 			BuildProjectAction.StatusDescription = Path.GetFileName(ProjectFileName);
-			BuildProjectAction.CommandPath = GetDotNetFrameworkToolPath(CompileEnvironment.EnvironmentTargetPlatform, "MSBuild");
+			BuildProjectAction.CommandPath       = EnvVars.MSBuildPath;
 			if (CompileEnvironment.TargetConfiguration == CSharpTargetConfiguration.Debug)
 			{
 				BuildProjectAction.CommandArguments = " /target:rebuild /property:Configuration=Debug";
@@ -1290,232 +1303,22 @@
 		/** Gets the default include paths for the given platform. */
 		public static string GetVCIncludePaths(CPPTargetPlatform Platform)
 		{
-			string IncludePaths = "";
-			if (Platform == CPPTargetPlatform.Win32 || Platform == CPPTargetPlatform.Win64)
-			{
+			Debug.Assert(Platform == CPPTargetPlatform.Win32 || Platform == CPPTargetPlatform.Win64);
+
 				// Make sure we've got the environment variables set up for this target
-				VCToolChain.InitializeEnvironmentVariables(Platform);
+			VCEnvironment.SetEnvironment(Platform);
 
 				// Also add any include paths from the INCLUDE environment variable.  MSVC is not necessarily running with an environment that
 				// matches what UBT extracted from the vcvars*.bat using SetEnvironmentVariablesFromBatchFile().  We'll use the variables we
 				// extracted to populate the project file's list of include paths
 				// @todo projectfiles: Should we only do this for VC++ platforms?
-				IncludePaths = Environment.GetEnvironmentVariable("INCLUDE");
+			var IncludePaths = Environment.GetEnvironmentVariable("INCLUDE");
 				if (!String.IsNullOrEmpty(IncludePaths) && !IncludePaths.EndsWith(";"))
 				{
 					IncludePaths += ";";
 				}
-			}
-			return IncludePaths;
-		}
 
-		/** Accesses the bin directory for the VC toolchain for the specified platform. */
-		static string GetVCToolPath(CPPTargetPlatform Platform, CPPTargetConfiguration Configuration, string ToolName)
-		{	
-			// Initialize environment variables required for spawned tools.
-			InitializeEnvironmentVariables( Platform );
-
-			// Out variable that is going to contain fully qualified path to executable upon return.
-			string VCToolPath = "";
-
-			// rc.exe resides in the Windows SDK folder.
-			if (ToolName.ToUpperInvariant() == "RC")
-			{
-				// 64 bit -- we can use the 32 bit version to target 64 bit on 32 bit OS.
-				if (Platform == CPPTargetPlatform.Win64)
-				{
-					VCToolPath = Path.Combine(WindowsSDKDir, "bin/x64/rc.exe");
-				}
-				// 32 bit
-				else
-				{
-					if( !WindowsPlatform.SupportWindowsXP )	// Windows XP requires use to force Windows SDK 7.1 even on the newer compiler, so we need the old path RC.exe
-					{
-						VCToolPath = Path.Combine( WindowsSDKDir, "bin/x86/rc.exe" );
-					}
-					else
-					{
-						VCToolPath = Path.Combine( WindowsSDKDir, "bin/rc.exe" );
-					}
-				}
-			}
-			// cl.exe and link.exe are found in the toolchain specific folders (32 vs. 64 bit)
-			else
-			{
-				bool bIsRequestingLinkTool = ToolName.Equals( "link", StringComparison.InvariantCultureIgnoreCase );
-				bool bIsRequestingLibTool = ToolName.Equals( "lib", StringComparison.InvariantCultureIgnoreCase );
-
-				// If we were asked to use Clang, then we'll redirect the path to the compiler to the LLVM installation directory
-				if( WindowsPlatform.bCompileWithClang && !bIsRequestingLinkTool && !bIsRequestingLibTool )
-				{
-					VCToolPath = Path.Combine( Environment.GetFolderPath( Environment.SpecialFolder.ProgramFilesX86 ), "LLVM", "msbuild-bin", ToolName + ".exe" );
-					if( !File.Exists( VCToolPath ) )
-					{
-						throw new BuildException( "Clang was selected as the Windows compiler, but LLVM/Clang does not appear to be installed.  Could not find: " + VCToolPath );
-					}
-				}
-				else
-				{
-					string BaseVSToolPath = FindBaseVSToolPath();
-
-					// Both target and build machines are 64 bit
-					bool bIs64Bit = (Platform == CPPTargetPlatform.Win64);
-					// Regardless of the target, if we're linking on a 64 bit machine, we want to use the 64 bit linker (it's faster than the 32 bit linker)
-					//@todo.WIN32: Using the 64-bit linker appears to be broken at the moment.
-					bool bUse64BitLinker = (Platform == CPPTargetPlatform.Win64) && bIsRequestingLinkTool;
-
-					// Use the 64 bit tools if the build machine and target are 64 bit or if we're linking a 32 bit binary on a 64 bit machine
-					if (bIs64Bit || bUse64BitLinker)
-					{
-						// Use the native 64-bit compiler if present, otherwise use the amd64-on-x86 compiler. VS2012 Express only includes the latter.
-						string PlatformToolPath = Path.Combine(BaseVSToolPath, "../../VC/bin/amd64/");
-						if(!Directory.Exists(PlatformToolPath))
-						{
-							PlatformToolPath = Path.Combine(BaseVSToolPath, "../../VC/bin/x86_amd64/");
-						}
-						VCToolPath = PlatformToolPath + ToolName + ".exe";
-					}
-					else
-					{
-						// Use 32 bit for cl.exe and other tools, or for link.exe if 64 bit path doesn't exist and we're targeting 32 bit.
-						VCToolPath = Path.Combine(BaseVSToolPath, "../../VC/bin/" + ToolName + ".exe");
-					}
-				}
-			}
-
-			return VCToolPath;
-		}
-
-		/** Accesses the directory for .NET Framework binaries such as MSBuild */
-		static string GetDotNetFrameworkToolPath(CPPTargetPlatform Platform, string ToolName)
-		{
-			// Initialize environment variables required for spawned tools.
-			InitializeEnvironmentVariables(Platform);
-
-			string FrameworkDirectory = Environment.GetEnvironmentVariable("FrameworkDir");
-			string FrameworkVersion = Environment.GetEnvironmentVariable("FrameworkVersion");
-			if (FrameworkDirectory == null || FrameworkVersion == null)
-			{
-				throw new BuildException( "NOTE: Please ensure that 64bit Tools are installed with DevStudio - there is usually an option to install these during install" );
-			}
-			string DotNetFrameworkBinDir = Path.Combine(FrameworkDirectory, FrameworkVersion);
-			string ToolPath = Path.Combine(DotNetFrameworkBinDir, ToolName + ".exe");
-			return ToolPath;
-		}
-
-		/** Helper to only initialize environment variables once. */
-		static bool bAreEnvironmentVariablesAlreadyInitialized = false;
-
-		/** Helper to make sure environment variables have been initialized for the right platform. */
-		static CPPTargetPlatform PlatformEnvironmentVariablesAreInitializedFor = CPPTargetPlatform.Win32;
-
-		/** Installation folder of the Windows SDK, e.g. C:\Program Files\Microsoft SDKs\Windows\v6.0A\ */
-		static string WindowsSDKDir = "";
-
-		/**
-		 * Initializes environment variables required by toolchain. Different for 32 and 64 bit.
-		 */
-		static void InitializeEnvironmentVariables( CPPTargetPlatform Platform )
-		{
-			if (!bAreEnvironmentVariablesAlreadyInitialized || Platform != PlatformEnvironmentVariablesAreInitializedFor)
-			{
-				string BaseVSToolPath = FindBaseVSToolPath();
-				
-				string VCVarsBatchFile = "";
-
-				// 64 bit tool chain.
-				if( Platform == CPPTargetPlatform.Win64 )
-				{
-					VCVarsBatchFile = Path.Combine(BaseVSToolPath, "../../VC/bin/x86_amd64/vcvarsx86_amd64.bat");
-				}
-				// The 32 bit vars batch file in the binary folder simply points to the one in the common tools folder.
-				else
-				{
-					VCVarsBatchFile = Path.Combine(BaseVSToolPath, "vsvars32.bat");
-				}
-				Utils.SetEnvironmentVariablesFromBatchFile(VCVarsBatchFile);
-
-				// Lib and bin folders have a x64 subfolder for 64 bit development.
-				string ConfigSuffix = "";
-				if( Platform == CPPTargetPlatform.Win64 )
-				{
-					ConfigSuffix = "\\x64";
-				}
-
-				// When targeting Windows XP on Visual Studio 2012+, we need to override the Windows SDK include and lib path set
-				// by the batch file environment (http://blogs.msdn.com/b/vcblog/archive/2012/10/08/10357555.aspx)
-				if( WindowsPlatform.SupportWindowsXP )
-				{
-					Environment.SetEnvironmentVariable("PATH", Utils.ResolveEnvironmentVariable(WindowsSDKDir + "bin" + ConfigSuffix + ";%PATH%"));
-					Environment.SetEnvironmentVariable("LIB", Utils.ResolveEnvironmentVariable(WindowsSDKDir + "lib" + ConfigSuffix + ";%LIB%"));
-					Environment.SetEnvironmentVariable( "INCLUDE", Utils.ResolveEnvironmentVariable(WindowsSDKDir + "include;%INCLUDE%"));
-				}
-
-				bAreEnvironmentVariablesAlreadyInitialized = true;
-				PlatformEnvironmentVariablesAreInitializedFor = Platform;
-			}			
-		}
-
-		/// <returns>The path to Windows SDK directory for the specified version.</returns>
-		private static string FindWindowsSDKInstallationFolder( string Version )
-		{
-			// Based on VCVarsQueryRegistry
-			string WinSDKPath = (string)Microsoft.Win32.Registry.GetValue( @"HKEY_CURRENT_USER\SOFTWARE\Microsoft\Microsoft SDKs\Windows\" + Version, "InstallationFolder", null );
-			if( WinSDKPath != null )
-			{
-				return WinSDKPath;
-			}
-			WinSDKPath = (string)Microsoft.Win32.Registry.GetValue( @"HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\" + Version, "InstallationFolder", null );
-			if( WinSDKPath != null )
-			{
-				return WinSDKPath;
-			}
-			WinSDKPath = (string)Microsoft.Win32.Registry.GetValue( @"HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\" + Version, "InstallationFolder", null );
-			if( WinSDKPath != null )
-			{
-				return WinSDKPath;
-			}
-
-			throw new BuildException( "Windows SDK {0} must be installed in order to build this target.", Version );
-		}
-
-		/// <summary>
-		/// Figures out the path to Visual Studio's /Common7/Tools directory.  Note that if Visual Studio is not
-		/// installed, the Windows SDK path will be used, which also happens to be the same directory. (It installs
-		/// the toolchain into the folder where Visual Studio would have installed it to.
-		/// </summary>
-		/// <returns>The path to Visual Studio's /Common7/Tools directory</returns>
-		private static string FindBaseVSToolPath()
-		{
-			string BaseVSToolPath = "";
-			
-			// When targeting Windows XP on Visual Studio 2012+, we need to point at the older Windows SDK 7.1A that comes
-			// installed with Visual Studio 2012 Update 1. (http://blogs.msdn.com/b/vcblog/archive/2012/10/08/10357555.aspx)
-			if( WindowsPlatform.SupportWindowsXP )
-			{
-				WindowsSDKDir = FindWindowsSDKInstallationFolder( "v7.1A" );
-			}
-			else
-			{
-				if (WindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)
-				{
-					WindowsSDKDir = FindWindowsSDKInstallationFolder( "v8.1" );
-				}
-				else if (WindowsPlatform.Compiler == WindowsCompiler.VisualStudio2012)
-				{
-					WindowsSDKDir = FindWindowsSDKInstallationFolder( "v8.0" );
-				}
-			}
-
-			// Grab path to Visual Studio binaries from the system environment
-			BaseVSToolPath = WindowsPlatform.GetVSComnToolsPath();
-
-			if (string.IsNullOrEmpty(BaseVSToolPath))
-			{
-				throw new BuildException("Visual Studio 2012 or Visual Studio 2013 must be installed in order to build this target.");
-			}
-
-			return BaseVSToolPath;
+			return IncludePaths;
 		}
 
         public override void AddFilesToManifest(ref FileManifest Manifest, UEBuildBinary Binary)
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Mac/MacApplication.cpp	2014-09-05 02:14:45.569762200 -0400
+++ ./Engine/Source/Runtime/Core/Private/Mac/MacApplication.cpp	2014-08-26 15:40:14.578725500 -0400
@@ -735,7 +735,6 @@
 
 void FMacApplication::SetCapture( const TSharedPtr< FGenericWindow >& InWindow )
 {
-	FPlatformMisc::PumpMessages(true);
 	bIsMouseCaptureEnabled = InWindow.IsValid();
 	UpdateMouseCaptureWindow( bIsMouseCaptureEnabled ? ((FMacWindow*)InWindow.Get())->GetWindowHandle() : NULL );
 }
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Mac/MacPlatformOutputDevices.cpp	2014-09-05 02:14:45.603794800 -0400
+++ ./Engine/Source/Runtime/Core/Private/Mac/MacPlatformOutputDevices.cpp	2014-08-26 15:40:14.601746900 -0400
@@ -11,6 +11,8 @@
 #include "MacPlatformOutputDevicesPrivate.h"
 #include "MacPlatformFeedbackContextPrivate.h"
 
+static uint64 GOutstandingTasks = 0;
+
 //////////////////////////////////
 // FMacPlatformOutputDevices
 //////////////////////////////////
@@ -254,6 +256,11 @@
 	{
 		SCOPED_AUTORELEASE_POOL;
 
+		do
+		{
+			FPlatformMisc::PumpMessages( true );
+		} while(GOutstandingTasks);
+
 		SaveToINI();
 		
 		if( TextViewTextColor )
@@ -316,24 +323,40 @@
 						*S -= '0';
 					}
 					
-					NSColor* Colors[2];
-					NSString* AttributeKeys[2];
+					NSMutableArray* Colors = [[NSMutableArray alloc] init];
+					NSMutableArray* AttributeKeys = [[NSMutableArray alloc] init];
 					
 					// Get FOREGROUND_INTENSITY and calculate final color
 					CGFloat Intensity = String[3] ? 1.0 : 0.5;
-					Colors[0] = [NSColor colorWithSRGBRed:(String[0] ? 1.0 * Intensity : 0.0) green:(String[1] ? 1.0 * Intensity : 0.0) blue:(String[2] ? 1.0 * Intensity : 0.0) alpha:1.0];
+					[Colors addObject:[NSColor colorWithSRGBRed:(String[0] ? 1.0 * Intensity : 0.0) green:(String[1] ? 1.0 * Intensity : 0.0) blue:(String[2] ? 1.0 * Intensity : 0.0) alpha:1.0]];
 					
 					// Get BACKGROUND_INTENSITY and calculate final color
 					Intensity = String[7] ? 1.0 : 0.5;
-					Colors[1] = [NSColor colorWithSRGBRed:(String[4] ? 1.0 * Intensity : 0.0) green:(String[5] ? 1.0 * Intensity : 0.0) blue:(String[6] ? 1.0 * Intensity : 0.0) alpha:1.0];
+					[Colors addObject:[NSColor colorWithSRGBRed:(String[4] ? 1.0 * Intensity : 0.0) green:(String[5] ? 1.0 * Intensity : 0.0) blue:(String[6] ? 1.0 * Intensity : 0.0) alpha:1.0]];
 					
-					AttributeKeys[0] = NSForegroundColorAttributeName;
-					AttributeKeys[1] = NSBackgroundColorAttributeName;
+					[AttributeKeys addObject:NSForegroundColorAttributeName];
+					[AttributeKeys addObject:NSBackgroundColorAttributeName];
 					
+					dispatch_block_t Block = ^{
 					if( TextViewTextColor )
 						[TextViewTextColor release];
 					
-					TextViewTextColor = [[NSDictionary alloc] initWithObjects:(id *)Colors forKeys:(id *)AttributeKeys count:2];
+						TextViewTextColor = [[NSDictionary alloc] initWithObjects:Colors forKeys:AttributeKeys];
+						
+						[Colors release];
+						[AttributeKeys release];
+						GOutstandingTasks--;
+					};
+					
+					GOutstandingTasks++;
+					if([NSThread isMainThread])
+					{
+						Block();
+					}
+					else
+					{
+						dispatch_async(dispatch_get_main_queue(), Block);
+					}
 				}
 			}
 			else
@@ -344,11 +367,25 @@
 				FCString::Sprintf(OutputString,TEXT("%s%s"),*FOutputDevice::FormatLogLine(Verbosity, Category, Data, GPrintLogTimes),LINE_TERMINATOR);
 
 				CFStringRef CocoaText = FPlatformString::TCHARToCFString(OutputString);
+				
+				dispatch_block_t Block = ^{
 				NSAttributedString *AttributedString = [[NSAttributedString alloc] initWithString:(NSString*)CocoaText attributes:TextViewTextColor];
 				[[TextView textStorage] appendAttributedString:AttributedString];
 				[TextView scrollRangeToVisible:NSMakeRange([[TextView string] length], 0)];
-				CFRelease(CocoaText);
 				[AttributedString release];
+					CFRelease(CocoaText);
+					GOutstandingTasks--;
+				};
+				
+				GOutstandingTasks++;
+				if([NSThread isMainThread])
+				{
+					Block();
+				}
+				else
+				{
+					dispatch_async(dispatch_get_main_queue(), Block);
+				}
 				
 				if(!MacApplication)
 				{
@@ -374,18 +411,35 @@
 void FOutputDeviceConsoleMac::SetDefaultTextColor()
 {
 	SCOPED_AUTORELEASE_POOL;
+	FScopeLock ScopeLock( &CriticalSection );
 
-	NSColor* Colors[2];
-	NSString* AttributeKeys[2];
+	NSMutableArray* Colors = [[NSMutableArray alloc] init];
+	NSMutableArray* AttributeKeys = [[NSMutableArray alloc] init];
 	
-	Colors[0] = [NSColor grayColor];
-	Colors[1] = [NSColor blackColor];
+	[Colors addObject:[NSColor grayColor]];
+	[Colors addObject:[NSColor blackColor]];
 	
-	AttributeKeys[0] = NSForegroundColorAttributeName;
-	AttributeKeys[1] = NSBackgroundColorAttributeName;
+	[AttributeKeys addObject:NSForegroundColorAttributeName];
+	[AttributeKeys addObject:NSBackgroundColorAttributeName];
 
+	dispatch_block_t Block = ^{
 	if( TextViewTextColor )
 		[TextViewTextColor release];
 	
-	TextViewTextColor = [[NSDictionary alloc] initWithObjects:(id *)Colors forKeys:(id *)AttributeKeys count:2];
+		TextViewTextColor = [[NSDictionary alloc] initWithObjects:Colors forKeys:AttributeKeys];
+		
+		[Colors release];
+		[AttributeKeys release];
+		GOutstandingTasks--;
+	};
+	
+	GOutstandingTasks++;
+	if([NSThread isMainThread])
+	{
+		Block();
+	}
+	else
+	{
+		dispatch_async(dispatch_get_main_queue(), Block);
+	}
 }
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Mac/MacTextInputMethodSystem.cpp	2014-09-05 02:14:45.628819000 -0400
+++ ./Engine/Source/Runtime/Core/Private/Mac/MacTextInputMethodSystem.cpp	2014-09-04 18:44:04.650372200 -0400
@@ -562,6 +562,14 @@
 		return;
 	}
 	
+	TSharedPtr<ITextInputMethodChangeNotifier> Notifier(NotifierRef.Pin());
+	FTextInputMethodChangeNotifier* MacNotifier = (FTextInputMethodChangeNotifier*)Notifier.Get();
+	TSharedPtr<FGenericWindow> GenericWindow = MacNotifier->GetContextWindow();
+	if(GenericWindow.IsValid())
+	{
+		DeactivateContext(Context);
+	}
+	
 	ContextMap.Remove(Context);
 }
 
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Misc/Parse.cpp	2014-09-05 02:14:45.956133200 -0400
+++ ./Engine/Source/Runtime/Core/Private/Misc/Parse.cpp	2014-08-18 16:17:05.083135600 -0400
@@ -1069,6 +1069,11 @@
 					WindowMode = EWindowMode::WindowedFullscreen;
 					StringTripLen = 2;
 				}
+				else if (WindowFullScreenChars == TEXT("wm"))
+				{
+					WindowMode = EWindowMode::WindowedMirror;
+					StringTripLen = 2;
+				}
 				else if (FullScreenChar == TEXT("f"))
 				{
 					WindowMode = EWindowMode::Fullscreen;
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Private/Windows/WindowsWindow.cpp	2014-09-05 02:14:47.037171500 -0400
+++ ./Engine/Source/Runtime/Core/Private/Windows/WindowsWindow.cpp	2014-08-18 16:17:05.697670100 -0400
@@ -4,11 +4,12 @@
 #include "WindowsWindow.h"
 #include "WindowsApplication.h"
 
+
 #if WINVER > 0x502	// Windows Vista or better required for DWM
-#include "AllowWindowsPlatformTypes.h"
-#include "Dwmapi.h"
-#include <ShlObj.h>
-#include "HideWindowsPlatformTypes.h"
+	#include "AllowWindowsPlatformTypes.h"
+	#include "Dwmapi.h"
+	#include <ShlObj.h>
+	#include "HideWindowsPlatformTypes.h"
 #endif
 
 FWindowsWindow::~FWindowsWindow()
@@ -453,13 +454,16 @@
 		const LONG RestoredFlags = WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_OVERLAPPED | WS_BORDER;
 
 		// If we're not in fullscreen, make it so
-		if( NewWindowMode == EWindowMode::WindowedFullscreen || NewWindowMode == EWindowMode::Fullscreen )
+		if( NewWindowMode == EWindowMode::WindowedFullscreen || NewWindowMode == EWindowMode::Fullscreen || NewWindowMode == EWindowMode::WindowedMirror)
 		{
 			::GetWindowPlacement(HWnd, &PreFullscreenWindowPlacement);
 
 			// Setup Win32 flags for fullscreen window
+			if (NewWindowMode != EWindowMode::WindowedMirror)
+			{
 			WindowFlags &= ~RestoredFlags;
 			WindowFlags |= FullscreenFlags;
+			}
 			SetWindowLong(HWnd, GWL_STYLE, WindowFlags);
 
 			if (!bTrueFullscreen)
--- ../../../../UE4-QA/Engine/Source/Runtime/Core/Public/GenericPlatform/GenericWindow.h	2014-09-05 02:14:50.707697300 -0400
+++ ./Engine/Source/Runtime/Core/Public/GenericPlatform/GenericWindow.h	2014-08-18 16:17:06.204110400 -0400
@@ -12,9 +12,9 @@
 	enum Type
 	{
 		/** The window is in true fullscreen mode */
-		Fullscreen,
+		Fullscreen = 0,
 		/** The window has no border and takes up the entire area of the screen */
-		WindowedFullscreen,
+		WindowedFullscreen = 1,
 		/** The window has a border and may not take up the entire screen area */
 		Windowed,
 		/** Pseudo-fullscreen mode for devices like HMDs */
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/Animation/AnimSequenceBase.cpp	2014-09-05 02:15:08.271566600 -0400
+++ ./Engine/Source/Runtime/Engine/Private/Animation/AnimSequenceBase.cpp	2014-09-04 18:44:04.730448200 -0400
@@ -384,6 +384,8 @@
 
 void UAnimSequenceBase::UpdateAnimNotifyTrackCache()
 {
+	SortNotifies();
+
 	for (int32 TrackIndex=0; TrackIndex<AnimNotifyTracks.Num(); ++TrackIndex)
 	{
 		AnimNotifyTracks[TrackIndex].Notifies.Empty();
@@ -405,8 +407,6 @@
 		}
 	}
 
-	SortNotifies();
-
 	// notification broadcast
 	OnNotifyChanged.Broadcast();
 }
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/Animation/Skeleton.cpp	2014-09-05 02:15:08.287581900 -0400
+++ ./Engine/Source/Runtime/Engine/Private/Animation/Skeleton.cpp	2014-08-26 15:40:14.795930100 -0400
@@ -717,8 +717,9 @@
 		{
 			PreviewMesh = Cast<USkeletalMesh>(StaticLoadObject(USkeletalMesh::StaticClass(), NULL, *PreviewMeshStringRef.ToString(), NULL, LOAD_None, NULL));
 		}
+		
 		// if not existing, and if bFindIfNotExisting is true, then try find one
-		else if (bFindIfNotSet)
+		if (!PreviewMesh && bFindIfNotSet)
 		{
 			FARFilter Filter;
 			Filter.ClassNames.Add(USkeletalMesh::StaticClass()->GetFName());
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameEngine.cpp	2014-09-05 02:15:09.494741500 -0400
+++ ./Engine/Source/Runtime/Engine/Private/GameEngine.cpp	2014-08-26 15:40:14.857988000 -0400
@@ -69,7 +69,7 @@
 	{
 		int32 Value = CVar->GetValueOnGameThread();
 
-		if(Value >= 0 && Value <= 2)
+		if (Value >= 0 && Value < EWindowMode::NumWindowModes)
 		{
 			return Value;
 		}
@@ -89,7 +89,7 @@
 			return WindowMode;
 		}
 
-		if (GEngine && GEngine->HMDDevice.IsValid())
+		if (GEngine && GEngine->HMDDevice.IsValid() && GEngine->HMDDevice->IsFullScreenAllowed())
 		{
 			return EWindowMode::Fullscreen;
 		}
@@ -190,7 +190,7 @@
 	}
 
 	//fullscreen is always supported, but don't allow windowed mode on platforms that dont' support it.
-	WindowMode = (!FPlatformProperties::SupportsWindowedMode() && (WindowMode == EWindowMode::Windowed || WindowMode == EWindowMode::WindowedFullscreen)) ? EWindowMode::Fullscreen : WindowMode;
+	WindowMode = (!FPlatformProperties::SupportsWindowedMode() && (WindowMode == EWindowMode::Windowed || WindowMode == EWindowMode::WindowedMirror || WindowMode == EWindowMode::WindowedFullscreen)) ? EWindowMode::Fullscreen : WindowMode;
 
 	FParse::Value(FCommandLine::Get(), TEXT("ResX="), ResolutionX);
 	FParse::Value(FCommandLine::Get(), TEXT("ResY="), ResolutionY);
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameUserSettings.cpp	2014-09-05 02:15:09.569813400 -0400
+++ ./Engine/Source/Runtime/Engine/Private/GameUserSettings.cpp	2014-08-18 16:17:13.788705800 -0400
@@ -56,6 +56,9 @@
 		case EWindowMode::WindowedFullscreen:
 			FullscreenMode = 1;
 			break;
+		case EWindowMode::WindowedMirror:
+			FullscreenMode = 3;
+			break;
 		case EWindowMode::Windowed:
 		default:
 			FullscreenMode = 2;
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/GameViewportClient.cpp	2014-09-05 02:15:09.581825000 -0400
+++ ./Engine/Source/Runtime/Engine/Private/GameViewportClient.cpp	2014-08-18 16:17:13.790707400 -0400
@@ -2398,13 +2398,25 @@
 		const TCHAR* CmdTemp = FCString::Strchr(Cmd,'x') ? FCString::Strchr(Cmd,'x')+1 : FCString::Strchr(Cmd,'X') ? FCString::Strchr(Cmd,'X')+1 : TEXT("");
 		int32 Y=FCString::Atoi(CmdTemp);
 		Cmd = CmdTemp;
-		EWindowMode::Type WindowMode = Viewport->IsFullscreen() ? EWindowMode::Fullscreen : EWindowMode::Windowed;
+		EWindowMode::Type WindowMode;
+		if (GEngine->HMDDevice.IsValid() && GEngine->HMDDevice->IsHMDEnabled() && !GEngine->HMDDevice->IsFullScreenAllowed())
+		{
+			WindowMode = Viewport->IsFullscreen() ? EWindowMode::WindowedMirror : EWindowMode::Windowed;
+		}
+		else
+		{
+			WindowMode = Viewport->IsFullscreen() ? EWindowMode::Fullscreen : EWindowMode::Windowed;
+		}
 		if(FCString::Strchr(Cmd,'w') || FCString::Strchr(Cmd,'W'))
 		{
 			if(FCString::Strchr(Cmd, 'f') || FCString::Strchr(Cmd, 'F'))
 			{
 				WindowMode = EWindowMode::WindowedFullscreen;
 			}
+			else if (FCString::Strchr(Cmd, 'm') || FCString::Strchr(Cmd, 'M'))
+			{
+				WindowMode = EWindowMode::WindowedMirror;
+			}
 			else
 			{
 				WindowMode = EWindowMode::Windowed;
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/Materials/Material.cpp	2014-09-05 02:15:11.028214100 -0400
+++ ./Engine/Source/Runtime/Engine/Private/Materials/Material.cpp	2014-09-04 18:44:04.905613800 -0400
@@ -2450,7 +2450,7 @@
 		for (int32 ExpIndex = 0; ExpIndex < Expressions.Num(); ExpIndex++)
 		{
 			UMaterialExpressionDynamicParameter* CheckParam = Cast<UMaterialExpressionDynamicParameter>(Expressions[ExpIndex]);
-			if (CheckParam->CopyDynamicParameterNames(DynParam))
+			if (CheckParam && CheckParam->CopyDynamicParameterNames(DynParam))
 			{
 #if WITH_EDITORONLY_DATA
 				CheckParam->GraphNode->ReconstructNode();
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/PlayerController.cpp	2014-09-05 02:15:14.009077300 -0400
+++ ./Engine/Source/Runtime/Engine/Private/PlayerController.cpp	2014-08-18 16:17:16.297887500 -0400
@@ -2086,6 +2086,15 @@
 {
 	bool bResult = false;
 
+	if (GEngine->HMDDevice.IsValid() && GEngine->IsStereoscopic3D())
+	{
+		bResult = GEngine->HMDDevice->HandleInputKey(PlayerInput, Key, EventType, AmountDepressed, bGamepad);
+		if (bResult)
+		{
+			return bResult;
+		}
+	}
+
 	if (PlayerInput)
 	{
 		bResult = PlayerInput->InputKey(Key, EventType, AmountDepressed, bGamepad);
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/Slate/SceneViewport.cpp	2014-09-05 02:15:15.416429100 -0400
+++ ./Engine/Source/Runtime/Engine/Private/Slate/SceneViewport.cpp	2014-08-18 16:17:16.850367900 -0400
@@ -827,12 +827,18 @@
 						FSlateRect PreFullScreenRect = WindowToResize->GetRectInScreen();
 
 						IHeadMountedDisplay::MonitorInfo MonitorInfo;
-						if (GEngine->HMDDevice->GetHMDMonitorInfo(MonitorInfo))
-						{
+						GEngine->HMDDevice->GetHMDMonitorInfo(MonitorInfo);
 							NewSizeX = MonitorInfo.ResolutionX;
 							NewSizeY = MonitorInfo.ResolutionY;
+						if (GEngine->HMDDevice->IsFullScreenAllowed())
+						{
 							WindowToResize->ReshapeWindow(FVector2D(MonitorInfo.DesktopX, MonitorInfo.DesktopY), FVector2D(MonitorInfo.ResolutionX, MonitorInfo.ResolutionY));
 						}
+						else
+						{
+							WindowToResize->Resize(FVector2D(MonitorInfo.ResolutionX, MonitorInfo.ResolutionY));
+							DesiredWindowMode = EWindowMode::WindowedMirror;
+						}
 
 						GEngine->HMDDevice->PushPreFullScreenRect(PreFullScreenRect);
 					}
@@ -847,7 +853,7 @@
 					{
 						FSlateRect PreFullScreenRect;
 						GEngine->HMDDevice->PopPreFullScreenRect(PreFullScreenRect);
-						if (PreFullScreenRect.GetSize().X > 0 && PreFullScreenRect.GetSize().Y > 0)
+						if (PreFullScreenRect.GetSize().X > 0 && PreFullScreenRect.GetSize().Y > 0 && GEngine->HMDDevice->IsFullScreenAllowed())
 						{
 							NewSizeX = PreFullScreenRect.GetSize().X;
 							NewSizeY = PreFullScreenRect.GetSize().Y;
@@ -867,7 +873,8 @@
 				int32 NewWindowSizeX = NewSizeX;
 				int32 NewWindowSizeY = NewSizeY;
 
-				if (DesiredWindowMode != EWindowMode::Windowed && CVarValue != 0)
+				if (DesiredWindowMode != EWindowMode::Windowed && CVarValue != 0 && 
+					(!GEngine->HMDDevice.IsValid() || GEngine->HMDDevice->IsFullScreenAllowed()))
 				{
 					FSlateRect Rect = WindowToResize->GetFullScreenInfo();
 
--- ../../../../UE4-QA/Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp	2014-09-05 02:15:16.240220400 -0400
+++ ./Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp	2014-08-18 16:17:17.650063400 -0400
@@ -9841,6 +9841,10 @@
 		{
 			WindowModeSuffix = TEXT("w");
 		} break;
+		case EWindowMode::WindowedMirror:
+		{
+			WindowModeSuffix = TEXT("wm");
+		} break;
 		case EWindowMode::WindowedFullscreen:
 		{
 			WindowModeSuffix = TEXT("wf");
--- ../../../../UE4-QA/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp	2014-09-05 02:15:21.503275300 -0400
+++ ./Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp	2014-08-26 15:40:15.006127700 -0400
@@ -2580,7 +2580,6 @@
 #if WITH_ENGINE
 	if (!GIsEditor)
 	{
-#if 0	//@todo vr: only preinit first valid hmd
 		if (!FParse::Param(FCommandLine::Get(), TEXT("nohmd")) && !FParse::Param(FCommandLine::Get(), TEXT("emulatestereo")))
 		{
 			// Get a list of plugins that implement this feature
@@ -2590,7 +2589,6 @@
 				(*HMDModuleIt)->PreInit();
 			}
 		}
-#endif
 	}
 #endif // #if WITH_ENGINE
 }
--- ../../../../UE4-QA/Engine/Source/Runtime/OpenGLDrv/Private/Mac/OpenGLMac.cpp	2014-09-05 02:15:30.881282500 -0400
+++ ./Engine/Source/Runtime/OpenGLDrv/Private/Mac/OpenGLMac.cpp	2014-08-18 16:17:24.236790900 -0400
@@ -654,6 +654,22 @@
 				[Context->OpenGLContext update];
 			}
 			
+            if (Viewport.GetCustomPresent())
+            {
+				SCOPED_AUTORELEASE_POOL;
+                
+				// Clear the Alpha channel
+				glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_TRUE);
+				glClearColor(0.f,0.f,0.f,1.f);
+				glClear(GL_COLOR_BUFFER_BIT);
+				glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);
+				glClearColor(0.f,0.f,0.f,0.f);
+
+                glDisable(GL_FRAMEBUFFER_SRGB);
+                Viewport.GetCustomPresent()->Present(SyncInterval);
+                glEnable(GL_FRAMEBUFFER_SRGB);
+                return false;
+            }
 			// OpenGL state necessary for blit is set up in PlatformResizeGLContext(), and should be correct here,
 			// as viewport contexts aren't bound at any other occasion.
 			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
--- ../../../../UE4-QA/Engine/Source/Runtime/Windows/D3D11RHI/Private/D3D11Viewport.cpp	2014-09-05 02:15:43.431336500 -0400
+++ ./Engine/Source/Runtime/Windows/D3D11RHI/Private/D3D11Viewport.cpp	2014-08-18 16:17:31.721299300 -0400
@@ -96,7 +96,7 @@
 	// create the render target view
 	TRefCountPtr<ID3D11RenderTargetView> BackBufferRenderTargetView;
 	D3D11_RENDER_TARGET_VIEW_DESC RTVDesc;
-	RTVDesc.Format = (DXGI_FORMAT)FD3D11Viewport::GetBackBufferFormat();
+	RTVDesc.Format = DXGI_FORMAT_UNKNOWN;
 	RTVDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
 	RTVDesc.Texture2D.MipSlice = 0;
 	VERIFYD3D11RESULT(D3DRHI->GetDevice()->CreateRenderTargetView(BackBufferResource,&RTVDesc,BackBufferRenderTargetView.GetInitReference()));
@@ -110,7 +110,7 @@
 	// create a shader resource view to allow using the backbuffer as a texture
 	TRefCountPtr<ID3D11ShaderResourceView> BackBufferShaderResourceView;
 	D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
-	SRVDesc.Format = (DXGI_FORMAT)FD3D11Viewport::GetBackBufferFormat();
+	SRVDesc.Format = DXGI_FORMAT_UNKNOWN;
 	SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
 	SRVDesc.Texture2D.MostDetailedMip = 0;
 	SRVDesc.Texture2D.MipLevels = 1;
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR.build.cs	2014-09-05 02:18:55.709012700 -0400
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR.build.cs	2014-09-04 18:32:32.350164600 -0400
@@ -7,15 +7,18 @@
 	public LibOVR(TargetInfo Target)
 	{
 		/** Mark the current version of the Oculus SDK */
-		string LibOVRVersion = "";
+		string LibOVRVersion = "_04";
 		Type = ModuleType.External;
 
+		string OculusThirdPartyDirectory = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion;
+
 		if ((Target.Platform == UnrealTargetPlatform.Win64) ||
 			(Target.Platform == UnrealTargetPlatform.Win32))
 		{
-            PublicIncludePaths.Add(UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Include");
 
-            string LibraryPath = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Lib/";
+            PublicIncludePaths.Add(OculusThirdPartyDirectory + "/Include");
+
+            string LibraryPath = OculusThirdPartyDirectory + "/Lib/";
 			string LibraryName = "libovr";
 			if (Target.Platform == UnrealTargetPlatform.Win64)
 			{
@@ -26,17 +29,22 @@
             {
                 LibraryPath += "Win32/";
             }
+
+			//LibraryName += "_sp";
+
 			LibraryPath += "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName() + "/";
 			PublicLibraryPaths.Add(LibraryPath);
 			PublicAdditionalLibraries.Add(LibraryName + ".lib");
+
+			PublicAdditionalLibraries.Add("Wtsapi32.lib");
             //PublicAdditionalLibraries.Add(LibraryName + "d.lib");
 			//PublicDelayLoadDLLs.Add(LibraryName + ".dll");
 		}
 		else if ((Target.Platform == UnrealTargetPlatform.Mac))
 		{
-            PublicIncludePaths.Add(UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Include");
+            PublicIncludePaths.Add(OculusThirdPartyDirectory + "/Include");
 
-            string LibraryPath = UEBuildConfiguration.UEThirdPartySourceDirectory + "Oculus/LibOVR" + LibOVRVersion + "/Lib/MacOS/Release/";
+            string LibraryPath = OculusThirdPartyDirectory + "/Lib/MacOS/Release/";
 			string LibraryName = "libovr";
 			PublicLibraryPaths.Add(LibraryPath);
 			PublicAdditionalLibraries.Add(LibraryPath + LibraryName + ".a");
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR.h	2014-09-03 00:33:52.000000000 -0400
@@ -0,0 +1,36 @@
+/************************************************************************************
+
+Filename    :   OVR.h
+Content     :   The main public interface to Oculus for C++ Developers.
+                Includes C API and helper classes.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_h
+#define OVR_h
+
+#include "OVR_Version.h"
+
+#include "../Src/Kernel/OVR_Math.h"
+
+#include "../Src/OVR_CAPI.h"
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Kernel.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Kernel.h	2014-09-03 00:33:52.000000000 -0400
@@ -0,0 +1,42 @@
+/************************************************************************************
+
+Filename    :   OVRKernel.h
+Content     :   This contains references to all OVR Kernel headers in Src folder.
+                Should be generated automatically based on PublicHeader tags.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_h
+#define OVR_h
+
+#include "../Src/Kernel/OVR_Types.h"
+#include "../Src/Kernel/OVR_Allocator.h"
+#include "../Src/Kernel/OVR_RefCount.h"
+#include "../Src/Kernel/OVR_Log.h"
+#include "../Src/Kernel/OVR_Math.h"
+#include "../Src/Kernel/OVR_System.h"
+#include "../Src/Kernel/OVR_Nullptr.h"
+#include "../Src/Kernel/OVR_String.h"
+#include "../Src/Kernel/OVR_Array.h"
+#include "../Src/Kernel/OVR_Timer.h"
+#include "../Src/Kernel/OVR_SysFile.h"
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Version.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Include/OVR_Version.h	2014-09-03 00:33:52.000000000 -0400
@@ -0,0 +1,33 @@
+/************************************************************************************
+
+Filename    :   OVRVersion.h
+Content     :
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef _OVR_VERSION_H
+#define _OVR_VERSION_H
+
+#define OVR_MAJOR_VERSION 0
+#define OVR_MINOR_VERSION 4
+#define OVR_BUILD_VERSION 2
+#define OVR_VERSION_STRING "0.4.2"
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,164 @@
+/************************************************************************************
+
+Filename    :   CAPI_DistortionRenderer.h
+Content     :   Abstract interface for platform-specific rendering of distortion
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_DistortionRenderer_h
+#define OVR_CAPI_DistortionRenderer_h
+
+#include "CAPI_HMDRenderState.h"
+#include "CAPI_FrameTimeManager.h"
+
+typedef void (*PostDistortionCallback)(void* pRenderContext);
+
+namespace OVR { namespace CAPI {
+
+//-------------------------------------------------------------------------------------
+// ***** CAPI::DistortionRenderer
+
+// DistortionRenderer implements rendering of distortion and other overlay elements
+// in platform-independent way.
+// Platform-specific renderer back ends for CAPI are derived from this class.
+
+class  DistortionRenderer : public RefCountBase<DistortionRenderer>
+{
+    // Quiet assignment compiler warning.
+    void operator = (const DistortionRenderer&) { }
+public:
+    
+    DistortionRenderer(ovrRenderAPIType api, ovrHmd hmd,
+                       FrameTimeManager& timeManager,              
+                       const HMDRenderState& renderState) :
+		LastUsedOverdriveTextureIndex(-1),
+        LatencyTestActive(false),
+        LatencyTest2Active(false),
+        RenderAPI(api),
+        HMD(hmd),
+        TimeManager(timeManager),
+        RState(renderState),
+        GfxState(),
+        RegisteredPostDistortionCallback(NULL)
+    {
+#ifdef OVR_OS_WIN32
+        timer = CreateWaitableTimer(NULL, TRUE, NULL);
+        OVR_ASSERT(timer != NULL);
+#endif
+    }
+    virtual ~DistortionRenderer()
+    {
+    }
+    
+
+    // Configures the Renderer based on externally passed API settings. Must be
+    // called before use.
+    // Under D3D, apiConfig includes D3D Device pointer, back buffer and other
+    // needed structures.
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps) = 0;
+
+    // Submits one eye texture for rendering. This is in the separate method to
+    // allow "submit as you render" scenarios on horizontal screens where one
+    // eye can be scanned out before the other.
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture) = 0;
+
+    // Finish the frame, optionally swapping buffers.
+    // Many implementations may actually apply the distortion here.
+    virtual void EndFrame(bool swapBuffers) = 0;
+    
+    void RegisterPostDistortionCallback(PostDistortionCallback postDistortionCallback)
+    {
+        RegisteredPostDistortionCallback = postDistortionCallback;
+    }
+
+	// Stores the current graphics pipeline state so it can be restored later.
+	void SaveGraphicsState() { if (!(RState.DistortionCaps & ovrDistortionCap_NoRestore)) GfxState->Save(); }
+
+	// Restores the saved graphics pipeline state.
+	void RestoreGraphicsState() { if (!(RState.DistortionCaps & ovrDistortionCap_NoRestore)) GfxState->Restore(); }
+
+    // *** Creation Factory logic
+    
+    ovrRenderAPIType GetRenderAPI() const { return RenderAPI; }
+
+    // Creation function for this interface, registered for API.
+    typedef DistortionRenderer* (*CreateFunc)(ovrHmd hmd,
+                                              FrameTimeManager &timeManager,
+                                              const HMDRenderState& renderState);
+
+    static CreateFunc APICreateRegistry[ovrRenderAPI_Count];
+
+    // Color is expected to be 3 byte RGB
+    void SetLatencyTestColor(unsigned char* color);
+    void SetLatencyTest2Color(unsigned char* color);
+    
+protected:
+	// Used for pixel luminance overdrive on DK2 displays
+	// A copy of back buffer images will be ping ponged
+	// TODO: figure out 0 dynamically based on DK2 latency?
+	static const int	NumOverdriveTextures = 2;
+	int					LastUsedOverdriveTextureIndex;
+
+    bool                LatencyTestActive;
+    unsigned char       LatencyTestDrawColor[3];
+    bool                LatencyTest2Active;
+    unsigned char       LatencyTest2DrawColor[3];
+
+    bool IsOverdriveActive()
+	{
+		// doesn't make sense to use overdrive when vsync is disabled as we cannot guarantee
+		// when the rendered frame will be displayed
+		return LastUsedOverdriveTextureIndex >= 0 && !((RState.EnabledHmdCaps & ovrHmdCap_NoVSync) > 0);
+	}
+
+    double WaitTillTime(double absTime);
+
+#ifdef OVR_OS_WIN32
+    HANDLE timer;
+    LARGE_INTEGER waitableTimerInterval;
+#endif
+
+    class GraphicsState : public RefCountBase<GraphicsState>
+    {
+    public:
+        GraphicsState() : IsValid(false) {}
+        virtual ~GraphicsState() {}
+        virtual void Save() = 0;
+        virtual void Restore() = 0;
+        
+    protected:
+        bool IsValid;
+    };
+    
+    const ovrRenderAPIType  RenderAPI;
+    const ovrHmd            HMD;
+    FrameTimeManager&       TimeManager;
+    const HMDRenderState&   RState;
+    Ptr<GraphicsState>      GfxState;
+    PostDistortionCallback  RegisteredPostDistortionCallback;
+};
+
+}} // namespace OVR::CAPI
+
+
+#endif // OVR_CAPI_DistortionRenderer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_FrameTimeManager.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,336 @@
+/************************************************************************************
+
+Filename    :   CAPI_FrameTimeManager.h
+Content     :   Manage frame timing and pose prediction for rendering
+Created     :   November 30, 2013
+Authors     :   Volga Aksoy, Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_FrameTimeManager_h
+#define OVR_CAPI_FrameTimeManager_h
+
+#include "../OVR_CAPI.h"
+#include "../Kernel/OVR_Timer.h"
+#include "../Kernel/OVR_Math.h"
+#include "../Util/Util_Render_Stereo.h"
+
+namespace OVR { namespace CAPI {
+
+//-------------------------------------------------------------------------------------
+
+// Helper class to collect median times between frames, so that we know
+// how long to wait. 
+struct TimeDeltaCollector
+{
+    TimeDeltaCollector() : Median(-1.0), Count(0), ReCalcMedian(true) { }
+
+    void    AddTimeDelta(double timeSeconds);    
+    void    Clear() { Count = 0; }    
+
+    double  GetMedianTimeDelta() const;
+
+    double  GetCount() const { return Count; }
+
+    enum { Capacity = 12 };
+private:
+	double  TimeBufferSeconds[Capacity];
+	mutable double  Median;
+	int     Count;
+    mutable bool    ReCalcMedian;
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** FrameLatencyTracker
+
+// FrameLatencyTracker tracks frame Present to display Scan-out timing, as reported by
+// the DK2 internal latency tester pixel read-back. The computed value is used in
+// FrameTimeManager for prediction. View Render and TimeWarp to scan-out latencies are
+// also reported for debugging.
+//
+// The class operates by generating color values from GetNextDrawColor() that must
+// be rendered on the back end and then looking for matching values in FrameTimeRecordSet
+// structure as reported by HW.
+
+class FrameLatencyTracker
+{
+public:
+
+    enum { FramesTracked = Util::LT2_IncrementCount-1 };
+
+    FrameLatencyTracker();
+
+    // DrawColor == 0 is special in that it doesn't need saving of timestamp
+    unsigned char GetNextDrawColor();
+
+    void SaveDrawColor(unsigned char drawColor, double endFrameTime,
+                       double renderIMUTime, double timewarpIMUTime );
+
+    void MatchRecord(const Util::FrameTimeRecordSet &r);   
+
+    bool IsLatencyTimingAvailable();
+    void GetLatencyTimings(float latencies[3]);
+
+    void Reset();
+
+public:
+
+    struct FrameTimeRecordEx : public Util::FrameTimeRecord
+    {
+        bool    MatchedRecord;
+        double  RenderIMUTimeSeconds;
+        double  TimewarpIMUTimeSeconds;
+    };
+
+    // True if rendering read-back is enabled.
+    bool                  TrackerEnabled;
+
+    enum SampleWaitType {
+        SampleWait_Zeroes, // We are waiting for a record with all zeros.
+        SampleWait_Match   // We are issuing & matching colors.
+    };
+    
+    SampleWaitType        WaitMode;
+    int                   MatchCount;
+    // Records of frame timings that we are trying to measure.
+    FrameTimeRecordEx     FrameEndTimes[FramesTracked];
+    int                   FrameIndex;
+    // Median filter for (ScanoutTimeSeconds - PostPresent frame time)
+    TimeDeltaCollector    FrameDeltas;
+    // Latency reporting results
+    double                RenderLatencySeconds;
+    double                TimewarpLatencySeconds;
+    double                LatencyRecordTime;
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** FrameTimeManager
+
+// FrameTimeManager keeps track of rendered frame timing and handles predictions for
+// orientations and time-warp.
+
+class FrameTimeManager
+{
+public:
+    FrameTimeManager(bool vsyncEnabled);
+
+    // Data that affects frame timing computation.
+    struct TimingInputs
+    {
+        // Hard-coded value or dynamic as reported by FrameTimeDeltas.GetMedianTimeDelta().
+        double              FrameDelta;
+        // Screen delay from present to scan-out, as potentially reported by ScreenLatencyTracker.
+        double              ScreenDelay;
+        // Negative value of how many seconds before EndFrame we start timewarp. 0.0 if not used.
+        double              TimewarpWaitDelta;
+        
+        TimingInputs()
+            : FrameDelta(0), ScreenDelay(0), TimewarpWaitDelta(0)
+        { }
+    };
+
+    // Timing values for a specific frame.
+    struct Timing
+    {
+        TimingInputs        Inputs;
+        
+        // Index of a frame that started at ThisFrameTime.
+        unsigned int        FrameIndex;
+        // Predicted absolute times for when this frame will show up on screen.
+        // Generally, all values will be >= NextFrameTime, since that's the time we expect next
+        // vsync to succeed.
+        double              ThisFrameTime;
+        double              TimewarpPointTime;
+        double              NextFrameTime;        
+        double              MidpointTime;
+        double              EyeRenderTimes[2];
+        double              TimeWarpStartEndTimes[2][2];
+
+        Timing()
+        {
+            memset(this, 0, sizeof(Timing));
+        }
+
+        void InitTimingFromInputs(const TimingInputs& inputs, HmdShutterTypeEnum shutterType,
+                                  double thisFrameTime, unsigned int frameIndex);
+    };
+
+   
+    // Called on startup to provided data on HMD timing.
+    void    Init(HmdRenderInfo& renderInfo);
+
+    // Called with each new ConfigureRendering.
+    void    ResetFrameTiming(unsigned frameIndex,
+                             bool dynamicPrediction, bool sdkRender);
+
+    void    SetVsync(bool enabled) { VsyncEnabled = enabled; }
+
+    // BeginFrame returns time of the call
+    // TBD: Should this be a predicted time value instead ?
+    double  BeginFrame(unsigned frameIndex);
+    void    EndFrame();    
+
+    // Thread-safe function to query timing for a future frame
+    Timing  GetFrameTiming(unsigned frameIndex);
+ 
+    double  GetEyePredictionTime(ovrEyeType eye);
+    Posef   GetEyePredictionPose(ovrHmd hmd, ovrEyeType eye);
+
+    void    GetTimewarpPredictions(ovrEyeType eye, double timewarpStartEnd[2]); 
+    void    GetTimewarpMatrices(ovrHmd hmd, ovrEyeType eye, ovrPosef renderPose, ovrMatrix4f twmOut[2]);
+
+    // Used by renderer to determine if it should time distortion rendering.
+    bool    NeedDistortionTimeMeasurement() const;
+    void    AddDistortionTimeMeasurement(double distortionTimeSeconds);
+
+    
+    // DK2 Latency test interface
+    
+    // Get next draw color for DK2 latency tester (3-byte RGB)
+    void GetFrameLatencyTestDrawColor(unsigned char outColor[3])
+    {
+        outColor[0] = ScreenLatencyTracker.GetNextDrawColor();
+        outColor[1] = ScreenLatencyTracker.IsLatencyTimingAvailable() ? 255 : 0;
+        outColor[2] = ScreenLatencyTracker.IsLatencyTimingAvailable() ? 0 : 255;
+    }
+
+    // Must be called after EndFrame() to update latency tester timings.
+    // Must pass color reported by NextFrameColor for this frame.
+    void    UpdateFrameLatencyTrackingAfterEndFrame(unsigned char frameLatencyTestColor[3],
+                                                    const Util::FrameTimeRecordSet& rs);
+
+    void    GetLatencyTimings(float latencies[3])
+    { return ScreenLatencyTracker.GetLatencyTimings(latencies); }
+
+    const Timing& GetFrameTiming() const { return FrameTiming; }
+
+#ifndef NO_SCREEN_TEAR_HEALING
+    bool    IsScreenTearing() const { return ScreenTearing; };
+    bool    ScreenTearingReaction();
+#endif // NO_SCREEN_TEAR_HEALING
+
+private:
+    double  calcFrameDelta() const;
+    double  calcScreenDelay() const;
+    double  calcTimewarpWaitDelta() const;
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    /*
+    void    updateTimewarpTiming();
+
+
+    
+    // TimewarpDelayAdjuster implements a simple state machine that reduces the amount
+    // of time-warp waiting based on skipped frames. 
+    struct TimewarpDelayAdjuster
+    {
+        enum StateInLevel
+        {        
+            // We are ok at this level, and will be waiting for some time before trying to reduce.
+            State_WaitingToReduceLevel,  
+            // After decrementing a level, we are verifying that this won't cause skipped frames.
+            State_VerifyingAfterReduce
+       };
+    
+        enum {
+            MaxDelayLevel          = 5,
+            MaxInfiniteTimingLevel = 3,
+            MaxTimeIndex           = 6
+        };
+
+        StateInLevel State;   
+        // Current level. Higher levels means larger delay reduction (smaller overall time-warp delay).
+        int          DelayLevel;
+        // Index for the amount of time we'd wait in this level. If attempt to decrease level fails,
+        // with is incrementing causing the level to become "sticky". 
+        int          WaitTimeIndexForLevel[MaxTimeIndex + 1];
+        // We skip few frames after each escalation to avoid too rapid of a reduction.
+        int          InitialFrameCounter;
+        // What th currect "reduction" currently is.
+        double       TimewarpDelayReductionSeconds;
+        // When we should try changing the level again.
+        double       DelayLevelFinishTime;
+
+    public:
+        TimewarpDelayAdjuster() { Reset(); }
+
+        void    Reset();
+
+        void    UpdateTimewarpWaitIfSkippedFrames(FrameTimeManager* manager,
+                                                  double measuredFrameDelta,
+                                                  double nextFrameTime);
+
+        double  GetDelayReduction() const { return TimewarpDelayReductionSeconds; }
+    };
+    */
+
+    
+    HmdRenderInfo       RenderInfo;
+    // Timings are collected through a median filter, to avoid outliers.
+    TimeDeltaCollector  FrameTimeDeltas;
+    TimeDeltaCollector  DistortionRenderTimes;
+    FrameLatencyTracker ScreenLatencyTracker;
+
+    // Timing changes if we have no Vsync (all prediction is reduced to fixed interval).
+    bool                VsyncEnabled;
+    // Set if we are rendering via the SDK, so DistortionRenderTimes is valid.
+    bool                DynamicPrediction;
+    // Set if SDk is doing the rendering.
+    bool                SdkRender;
+    // Direct to rift.
+    bool                DirectToRift;
+#ifndef NO_SCREEN_TEAR_HEALING
+    // Screen tearing detection
+    mutable bool        ScreenTearing;
+    // Number of frames tearing has been observed
+    mutable int         TearingFrameCount;
+    // Number of frames of reaction
+    mutable int         HealingFrameCount;
+#endif // NO_SCREEN_TEAR_HEALING
+
+    // Total frame delay due to VsyncToFirstScanline, persistence and settle time.
+    // Computed from RenderInfor.Shutter.
+    double              VSyncToScanoutDelay;
+    double              NoVSyncToScanoutDelay;
+    double              ScreenSwitchingDelay;
+
+    //Revisit dynamic pre-Timewarp delay adjustment logic
+    //TimewarpDelayAdjuster  TimewarpAdjuster;
+
+    // Current (or last) frame timing info. Used as a source for LocklessTiming.
+    Timing                  FrameTiming;
+    // TBD: Don't we need NextFrame here as well?
+    LocklessUpdater<Timing, Timing> LocklessTiming;
+
+
+    // IMU Read timings
+    double              RenderIMUTimeSeconds;
+    double              TimewarpIMUTimeSeconds;
+};
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_FrameTimeManager_h
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDRenderState.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,74 @@
+/************************************************************************************
+
+Filename    :   CAPI_HMDRenderState.h
+Content     :   Combines all of the rendering state associated with the HMD
+Created     :   February 2, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HMDRenderState_h
+#define OVR_CAPI_HMDRenderState_h
+
+#include "../OVR_CAPI.h"
+#include "../Kernel/OVR_Math.h"
+#include "../Util/Util_Render_Stereo.h"
+#include "../Service/Service_NetSessionCommon.h"
+
+namespace OVR { namespace CAPI {
+
+using namespace OVR::Util::Render;
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDRenderState
+
+// Combines all of the rendering setup information about one HMD.
+// This structure only ever exists inside HMDState, but this 
+// declaration is in a separate file to reduce #include dependencies.
+// All actual lifetime and update control is done by the surrounding HMDState.
+struct HMDRenderState
+{
+    // Utility query functions.
+    ovrHmdDesc          GetDesc() const;
+    ovrSizei            GetFOVTextureSize(int eye, ovrFovPort fov, float pixelsPerDisplayPixel) const;
+    ovrEyeRenderDesc    CalcRenderDesc(ovrEyeType eyeType, const ovrFovPort& fov) const;
+
+    HMDInfo                 OurHMDInfo;
+
+    HmdRenderInfo           RenderInfo;
+    DistortionRenderDesc    Distortion[2];
+    ovrEyeRenderDesc        EyeRenderDesc[2]; 
+
+    // Clear color used for distortion
+    float                   ClearColor[4];
+
+    // Pose at which last time the eye was rendered, as submitted by EndEyeRender.
+    ovrPosef                EyeRenderPoses[2];
+
+    // Capabilities passed to Configure.
+    unsigned                EnabledHmdCaps;
+    unsigned                DistortionCaps;
+};
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_HMDState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HMDState.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,300 @@
+/************************************************************************************
+
+Filename    :   CAPI_HMDState.h
+Content     :   State associated with a single HMD
+Created     :   January 24, 2014
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HMDState_h
+#define OVR_CAPI_HMDState_h
+
+#include "../Kernel/OVR_Math.h"
+#include "../Kernel/OVR_List.h"
+#include "../Kernel/OVR_Log.h"
+#include "../OVR_CAPI.h"
+
+#include "CAPI_FrameTimeManager.h"
+#include "CAPI_HMDRenderState.h"
+#include "CAPI_DistortionRenderer.h"
+#include "CAPI_HSWDisplay.h"
+
+#include "../Service/Service_NetClient.h"
+#include "../Net/OVR_NetworkTypes.h"
+#include "../Util/Util_LatencyTest2Reader.h"
+
+struct ovrHmdStruct { };
+
+namespace OVR { namespace CAPI {
+
+
+using namespace OVR::Util::Render;
+using namespace OVR::Service;
+using namespace OVR::Net;
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadChecker
+
+// This helper class is used to verify that the API is used according to supported
+// thread safety constraints (is not re-entrant for this and related functions).
+class ThreadChecker
+{
+public:
+
+#ifndef OVR_BUILD_DEBUG
+
+    // In release build, thread checks are disabled.
+    ThreadChecker() { }
+    void Begin(const char* functionName)    { OVR_UNUSED1(functionName); }
+    void End()                              {  }
+
+    // Add thread-re-entrancy check for function scope
+    struct Scope
+    {
+        Scope(ThreadChecker*, const char *) { }
+        ~Scope() { }
+    };
+
+
+#else // OVR_BUILD_DEBUG
+    ThreadChecker() : pFunctionName(0), FirstThread(0)
+    { }
+
+    void Begin(const char* functionName)
+    {        
+        if (!pFunctionName)
+        {
+            pFunctionName = functionName;
+            FirstThread   = GetCurrentThreadId();
+        }
+        else
+        {
+            // pFunctionName may be not null here if function is called internally on the same thread.
+            OVR_ASSERT_LOG((FirstThread == GetCurrentThreadId()),
+                ("%s (threadId=%p) called at the same times as %s (threadId=%p)\n",
+                functionName, GetCurrentThreadId(), pFunctionName, FirstThread) );
+        }        
+    }
+    void End()
+    {
+        pFunctionName = 0;
+        FirstThread   = 0;
+    }
+
+    // Add thread-reentrancy check for function scope.
+    struct Scope
+    {
+        Scope(ThreadChecker* threadChecker, const char *functionName) : pChecker(threadChecker)
+        { pChecker->Begin(functionName); }
+        ~Scope()
+        { pChecker->End(); }
+    private:
+        ThreadChecker* pChecker;
+    };
+
+private:
+    // If not 0, contains the name of the function that first entered the scope.
+    const char * pFunctionName;
+    ThreadId     FirstThread;
+
+#endif // OVR_BUILD_DEBUG
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDState
+
+// Describes a single HMD.
+class HMDState : public ListNode<HMDState>,
+                 public ovrHmdStruct, public NewOverrideBase 
+{
+    void operator=(const HMDState&) { } // Quiet warning.
+
+protected:   
+	HMDState(const OVR::Service::HMDNetworkInfo& netInfo,
+			 const OVR::HMDInfo& hmdInfo,
+			 Profile* profile,
+			 Service::NetClient* client);
+    HMDState(const HMDInfo& src, Profile* profile);
+
+public:   
+    virtual ~HMDState();
+
+    static HMDState* CreateHMDState(Service::NetClient* client, const HMDNetworkInfo& netInfo);
+    static HMDState* CreateHMDState(ovrHmdType hmdType); // Used for debug mode
+
+    // *** Sensor Setup
+
+    bool            ConfigureTracking(unsigned supportedCaps, unsigned requiredCaps);    
+    void            ResetTracking();
+	void			RecenterPose();
+    ovrTrackingState PredictedTrackingState(double absTime);
+
+    // Changes HMD Caps.
+    // Capability bits that are not directly or logically tied to one system (such as sensor)
+    // are grouped here. ovrHmdCap_VSync, for example, affects rendering and timing.
+    void            SetEnabledHmdCaps(unsigned caps);
+    unsigned        SetEnabledHmdCaps();
+
+    bool            ProcessLatencyTest(unsigned char rgbColorOut[3]);
+
+    // *** Rendering Setup
+    bool        ConfigureRendering(ovrEyeRenderDesc eyeRenderDescOut[2],
+                                   const ovrFovPort eyeFovIn[2],
+                                   const ovrRenderAPIConfig* apiConfig,                                  
+                                   unsigned distortionCaps);  
+    
+    void        UpdateRenderProfile(Profile* profile);
+
+
+    void        SubmitEyeTextures(const ovrPosef renderPose[2],
+                                  const ovrTexture eyeTexture[2]);
+
+
+    void sharedInit ( Profile *profile );
+
+    void applyProfileToSensorFusion();
+
+    // INlines so that they can be easily compiled out.    
+    // Does debug ASSERT checks for functions that require BeginFrame.
+    // Also verifies that we are on the right thread.
+    void checkBeginFrameScope(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(BeginFrameCalled == true,
+                       ("%s called outside ovrHmd_BeginFrame.", functionName));
+        OVR_ASSERT_LOG(BeginFrameThreadId == OVR::GetCurrentThreadId(),
+                       ("%s called on a different thread then ovrHmd_BeginFrame.", functionName));
+    }
+
+    void checkRenderingConfigured(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(RenderingConfigured == true,
+                       ("%s called without ovrHmd_ConfigureRendering.", functionName));
+    }
+
+    void checkBeginFrameTimingScope(const char* functionName)
+    {
+        OVR_UNUSED1(functionName); // for Release build.
+        OVR_ASSERT_LOG(BeginFrameTimingCalled == true,
+                       ("%s called outside ovrHmd_BeginFrameTiming.", functionName));
+    }
+
+	// Get properties by name.
+    bool     getBoolValue(const char* propertyName, bool defaultVal);
+    bool     setBoolValue(const char* propertyName, bool value);
+    int      getIntValue(const char* propertyName, int defaultVal);
+    bool     setIntValue(const char* propertyName, int value);
+    float    getFloatValue(const char* propertyName, float defaultVal);
+    bool     setFloatValue(const char* propertyName, float value);
+	unsigned getFloatArray(const char* propertyName, float values[], unsigned arraySize);
+    bool     setFloatArray(const char* propertyName, float values[], unsigned arraySize);
+    const char* getString(const char* propertyName, const char* defaultVal);
+    bool        setString(const char* propertyName, const char* value);
+
+	VirtualHmdId GetNetId() { return NetId; }
+
+public:
+	Ptr<Profile>            pProfile;
+    // Descriptor that gets allocated and returned to the user as ovrHmd.
+    ovrHmdDesc*             pHmdDesc;
+    // Window handle passed in AttachWindow.
+    void*                   pWindow;
+
+	// Network
+	Service::NetClient*     pClient;
+	VirtualHmdId            NetId;
+	HMDNetworkInfo          NetInfo;
+
+    // HMDInfo shouldn't change, as its string pointers are passed out.    
+    HMDInfo                 OurHMDInfo;
+
+    const char*             pLastError;
+
+    // Caps enabled for the HMD.
+    unsigned                EnabledHmdCaps;
+    
+    // Caps actually sent to the Sensor Service
+    unsigned                EnabledServiceHmdCaps;
+    
+    // These are the flags actually applied to the Sensor device,
+    // used to track whether SetDisplayReport calls are necessary.
+    //unsigned                HmdCapsAppliedToSensor;
+    
+    // *** Sensor
+    Tracking::CombinedSharedStateReader SharedStateReader;
+    Tracking::SensorStateReader         TheSensorStateReader;
+    Util::RecordStateReader             TheLatencyTestStateReader;
+
+    bool                    LatencyTestActive;
+    unsigned char           LatencyTestDrawColor[3];
+
+    bool                    LatencyTest2Active;
+    unsigned char           LatencyTest2DrawColor[3];
+
+    // Rendering part
+    FrameTimeManager        TimeManager;
+    HMDRenderState          RenderState;
+    Ptr<DistortionRenderer> pRenderer;
+
+    // Health and Safety Warning display.
+    Ptr<HSWDisplay>         pHSWDisplay;
+
+    // Last timing value reported by BeginFrame.
+    double                  LastFrameTimeSeconds;    
+    // Last timing value reported by GetFrameTime. These are separate since the intended
+    // use is from different threads. TBD: Move to FrameTimeManager? Make atomic?
+    double                  LastGetFrameTimeSeconds;
+
+    // Last cached value returned by ovrHmd_GetString/ovrHmd_GetStringArray.
+    char                    LastGetStringValue[256];
+   
+    // Debug flag set after ovrHmd_ConfigureRendering succeeds.
+    bool                    RenderingConfigured;
+    // Set after BeginFrame succeeds, and its corresponding thread id for debug checks.
+    bool                    BeginFrameCalled;
+    ThreadId                BeginFrameThreadId;    
+    // Graphics functions are not re-entrant from other threads.
+    ThreadChecker           RenderAPIThreadChecker;
+    // 
+    bool                    BeginFrameTimingCalled;
+};
+
+
+
+
+//I appreciate this isn't an idea place for this function prototype, but needed
+//to be seen by OVR_CAPI.cpp and the various SDK renderers of CAPI,
+//and have everything defined.  Please move to a better place if you know of one.
+ovrBool ovrHmd_CreateDistortionMeshInternal( ovrHmdStruct *  hmd,
+                                             ovrEyeType eyeType, ovrFovPort fov,
+                                             unsigned int distortionCaps,
+                                             ovrDistortionMesh *meshData,
+											 float overrideEyeReliefIfNonZero=0 );
+
+
+
+
+}} // namespace OVR::CAPI
+
+#endif // OVR_CAPI_HMDState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/CAPI_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,245 @@
+/************************************************************************************
+
+Filename    :   CAPI_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 3, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_HSWDisplay_h
+#define OVR_CAPI_HSWDisplay_h
+
+#include "../OVR_CAPI.h"
+#include "CAPI_HMDRenderState.h"
+#include <time.h>
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_LOG
+//
+// Debug log wrapper.
+
+#if !defined(HSWDISPLAY_LOG_ENABLED)
+    #ifdef OVR_BUILD_DEBUG
+        #define HSWDISPLAY_LOG_ENABLED 1
+    #else
+        #define HSWDISPLAY_LOG_ENABLED 0
+    #endif
+#endif
+
+#if HSWDISPLAY_LOG_ENABLED
+    #define HSWDISPLAY_LOG(...) OVR_DEBUG_LOG(__VA_ARGS__)
+#else
+    #define HSWDISPLAY_LOG(...)
+#endif
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_DISTANCE
+//
+// Floating point value in the range of ~0.75 to ~3.0 which controls the distance 
+// (in meters) of the display from the viewer.
+
+#ifndef HSWDISPLAY_DISTANCE
+    #define HSWDISPLAY_DISTANCE 1.5f
+#endif
+
+
+//-------------------------------------------------------------------------------------
+// ***** HSWDISPLAY_SCALE
+//
+// Floating point value in the range of ~0.1 to ~2.0 which controls the size scale of the 
+// SDK-rendered HSW display. The value is an arbitrary relative value, though this may 
+// change in future SDK versions.
+
+#ifndef HSWDISPLAY_SCALE
+    #define HSWDISPLAY_SCALE 0.92f
+#endif
+
+
+
+
+//-------------------------------------------------------------------------------------
+// ***** Experimental C API functions
+//
+// These are currently not formally supported and may be promoted to the formal C API
+// or may be removed in the future.
+
+extern "C"
+{
+    // Normally if an application uses SDK-based distortion rendering 
+    // (ovrHmd_BeginFrame / ovrHmd_EndFrame) then the SDK also takes care of 
+    // drawing the health and safety warning. If an application is using 
+    // SDK-based rendering but wants to draw the warning display itself, 
+    // it call this function with enabled set to false.
+    OVR_EXPORT void ovrhmd_EnableHSWDisplaySDKRender(ovrHmd hmd, ovrBool enabled);
+}
+
+
+namespace OVR { namespace CAPI {
+
+
+//-------------------------------------------------------------------------------------
+// ***** CAPI::HSWDisplay
+//
+// Note: This will be renamed to HSWDisplay in the future.
+//
+// Implements the logic for the Health and Safety (HAS) warning display. Primarily this
+// is two things: providing information about whether the warning needs to be currently
+// displayed, and implementing the display itself. 
+//
+// An HSWDisplay is associated 1:1 with an HMD. There can be at most one HSWDisplay 
+// being displayed on an HMD at a time. If a warning needs to be displayed while an  
+// existing one is present, it replaces the existing one. 
+//
+// Notes
+//    Warnings are displayed per HMD (head mounted display).
+//    The app can have multiple HMDs.
+//    There can be multiple users of a given HMD over time, with each identified by a different user profile.
+//    There can be multiple apps using HMDs.
+//
+//    Shows upon first entering a VR application (or VR mode in an application) when in Event Mode (e.g. trade show).
+//    Shows upon each wearing of the HMD.
+//    If the user profile is switched while display is active, the display must restart.
+//    Doesn't show in app when app was started by a launcher app.
+//
+//    First display ever (per profile): 15 seconds until the display can be dismissed.
+//    Subsequent displays: 6 seconds until the display can be dismissed. Per profile.
+//    Dismissing occurs via HMD tap, designated keypress, gaze detection on OK button for N seconds, 
+//        and possibly via an input gesture in the future.
+//
+//    If the warning fades out upon completion, the fade out should begin after the full display time has elapsed, 
+//        but it needs to avoid interfering (e.g. obscuring) with the application. This likely means the application 
+//        would need to put in a couple seconds delay to allow the fade to complete.
+//    Ideally we'd handle the case of a user switching HMDs and not needing to see the warning again.
+
+class HSWDisplay : public RefCountBase<HSWDisplay>
+{
+public:
+    HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+    virtual ~HSWDisplay();
+
+    // Must be called after construction and before use.
+    virtual bool Initialize(const ovrRenderAPIConfig*)
+        { return true; }
+
+    // Must be called before destruction.
+    virtual void Shutdown() {}
+
+    // Enables or disables the HSW display system. It may be disabled only for development uses.
+    // It is enabled by default. 
+    void Enable(bool enable);
+
+    // Enables or disables our internal rendering when Render is called. If set to false then the 
+    // application is expected to implement drawing of the display when Displayed is true.
+    // It is enabled by default. 
+    void EnableRender(bool enable);
+
+    // Triggers a display of the HSW display for the associated HMD. Restarts the display if 
+    // the warning is already being displayed. 
+    void Display();
+
+    // This function should be called per HMD every frame in order to give this class processing time. 
+    // Returns the new state if newHSWDisplayState is non-NULL. Returns true if the new state results
+    // in a required warning display (ovrHSWDisplayState::Displayed became true).
+    bool TickState(ovrHSWDisplayState *newHSWDisplayState = NULL);
+
+    // Gets the current state of the HSW display. 
+    // Corresponds to ovrhmd_GetHSWDisplayState.
+    void GetState(ovrHSWDisplayState *hasWarningState) const;
+
+    // Removes the HSW display display if the minimum dismissal time has occurred. 
+    // Returns true if the warning display could be dissmissed or was not displayed at the time of the call.
+    // Corresponds to ovrhmd_DismissHSWDisplay.
+    bool Dismiss();
+
+    // Returns true if the HMD appears to be currently mounted and in a state that a 
+    // warning display would be viewable.
+    bool IsDisplayViewable() const;
+
+    // Draws the warning to the eye texture(s). This must be done at the end of a 
+    // frame but prior to executing the distortion rendering of the eye textures. 
+    virtual void Render(ovrEyeType, const ovrTexture*);
+
+    // Resets the current profile's HAS settings (e.g. to act as if the user has never seen the HSW display before).
+    void ResetProfileData();
+
+    // Returns the ovrRenderAPIType. This is essentially the same as RTTI, as it's indicating what subclass
+    // is being used for this.
+    ovrRenderAPIType GetRenderAPIType() const // e.g. ovrRenderAPI_D3D11
+        { return RenderAPIType; }
+
+    // Returns the required HSW display text for the current profile's locale. 
+    // Useful for implementing custom warning displays. Returns the required strlen 
+    // of the text, and thus success is indicated by a return value < strCapacity.
+    // size_t GetText(char *str, size_t strCapacity);
+
+    // Creates and constructs an instance of an HSWDisplay subclass based on the API type.
+    static HSWDisplay* Factory(ovrRenderAPIType apiType, ovrHmd hmd, const HMDRenderState& renderState);
+
+private:
+    OVR_NON_COPYABLE(HSWDisplay)
+
+protected:
+    virtual void DisplayInternal() {}
+    virtual void DismissInternal() {}
+    virtual void RenderInternal(ovrEyeType, const ovrTexture*) {}
+
+    // Profile functionality
+    time_t GetCurrentProfileLastHSWTime() const;
+    void   SetCurrentProfileLastHSWTime(time_t t);
+
+    // Generates an appropriate stereo ortho projection matrix.
+    static void GetOrthoProjection(const HMDRenderState& RenderState, Matrix4f OrthoProjection[2]);
+
+    // Returns the default HSW display texture data.
+    static const uint8_t* GetDefaultTexture(size_t& TextureSize);
+
+protected:
+    bool                   Enabled;            // If true then the HSW display system is enabled. True by default. 
+    bool                   Displayed;          // If true then the warning is currently visible and the following variables have meaning. Else there is no warning being displayed for this application on the given HMD.
+    bool                   SDKRendered;        // If true then the display is being rendered by the SDK as opposed to the application. 
+    bool                   DismissRequested;   // If true then the warning has been requested to be hidden.
+    bool                   RenderEnabled;      // If true then we handle rendering when Render is called. Else we skip it and assume the application is otherwise handling it itself.
+    double                 StartTime;          // Absolute time when the warning was first displayed. See ovr_GetTimeInSeconds().
+    double                 DismissibleTime;    // Absolute time when the warning can be dismissed.
+    double                 LastPollTime;       // Used to prevent us from polling the required display state every frame but rather more like every 200 milliseconds.
+    const ovrHmd           HMD;                // The HMDState this HSWDisplay instance corresponds to.
+    mutable bool           HMDMounted;         // True if the HMD was most recently found to be mounted. We need this in order to maintain HMDNewlyMounted.
+    mutable bool           HMDNewlyMounted;    // True if HMDMounted has transitioned from false to true. We need this in order to tell if the HMD was recently mounted so we can display the HSW display.
+    bool                   EventMode;          // True if the application is being run in Event Mode, which means it's running at a trade show or similar public demo.
+    const ovrRenderAPIType RenderAPIType;      // e.g. ovrRenderAPI_D3D11
+    const HMDRenderState&  RenderState;        // Information about the rendering setup.
+
+    // Settings cache
+    mutable String         LastProfileName;
+    mutable int            LastHSWTime;
+
+}; // class HSWDisplay
+
+
+
+}} // namespace OVR::CAPI
+
+
+#endif // OVR_CAPI_HSWDisplay_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,34 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_DistortionRenderer.h
+Content     :   Distortion renderer header for D3D10
+Created     :   November 11, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_CAPI_D3D10_DistortionRenderer_h
+#define INC_CAPI_D3D10_DistortionRenderer_h
+
+#define OVR_D3D_VERSION 10
+#include "CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D10_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,41 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D10_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D10_HSWDisplay_h
+#define OVR_CAPI_D3D10_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+// Due to the similarities between DX10 and DX11, there is a shared implementation of the headers and source
+// which is differentiated only by the OVR_D3D_VERSION define. This define causes D3D_NS (D3D namespace) to 
+// be defined to either D3D10 or D3D11, as well as other similar effects. 
+#include "CAPI_D3D1X_HSWDisplay.h"
+
+
+#endif // OVR_CAPI_D3D10_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,34 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_DistortionRenderer.h
+Content     :   Distortion renderer header for D3D11
+Created     :   November 11, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_CAPI_D3D11_DistortionRenderer_h
+#define INC_CAPI_D3D11_DistortionRenderer_h
+
+#define OVR_D3D_VERSION 11
+#include "CAPI_D3D1X_DistortionRenderer.h"
+#undef OVR_D3D_VERSION
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D11_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,41 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D11_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D11_HSWDisplay_h
+#define OVR_CAPI_D3D11_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+// Due to the similarities between DX10 and DX11, there is a shared implementation of the headers and source
+// which is differentiated only by the OVR_D3D_VERSION define. This define causes D3D_NS (D3D namespace) to 
+// be defined to either D3D10 or D3D11, as well as other similar effects. 
+#include "CAPI_D3D1X_HSWDisplay.h"
+
+
+#endif // OVR_CAPI_D3D11_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,190 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.h
+Content     :   Experimental distortion renderer
+Created     :   November 11, 2013
+Authors     :   Volga Aksoy
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// No include guard, since this fill will be multiply-included. 
+//#ifndef OVR_CAPI_D3D1X_DistortionRenderer_h
+
+#include "CAPI_D3D1X_Util.h"
+#include "../CAPI_DistortionRenderer.h"
+
+#include "../../Kernel/OVR_Log.h"
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+
+// ***** D3D1X::DistortionRenderer
+
+// Implementation of DistortionRenderer for D3D10/11.
+
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd,
+                       FrameTimeManager& timeManager,
+                       const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+                                            FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+
+
+    // ***** Public DistortionRenderer interface
+
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    // TBD: Make public?
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+
+	class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+	{
+	public:
+		GraphicsState(ID3D1xDeviceContext* context);
+		virtual ~GraphicsState();
+		virtual void clearMemory();
+		virtual void Save();
+		virtual void Restore();
+
+	protected:
+		ID3D1xDeviceContext* context;
+		BOOL memoryCleared;
+
+		ID3D1xRasterizerState* rasterizerState;
+		ID3D1xSamplerState* samplerStates[D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT];
+		ID3D1xInputLayout* inputLayoutState;
+
+		ID3D1xShaderResourceView* psShaderResourceState[D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT];
+		ID3D1xShaderResourceView* vsShaderResourceState[D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT];
+
+		ID3D1xBuffer* psConstantBuffersState[D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT];
+		ID3D1xBuffer* vsConstantBuffersState[D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT];
+
+		ID3D1xRenderTargetView* renderTargetViewState[D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT];
+		ID3D1xDepthStencilView* depthStencilViewState;
+
+		ID3D1xBlendState* omBlendState;
+		FLOAT omBlendFactorState[4];
+		UINT omSampleMaskState;
+
+		D3D1x_PRIMITIVE_TOPOLOGY primitiveTopologyState;
+
+		ID3D1xBuffer* iaIndexBufferPointerState;
+		DXGI_FORMAT iaIndexBufferFormatState;
+		UINT iaIndexBufferOffsetState;
+
+		ID3D1xBuffer* iaVertexBufferPointersState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+		UINT iaVertexBufferStridesState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+		UINT iaVertexBufferOffsetsState[D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT];
+
+		ID3D1xPixelShader* currentPixelShader;
+		ID3D1xVertexShader* currentVertexShader;
+		ID3D1xGeometryShader* currentGeometryShader;
+#if (OVR_D3D_VERSION == 11)
+		ID3D11HullShader* currentHullShader;
+		ID3D11DomainShader* currentDomainShader;
+#endif
+
+	};
+
+private:
+    // Helpers
+    void initBuffersAndShaders();
+    void initShaders();
+    void initFullscreenQuad();
+	void initOverdrive();
+    void destroy();
+
+    void setViewport(const Recti& vp);
+
+    void renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture);
+
+    void renderPrimitives(const ShaderFill* fill, Buffer* vertices, Buffer* indices,
+                          Matrix4f* viewMatrix, int offset, int count,
+                          PrimitiveType rprim);
+
+    void renderEndFrame();
+
+    void createDrawQuad();
+    void renderLatencyQuad(unsigned char* latencyTesterDrawColor);
+    void renderLatencyPixel(unsigned char* latencyTesterPixelColor);
+
+    // Create or get cached D3D sampler based on flags.
+    ID3D1xSamplerState* getSamplerState(int sm);
+
+    
+    // TBD: Should we be using oe from RState instead?
+    unsigned            DistortionCaps;
+
+    // D3DX device and utility variables.
+    RenderParams        RParams;    
+    Ptr<Texture>        pEyeTextures[2];
+
+    // U,V scale and offset needed for timewarp.
+    ovrVector2f         UVScaleOffset[2][2];
+    ovrSizei            EyeTextureSize[2];
+    ovrRecti            EyeRenderViewport[2];
+
+	Ptr<Texture>        pOverdriveTextures[NumOverdriveTextures];
+
+    //Ptr<Buffer>         mpFullScreenVertexBuffer;
+
+	Ptr<Buffer>         DistortionMeshVBs[2];    // one per-eye
+	Ptr<Buffer>         DistortionMeshIBs[2];    // one per-eye
+
+	Ptr<ShaderSet>      DistortionShader;
+	Ptr<ID3D1xInputLayout> DistortionVertexIL;
+
+    struct StandardUniformData
+    {
+        Matrix4f  Proj;
+        Matrix4f  View;
+    }                   StdUniforms;
+    Ptr<Buffer>         UniformBuffers[Shader_Count];
+    
+    Ptr<ID3D1xSamplerState>     SamplerStates[Sample_Count];
+    Ptr<ID3D1xRasterizerState>  Rasterizer;
+
+    Ptr<Buffer>         LatencyTesterQuadVB;
+    Ptr<ShaderSet>      SimpleQuadShader;
+    Ptr<ID3D1xInputLayout> SimpleQuadVertexIL;
+
+    GpuTimer GpuProfiler;
+};
+
+}}} // OVR::CAPI::D3D1X
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,84 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// Do not use include guards, as this file is #included separately by both 
+// CAPI_D3D10_HSWDisplay.h and CAPI_D3D11_HSWDisplay.h with OVR_D3D_VERSION defined
+// to either 10 or 11. Only those two headers should #include this one.
+//#ifndef OVR_CAPI_D3D1X_HSWDisplay_h
+//#define OVR_CAPI_D3D1X_HSWDisplay_h
+
+//#if !defined(OVR_CAPI_D3D10_HSWDisplay_h) && !defined(OVR_CAPI_D3D11_HSWDisplay_h)
+//    #error This header is expected to be compiled only by these two headers.
+//#endif
+#if !defined(OVR_D3D_VERSION) || ((OVR_D3D_VERSION != 10) && (OVR_D3D_VERSION != 11))
+    #error This header expects OVR_D3D_VERSION to be defined, to 10 or 11.
+#endif
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_D3D1X_Util.h"
+
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrD3D11Config* config = (const ovrD3D11Config*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void LoadGraphics();
+        void UnloadGraphics();
+
+        OVR::CAPI::D3D_NS::RenderParams   RenderParams;
+        Ptr<ID3D1xSamplerState>           pSamplerState;
+        Ptr<OVR::CAPI::D3D_NS::Texture>   pTexture;
+        Ptr<Buffer>                       pVB;
+        Ptr<Buffer>                       UniformBufferArray[OVR::CAPI::D3D_NS::Shader_Count];
+        Ptr<ShaderSet>                    pShaderSet;
+        Ptr<ID3D1xInputLayout>            pVertexInputLayout;
+        Ptr<ID3D1xBlendState>             pBlendState;
+        Ptr<ID3D1xRasterizerState>        pRasterizerState;
+        Matrix4f                          OrthoProjection[ovrEye_Count];
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::D3D_NS
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D1X_Util.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,514 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_Util.h
+Content     :   D3DX 10/11 utility classes for rendering
+Created     :   September 10, 2012
+Authors     :   Andrew Reisse
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+// ***** IMPORTANT:
+// This file can be included twice, once with OVR_D3D_VERSION=10 and
+// once with OVR_D3D_VERSION=11.
+
+
+#ifndef OVR_D3D_VERSION
+#error define OVR_D3D_VERSION to 10 or 11
+#endif
+
+// Custom include guard, allowing one of each D3D10/11.
+#if (OVR_D3D_VERSION == 10 && !defined(INC_OVR_CAPI_D3D10_Util_h)) || \
+    (OVR_D3D_VERSION == 11 && !defined(INC_OVR_CAPI_D3D11_Util_h))
+
+#include "../../Kernel/OVR_String.h"
+#include "../../Kernel/OVR_Array.h"
+#include "../../Kernel/OVR_Math.h"
+
+#if defined(OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <comdef.h> // for _COM_SMARTPTR_TYPEDEF()
+
+#undef D3D_NS           // namespace
+#undef D3D1X_       
+#undef ID3D1X           // interface prefix
+#undef ovrD3D1X         // ovrD3D10Config, etc.
+#undef D3D11_COMMA_0    // Injects on ", 0" for D3D11 only
+#undef D3DSELECT_10_11
+#undef IID_ID3D1xShaderReflection
+
+#if (OVR_D3D_VERSION == 10)
+
+    #define INC_OVR_CAPI_D3D10_Util_h 
+    #define D3D_NS                      D3D10
+    #define D3D1X_(x)                   D3D10_##x
+    #define ID3D1X(x)                   ID3D10##x
+    #define ovrD3D1X(x)                 ovrD3D10##x
+    #define D3DSELECT_10_11(a10, a11)   a10
+    #define D3D11_COMMA_0    
+    #define IID_ID3D1xShaderReflection  IID_ID3D10ShaderReflection
+    #include <d3d10_1.h> // avoids warning?
+    #include <d3d10.h>
+
+#else // (OVR_D3D_VERSION == 11)
+
+    #define INC_OVR_CAPI_D3D11_Util_h
+    #define D3D_NS                      D3D11        
+    #define D3D1X_(x)                   D3D11_##x
+    #define ID3D1X(x)                   ID3D11##x
+    #define ovrD3D1X(x)                 ovrD3D11##x
+    #define D3DSELECT_10_11(a10, a11)   a11
+    #define D3D11_COMMA_0               , 0
+    #define IID_ID3D1xShaderReflection  IID_ID3D11ShaderReflection
+    #include <d3d11.h>
+    #include <D3D11Shader.h>
+#endif
+#endif
+
+
+namespace OVR { namespace CAPI { namespace D3D_NS {
+
+// D3D Namespace-local types.
+typedef ID3D1X(Device)                          ID3D1xDevice;
+typedef ID3D1X(RenderTargetView)                ID3D1xRenderTargetView;
+typedef ID3D1X(Texture2D)                       ID3D1xTexture2D;
+typedef ID3D1X(ShaderResourceView)              ID3D1xShaderResourceView;
+typedef ID3D1X(DepthStencilView)                ID3D1xDepthStencilView;
+typedef ID3D1X(DepthStencilState)               ID3D1xDepthStencilState;
+typedef ID3D1X(InputLayout)                     ID3D1xInputLayout;
+typedef ID3D1X(Buffer)                          ID3D1xBuffer;
+typedef ID3D1X(VertexShader)                    ID3D1xVertexShader;
+typedef ID3D1X(PixelShader)                     ID3D1xPixelShader;
+typedef ID3D1X(GeometryShader)                  ID3D1xGeometryShader;
+typedef ID3D1X(BlendState)                      ID3D1xBlendState;
+typedef ID3D1X(RasterizerState)                 ID3D1xRasterizerState;
+typedef ID3D1X(SamplerState)                    ID3D1xSamplerState;
+typedef ID3D1X(Query)                           ID3D1xQuery;
+typedef ID3D1X(ShaderReflection)                ID3D1xShaderReflection;
+typedef ID3D1X(ShaderReflectionVariable)        ID3D1xShaderReflectionVariable;
+typedef ID3D1X(ShaderReflectionConstantBuffer)  ID3D1xShaderReflectionConstantBuffer;
+typedef D3D1X_(VIEWPORT)                        D3D1x_VIEWPORT;
+typedef D3D1X_(QUERY_DESC)                      D3D1x_QUERY_DESC;
+typedef D3D1X_(SHADER_BUFFER_DESC)              D3D1x_SHADER_BUFFER_DESC;
+typedef D3D1X_(SHADER_VARIABLE_DESC)            D3D1x_SHADER_VARIABLE_DESC;
+typedef D3D1X_(PRIMITIVE_TOPOLOGY)            D3D1x_PRIMITIVE_TOPOLOGY;
+static const int D3D1x_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT = D3D1X_(COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
+static const int D3D1x_COMMONSHADER_SAMPLER_SLOT_COUNT = D3D1X_(COMMONSHADER_SAMPLER_SLOT_COUNT);
+static const int D3D1x_SIMULTANEOUS_RENDER_TARGET_COUNT = D3D1X_(SIMULTANEOUS_RENDER_TARGET_COUNT);
+static const int D3D1x_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT = D3D1X_(IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT);
+static const int D3D1x_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT = D3D1X_(COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
+// Blob is the same
+typedef ID3D10Blob                 ID3D1xBlob;
+
+#if (OVR_D3D_VERSION == 10)
+    typedef ID3D10Device		        ID3D1xDeviceContext;
+#else
+    typedef ID3D11DeviceContext         ID3D1xDeviceContext;
+#endif
+
+
+// Assert on HRESULT failure
+inline void VERIFY_HRESULT(HRESULT hr)
+{
+    if (FAILED(hr))
+        OVR_ASSERT(false);
+}
+
+class Buffer;
+
+// Rendering parameters/pointers describing D3DX rendering setup.
+struct RenderParams
+{
+    ID3D1xDevice*			pDevice;
+    ID3D1xDeviceContext*    pContext;
+    ID3D1xRenderTargetView* pBackBufferRT;
+    IDXGISwapChain*         pSwapChain;
+    Sizei                   RTSize;
+    int                     Multisample;
+};
+
+
+// Rendering primitive type used to render Model.
+enum PrimitiveType
+{
+    Prim_Triangles,
+    Prim_Lines,
+    Prim_TriangleStrip,
+    Prim_Unknown,
+    Prim_Count
+};
+
+// Types of shaders that can be stored together in a ShaderSet.
+enum ShaderStage
+{
+    Shader_Vertex   = 0,
+    Shader_Fragment = 2,
+    Shader_Pixel    = 2,
+    Shader_Count    = 3,
+};
+
+enum MapFlags
+{
+    Map_Discard        = 1,
+    Map_Read           = 2, // do not use
+    Map_Unsynchronized = 4, // like D3D11_MAP_NO_OVERWRITE
+};
+
+
+// Buffer types used for uploading geometry & constants.
+enum BufferUsage
+{
+    Buffer_Unknown  = 0,
+    Buffer_Vertex   = 1,
+    Buffer_Index    = 2,
+    Buffer_Uniform  = 4,
+    Buffer_TypeMask = 0xff,
+    Buffer_ReadOnly = 0x100, // Buffer must be created with Data().
+};
+
+enum TextureFormat
+{
+    Texture_RGBA            = 0x0100,
+    Texture_Depth           = 0x8000,
+    Texture_TypeMask        = 0xff00,
+    Texture_SamplesMask     = 0x00ff,
+    Texture_RenderTarget    = 0x10000,
+    Texture_GenMipmaps      = 0x20000,
+};
+
+// Texture sampling modes.
+enum SampleMode
+{
+    Sample_Linear       = 0,
+    Sample_Nearest      = 1,
+    Sample_Anisotropic  = 2,
+    Sample_FilterMask   = 3,
+
+    Sample_Repeat       = 0,
+    Sample_Clamp        = 4,
+    Sample_ClampBorder  = 8, // If unsupported Clamp is used instead.
+    Sample_AddressMask  =12,
+
+    Sample_Count        =13,
+};
+
+// Base class for vertex and pixel shaders. Stored in ShaderSet.
+class Shader : public RefCountBase<Shader>
+{
+    friend class ShaderSet;
+
+protected:
+    ShaderStage Stage;
+
+public:
+    Shader(ShaderStage s) : Stage(s) {}
+    virtual ~Shader() {}
+
+    ShaderStage GetStage() const { return Stage; }
+
+    virtual void Set(PrimitiveType) const { }
+    virtual void SetUniformBuffer(class Buffer* buffers, int i = 0) { OVR_UNUSED2(buffers, i); }
+
+protected:
+    virtual bool SetUniform(const char* name, int n, const float* v) { OVR_UNUSED3(name, n, v); return false; }
+    virtual bool SetUniformBool(const char* name, int n, const bool* v) { OVR_UNUSED3(name, n, v); return false; }
+};
+
+
+
+// A group of shaders, one per stage.
+// A ShaderSet is applied to a RenderDevice for rendering with a given fill.
+class ShaderSet : public RefCountBase<ShaderSet>
+{
+protected:
+    Ptr<Shader> Shaders[Shader_Count];
+
+public:
+    ShaderSet() { }
+    ~ShaderSet() { }
+
+    virtual void SetShader(Shader *s)
+    {
+        Shaders[s->GetStage()] = s;
+    }
+    virtual void UnsetShader(int stage)
+    {
+        Shaders[stage] = NULL;
+    }
+    Shader* GetShader(int stage) { return Shaders[stage]; }
+
+    virtual void Set(PrimitiveType prim) const
+    {
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                Shaders[i]->Set(prim);
+    }
+
+    // Set a uniform (other than the standard matrices). It is undefined whether the
+    // uniforms from one shader occupy the same space as those in other shaders
+    // (unless a buffer is used, then each buffer is independent).     
+    virtual bool SetUniform(const char* name, int n, const float* v)
+    {
+        bool result = 0;
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                result |= Shaders[i]->SetUniform(name, n, v);
+
+        return result;
+    }
+    bool SetUniform1f(const char* name, float x)
+    {
+        const float v[] = {x};
+        return SetUniform(name, 1, v);
+    }
+    bool SetUniform2f(const char* name, float x, float y)
+    {
+        const float v[] = {x,y};
+        return SetUniform(name, 2, v);
+    }
+    bool SetUniform3f(const char* name, float x, float y, float z)
+    {
+        const float v[] = {x,y,z};
+        return SetUniform(name, 3, v);
+    }
+    bool SetUniform4f(const char* name, float x, float y, float z, float w = 1)
+    {
+        const float v[] = {x,y,z,w};
+        return SetUniform(name, 4, v);
+    }
+
+    bool SetUniformv(const char* name, const Vector3f& v)
+    {
+        const float a[] = {v.x,v.y,v.z,1};
+        return SetUniform(name, 4, a);
+    }
+ 
+    virtual bool SetUniform4x4f(const char* name, const Matrix4f& m)
+    {
+        Matrix4f mt = m.Transposed();
+        return SetUniform(name, 16, &mt.M[0][0]);
+    }
+};
+
+
+// Fill combines a ShaderSet (vertex, pixel) with textures, if any.
+// Every model has a fill.
+class ShaderFill : public RefCountBase<ShaderFill>
+{
+    Ptr<ShaderSet>     Shaders;
+    Ptr<class Texture> Textures[8];
+    void*              InputLayout; // HACK this should be abstracted
+
+public:
+    ShaderFill(ShaderSet* sh) : Shaders(sh) { InputLayout = NULL; }
+    ShaderFill(ShaderSet& sh) : Shaders(sh) { InputLayout = NULL; }    
+
+    ShaderSet*  GetShaders() const      { return Shaders; }
+    void*       GetInputLayout() const  { return InputLayout; }
+
+    virtual void Set(PrimitiveType prim = Prim_Unknown) const;   
+    virtual void SetTexture(int i, class Texture* tex) { if (i < 8) Textures[i] = tex; }
+    void SetInputLayout(void* newIL) { InputLayout = (void*)newIL; }
+};
+
+
+class ShaderBase : public Shader
+{
+public:    
+    RenderParams*   pParams;
+    unsigned char*  UniformData;
+    int             UniformsSize;
+
+	enum VarType
+	{
+		VARTYPE_FLOAT,
+		VARTYPE_INT,
+		VARTYPE_BOOL,
+	};
+
+	struct Uniform
+	{
+		const char* Name;
+		VarType Type;
+		int     Offset, Size;
+	};
+    const Uniform* UniformRefl;
+    size_t UniformReflSize;
+
+	ShaderBase(RenderParams* rp, ShaderStage stage);
+	~ShaderBase();
+
+    ShaderStage GetStage() const { return Stage; }
+
+    void InitUniforms(const Uniform* refl, size_t reflSize);
+	bool SetUniform(const char* name, int n, const float* v);
+	bool SetUniformBool(const char* name, int n, const bool* v);
+ 
+    void UpdateBuffer(Buffer* b);
+};
+
+
+template<ShaderStage SStage, class D3DShaderType>
+class ShaderImpl : public ShaderBase
+{
+public:
+    D3DShaderType*  D3DShader;
+
+    ShaderImpl(RenderParams* rp, void* s, size_t size, const Uniform* refl, size_t reflSize) : ShaderBase(rp, SStage)
+    {
+        Load(s, size);
+        InitUniforms(refl, reflSize);
+    }
+    ~ShaderImpl()
+    {
+        if (D3DShader)        
+            D3DShader->Release();        
+    }
+
+    // These functions have specializations.
+    bool Load(void* shader, size_t size);
+    void Set(PrimitiveType prim) const;
+    void SetUniformBuffer(Buffer* buffers, int i = 0);
+};
+
+typedef ShaderImpl<Shader_Vertex,  ID3D1xVertexShader> VertexShader;
+typedef ShaderImpl<Shader_Fragment, ID3D1xPixelShader> PixelShader;
+
+
+class Buffer : public RefCountBase<Buffer>
+{
+public:
+    RenderParams*     pParams;
+    Ptr<ID3D1xBuffer> D3DBuffer;
+    size_t            Size;
+    int               Use;
+    bool              Dynamic;
+
+public:
+    Buffer(RenderParams* rp) : pParams(rp), Size(0), Use(0) {}
+    ~Buffer();
+
+    ID3D1xBuffer* GetBuffer() const { return D3DBuffer; }
+
+    virtual size_t GetSize()        { return Size; }
+    virtual void*  Map(size_t start, size_t size, int flags = 0);
+    virtual bool   Unmap(void *m);
+    virtual bool   Data(int use, const void* buffer, size_t size);
+};
+
+
+class Texture : public RefCountBase<Texture>
+{
+public:
+    RenderParams*                   pParams;
+    Ptr<ID3D1xTexture2D>            Tex;
+    Ptr<ID3D1xShaderResourceView>   TexSv;
+    Ptr<ID3D1xRenderTargetView>     TexRtv;
+    Ptr<ID3D1xDepthStencilView>     TexDsv;
+    mutable Ptr<ID3D1xSamplerState> Sampler;
+    Sizei                           TextureSize;
+    int                             Samples;
+
+    Texture(RenderParams* rp, int fmt, const Sizei texSize,
+            ID3D1xSamplerState* sampler, int samples = 1);
+    ~Texture();
+
+    virtual Sizei GetSize() const     { return TextureSize; }    
+    virtual int   GetSamples() const  { return Samples; }
+
+  //  virtual void SetSampleMode(int sm);
+
+    // Updates texture to point to specified resources
+    //  - used for slave rendering.
+    void UpdatePlaceholderTexture(ID3D1xTexture2D* texture,
+                                  ID3D1xShaderResourceView* psrv,
+                                  const Sizei& textureSize)
+    {
+        Tex     = texture;
+        TexSv   = psrv;
+        TexRtv.Clear();
+        TexDsv.Clear();
+
+        TextureSize = textureSize;
+
+#ifdef OVR_BUILD_DEBUG
+        D3D1X_(TEXTURE2D_DESC) desc;
+        texture->GetDesc(&desc);
+        OVR_ASSERT(TextureSize == Sizei(desc.Width, desc.Height));
+#endif
+    }
+
+
+    virtual void Set(int slot, ShaderStage stage = Shader_Fragment) const;
+
+};
+
+
+class GpuTimer : public RefCountBase<GpuTimer>
+{
+public:
+    GpuTimer()
+        : QuerySets(MaxNumQueryFrames)
+        , D3dDevice(NULL)
+        , Context(NULL)
+        , LastQueuedFrame(-1)
+        , LastTimedFrame(-1)
+    { }
+
+    void Init(ID3D1xDevice* device, ID3D1xDeviceContext* content);
+
+    void BeginQuery();
+    void EndQuery();
+
+    // Returns -1 if timing is invalid
+    float GetTiming(bool blockUntilValid);
+
+protected:
+    static const unsigned MaxNumQueryFrames = 10;
+    
+    int GotoNextFrame(int frame)
+    {
+        return (frame + 1) % MaxNumQueryFrames;
+    }
+    
+    _COM_SMARTPTR_TYPEDEF(ID3D1xQuery, __uuidof(ID3D1xQuery));
+
+    struct GpuQuerySets
+    {
+        ID3D1xQueryPtr DisjointQuery;
+        ID3D1xQueryPtr TimeStartQuery;
+        ID3D1xQueryPtr TimeEndQuery;
+        bool QueryStarted;
+        bool QueryAwaitingTiming;
+
+        GpuQuerySets() : QueryStarted(false), QueryAwaitingTiming(false) {}
+    };
+    Array<GpuQuerySets> QuerySets;
+    
+    int LastQueuedFrame;
+    int LastTimedFrame;
+
+    Ptr<ID3D1xDevice> D3dDevice;
+    Ptr<ID3D1xDeviceContext> Context;
+};
+
+}}} // OVR::CAPI::D3D1X
+
+#endif // INC_OVR_CAPI_D3D10/11_Util_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,140 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D1X_DistortionRenderer.h
+Content     :   Experimental distortion renderer
+Created     :   March 7, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#include "../../Kernel/OVR_Types.h"
+
+#if defined (OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#if _MSC_VER < 1700
+#include <d3dx9.h>
+#else
+#include <d3d9.h>
+#endif
+#endif
+
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif 
+
+#include "../CAPI_DistortionRenderer.h"
+
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+
+//Implementation of DistortionRenderer for D3D9.
+/***************************************************/
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd, FrameTimeManager& timeManager, const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+		                                    FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+	
+    // ***** Public DistortionRenderer interface
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    // TBD: Make public?
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+	
+	class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+	{
+	public:
+		GraphicsState(IDirect3DDevice9* d, unsigned arg_distortionCaps);
+		virtual void Save();
+		virtual void Restore();
+
+	protected:
+		void RecordAndSetState(int which, int type, DWORD newValue);
+
+		//Structure to store our state changes
+		static const int MAX_SAVED_STATES=100;
+		struct SavedStateType
+		{
+			int which;  //0 for samplerstate, 1 for renderstate
+			int type;
+			DWORD valueToRevertTo;
+		} savedState[MAX_SAVED_STATES];
+
+		//Keep track of how many we've done, for reverting
+		int numSavedStates;
+		IDirect3DDevice9* device;
+        unsigned distortionCaps;
+	};
+
+private:
+
+	//Functions
+	void         CreateDistortionShaders(void);
+	void         Create_Distortion_Models(void);
+	void         CreateVertexDeclaration(void);
+	void         RenderBothDistortionMeshes();
+	void         RecordAndSetState(int which, int type, DWORD newValue);
+	void         RevertAllStates(void);
+
+    void         renderEndFrame();
+	
+	//Data, structures and pointers
+	IDirect3DDevice9            * device;
+	IDirect3DSwapChain9         * swapChain;
+	IDirect3DVertexDeclaration9 * vertexDecl;
+	IDirect3DPixelShader9       * pixelShader;
+	IDirect3DVertexShader9      * vertexShader;
+	IDirect3DVertexShader9      * vertexShaderTimewarp;
+	ovrSizei                      screenSize; 
+	unsigned                      distortionCaps;
+
+	struct FOR_EACH_EYE
+	{
+        FOR_EACH_EYE() : TextureSize(0), RenderViewport(Sizei(0)) { }
+
+		IDirect3DVertexBuffer9  * dxVerts;
+		IDirect3DIndexBuffer9   * dxIndices;
+		int                       numVerts;
+		int                       numIndices;
+		IDirect3DTexture9       * texture;
+		ovrVector2f			 	  UVScaleOffset[2]; 
+        Sizei                     TextureSize;
+        Recti                     RenderViewport;
+	} eachEye[2];
+};
+
+}}} // OVR::CAPI::D3D9
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/D3D1X/CAPI_D3D9_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,82 @@
+/************************************************************************************
+
+Filename    :   CAPI_D3D9_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_D3D9_HSWDisplay_h
+#define OVR_CAPI_D3D9_HSWDisplay_h
+
+#if !defined(OVR_D3D_VERSION) || (OVR_D3D_VERSION != 9)
+    #error This header expects OVR_D3D_VERSION to be defined, to 9.
+#endif
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_D3D1X_Util.h"
+#include <d3d9.h>
+
+
+namespace OVR { namespace CAPI { namespace D3D9 {
+
+    // There currently isn't a D3D9::RenderParams, as D3D9 support is currently only very basic.
+    struct HSWRenderParams
+    {
+	    IDirect3DDevice9*    Device;
+	    IDirect3DSwapChain9* SwapChain;
+	    ovrSizei             ScreenSize; 
+    };
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrD3D9Config* config = (const ovrD3D9Config*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void LoadGraphics();
+        void UnloadGraphics();
+
+        D3D9::HSWRenderParams       RenderParams;
+        Ptr<IDirect3DTexture9>      pTexture;
+        Ptr<IDirect3DVertexBuffer9> pVB;
+        Matrix4f                    OrthoProjection[2];     // Projection for 2D.
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::D3D9
+
+
+#endif // OVR_CAPI_D3D9_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionRenderer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,188 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_DistortionRenderer.h
+Content     :   Distortion renderer header for GL
+Created     :   November 11, 2013
+Authors     :   David Borel, Lee Cooper
+
+Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_GL_DistortionRenderer_h
+#define OVR_CAPI_GL_DistortionRenderer_h
+
+#include "../CAPI_DistortionRenderer.h"
+
+#include "../../Kernel/OVR_Log.h"
+#include "CAPI_GL_Util.h"
+
+namespace OVR { namespace CAPI { namespace GL {
+
+// ***** GL::DistortionRenderer
+
+// Implementation of DistortionRenderer for GL.
+
+class DistortionRenderer : public CAPI::DistortionRenderer
+{
+public:    
+    DistortionRenderer(ovrHmd hmd,
+                       FrameTimeManager& timeManager,
+                       const HMDRenderState& renderState);
+    ~DistortionRenderer();
+
+    
+    // Creation function for the device.    
+    static CAPI::DistortionRenderer* Create(ovrHmd hmd,
+                                            FrameTimeManager& timeManager,
+                                            const HMDRenderState& renderState);
+
+
+    // ***** Public DistortionRenderer interface
+	
+    virtual bool Initialize(const ovrRenderAPIConfig* apiConfig,
+                            unsigned distortionCaps);
+
+    virtual void SubmitEye(int eyeId, const ovrTexture* eyeTexture);
+
+    virtual void EndFrame(bool swapBuffers);
+
+    void         WaitUntilGpuIdle();
+
+	// Similar to ovr_WaitTillTime but it also flushes GPU.
+	// Note, it exits when time expires, even if GPU is not in idle state yet.
+	double       FlushGpuAndWaitTillTime(double absTime);
+
+protected:
+    
+    
+    class GraphicsState : public CAPI::DistortionRenderer::GraphicsState
+    {
+    public:
+        GraphicsState();
+        virtual void Save();
+        virtual void Restore();
+        
+#ifdef OVR_OS_MAC
+        // Asking for Core Profile is equivalent to asking whether we have a
+        // 3.2+ context on mac.
+        bool isAtLeastOpenGL3();
+#endif
+
+    protected:
+        void ApplyBool(GLenum Name, GLint Value, GLint index = -1);
+        
+    public:
+        GLVersionAndExtensions GLVersionInfo;
+        
+        GLint Viewport[4];
+        GLfloat ClearColor[4];
+        GLint DepthTest;
+        GLint CullFace;
+        GLint SRGB;
+        GLint Program;
+        GLint ActiveTexture;
+        GLint TextureBinding;
+        GLint VertexArrayBinding;
+        GLint ElementArrayBufferBinding;
+        GLint ArrayBufferBinding;
+        GLint FrameBufferBinding;
+        
+        GLint Blend;
+        GLint ColorWritemask[4];
+        GLint Dither;
+        GLint Fog;
+        GLint Lighting;
+        GLint RasterizerDiscard;
+        GLint RenderMode;
+        GLint SampleMask;
+        GLint ScissorTest;
+        GLfloat ZoomX;
+        GLfloat ZoomY;
+    };
+
+    // TBD: Should we be using oe from RState instead?
+    unsigned            DistortionCaps;
+
+	struct FOR_EACH_EYE
+	{
+        FOR_EACH_EYE() : TextureSize(0), RenderViewport(Sizei(0)) { }
+
+#if 0
+		IDirect3DVertexBuffer9  * dxVerts;
+		IDirect3DIndexBuffer9   * dxIndices;
+#endif
+		int                       numVerts;
+		int                       numIndices;
+
+		GLuint                    texture;
+
+		ovrVector2f			 	  UVScaleOffset[2];
+        Sizei                     TextureSize;
+        Recti                     RenderViewport;
+	} eachEye[2];
+
+    // GL context and utility variables.
+    RenderParams        RParams;    
+
+	// Helpers
+    void initBuffersAndShaders();
+    void initShaders();
+    void initFullscreenQuad();
+    void destroy();
+	
+    void setViewport(const Recti& vp);
+
+    void renderDistortion(Texture* leftEyeTexture, Texture* rightEyeTexture);
+
+    void renderPrimitives(const ShaderFill* fill, Buffer* vertices, Buffer* indices,
+                          int offset, int count,
+						  PrimitiveType rprim, GLuint* vao, bool isDistortionMesh);
+
+	void createDrawQuad();
+    void renderLatencyQuad(unsigned char* latencyTesterDrawColor);
+    void renderLatencyPixel(unsigned char* latencyTesterPixelColor);
+	
+    void renderEndFrame();
+
+    Ptr<Texture>        pEyeTextures[2];
+
+	Ptr<Buffer>         DistortionMeshVBs[2];    // one per-eye
+	Ptr<Buffer>         DistortionMeshIBs[2];    // one per-eye
+	GLuint              DistortionMeshVAOs[2];   // one per-eye
+
+	Ptr<ShaderSet>      DistortionShader;
+
+    struct StandardUniformData
+    {
+        Matrix4f  Proj;
+        Matrix4f  View;
+    }                   StdUniforms;
+	
+	GLuint              LatencyVAO;
+    Ptr<Buffer>         LatencyTesterQuadVB;
+    Ptr<ShaderSet>      SimpleQuadShader;
+    Ptr<ShaderSet>      SimpleQuadGammaShader;
+
+    Ptr<Texture>             CurRenderTarget;
+    Array<Ptr<Texture> >     DepthBuffers;
+    GLuint                   CurrentFbo;
+
+	GLint SavedViewport[4];
+	GLfloat SavedClearColor[4];
+	GLint SavedDepthTest;
+	GLint SavedCullFace;
+	GLint SavedProgram;
+	GLint SavedActiveTexture;
+	GLint SavedBoundTexture;
+	GLint SavedVertexArray;
+    GLint SavedBoundFrameBuffer;
+};
+
+}}} // OVR::CAPI::GL
+
+#endif // OVR_CAPI_GL_DistortionRenderer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionShaders.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_DistortionShaders.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,383 @@
+/************************************************************************************
+ 
+ Filename    :   CAPI_GL_Shaders.h
+ Content     :   Distortion shader header for GL
+ Created     :   November 11, 2013
+ Authors     :   David Borel, Volga Aksoy
+ 
+ Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+ 
+ Use of this software is subject to the terms of the Oculus Inc license
+ agreement provided at the time of installation or download, or which
+ otherwise accompanies this software in either electronic or hard copy form.
+ 
+ ************************************************************************************/
+
+
+#ifndef OVR_CAPI_GL_Shaders_h
+#define OVR_CAPI_GL_Shaders_h
+
+
+#include "CAPI_GL_Util.h"
+
+namespace OVR { namespace CAPI { namespace GL {
+    
+    static const char glsl2Prefix[] =
+    "#version 110\n"
+    "#extension GL_ARB_shader_texture_lod : enable\n"
+    "#define _FRAGCOLOR_DECLARATION\n"
+    "#define _VS_IN attribute\n"
+    "#define _VS_OUT varying\n"
+    "#define _FS_IN varying\n"
+    "#define _TEXTURELOD texture2DLod\n"
+    "#define _TEXTURE texture2D\n"
+    "#define _FRAGCOLOR gl_FragColor\n";
+    
+    static const char glsl3Prefix[] =
+    "#version 150\n"
+    "#define _FRAGCOLOR_DECLARATION out vec4 FragColor;\n"
+    "#define _VS_IN in\n"
+    "#define _VS_OUT out\n"
+    "#define _FS_IN in\n"
+    "#define _TEXTURELOD textureLod\n"
+    "#define _TEXTURE texture\n"
+    "#define _FRAGCOLOR FragColor\n";
+    
+    static const char SimpleQuad_vs[] =
+    "uniform vec2 PositionOffset;\n"
+    "uniform vec2 Scale;\n"
+    
+    "_VS_IN vec3 Position;\n"
+    
+	"void main()\n"
+	"{\n"
+	"	gl_Position = vec4(Position.xy * Scale + PositionOffset, 0.5, 1.0);\n"
+	"}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuad_vs_refl[] =
+    {
+        { "PositionOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "Scale",          OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char SimpleQuad_fs[] =
+    "uniform vec4 Color;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+	"void main()\n"
+	"{\n"
+	"    _FRAGCOLOR = Color;\n"
+	"}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuad_fs_refl[] =
+    {
+        { "Color", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    static const char SimpleQuadGamma_fs[] =
+        "uniform vec4 Color;\n"
+
+        "_FRAGCOLOR_DECLARATION\n"
+
+        "void main()\n"
+        "{\n"
+        "    _FRAGCOLOR.rgb = pow(Color.rgb, vec3(2.2));\n"
+        "    _FRAGCOLOR.a = Color.a;\n"
+        "}\n";
+
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleQuadGamma_fs_refl[] =
+    {
+        { "Color", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    // This must be prefixed with glsl2Prefix or glsl3Prefix before being compiled.
+    static const char SimpleTexturedQuad_vs[] =
+        "uniform vec2 PositionOffset;\n"
+        "uniform vec2 Scale;\n"
+
+        "_VS_IN vec3 Position;\n"
+        "_VS_IN vec4 Color;\n"
+        "_VS_IN vec2 TexCoord;\n"
+  
+        "_VS_OUT vec4 oColor;\n"
+        "_VS_OUT vec2 oTexCoord;\n"
+
+        "void main()\n"
+        "{\n"
+	    "	gl_Position = vec4(Position.xy * Scale + PositionOffset, 0.5, 1.0);\n"
+        "   oColor = Color;\n"
+        "   oTexCoord = TexCoord;\n"
+        "}\n";
+
+    // The following declaration is copied from the generated D3D SimpleTexturedQuad_vs_refl.h file, with D3D_NS renamed to GL.
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleTexturedQuad_vs_refl[] =
+    {
+	    { "PositionOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	    { "Scale",          OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+
+
+    // This must be prefixed with glsl2Prefix or glsl3Prefix before being compiled.
+    static const char SimpleTexturedQuad_ps[] =
+        "uniform sampler2D Texture0;\n"
+    
+        "_FS_IN vec4 oColor;\n"
+        "_FS_IN vec2 oTexCoord;\n"
+    
+        "_FRAGCOLOR_DECLARATION\n"
+
+        "void main()\n"
+        "{\n"
+        "   _FRAGCOLOR = oColor * _TEXTURE(Texture0, oTexCoord);\n"
+        "}\n";
+
+    // The following is copied from the generated D3D SimpleTexturedQuad_ps_refl.h file, with D3D_NS renamed to GL.
+    const OVR::CAPI::GL::ShaderBase::Uniform SimpleTexturedQuad_ps_refl[] =
+    {
+	    { "Color", 	OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+    };
+
+    
+    static const char Distortion_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.5;\n"
+    "   gl_Position.w = 1.0;\n"
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   oTexCoord0 = TexCoord0 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oColor = Color;\n"              // Used for vignette fade.
+    "}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform Distortion_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char Distortion_fs[] =
+    "uniform sampler2D Texture0;\n"
+    
+    "_FS_IN vec4 oColor;\n"
+    "_FS_IN vec2 oTexCoord0;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+    "void main()\n"
+    "{\n"
+    "   _FRAGCOLOR = _TEXTURELOD(Texture0, oTexCoord0, 0.0);\n"
+    "   _FRAGCOLOR.a = 1.0;\n"
+    "}\n";
+    
+    
+    static const char DistortionTimewarp_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    "uniform mat4 EyeRotationStart;\n"
+    "uniform mat4 EyeRotationEnd;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.0;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.
+    "   vec3 TanEyeAngle = vec3 ( TexCoord0.x, TexCoord0.y, 1.0 );\n"
+    
+    // Accurate time warp lerp vs. faster
+#if 1
+    // Apply the two 3x3 timewarp rotations to these vectors.
+	"   vec3 TransformedStart = (EyeRotationStart * vec4(TanEyeAngle, 0)).xyz;\n"
+	"   vec3 TransformedEnd   = (EyeRotationEnd * vec4(TanEyeAngle, 0)).xyz;\n"
+    // And blend between them.
+    "   vec3 Transformed = mix ( TransformedStart, TransformedEnd, Color.a );\n"
+#else
+    "   mat4 EyeRotation = mix ( EyeRotationStart, EyeRotationEnd, Color.a );\n"
+    "   vec3 Transformed   = EyeRotation * TanEyeAngle;\n"
+#endif
+    
+    // Project them back onto the Z=1 plane of the rendered images.
+    "   float RecipZ = 1.0 / Transformed.z;\n"
+    "   vec2 Flattened = vec2 ( Transformed.x * RecipZ, Transformed.y * RecipZ );\n"
+    
+    // These are now still in TanEyeAngle space.
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   vec2 SrcCoord = Flattened * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord0 = SrcCoord;\n"
+    "   oColor = vec4(Color.r, Color.r, Color.r, Color.r);\n"              // Used for vignette fade.
+    "}\n";
+
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionTimewarp_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char DistortionChroma_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    "_VS_IN vec2 TexCoord1;\n"
+    "_VS_IN vec2 TexCoord2;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    "_VS_OUT vec2 oTexCoord1;\n"
+    "_VS_OUT vec2 oTexCoord2;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.5;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   oTexCoord0 = TexCoord0 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord1 = TexCoord1 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   oTexCoord2 = TexCoord2 * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    
+    "   oColor = Color;\n" // Used for vignette fade.
+    "}\n";
+    
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionChroma_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+    };
+    
+    static const char DistortionChroma_fs[] =
+    "uniform sampler2D Texture0;\n"
+    
+    "_FS_IN vec4 oColor;\n"
+    "_FS_IN vec2 oTexCoord0;\n"
+    "_FS_IN vec2 oTexCoord1;\n"
+    "_FS_IN vec2 oTexCoord2;\n"
+    
+    "_FRAGCOLOR_DECLARATION\n"
+    
+    "void main()\n"
+    "{\n"
+    "   float ResultR = _TEXTURELOD(Texture0, oTexCoord0, 0.0).r;\n"
+    "   float ResultG = _TEXTURELOD(Texture0, oTexCoord1, 0.0).g;\n"
+    "   float ResultB = _TEXTURELOD(Texture0, oTexCoord2, 0.0).b;\n"
+    
+    "   _FRAGCOLOR = vec4(ResultR * oColor.r, ResultG * oColor.g, ResultB * oColor.b, 1.0);\n"
+    "}\n";
+
+    
+    static const char DistortionTimewarpChroma_vs[] =
+    "uniform vec2 EyeToSourceUVScale;\n"
+    "uniform vec2 EyeToSourceUVOffset;\n"
+    "uniform mat4 EyeRotationStart;\n"
+    "uniform mat4 EyeRotationEnd;\n"
+    
+    "_VS_IN vec2 Position;\n"
+    "_VS_IN vec4 Color;\n"
+    "_VS_IN vec2 TexCoord0;\n"
+    "_VS_IN vec2 TexCoord1;\n"
+    "_VS_IN vec2 TexCoord2;\n"
+    
+    "_VS_OUT vec4 oColor;\n"
+    "_VS_OUT vec2 oTexCoord0;\n"
+    "_VS_OUT vec2 oTexCoord1;\n"
+    "_VS_OUT vec2 oTexCoord2;\n"
+    
+    "void main()\n"
+    "{\n"
+    "   gl_Position.x = Position.x;\n"
+    "   gl_Position.y = Position.y;\n"
+    "   gl_Position.z = 0.0;\n"
+    "   gl_Position.w = 1.0;\n"
+    
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.
+    "   vec3 TanEyeAngleR = vec3 ( TexCoord0.x, TexCoord0.y, 1.0 );\n"
+    "   vec3 TanEyeAngleG = vec3 ( TexCoord1.x, TexCoord1.y, 1.0 );\n"
+    "   vec3 TanEyeAngleB = vec3 ( TexCoord2.x, TexCoord2.y, 1.0 );\n"
+    
+    // Accurate time warp lerp vs. faster
+#if 1
+    // Apply the two 3x3 timewarp rotations to these vectors.
+	"   vec3 TransformedRStart = (EyeRotationStart * vec4(TanEyeAngleR, 0)).xyz;\n"
+	"   vec3 TransformedGStart = (EyeRotationStart * vec4(TanEyeAngleG, 0)).xyz;\n"
+	"   vec3 TransformedBStart = (EyeRotationStart * vec4(TanEyeAngleB, 0)).xyz;\n"
+	"   vec3 TransformedREnd   = (EyeRotationEnd * vec4(TanEyeAngleR, 0)).xyz;\n"
+	"   vec3 TransformedGEnd   = (EyeRotationEnd * vec4(TanEyeAngleG, 0)).xyz;\n"
+	"   vec3 TransformedBEnd   = (EyeRotationEnd * vec4(TanEyeAngleB, 0)).xyz;\n"
+    
+    // And blend between them.
+    "   vec3 TransformedR = mix ( TransformedRStart, TransformedREnd, Color.a );\n"
+    "   vec3 TransformedG = mix ( TransformedGStart, TransformedGEnd, Color.a );\n"
+    "   vec3 TransformedB = mix ( TransformedBStart, TransformedBEnd, Color.a );\n"
+#else
+    "   mat3 EyeRotation;\n"
+    "   EyeRotation[0] = mix ( EyeRotationStart[0], EyeRotationEnd[0], Color.a ).xyz;\n"
+    "   EyeRotation[1] = mix ( EyeRotationStart[1], EyeRotationEnd[1], Color.a ).xyz;\n"
+    "   EyeRotation[2] = mix ( EyeRotationStart[2], EyeRotationEnd[2], Color.a ).xyz;\n"
+    "   vec3 TransformedR   = EyeRotation * TanEyeAngleR;\n"
+    "   vec3 TransformedG   = EyeRotation * TanEyeAngleG;\n"
+    "   vec3 TransformedB   = EyeRotation * TanEyeAngleB;\n"
+#endif
+    
+    // Project them back onto the Z=1 plane of the rendered images.
+    "   float RecipZR = 1.0 / TransformedR.z;\n"
+    "   float RecipZG = 1.0 / TransformedG.z;\n"
+    "   float RecipZB = 1.0 / TransformedB.z;\n"
+    "   vec2 FlattenedR = vec2 ( TransformedR.x * RecipZR, TransformedR.y * RecipZR );\n"
+    "   vec2 FlattenedG = vec2 ( TransformedG.x * RecipZG, TransformedG.y * RecipZG );\n"
+    "   vec2 FlattenedB = vec2 ( TransformedB.x * RecipZB, TransformedB.y * RecipZB );\n"
+    
+    // These are now still in TanEyeAngle space.
+    // Scale them into the correct [0-1],[0-1] UV lookup space (depending on eye)
+    "   vec2 SrcCoordR = FlattenedR * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   vec2 SrcCoordG = FlattenedG * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    "   vec2 SrcCoordB = FlattenedB * EyeToSourceUVScale + EyeToSourceUVOffset;\n"
+    
+    "   oTexCoord0 = SrcCoordR;\n"
+    "   oTexCoord1 = SrcCoordG;\n"
+    "   oTexCoord2 = SrcCoordB;\n"
+    
+    "   oColor = vec4(Color.r, Color.r, Color.r, Color.r);\n"              // Used for vignette fade.
+    "}\n";
+    
+
+    const OVR::CAPI::GL::ShaderBase::Uniform DistortionTimewarpChroma_vs_refl[] =
+    {
+        { "EyeToSourceUVScale",  OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+        { "EyeToSourceUVOffset", OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+        { "EyeRotationStart",    OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+        { "EyeRotationEnd",      OVR::CAPI::GL::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+    };
+    
+}}} // OVR::CAPI::GL
+
+#endif // OVR_CAPI_GL_Shaders_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_HSWDisplay.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,77 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_HSWDisplay.h
+Content     :   Implements Health and Safety Warning system.
+Created     :   July 7, 2014
+Authors     :   Paul Pedriana
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CAPI_GL_HSWDisplay_h
+#define OVR_CAPI_GL_HSWDisplay_h
+
+
+#include "../CAPI_HSWDisplay.h"
+#include "CAPI_GL_Util.h"
+
+
+namespace OVR { namespace CAPI { namespace GL {
+
+    class HSWDisplay : public CAPI::HSWDisplay
+    {
+    public:
+        HSWDisplay(ovrRenderAPIType api, ovrHmd hmd, const HMDRenderState& renderState);
+
+        // Must be called before use. apiConfig is such that:
+        //   const ovrGLConfig* config = (const ovrGLConfig*)apiConfig; or
+        bool Initialize(const ovrRenderAPIConfig* apiConfig);
+        void Shutdown();
+        void DisplayInternal();
+        void DismissInternal();
+
+        // Draws the warning to the eye texture(s). This must be done at the end of a 
+        // frame but prior to executing the distortion rendering of the eye textures. 
+        void RenderInternal(ovrEyeType eye, const ovrTexture* eyeTexture);
+
+    protected:
+        void UnloadGraphics();
+        void LoadGraphics();
+
+        OVR::CAPI::GL::RenderParams        RenderParams;
+        GLVersionAndExtensions             GLVersionInfo;
+        GLuint                             FrameBuffer;         // This is a container for a texture, depth buffer, stencil buffer to be rendered to. To consider: Make a wrapper class, like the OculusWorldDemo RBuffer class. 
+        Ptr<OVR::CAPI::GL::Texture>        pTexture;
+        Ptr<OVR::CAPI::GL::ShaderSet>      pShaderSet;
+        Ptr<OVR::CAPI::GL::VertexShader>   pVertexShader;
+        Ptr<OVR::CAPI::GL::FragmentShader> pFragmentShader;
+        Ptr<OVR::CAPI::GL::Buffer>         pVB;
+        GLuint                             VAO;                 // Vertex Array Object.
+        bool                               VAOInitialized;      // True if the VAO was initialized with vertex buffer data.
+        Matrix4f                           OrthoProjection[2];  // Projection for 2D.
+
+    private:
+        OVR_NON_COPYABLE(HSWDisplay)
+    };
+
+}}} // namespace OVR::CAPI::GL
+
+
+#endif // OVR_CAPI_GL_HSWDisplay_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/GL/CAPI_GL_Util.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,629 @@
+/************************************************************************************
+
+Filename    :   CAPI_GL_Util.h
+Content     :   Utility header for OpenGL
+Created     :   March 27, 2014
+Authors     :   Andrew Reisse, David Borel
+
+Copyright   :   Copyright 2012 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef INC_OVR_CAPI_GL_Util_h
+#define INC_OVR_CAPI_GL_Util_h
+
+#include "../../OVR_CAPI.h"  
+#include "../../Kernel/OVR_Array.h"
+#include "../../Kernel/OVR_Math.h"
+#include "../../Kernel/OVR_RefCount.h"
+#include "../../Kernel/OVR_String.h"
+#include "../../Kernel/OVR_Types.h"
+#include "../../Kernel/OVR_Log.h"
+
+#if defined(OVR_OS_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#endif
+
+#if defined(OVR_OS_MAC)
+#define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
+#include <OpenGL/gl.h>
+#include <OpenGL/glext.h>
+#include <OpenGL/gl3.h>
+#include <OpenGL/gl3ext.h>
+#else
+#ifndef GL_GLEXT_PROTOTYPES
+#define GL_GLEXT_PROTOTYPES
+#endif
+#include <GL/gl.h>
+#include <GL/glext.h>
+#if defined(OVR_OS_WIN32)
+#include <GL/wglext.h>
+#elif defined(OVR_OS_LINUX)
+#include <GL/glx.h>
+#endif
+#endif
+
+namespace OVR { namespace CAPI { namespace GL {
+
+
+// GL extension Hooks for Non-Mac.
+#if !defined(OVR_OS_MAC)
+
+// Let Windows apps build without linking GL.
+#if defined(OVR_OS_WIN32)
+
+typedef GLenum (__stdcall *PFNGLGETERRORPROC) ();
+typedef void (__stdcall *PFNGLENABLEPROC) (GLenum);
+typedef void (__stdcall *PFNGLDISABLEPROC) (GLenum);
+typedef void (__stdcall *PFNGLGETFLOATVPROC) (GLenum, GLfloat*);
+typedef const GLubyte * (__stdcall *PFNGLGETSTRINGPROC) (GLenum);
+typedef const GLubyte * (__stdcall *PFNGLGETSTRINGIPROC) (GLenum, GLuint);
+typedef void(__stdcall *PFNGLGETINTEGERVPROC) (GLenum, GLint*);
+typedef void (__stdcall *PFNGLGETDOUBLEVPROC) (GLenum, GLdouble*);
+typedef PROC (__stdcall *PFNWGLGETPROCADDRESS) (LPCSTR);
+typedef void (__stdcall *PFNGLFLUSHPROC) ();
+typedef void (__stdcall *PFNGLFINISHPROC) ();
+typedef void (__stdcall *PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
+typedef void (__stdcall *PFNGLCLEARPROC) (GLbitfield);
+typedef void (__stdcall *PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+typedef void (__stdcall *PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
+typedef void (__stdcall *PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
+typedef void (__stdcall *PFNGLDELETETEXTURESPROC) (GLsizei n, GLuint *textures);
+typedef void (__stdcall *PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
+typedef void (__stdcall *PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLint format, GLenum type, const GLvoid *pixels);
+typedef void (__stdcall *PFNGLCLEARCOLORPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a);
+typedef void (__stdcall *PFNGLCLEARDEPTHPROC) (GLclampd depth);
+typedef void (__stdcall *PFNGLDEPTHMASKPROC) (GLboolean flag);
+typedef void (__stdcall *PFNGLDEPTHRANGEPROC) (GLclampd nearVal,  GLclampd farVal);
+typedef void (__stdcall *PFNGLDEPTHRANGEFPROC) (GLclampf nearVal,  GLclampf farVal);
+typedef void (__stdcall *PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
+typedef void (__stdcall *PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
+typedef void (__stdcall *PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
+typedef void (__stdcall *PFNGLFRONTFACEPROC) (GLenum mode);
+typedef GLint (__stdcall *PFNGLRENDERMODEPROC) (GLenum mode);
+typedef void (__stdcall *PFNGLPOLYGONMODEPROC) (GLenum face, GLenum mode);
+
+extern PFNWGLGETPROCADDRESS                     wglGetProcAddress;
+extern PFNWGLGETSWAPINTERVALEXTPROC             wglGetSwapIntervalEXT;
+extern PFNWGLSWAPINTERVALEXTPROC                wglSwapIntervalEXT;
+
+extern PFNGLGETERRORPROC                        glGetError;
+extern PFNGLENABLEPROC                          glEnable;
+extern PFNGLENABLEIPROC                         glEnablei;
+extern PFNGLDISABLEPROC                         glDisable;
+extern PFNGLDISABLEIPROC                        glDisablei;
+extern PFNGLCOLORMASKPROC                       glColorMask;
+extern PFNGLCOLORMASKIPROC                      glColorMaski;
+extern PFNGLGETFLOATVPROC                       glGetFloatv;
+extern PFNGLGETSTRINGPROC                       glGetString;
+extern PFNGLGETINTEGERVPROC                     glGetIntegerv;
+extern PFNGLGETINTEGERI_VPROC                   glGetIntegeri_v;
+extern PFNGLGETDOUBLEVPROC                      glGetDoublev;
+extern PFNGLCLEARPROC                           glClear;
+extern PFNGLCLEARCOLORPROC                      glClearColor;
+extern PFNGLCLEARDEPTHPROC                      glClearDepth;
+extern PFNGLDEPTHMASKPROC                       glDepthMask;
+extern PFNGLDEPTHRANGEPROC                      glDepthRange;
+extern PFNGLDEPTHRANGEFPROC                     glDepthRangef;
+extern PFNGLVIEWPORTPROC                        glViewport;
+extern PFNGLDRAWARRAYSPROC                      glDrawArrays;
+extern PFNGLDRAWELEMENTSPROC                    glDrawElements;
+extern PFNGLGENTEXTURESPROC                     glGenTextures;
+extern PFNGLDELETETEXTURESPROC                  glDeleteTextures;
+extern PFNGLBINDTEXTUREPROC                     glBindTexture;
+extern PFNGLTEXIMAGE2DPROC                      glTexImage2D;
+extern PFNGLTEXPARAMETERIPROC                   glTexParameteri;
+extern PFNGLFLUSHPROC                           glFlush;
+extern PFNGLFINISHPROC                          glFinish;
+extern PFNGLBLENDFUNCPROC                       glBlendFunc;
+extern PFNGLFRONTFACEPROC                       glFrontFace;
+extern PFNGLRENDERMODEPROC                      glRenderMode;
+extern PFNGLPOLYGONMODEPROC                     glPolygonMode;
+
+#elif defined(OVR_OS_LINUX)
+
+extern PFNGLXSWAPINTERVALEXTPROC                glXSwapIntervalEXT;
+
+#endif // defined(OVR_OS_WIN32)
+
+extern PFNGLGETSTRINGIPROC                      glGetStringi;
+extern PFNGLGENFRAMEBUFFERSPROC                 glGenFramebuffers;
+extern PFNGLDELETEFRAMEBUFFERSPROC              glDeleteFramebuffers;
+extern PFNGLDELETESHADERPROC                    glDeleteShader;
+extern PFNGLCHECKFRAMEBUFFERSTATUSPROC          glCheckFramebufferStatus;
+extern PFNGLFRAMEBUFFERRENDERBUFFERPROC         glFramebufferRenderbuffer;
+extern PFNGLFRAMEBUFFERTEXTURE2DPROC            glFramebufferTexture2D;
+extern PFNGLBINDFRAMEBUFFERPROC                 glBindFramebuffer;
+extern PFNGLACTIVETEXTUREPROC                   glActiveTexture;
+extern PFNGLGETVERTEXATTRIBIVPROC               glGetVertexAttribiv;
+extern PFNGLGETVERTEXATTRIBPOINTERVPROC         glGetVertexAttribPointerv;
+extern PFNGLDISABLEVERTEXATTRIBARRAYPROC        glDisableVertexAttribArray;
+extern PFNGLVERTEXATTRIBPOINTERPROC             glVertexAttribPointer;
+extern PFNGLENABLEVERTEXATTRIBARRAYPROC         glEnableVertexAttribArray;
+extern PFNGLBINDBUFFERPROC                      glBindBuffer;
+extern PFNGLUNIFORMMATRIX4FVPROC                glUniformMatrix4fv;
+extern PFNGLDELETEBUFFERSPROC                   glDeleteBuffers;
+extern PFNGLBUFFERDATAPROC                      glBufferData;
+extern PFNGLGENBUFFERSPROC                      glGenBuffers;
+extern PFNGLMAPBUFFERPROC                       glMapBuffer;
+extern PFNGLUNMAPBUFFERPROC                     glUnmapBuffer;
+extern PFNGLGETSHADERINFOLOGPROC                glGetShaderInfoLog;
+extern PFNGLGETSHADERIVPROC                     glGetShaderiv;
+extern PFNGLCOMPILESHADERPROC                   glCompileShader;
+extern PFNGLSHADERSOURCEPROC                    glShaderSource;
+extern PFNGLCREATESHADERPROC                    glCreateShader;
+extern PFNGLCREATEPROGRAMPROC                   glCreateProgram;
+extern PFNGLATTACHSHADERPROC                    glAttachShader;
+extern PFNGLDETACHSHADERPROC                    glDetachShader;
+extern PFNGLDELETEPROGRAMPROC                   glDeleteProgram;
+extern PFNGLUNIFORM1IPROC                       glUniform1i;
+extern PFNGLGETUNIFORMLOCATIONPROC              glGetUniformLocation;
+extern PFNGLGETACTIVEUNIFORMPROC                glGetActiveUniform;
+extern PFNGLUSEPROGRAMPROC                      glUseProgram;
+extern PFNGLGETPROGRAMINFOLOGPROC               glGetProgramInfoLog;
+extern PFNGLGETPROGRAMIVPROC                    glGetProgramiv;
+extern PFNGLLINKPROGRAMPROC                     glLinkProgram;
+extern PFNGLBINDATTRIBLOCATIONPROC              glBindAttribLocation;
+extern PFNGLGETATTRIBLOCATIONPROC               glGetAttribLocation;
+extern PFNGLUNIFORM4FVPROC                      glUniform4fv;
+extern PFNGLUNIFORM3FVPROC                      glUniform3fv;
+extern PFNGLUNIFORM2FVPROC                      glUniform2fv;
+extern PFNGLUNIFORM1FVPROC                      glUniform1fv;
+extern PFNGLGENVERTEXARRAYSPROC                 glGenVertexArrays;
+extern PFNGLDELETEVERTEXARRAYSPROC              glDeleteVertexArrays;
+extern PFNGLBINDVERTEXARRAYPROC                 glBindVertexArray;
+extern PFNGLBLENDFUNCSEPARATEPROC               glBlendFuncSeparate;
+
+extern void InitGLExtensions();
+
+#endif // !defined(OVR_OS_MAC)
+
+
+// Rendering primitive type used to render Model.
+enum PrimitiveType
+{
+    Prim_Triangles,
+    Prim_Lines,
+    Prim_TriangleStrip,
+    Prim_Unknown,
+    Prim_Count
+};
+
+// Types of shaders that can be stored together in a ShaderSet.
+enum ShaderStage
+{
+    Shader_Vertex   = 0,
+    Shader_Fragment = 2,
+    Shader_Pixel    = 2,
+    Shader_Count    = 3,
+};
+
+enum MapFlags
+{
+    Map_Discard        = 1,
+    Map_Read           = 2, // do not use
+    Map_Unsynchronized = 4, // like D3D11_MAP_NO_OVERWRITE
+};
+
+
+// Buffer types used for uploading geometry & constants.
+enum BufferUsage
+{
+    Buffer_Unknown  = 0,
+    Buffer_Vertex   = 1,
+    Buffer_Index    = 2,
+    Buffer_Uniform  = 4,
+    Buffer_TypeMask = 0xff,
+    Buffer_ReadOnly = 0x100, // Buffer must be created with Data().
+};
+
+enum TextureFormat
+{
+    Texture_RGBA            = 0x0100,
+    Texture_Depth           = 0x8000,
+    Texture_TypeMask        = 0xff00,
+    Texture_SamplesMask     = 0x00ff,
+    Texture_RenderTarget    = 0x10000,
+    Texture_GenMipmaps      = 0x20000,
+};
+
+// Texture sampling modes.
+enum SampleMode
+{
+    Sample_Linear       = 0,
+    Sample_Nearest      = 1,
+    Sample_Anisotropic  = 2,
+    Sample_FilterMask   = 3,
+
+    Sample_Repeat       = 0,
+    Sample_Clamp        = 4,
+    Sample_ClampBorder  = 8, // If unsupported Clamp is used instead.
+    Sample_AddressMask  =12,
+
+    Sample_Count        =13,
+};
+
+
+// Rendering parameters/pointers describing GL rendering setup.
+struct RenderParams
+{
+#if defined(OVR_OS_WIN32)
+    HWND   Window;
+    HDC    DC;
+#elif defined(OVR_OS_LINUX)
+    _XDisplay*  Disp;
+    Window      Win;
+#endif
+
+    ovrSizei  RTSize;
+    int    Multisample;
+};
+
+
+class Buffer : public RefCountBase<Buffer>
+{
+public:
+    RenderParams* pParams;
+    size_t        Size;
+    GLenum        Use;
+    GLuint        GLBuffer;
+
+public:
+    Buffer(RenderParams* r);
+    ~Buffer();
+
+    GLuint         GetBuffer() { return GLBuffer; }
+
+    virtual size_t GetSize() { return Size; }
+    virtual void*  Map(size_t start, size_t size, int flags = 0);
+    virtual bool   Unmap(void *m);
+    virtual bool   Data(int use, const void* buffer, size_t size);
+};
+
+class Texture : public RefCountBase<Texture>
+{
+	bool IsUserAllocated;
+
+public:
+    RenderParams* pParams;
+    GLuint        TexId;
+    int           Width, Height;
+
+    Texture(RenderParams* rp, int w, int h);
+    ~Texture();
+
+    virtual int GetWidth() const { return Width; }
+    virtual int GetHeight() const { return Height; }
+
+    virtual void SetSampleMode(int sm);
+
+    // Updates texture to point to specified resources
+    //  - used for slave rendering.
+    void UpdatePlaceholderTexture(GLuint texId,
+                                  const Sizei& textureSize);
+
+    virtual void Set(int slot, ShaderStage stage = Shader_Fragment) const;
+};
+
+// Base class for vertex and pixel shaders. Stored in ShaderSet.
+class Shader : public RefCountBase<Shader>
+{
+    friend class ShaderSet;
+
+protected:
+    ShaderStage Stage;
+
+public:
+    Shader(ShaderStage s) : Stage(s) {}
+    virtual ~Shader() {}
+
+    ShaderStage GetStage() const { return Stage; }
+
+    virtual void Set(PrimitiveType) const { }
+    virtual void SetUniformBuffer(class Buffer* buffers, int i = 0) { OVR_UNUSED2(buffers, i); }
+
+protected:
+    virtual bool SetUniform(const char* name, int n, const float* v) { OVR_UNUSED3(name, n, v); return false; }
+    virtual bool SetUniformBool(const char* name, int n, const bool* v) { OVR_UNUSED3(name, n, v); return false; }
+};
+
+
+
+// A group of shaders, one per stage.
+// A ShaderSet is applied for rendering with a given fill.
+class ShaderSet : public RefCountBase<ShaderSet>
+{
+protected:
+    Ptr<Shader> Shaders[Shader_Count];
+
+    struct Uniform
+    {
+        String Name;
+        int    Location, Size;
+        int    Type; // currently number of floats in vector
+    };
+    Array<Uniform> UniformInfo;
+	
+public:
+	GLuint    Prog;
+    GLint     ProjLoc, ViewLoc;
+    GLint     TexLoc[8];
+    bool      UsesLighting;
+    int       LightingVer;
+
+    ShaderSet();
+    ~ShaderSet();
+
+    virtual void SetShader(Shader *s);
+    virtual void UnsetShader(int stage);
+    Shader* GetShader(int stage) { return Shaders[stage]; }
+
+    virtual void Set(PrimitiveType prim) const
+    {
+		glUseProgram(Prog);
+
+        for (int i = 0; i < Shader_Count; i++)
+            if (Shaders[i])
+                Shaders[i]->Set(prim);
+    }
+
+    // Set a uniform (other than the standard matrices). It is undefined whether the
+    // uniforms from one shader occupy the same space as those in other shaders
+    // (unless a buffer is used, then each buffer is independent).     
+    virtual bool SetUniform(const char* name, int n, const float* v);
+    bool SetUniform1f(const char* name, float x)
+    {
+        const float v[] = {x};
+        return SetUniform(name, 1, v);
+    }
+    bool SetUniform2f(const char* name, float x, float y)
+    {
+        const float v[] = {x,y};
+        return SetUniform(name, 2, v);
+    }
+    bool SetUniform3f(const char* name, float x, float y, float z)
+    {
+        const float v[] = {x,y,z};
+        return SetUniform(name, 3, v);
+    }
+    bool SetUniform4f(const char* name, float x, float y, float z, float w = 1)
+    {
+        const float v[] = {x,y,z,w};
+        return SetUniform(name, 4, v);
+    }
+
+    bool SetUniformv(const char* name, const Vector3f& v)
+    {
+        const float a[] = {v.x,v.y,v.z,1};
+        return SetUniform(name, 4, a);
+    }
+ 
+    virtual bool SetUniform4x4f(const char* name, const Matrix4f& m)
+    {
+        Matrix4f mt = m.Transposed();
+        return SetUniform(name, 16, &mt.M[0][0]);
+    }
+
+protected:
+	GLint GetGLShader(Shader* s);
+    bool Link();
+};
+
+
+// Fill combines a ShaderSet (vertex, pixel) with textures, if any.
+// Every model has a fill.
+class ShaderFill : public RefCountBase<ShaderFill>
+{
+    Ptr<ShaderSet>     Shaders;
+    Ptr<class Texture> Textures[8];
+    void*              InputLayout; // HACK this should be abstracted
+
+public:
+    ShaderFill(ShaderSet* sh) : Shaders(sh) { InputLayout = NULL; }
+    ShaderFill(ShaderSet& sh) : Shaders(sh) { InputLayout = NULL; }    
+
+    ShaderSet*  GetShaders() const      { return Shaders; }
+    void*       GetInputLayout() const  { return InputLayout; }
+
+    virtual void Set(PrimitiveType prim = Prim_Unknown) const {
+		Shaders->Set(prim);
+		for(int i = 0; i < 8; i++)
+		{
+			if(Textures[i])
+			{
+				Textures[i]->Set(i);
+			}
+		}
+	}
+
+    virtual void SetTexture(int i, class Texture* tex) { if (i < 8) Textures[i] = tex; }
+};
+
+    
+struct DisplayId
+{
+    // Windows
+    String MonitorName; // Monitor name for fullscreen mode
+    
+    // MacOS
+    long   CgDisplayId; // CGDirectDisplayID
+    
+    DisplayId() : CgDisplayId(0) {}
+    DisplayId(long id) : CgDisplayId(id) {}
+    DisplayId(String m, long id=0) : MonitorName(m), CgDisplayId(id) {}
+    
+    operator bool () const
+    {
+        return MonitorName.GetLength() || CgDisplayId;
+    }
+    
+    bool operator== (const DisplayId& b) const
+    {
+        return CgDisplayId == b.CgDisplayId &&
+            (strstr(MonitorName.ToCStr(), b.MonitorName.ToCStr()) ||
+             strstr(b.MonitorName.ToCStr(), MonitorName.ToCStr()));
+    }
+};
+
+
+class ShaderBase : public Shader
+{
+public:    
+    RenderParams*   pParams;
+    unsigned char*  UniformData;
+    int             UniformsSize;
+
+	enum VarType
+	{
+		VARTYPE_FLOAT,
+		VARTYPE_INT,
+		VARTYPE_BOOL,
+	};
+
+	struct Uniform
+	{
+		const char* Name;
+		VarType Type;
+		int     Offset, Size;
+	};
+    const Uniform* UniformRefl;
+    size_t UniformReflSize;
+
+	ShaderBase(RenderParams* rp, ShaderStage stage) : Shader(stage), pParams(rp), UniformData(0), UniformsSize(0) {}
+	~ShaderBase()
+	{
+		if (UniformData)    
+			OVR_FREE(UniformData);
+	}
+
+    void InitUniforms(const Uniform* refl, size_t reflSize);
+	bool SetUniform(const char* name, int n, const float* v);
+	bool SetUniformBool(const char* name, int n, const bool* v);
+};
+
+
+template<ShaderStage SStage, GLenum SType>
+class ShaderImpl : public ShaderBase
+{
+    friend class ShaderSet;
+
+public:
+    ShaderImpl(RenderParams* rp, void* s, size_t size, const Uniform* refl, size_t reflSize)
+		: ShaderBase(rp, SStage)
+		, GLShader(0)
+    {
+		bool success;
+        OVR_UNUSED(size);
+        success = Compile((const char*) s);
+        OVR_ASSERT(success);
+        OVR_UNUSED(success);
+		InitUniforms(refl, reflSize);
+    }
+    ~ShaderImpl()
+    {      
+		if (GLShader)
+		{
+			glDeleteShader(GLShader);
+			GLShader = 0;
+		}
+    }
+    bool Compile(const char* src)
+	{
+		if (!GLShader)
+			GLShader = glCreateShader(GLStage());
+
+		glShaderSource(GLShader, 1, &src, 0);
+		glCompileShader(GLShader);
+		GLint r;
+		glGetShaderiv(GLShader, GL_COMPILE_STATUS, &r);
+		if (!r)
+		{
+			GLchar msg[1024];
+			glGetShaderInfoLog(GLShader, sizeof(msg), 0, msg);
+			if (msg[0])
+				OVR_DEBUG_LOG(("Compiling shader\n%s\nfailed: %s\n", src, msg));
+
+			return 0;
+		}
+		return 1;
+	}
+	
+    GLenum GLStage() const
+    {
+		return SType;
+	}
+
+private:
+	GLuint GLShader;
+};
+
+typedef ShaderImpl<Shader_Vertex,  GL_VERTEX_SHADER> VertexShader;
+typedef ShaderImpl<Shader_Fragment, GL_FRAGMENT_SHADER> FragmentShader;
+
+
+//// GLVersionAndExtensions
+//
+// FIXME: CODE DUPLICATION WARNING
+// Right now we have this same code in CommonSrc and in CAPI::GL.
+// At some point we need to consolidate these, in Kernel or Util.
+// Be sure to update both locations for now!
+//
+// This class needs to be initialized at runtime with GetGLVersionAndExtensions,
+// after an OpenGL context has been created. It must be re-initialized any time
+// a new OpenGL context is created, as the new context may differ in version or
+// supported functionality.
+struct GLVersionAndExtensions
+{
+    // Version information
+    int         MajorVersion;        // Best guess at major version
+    int         MinorVersion;        // Best guess at minor version
+    int         WholeVersion;        // Equals ((MajorVersion * 100) + MinorVersion). Example usage: if(glv.WholeVersion >= 302) // If OpenGL v3.02+ ...
+    bool        IsGLES;              // Open GL ES?
+    bool        IsCoreProfile;       // Is the current OpenGL context a core profile context? Its trueness may be a false positive but will never be a false negative.
+
+    // Extension information
+    bool        SupportsVAO;         // Supports Vertex Array Objects?
+    bool        SupportsDrawBuffers; // Supports Draw Buffers?
+    const char* Extensions;          // Other extensions string (will not be null)
+
+    GLVersionAndExtensions()
+      : MajorVersion(0),
+        MinorVersion(0),
+        WholeVersion(0),
+        IsGLES(false),
+        IsCoreProfile(false),
+        SupportsDrawBuffers(false),
+        SupportsVAO(false),
+        Extensions("")
+    {
+    }
+    
+    bool HasGLExtension(const char* searchKey) const;
+    
+protected:
+    friend void GetGLVersionAndExtensions(GLVersionAndExtensions& versionInfo);
+    
+    void ParseGLVersion();
+    void ParseGLExtensions();
+};
+
+void GetGLVersionAndExtensions(GLVersionAndExtensions& versionInfo);
+
+
+}}} // namespace OVR::CAPI::GL
+
+
+#endif // INC_OVR_CAPI_GL_Util_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,66 @@
+#ifndef DISTORTION_PS_H
+#define DISTORTION_PS_H
+
+static const unsigned char Distortion_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x43, 0xb8, 0xfc, 0x1d, 0x5b, 0xd5, 0xae, 0xc2, 
+    0x67, 0xa3, 0x69, 0xc1, 0x8c, 0xb8, 0xbe, 0x9d, 0x01, 0x00, 0x00, 0x00, 
+    0xb8, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0xdc, 0x00, 0x00, 0x00, 0x50, 0x01, 0x00, 0x00, 0x84, 0x01, 0x00, 0x00, 
+    0x3c, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xa0, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x6b, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x63, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x4c, 0x69, 0x6e, 0x65, 
+    0x61, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 
+    0x33, 0x2e, 0x39, 0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 
+    0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 
+    0x74, 0x00, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0xb0, 0x00, 0x00, 0x00, 
+    0x40, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x03, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04, 
+    0x00, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 
+    0x62, 0x10, 0x00, 0x03, 0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x62, 0x10, 0x00, 0x03, 0x62, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x68, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x15, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x72, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x82, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x80, 0x3f, 0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 
+    0x74, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.psh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps.psh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,10 @@
+Texture2D    Texture : register(t0);
+SamplerState Linear  : register(s0);
+
+float4 main(in float4 oPosition  : SV_Position,
+            in float1 oColor     : COLOR,
+            in float2 oTexCoord0 : TEXCOORD0) : SV_Target
+{
+	float3 Result = Texture.SampleLevel(Linear, oTexCoord0, 0.0).rgb;
+	return float4(Result * oColor, 1.0 );
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_ps_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1 @@
+// No data available for shader reflection Distortion_ps_refl
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,82 @@
+#ifndef DISTORTION_VS_H
+#define DISTORTION_VS_H
+
+static const unsigned char Distortion_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x77, 0x9d, 0x99, 0x8c, 0xc0, 0xf3, 0x3f, 0xec, 
+    0xf9, 0x83, 0x0b, 0xe5, 0x85, 0x2b, 0x86, 0xf6, 0x01, 0x00, 0x00, 0x00, 
+    0x7c, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 
+    0x00, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xb4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 0x33, 0x2e, 0x39, 
+    0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 0x00, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x01, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0xdc, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x37, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x11, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,18 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;   
+    oTexCoord0  = EyeToSourceUVScale * TexCoord0 + EyeToSourceUVOffset;
+    oColor      = Color.r;      // Used for vignette fade.
+}
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/Distortion_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,9 @@
+#ifndef Distortion_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform Distortion_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,252 @@
+#ifndef DISTORTIONCHROMA_PS_H
+#define DISTORTIONCHROMA_PS_H
+
+static const unsigned char DistortionChroma_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x8b, 0xb5, 0x62, 0xd4, 0xa4, 0xf3, 0xee, 0xa6, 
+    0x11, 0x95, 0x03, 0x4f, 0xaa, 0x21, 0xa6, 0x42, 0x01, 0x00, 0x00, 0x00, 
+    0x74, 0x0b, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0xbc, 0x01, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0xac, 0x02, 0x00, 0x00, 
+    0xf8, 0x0a, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x80, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x4c, 0x01, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0xa3, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0d, 0x00, 0x00, 0x00, 0xb7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 
+    0x72, 0x65, 0x00, 0x4c, 0x61, 0x73, 0x74, 0x54, 0x65, 0x78, 0x74, 0x75, 
+    0x72, 0x65, 0x00, 0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 
+    0xb7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x28, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x69, 0x76, 0x65, 0x53, 0x63, 0x61, 
+    0x6c, 0x65, 0x73, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x61, 0x44, 0x65, 
+    0x72, 0x69, 0x76, 0x61, 0x74, 0x69, 0x76, 0x65, 0x4d, 0x75, 0x6c, 0x74, 
+    0x00, 0xab, 0xab, 0xab, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 0x33, 0x2e, 0x39, 
+    0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 0x00, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x9c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0f, 0x03, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x01, 0x01, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x06, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x0c, 0x0c, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 
+    0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 
+    0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 0x4f, 0x53, 0x47, 0x4e, 
+    0x44, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0xab, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x44, 0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x11, 0x02, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x03, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x04, 
+    0x00, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 
+    0x58, 0x18, 0x00, 0x04, 0x00, 0x70, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x55, 0x55, 0x00, 0x00, 0x64, 0x20, 0x00, 0x04, 0x32, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0x62, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 
+    0xc2, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 
+    0xf2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 
+    0x08, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x96, 0x15, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0xe6, 0x1a, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x0b, 0x62, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xa6, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1f, 0x00, 0x04, 0x03, 0x1a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0b, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x0a, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x05, 
+    0x22, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1a, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x08, 0x32, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0xa6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
+    0xa2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x56, 0x19, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xd6, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
+    0xf2, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x86, 0x08, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x46, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0xe6, 0x0a, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x22, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 
+    0xd2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x42, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
+    0xf2, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x86, 0x06, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x96, 0x19, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x46, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
+    0xf2, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0x86, 0x08, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x46, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0xe6, 0x0a, 0x10, 0x00, 
+    0x06, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00, 
+    0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x22, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0xe6, 0x0a, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf2, 0x00, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x66, 0x06, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x46, 0x1e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0xe6, 0x0a, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x22, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x07, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 0x82, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xa2, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xa6, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x56, 0x19, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 
+    0xf2, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0xd6, 0x05, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0c, 0xf2, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x66, 0x06, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0xbf, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0xbf, 0x46, 0x1e, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 
+    0x07, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x48, 0x00, 0x00, 0x0b, 0xf2, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0xe6, 0x0a, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x12, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x22, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x12, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x22, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 0xd2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x06, 0x09, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 0xd2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x06, 0x09, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 0xd2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x06, 0x09, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x09, 0xd2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x06, 0x09, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x0a, 0xd2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x02, 0x40, 0x00, 0x00, 0xcd, 0xcc, 0x4c, 0x3e, 0x00, 0x00, 0x00, 0x00, 
+    0xcd, 0xcc, 0x4c, 0x3e, 0xcd, 0xcc, 0x4c, 0x3e, 0x4b, 0x00, 0x00, 0x05, 
+    0x72, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x86, 0x03, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x01, 0x36, 0x00, 0x00, 0x05, 
+    0x12, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x22, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x15, 0x00, 0x00, 0x01, 0x38, 0x00, 0x00, 0x07, 0xb2, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x08, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x06, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x04, 0x03, 
+    0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x05, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2d, 0x00, 0x00, 0x07, 0xf2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x07, 0x72, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x0b, 
+    0x72, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x06, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x56, 0x85, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x72, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x06, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x20, 0x00, 0x09, 
+    0x72, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x46, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x01, 
+    0x36, 0x00, 0x00, 0x05, 0x72, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x01, 
+    0x36, 0x00, 0x00, 0x05, 0x72, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x82, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x72, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x02, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x82, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.psh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps.psh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,77 @@
+Texture2D Texture : register(t0);
+Texture2D LastTexture : register(t1);
+SamplerState Linear : register(s0);
+
+float2 OverdriveScales;
+float AaDerivativeMult;
+
+// Fast approximate gamma to linear conversion when averaging colors
+float3 ToLinear(float3 inColor) { return inColor * inColor; }
+float3 ToGamma(float3 inColor)	{ return sqrt(inColor); }
+
+float3 ApplyHqAa(float3 inColor, float2 oTexCoord0, float2 oTexCoord1, float2 oTexCoord2)
+{
+	float2 uvDeriv = float2(ddx(oTexCoord1.x), ddy(oTexCoord1.y)) * AaDerivativeMult;
+		
+	float ResultR = Texture.SampleLevel(Linear, oTexCoord0 + float2(-uvDeriv.x, 0), 0.0).r;
+	float ResultG = Texture.SampleLevel(Linear, oTexCoord1 + float2(-uvDeriv.x, 0), 0.0).g;
+	float ResultB = Texture.SampleLevel(Linear, oTexCoord2 + float2(-uvDeriv.x, 0), 0.0).b;
+	float3 newColor0 = ToLinear(float3(ResultR, ResultG, ResultB));
+	
+	ResultR = Texture.SampleLevel(Linear, oTexCoord0 + float2(uvDeriv.x, 0), 0.0).r;
+	ResultG = Texture.SampleLevel(Linear, oTexCoord1 + float2(uvDeriv.x, 0), 0.0).g;
+	ResultB = Texture.SampleLevel(Linear, oTexCoord2 + float2(uvDeriv.x, 0), 0.0).b;
+	float3 newColor1 = ToLinear(float3(ResultR, ResultG, ResultB));
+
+	ResultR = Texture.SampleLevel(Linear, oTexCoord0 + float2(0, uvDeriv.y), 0.0).r;
+	ResultG = Texture.SampleLevel(Linear, oTexCoord1 + float2(0, uvDeriv.y), 0.0).g;
+	ResultB = Texture.SampleLevel(Linear, oTexCoord2 + float2(0, uvDeriv.y), 0.0).b;
+	float3 newColor2 = ToLinear(float3(ResultR, ResultG, ResultB));
+
+	ResultR = Texture.SampleLevel(Linear, oTexCoord0 + float2(0, -uvDeriv.y), 0.0).r;
+	ResultG = Texture.SampleLevel(Linear, oTexCoord1 + float2(0, -uvDeriv.y), 0.0).g;
+	ResultB = Texture.SampleLevel(Linear, oTexCoord2 + float2(0, -uvDeriv.y), 0.0).b;
+	float3 newColor3 = ToLinear(float3(ResultR, ResultG, ResultB));
+
+	float3 outColor = ToLinear(inColor) + newColor0 + newColor1 + newColor2 + newColor3;
+	outColor = ToGamma(outColor * 0.2);
+	return outColor;
+}
+
+void   main(in float4 oPosition  : SV_Position,
+            in float  oColor     : COLOR,
+            in float2 oTexCoord0 : TEXCOORD0,
+            in float2 oTexCoord1 : TEXCOORD1,
+            in float2 oTexCoord2 : TEXCOORD2,
+			out float4 outColor0 : SV_Target0,
+			out float4 outColor1 : SV_Target1)
+{
+	float ResultR = Texture.SampleLevel(Linear, oTexCoord0, 0.0).r;
+	float ResultG = Texture.SampleLevel(Linear, oTexCoord1, 0.0).g;
+	float ResultB = Texture.SampleLevel(Linear, oTexCoord2, 0.0).b;
+	float3 newColor = float3(ResultR, ResultG, ResultB);
+
+	// High quality anti-aliasing in distortion
+	if(AaDerivativeMult > 0)
+	{
+		newColor = ApplyHqAa(newColor, oTexCoord0, oTexCoord1, oTexCoord2);
+	}
+
+	newColor = newColor * oColor.xxx;
+	outColor0 = float4(newColor, 1.0);
+	outColor1 = outColor0;
+	
+	// pixel luminance overdrive
+	if(OverdriveScales.x > 0)
+	{
+		float3 oldColor = LastTexture.Load(int3(oPosition.xy, 0)).rgb;
+		
+		float3 adjustedScales;
+		adjustedScales.x = newColor.x > oldColor.x ? OverdriveScales.x : OverdriveScales.y;
+		adjustedScales.y = newColor.y > oldColor.y ? OverdriveScales.x : OverdriveScales.y;
+		adjustedScales.z = newColor.z > oldColor.z ? OverdriveScales.x : OverdriveScales.y;
+		
+		float3 overdriveColor = saturate(newColor + (newColor - oldColor) * adjustedScales);
+		outColor1 = float4(overdriveColor, 1.0);
+	}
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_ps_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,9 @@
+#ifndef DistortionChroma_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionChroma_ps_refl[] =
+{
+	{ "OverdriveScales", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "AaDerivativeMult", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 4 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,101 @@
+#ifndef DISTORTIONCHROMA_VS_H
+#define DISTORTIONCHROMA_VS_H
+
+static const unsigned char DistortionChroma_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x0e, 0xfe, 0xef, 0x9e, 0xe4, 0xce, 0x0b, 0xf4, 
+    0xdc, 0xc4, 0xfc, 0x1d, 0x3a, 0xf6, 0x54, 0x11, 0x01, 0x00, 0x00, 0x00, 
+    0x64, 0x04, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xd8, 0x01, 0x00, 0x00, 0x7c, 0x02, 0x00, 0x00, 
+    0xe8, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xb4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 0x33, 0x2e, 0x39, 
+    0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 0x00, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x98, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x01, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x9c, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x64, 0x01, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x59, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x12, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xc2, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x11, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 0xc2, 0x20, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x06, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x14, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xa6, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,30 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          in float2 TexCoord1   : TEXCOORD1,
+          in float2 TexCoord2   : TEXCOORD2,
+          out float4 oPosition  : SV_Position,          
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0,
+          out float2 oTexCoord1 : TEXCOORD1,
+          out float2 oTexCoord2 : TEXCOORD2)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+
+    // Scale them into  UV lookup space
+    float2 tc0scaled = EyeToSourceUVScale * TexCoord0 + EyeToSourceUVOffset;
+    float2 tc1scaled = EyeToSourceUVScale * TexCoord1 + EyeToSourceUVOffset;
+    float2 tc2scaled = EyeToSourceUVScale * TexCoord2 + EyeToSourceUVOffset;
+
+    oTexCoord0  = tc0scaled;        // R sample.
+    oTexCoord1  = tc1scaled;        // G sample.
+    oTexCoord2  = tc2scaled;        // B sample.
+    oColor      = Color.r;          // Used for vignette fade.
+}
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionChroma_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,9 @@
+#ifndef DistortionChroma_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionChroma_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,168 @@
+#ifndef DISTORTIONTIMEWARP_VS_H
+#define DISTORTIONTIMEWARP_VS_H
+
+static const unsigned char DistortionTimewarp_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x91, 0xed, 0x41, 0x60, 0xb0, 0x3e, 0xf0, 0x08, 
+    0x7a, 0xeb, 0x1b, 0xe6, 0x05, 0x4c, 0x48, 0xd2, 0x01, 0x00, 0x00, 0x00, 
+    0x80, 0x07, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x9c, 0x01, 0x00, 0x00, 0x0c, 0x02, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 
+    0x04, 0x07, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x60, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x2b, 0x01, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1c, 0x01, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 
+    0x00, 0xab, 0xab, 0xab, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 
+    0x33, 0x2e, 0x39, 0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 
+    0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x09, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 
+    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 
+    0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 
+    0x6c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 
+    0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 
+    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 
+    0x52, 0x44, 0x00, 0xab, 0x53, 0x48, 0x44, 0x52, 0x7c, 0x04, 0x00, 0x00, 
+    0x40, 0x00, 0x01, 0x00, 0x1f, 0x01, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 
+    0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x92, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x22, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x82, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x82, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x09, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf6, 0x1f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x62, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x81, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x62, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x56, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x52, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x56, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x92, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x56, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x82, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 
+    0x82, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x0a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x96, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 
+    0x74, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,40 @@
+float2   EyeToSourceUVScale;
+float2   EyeToSourceUVOffset;
+float4x4 EyeRotationStart;
+float4x4 EyeRotationEnd;
+
+float2 TimewarpTexCoordToWarpedPos(float2 inTexCoord, float4x4 rotMat)
+{
+    // Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+    // These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.    
+    // Apply the 3x3 timewarp rotation to these vectors.
+	float3 transformed = float3( mul ( rotMat, float4(inTexCoord,1,1) ).xyz);
+    // Project them back onto the Z=1 plane of the rendered images.
+	float2 flattened = transformed.xy / transformed.z;
+    // Scale them into ([0,0.5],[0,1]) or ([0.5,0],[0,1]) UV lookup space (depending on eye)
+	return flattened * EyeToSourceUVScale + EyeToSourceUVOffset;
+	
+}
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,    
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0)
+{
+
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+
+    float timewarpLerpFactor = Color.a;
+    float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, timewarpLerpFactor);	
+
+    // Warped positions are a bit more involved, hence a separate function
+	oTexCoord0 = TimewarpTexCoordToWarpedPos(TexCoord0, lerpedEyeRot);
+    oColor = Color.r;              // Used for vignette fade.
+}
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarp_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,11 @@
+#ifndef DistortionTimewarp_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionTimewarp_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+	{ "EyeRotationStart", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+	{ "EyeRotationEnd", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,214 @@
+#ifndef DISTORTIONTIMEWARPCHROMA_VS_H
+#define DISTORTIONTIMEWARPCHROMA_VS_H
+
+static const unsigned char DistortionTimewarpChroma_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x80, 0x9f, 0x5c, 0x4f, 0x89, 0x6f, 0x5a, 0xbf, 
+    0x65, 0xe8, 0x9a, 0x58, 0x95, 0xd7, 0x18, 0x18, 0x01, 0x00, 0x00, 0x00, 
+    0xb0, 0x09, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x9c, 0x01, 0x00, 0x00, 0x3c, 0x02, 0x00, 0x00, 0xe0, 0x02, 0x00, 0x00, 
+    0x34, 0x09, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x60, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x2b, 0x01, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf8, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x1c, 0x01, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x45, 0x79, 0x65, 0x54, 0x6f, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 
+    0x56, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 
+    0x00, 0xab, 0xab, 0xab, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x79, 0x65, 0x52, 
+    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x00, 0x4d, 
+    0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 
+    0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 
+    0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 
+    0x33, 0x2e, 0x39, 0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 
+    0x00, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x98, 0x00, 0x00, 0x00, 
+    0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x09, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 
+    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 
+    0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 
+    0x9c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x09, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 
+    0x92, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 
+    0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 
+    0x52, 0x44, 0x00, 0xab, 0x53, 0x48, 0x44, 0x52, 0x4c, 0x06, 0x00, 0x00, 
+    0x40, 0x00, 0x01, 0x00, 0x93, 0x01, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 
+    0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x92, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x62, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xc2, 0x20, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0x12, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x12, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x22, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x22, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x42, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x42, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x06, 0x82, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x09, 0x82, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3a, 0x00, 0x10, 0x80, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x2a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x09, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xf6, 0x1f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x32, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x46, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x12, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x32, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x85, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x16, 0x85, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x52, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x84, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x56, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x2a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
+    0x92, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x56, 0x81, 0x20, 0x80, 
+    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x56, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0a, 0x82, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x1a, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0a, 0x82, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x3a, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3a, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 
+    0x22, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x96, 0x05, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0xa6, 0x0a, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x62, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x06, 0x81, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xa6, 0x8b, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0x32, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x11, 0x00, 0x00, 0x07, 
+    0x12, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x11, 0x00, 0x00, 0x07, 0x22, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 0x46, 0x0f, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 0x12, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x00, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 
+    0x32, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x00, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x11, 0x00, 0x00, 0x07, 0x42, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 0x82, 0x00, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x07, 
+    0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0e, 0x00, 0x00, 0x07, 0x32, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xe6, 0x0a, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 0xc2, 0x20, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x06, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x06, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xa6, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x2e, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,43 @@
+float2 EyeToSourceUVScale;
+float2 EyeToSourceUVOffset;
+float4x4 EyeRotationStart;
+float4x4 EyeRotationEnd;
+
+float2 TimewarpTexCoordToWarpedPos(float2 inTexCoord, float4x4 rotMat)
+{
+	// Vertex inputs are in TanEyeAngle space for the R,G,B channels (i.e. after chromatic aberration and distortion).
+	// These are now "real world" vectors in direction (x,y,1) relative to the eye of the HMD.	
+	// Apply the 3x3 timewarp rotation to these vectors.
+	float3 transformed = float3( mul ( rotMat, float4(inTexCoord.xy, 1, 1) ).xyz);
+	// Project them back onto the Z=1 plane of the rendered images.
+	float2 flattened = transformed.xy / transformed.z;
+	// Scale them into ([0,0.5],[0,1]) or ([0.5,0],[0,1]) UV lookup space (depending on eye)
+	return flattened * EyeToSourceUVScale + EyeToSourceUVOffset;
+}
+
+void main(in float2 Position    : POSITION,
+          in float4 Color       : COLOR0,
+          in float2 TexCoord0   : TEXCOORD0,
+          in float2 TexCoord1   : TEXCOORD1,
+          in float2 TexCoord2   : TEXCOORD2,
+          out float4 oPosition  : SV_Position,
+          out float1 oColor     : COLOR,
+          out float2 oTexCoord0 : TEXCOORD0,
+          out float2 oTexCoord1 : TEXCOORD1,
+          out float2 oTexCoord2 : TEXCOORD2)
+{
+    oPosition.x = Position.x;
+    oPosition.y = Position.y;
+    oPosition.z = 0.5;
+    oPosition.w = 1.0;
+     	    
+    float timewarpLerpFactor = Color.a;
+    float4x4 lerpedEyeRot = lerp(EyeRotationStart, EyeRotationEnd, timewarpLerpFactor);
+
+    // warped positions are a bit more involved, hence a separate function
+	oTexCoord0 = TimewarpTexCoordToWarpedPos(TexCoord0, lerpedEyeRot);
+	oTexCoord1 = TimewarpTexCoordToWarpedPos(TexCoord1, lerpedEyeRot);
+	oTexCoord2 = TimewarpTexCoordToWarpedPos(TexCoord2, lerpedEyeRot);
+
+    oColor = Color.r;              // Used for vignette fade.
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/DistortionTimewarpChroma_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,11 @@
+#ifndef DistortionTimewarpChroma_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform DistortionTimewarpChroma_vs_refl[] =
+{
+	{ "EyeToSourceUVScale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "EyeToSourceUVOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+	{ "EyeRotationStart", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 16, 64 },
+	{ "EyeRotationEnd", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 80, 64 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,51 @@
+#ifndef SIMPLEQUAD_PS_H
+#define SIMPLEQUAD_PS_H
+
+static const unsigned char SimpleQuad_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0xc5, 0x64, 0xa2, 0x55, 0x15, 0x24, 0x7d, 0xe6, 
+    0x27, 0xd2, 0xf4, 0x4e, 0x42, 0xb6, 0xba, 0x78, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x00, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 
+    0x8c, 0x01, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xc4, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xab, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 
+    0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 
+    0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 
+    0x2e, 0x33, 0x2e, 0x39, 0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 
+    0x34, 0x00, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x08, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4f, 0x53, 0x47, 0x4e, 
+    0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
+    0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0xab, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x06, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.psh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps.psh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,6 @@
+float4 Color;
+
+float4 main() : SV_Target
+{
+   return Color;
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_ps_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,8 @@
+#ifndef SimpleQuad_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleQuad_ps_refl[] =
+{
+	{ "Color", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,64 @@
+#ifndef SIMPLEQUAD_VS_H
+#define SIMPLEQUAD_VS_H
+
+static const unsigned char SimpleQuad_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0xb2, 0x87, 0xff, 0xa1, 0x41, 0xd7, 0x0e, 0x94, 
+    0x59, 0xd6, 0x1b, 0x8c, 0x94, 0x3d, 0xb9, 0x46, 0x01, 0x00, 0x00, 0x00, 
+    0xa8, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0x6c, 0x01, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00, 
+    0x2c, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 
+    0xb8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
+    0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x66, 0x73, 
+    0x65, 0x74, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0xab, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 0x33, 0x2e, 0x39, 
+    0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 0x00, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x07, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0xab, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x53, 0x48, 0x44, 0x52, 
+    0x84, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 
+    0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x0b, 
+    0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 0xc2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,8 @@
+float2 PositionOffset = float2(0, 0);
+float2 Scale = float2(1, 1);
+
+void main(	in  float3 Position		: POSITION,
+out float4 oPosition	: SV_Position)
+{
+	oPosition = float4(Position.xy * Scale + PositionOffset, 0.5, 1.0);
+}
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleQuad_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,9 @@
+#ifndef SimpleQuad_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleQuad_vs_refl[] =
+{
+	{ "PositionOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "Scale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,77 @@
+#ifndef SIMPLETEXTUREDQUAD_PS_H
+#define SIMPLETEXTUREDQUAD_PS_H
+
+static const unsigned char SimpleTexturedQuad_ps[] = {
+    0x44, 0x58, 0x42, 0x43, 0x28, 0x50, 0xb2, 0x7b, 0x03, 0x55, 0x33, 0xd0, 
+    0x24, 0xd2, 0xc9, 0x9f, 0x95, 0x9b, 0xa9, 0x0a, 0x01, 0x00, 0x00, 0x00, 
+    0x44, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x54, 0x01, 0x00, 0x00, 0xc8, 0x01, 0x00, 0x00, 0xfc, 0x01, 0x00, 0x00, 
+    0xc8, 0x02, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x18, 0x01, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xe4, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x8a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x53, 0x61, 
+    0x6d, 0x70, 0x6c, 0x65, 0x72, 0x00, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 
+    0x65, 0x00, 0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 
+    0x92, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x00, 0xab, 0xab, 0x01, 0x00, 0x03, 0x00, 
+    0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 
+    0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 
+    0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 
+    0x2e, 0x33, 0x2e, 0x39, 0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 
+    0x34, 0x00, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 
+    0x74, 0x00, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0xc4, 0x00, 0x00, 0x00, 
+    0x40, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 
+    0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x5a, 0x00, 0x00, 0x03, 0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x58, 0x18, 0x00, 0x04, 0x00, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x55, 0x55, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0xf2, 0x10, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 
+    0x38, 0x00, 0x00, 0x08, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x1e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x09, 
+    0xf2, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x10, 0x10, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x46, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x60, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x3e, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 
+    0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.psh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps.psh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,16 @@
+float4 Color;
+
+SamplerState LinearSampler : register(s0);
+Texture2D Texture : register(t0);
+
+struct Values
+{
+   float4 Position : SV_Position;
+   float4 Color    : COLOR0;
+   float2 TexCoord : TEXCOORD0;
+};
+
+float4 main(in Values inputValues) : SV_Target
+{
+    return Color * inputValues.Color * Texture.Sample(LinearSampler, inputValues.TexCoord);
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_ps_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,8 @@
+#ifndef SimpleTexturedQuad_ps_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleTexturedQuad_ps_refl[] =
+{
+	{ "Color", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 16 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,82 @@
+#ifndef SIMPLETEXTUREDQUAD_VS_H
+#define SIMPLETEXTUREDQUAD_VS_H
+
+static const unsigned char SimpleTexturedQuad_vs[] = {
+    0x44, 0x58, 0x42, 0x43, 0x65, 0x25, 0x0c, 0xd1, 0x14, 0xa7, 0xfd, 0xde, 
+    0xf4, 0x91, 0xf7, 0xf7, 0x9e, 0xd4, 0xa5, 0x8c, 0x01, 0x00, 0x00, 0x00, 
+    0x7c, 0x03, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
+    0x38, 0x01, 0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 
+    0x00, 0x03, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0xfc, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x1c, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x00, 0x01, 0x00, 0x00, 
+    0xc8, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x24, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x00, 0xab, 0xab, 0xab, 
+    0x3c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
+    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 
+    0xb8, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
+    0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x66, 0x66, 0x73, 
+    0x65, 0x74, 0x00, 0xab, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x53, 0x63, 0x61, 0x6c, 0x65, 0x00, 0xab, 0xab, 
+    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x4d, 0x69, 0x63, 0x72, 
+    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 
+    0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 
+    0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x36, 0x2e, 0x33, 0x2e, 0x39, 
+    0x36, 0x30, 0x30, 0x2e, 0x31, 0x36, 0x33, 0x38, 0x34, 0x00, 0xab, 0xab, 
+    0x49, 0x53, 0x47, 0x4e, 0x68, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x07, 0x03, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x0f, 0x0f, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x03, 0x03, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 
+    0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 
+    0x4f, 0x52, 0x44, 0x00, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
+    0x02, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x50, 
+    0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 
+    0x52, 0x00, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x00, 0xab, 
+    0x53, 0x48, 0x44, 0x52, 0xdc, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 
+    0x37, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0xf2, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03, 
+    0x32, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 
+    0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x65, 0x00, 0x00, 0x03, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x32, 0x00, 0x00, 0x0b, 0x32, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x8a, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x80, 0x20, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x08, 
+    0xc2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
+    0x00, 0x00, 0x80, 0x3f, 0x36, 0x00, 0x00, 0x05, 0xf2, 0x20, 0x10, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 
+    0x36, 0x00, 0x00, 0x05, 0x32, 0x20, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 
+    0x46, 0x10, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01, 
+    0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x00, 0x00
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.vsh	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs.vsh	2014-09-03 00:32:16.000000000 -0400
@@ -0,0 +1,16 @@
+struct Values
+{
+   float4 Position : SV_Position;
+   float4 Color    : COLOR0;
+   float2 TexCoord : TEXCOORD0;
+};
+
+float2 PositionOffset = float2(0, 0);
+float2 Scale = float2(1, 1);
+
+void main(in float3 Position : POSITION, in float4 Color : COLOR0, in float2 TexCoord : TEXCOORD0, out Values outputValues)
+{
+   outputValues.Position = float4(Position.xy * Scale + PositionOffset, 0.5, 1.0);
+   outputValues.Color    = Color;
+   outputValues.TexCoord = TexCoord;
+}
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs_refl.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Shaders/SimpleTexturedQuad_vs_refl.h	2014-09-03 00:33:38.000000000 -0400
@@ -0,0 +1,9 @@
+#ifndef SimpleTexturedQuad_vs_refl
+
+const OVR::CAPI::D3D_NS::ShaderBase::Uniform SimpleTexturedQuad_vs_refl[] =
+{
+	{ "PositionOffset", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 0, 8 },
+	{ "Scale", 	OVR::CAPI::D3D_NS::ShaderBase::VARTYPE_FLOAT, 8, 8 },
+};
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Textures/healthAndSafety.tga.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/CAPI/Textures/healthAndSafety.tga.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,3349 @@
+
+const uint8_t healthAndSafety_tga[107070] = {
+   0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x02,0x20,0x08,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc7,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,
+   0x9f,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0x00,0x00,0x00,0x00,0xb3,0x82,0x7e,
+   0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x8c,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xc6,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x9d,0x00,
+   0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0xfc,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,
+   0x84,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x8a,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc6,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x9d,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xfb,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,
+   0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x89,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc6,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,
+   0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x9d,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0xfc,0x00,0x00,0x00,0xb3,0x05,0xef,0xef,0xef,0xf5,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,
+   0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x88,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x96,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,
+   0xc7,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,
+   0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x89,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x91,0x00,0x00,0x00,0xb3,0x00,
+   0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x95,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,
+   0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x8a,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,
+   0x00,0x33,0x33,0x33,0xb8,0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x8b,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,
+   0x7e,0xc7,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x99,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,
+   0x7e,0x7e,0x7e,0xc7,0x9b,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,
+   0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x00,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x01,
+   0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x04,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,
+   0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x03,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,
+   0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xd2,0xd2,0xd2,0xe6,0x81,0xff,
+   0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x04,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,
+   0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,
+   0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,
+   0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,
+   0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,
+   0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,
+   0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,
+   0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,
+   0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x87,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,
+   0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,
+   0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x88,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,
+   0x84,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x86,0x00,0x00,0x00,
+   0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,
+   0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0x33,0x33,
+   0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,
+   0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,
+   0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,
+   0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,
+   0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x85,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xd2,
+   0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,
+   0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0x6a,
+   0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x05,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,
+   0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x02,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xe6,0xe6,0xe6,0xf0,0x82,0xff,
+   0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x90,0x90,0x90,0xcc,
+   0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,
+   0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x87,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x01,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x01,0xff,0xff,0xff,0xff,0xc7,0xc7,0xc7,
+   0xe1,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,
+   0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,
+   0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xbb,
+   0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,
+   0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,
+   0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,
+   0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,
+   0x03,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x86,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,
+   0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,
+   0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,
+   0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,
+   0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xbb,0xbb,
+   0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x04,
+   0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,
+   0xb3,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,
+   0xdc,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,
+   0xbd,0x88,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,
+   0xd2,0xd2,0xd2,0xe6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,
+   0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,
+   0x03,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,
+   0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x82,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x05,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,
+   0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x05,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,
+   0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,
+   0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xc7,0xc7,0xc7,0xe1,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x7e,
+   0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x0a,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,
+   0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x08,0xaf,0xaf,0xaf,0xd6,0x52,
+   0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,
+   0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x05,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x85,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x02,0xe6,
+   0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x85,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x05,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,
+   0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x01,
+   0xd2,0xd2,0xd2,0xe6,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x09,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,
+   0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x0a,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,
+   0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,
+   0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,
+   0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,
+   0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x08,0x00,0x00,
+   0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,
+   0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x84,0x00,0x00,0x00,0xb3,0x86,0xff,0xff,0xff,0xff,0x02,0x00,
+   0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x86,0x00,0x00,0x00,0xb3,0x04,0x33,0x33,0x33,0xb8,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,
+   0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,
+   0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,
+   0xd1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,
+   0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,
+   0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,
+   0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0x81,0x00,
+   0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x06,
+   0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,
+   0xb3,0x01,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x86,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,
+   0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,
+   0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x02,0xd2,0xd2,0xd2,0xe6,0xdc,0xdc,0xdc,0xeb,0xc7,0xc7,
+   0xc7,0xe1,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,
+   0x0b,0xd2,0xd2,0xd2,0xe6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,
+   0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x01,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,
+   0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xd2,0xd2,0xd2,0xe6,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x05,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,
+   0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0xdc,0xdc,0xdc,0xeb,0x01,0x52,0x52,0x52,0xbd,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,
+   0xe6,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,
+   0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0xca,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0xa5,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xaa,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0x93,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0xcb,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0xa5,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xaa,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x91,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0x93,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0x87,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0xcb,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0xb3,0x00,0x33,
+   0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0xa5,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xaa,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x93,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x85,0xdc,0xdc,0xdc,0xeb,0x01,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0xcc,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xca,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xaa,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x93,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd6,0x00,0x00,
+   0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0xca,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0xaa,0x00,0x00,0x00,0xb3,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x93,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x8f,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb4,0xf1,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd6,0x00,0x00,0x00,0xb3,0xc3,0x00,0x00,0x00,0xb4,0xff,0x01,0x00,0x00,0xb4,
+   0xdb,0x01,0x00,0x00,0xb4,0xc3,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x82,0x00,0x00,0x00,0xb4,0x8b,0x00,0x00,0x00,0xb3,0x97,0x00,0x00,0x00,0xb4,0x92,0x01,0x00,0x00,0xb4,0x91,0x01,0x00,0x00,
+   0xb5,0x8c,0x01,0x01,0x00,0xb5,0xff,0x01,0x01,0x01,0xb6,0xf3,0x01,0x01,0x01,0xb6,0x8c,0x01,0x01,0x00,0xb5,0x91,0x01,0x00,0x00,0xb5,0x92,0x01,0x00,0x00,0xb4,0x97,
+   0x00,0x00,0x00,0xb4,0x8b,0x00,0x00,0x00,0xb3,0x82,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa3,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa8,0x00,0x00,0x00,0xb3,0x9b,0x00,0x00,0x00,0xb4,0x8e,0x01,0x00,0x00,0xb4,0x88,0x01,0x00,0x00,0xb5,0x81,0x01,0x01,0x00,0xb5,
+   0x8f,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x8b,0x02,0x01,0x01,0xb7,0xa8,0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x82,0x02,
+   0x02,0x01,0xb9,0x82,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,
+   0xb9,0x00,0x03,0x02,0x01,0xb9,0x85,0x02,0x02,0x01,0xb9,0x02,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,0xb9,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,
+   0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x04,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,0xb9,0x03,0x02,0x01,0xb9,0x02,0x02,
+   0x01,0xb9,0x03,0x02,0x01,0xb9,0x84,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x00,
+   0x03,0x02,0x01,0xb9,0x85,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,
+   0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x02,0x02,0x02,0x01,0xb9,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x81,0x02,
+   0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x8d,0x02,0x02,0x01,0xb9,0x01,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,0xb9,
+   0x81,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x87,0x02,0x02,0x01,0xb9,0x81,0x03,
+   0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x87,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,
+   0xb9,0x85,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x85,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x84,
+   0x02,0x02,0x01,0xb9,0x82,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x01,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,
+   0xb9,0x82,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x8b,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x8d,
+   0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb8,0x90,0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb8,0x87,0x02,0x01,0x01,0xb8,0x8b,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,
+   0x01,0xb7,0x8f,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x00,0xb5,0x88,0x01,0x00,0x00,0xb5,0x8e,0x01,0x00,0x00,0xb4,0x9b,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0x96,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa6,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb4,0x87,0x01,
+   0x00,0x00,0xb4,0x85,0x01,0x00,0x00,0xb5,0x88,0x01,0x01,0x00,0xb5,0x86,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x01,0xb7,0x86,0x02,0x01,0x01,0xb7,0x83,0x02,0x01,0x01,
+   0xb8,0x00,0x02,0x02,0x01,0xb8,0x86,0x02,0x01,0x01,0xb8,0x83,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x89,0x03,0x02,0x01,0xba,0x82,0x03,0x02,0x02,0xbb,0x00,
+   0x03,0x02,0x01,0xbb,0x8c,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,0xbc,0x8d,0x04,0x02,0x02,0xbc,0xff,0x04,0x03,0x02,0xbd,0xd9,0x04,0x03,0x02,0xbd,0x85,0x04,0x02,
+   0x02,0xbc,0x00,0x04,0x03,0x02,0xbc,0x86,0x04,0x02,0x02,0xbc,0x00,0x03,0x02,0x02,0xbc,0x87,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x87,0x03,0x02,0x02,0xbb,
+   0x89,0x03,0x02,0x01,0xba,0x00,0x03,0x02,0x01,0xb9,0x84,0x02,0x02,0x01,0xb9,0x8b,0x02,0x01,0x01,0xb8,0x86,0x02,0x01,0x01,0xb7,0x81,0x01,0x01,0x01,0xb7,0x86,0x01,
+   0x01,0x01,0xb6,0x88,0x01,0x01,0x00,0xb5,0x85,0x01,0x00,0x00,0xb5,0x87,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0x94,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9d,0x00,0x00,0x00,0xb3,0x92,0x00,0x00,0x00,0xb4,0x88,0x01,0x00,0x00,0xb4,0x84,
+   0x01,0x00,0x00,0xb5,0x86,0x01,0x01,0x00,0xb5,0x83,0x01,0x01,0x01,0xb6,0x01,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,0x85,0x02,0x01,0x01,0xb7,0x86,0x02,0x01,0x01,
+   0xb8,0x82,0x02,0x02,0x01,0xb9,0x82,0x03,0x02,0x01,0xb9,0x83,0x03,0x02,0x01,0xba,0x00,0x03,0x02,0x01,0xbb,0x82,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x83,
+   0x03,0x02,0x02,0xbb,0x81,0x03,0x02,0x02,0xbc,0x01,0x04,0x02,0x02,0xbc,0x03,0x02,0x02,0xbc,0x84,0x04,0x02,0x02,0xbc,0x88,0x04,0x03,0x02,0xbd,0x01,0x04,0x03,0x02,
+   0xbe,0x05,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbe,0x00,0x04,0x03,0x02,0xbf,0x85,0x05,0x03,0x02,0xbf,0x85,0x05,0x03,0x02,0xc0,0x00,0x05,0x04,0x01,0xc0,0x81,0x05,
+   0x03,0x02,0xc0,0x00,0x05,0x03,0x03,0xc0,0x8d,0x05,0x04,0x03,0xc0,0x00,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,0x02,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,
+   0x05,0x04,0x01,0xc1,0x81,0x05,0x04,0x03,0xc1,0x81,0x06,0x04,0x03,0xc1,0x05,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x05,
+   0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x82,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,0x01,0xc1,0x81,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,
+   0x00,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,0x01,0xc1,0x81,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x02,0x06,
+   0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x02,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x82,0x05,0x04,
+   0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x82,0x05,0x04,0x03,0xc1,0xd9,0x06,0x04,0x03,0xc2,0x05,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,
+   0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,0x02,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,
+   0xc1,0x00,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x82,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x82,0x05,0x04,0x03,0xc1,0x01,
+   0x05,0x04,0x01,0xc1,0x05,0x04,0x03,0xc1,0x82,0x06,0x04,0x03,0xc1,0x00,0x05,0x04,0x03,0xc1,0x81,0x06,0x04,0x03,0xc1,0x03,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,
+   0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x85,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,0x01,0xc1,0x81,0x05,0x04,0x03,0xc1,0x01,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,
+   0x81,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x81,0x06,0x04,0x03,0xc1,0x8d,0x05,0x04,0x03,0xc0,0x00,0x05,0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x00,0x05,
+   0x04,0x01,0xc0,0x85,0x05,0x03,0x02,0xc0,0x85,0x05,0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x81,0x04,0x03,0x02,0xbe,0x82,0x05,0x03,0x02,0xbe,0x02,0x04,0x03,0x02,
+   0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x88,0x04,0x03,0x02,0xbd,0x84,0x04,0x02,0x02,0xbc,0x82,0x03,0x02,0x02,0xbc,0x00,0x04,0x02,0x02,0xbc,0x88,0x03,0x02,
+   0x02,0xbb,0x83,0x03,0x02,0x01,0xba,0x82,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x86,0x02,0x01,0x01,0xb8,0x85,0x02,0x01,0x01,0xb7,0x81,0x01,0x01,0x01,0xb7,
+   0x83,0x01,0x01,0x01,0xb6,0x86,0x01,0x01,0x00,0xb5,0x84,0x01,0x00,0x00,0xb5,0x88,0x01,0x00,0x00,0xb4,0x92,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0x8b,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9b,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,
+   0xb4,0x82,0x01,0x00,0x00,0xb5,0x81,0x01,0x01,0x00,0xb5,0x89,0x01,0x01,0x01,0xb6,0x81,0x02,0x01,0x01,0xb7,0x8a,0x02,0x01,0x01,0xb8,0x81,0x02,0x02,0x01,0xb9,0x81,
+   0x03,0x02,0x01,0xb9,0x84,0x03,0x02,0x01,0xba,0x83,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,0xbc,0x85,0x04,0x02,0x02,0xbc,0x84,0x04,0x03,0x02,0xbd,0x01,0x04,0x03,
+   0x02,0xbe,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x00,0x04,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xbf,0x82,
+   0x05,0x03,0x02,0xc0,0x00,0x05,0x04,0x03,0xc0,0x81,0x05,0x04,0x03,0xc1,0x02,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x85,0x05,0x04,0x03,0xc1,
+   0x87,0x06,0x04,0x03,0xc2,0x86,0x06,0x04,0x03,0xc3,0x86,0x06,0x04,0x03,0xc4,0x81,0x07,0x04,0x03,0xc5,0x97,0x07,0x05,0x02,0xc5,0xa4,0x07,0x05,0x02,0xc6,0x8b,0x07,
+   0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x96,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x98,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x8b,0x07,0x05,0x04,
+   0xc6,0x00,0x07,0x05,0x02,0xc6,0x88,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x85,0x07,0x05,0x04,0xc6,0xa4,0x07,0x05,0x02,0xc6,0x98,0x07,0x05,0x02,0xc5,0x00,
+   0x07,0x04,0x03,0xc5,0x81,0x06,0x04,0x03,0xc4,0x81,0x07,0x04,0x03,0xc4,0x82,0x06,0x04,0x03,0xc4,0x86,0x06,0x04,0x03,0xc3,0x87,0x06,0x04,0x03,0xc2,0x82,0x06,0x04,
+   0x03,0xc1,0x01,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,0x01,0xc1,0x82,0x05,0x04,0x03,0xc1,0x01,0x05,0x04,0x03,0xc0,0x05,
+   0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x82,0x05,0x03,0x02,0xbf,0x00,0x05,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbe,0x01,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,
+   0x84,0x04,0x03,0x02,0xbd,0x82,0x04,0x02,0x02,0xbc,0x00,0x04,0x03,0x02,0xbc,0x82,0x04,0x02,0x02,0xbc,0x83,0x03,0x02,0x02,0xbb,0x84,0x03,0x02,0x01,0xba,0x82,0x03,
+   0x02,0x01,0xb9,0x00,0x02,0x02,0x01,0xb9,0x8a,0x02,0x01,0x01,0xb8,0x81,0x02,0x01,0x01,0xb7,0x89,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x00,0xb5,0x82,0x01,0x00,0x00,
+   0xb5,0x87,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x89,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0x99,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb4,0x81,0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x82,0x01,0x01,0x00,0xb5,0x83,0x01,0x01,
+   0x01,0xb6,0x03,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,0x83,0x02,0x01,0x01,0xb7,0x82,0x02,0x01,0x01,0xb8,0x85,0x02,0x02,
+   0x01,0xb9,0x85,0x03,0x02,0x01,0xba,0x82,0x03,0x02,0x02,0xbb,0x83,0x03,0x02,0x02,0xbc,0x82,0x04,0x02,0x02,0xbc,0x85,0x04,0x03,0x02,0xbd,0x81,0x04,0x03,0x02,0xbe,
+   0x83,0x04,0x03,0x02,0xbf,0x00,0x05,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xc0,0x01,0x05,0x03,0x03,0xc0,0x05,0x04,0x03,0xc0,0x86,0x05,0x04,0x03,0xc1,0x83,0x06,0x04,
+   0x03,0xc2,0x81,0x06,0x04,0x03,0xc3,0x00,0x06,0x05,0x02,0xc3,0x83,0x06,0x04,0x03,0xc3,0x82,0x06,0x04,0x03,0xc4,0x81,0x07,0x04,0x03,0xc5,0x89,0x07,0x05,0x02,0xc5,
+   0x04,0x07,0x05,0x02,0xc6,0x07,0x05,0x04,0xc6,0x07,0x05,0x02,0xc6,0x07,0x05,0x02,0xc7,0x07,0x05,0x04,0xc7,0x82,0x08,0x05,0x04,0xc7,0x00,0x08,0x05,0x02,0xc7,0x86,
+   0x08,0x05,0x04,0xc7,0x86,0x08,0x05,0x04,0xc8,0x00,0x08,0x05,0x02,0xc8,0x8f,0x08,0x05,0x04,0xc8,0x81,0x08,0x05,0x04,0xc9,0xff,0x08,0x06,0x03,0xc9,0x9d,0x08,0x06,
+   0x03,0xc9,0x81,0x08,0x05,0x04,0xc9,0x84,0x08,0x05,0x04,0xc8,0x00,0x08,0x06,0x03,0xc8,0x91,0x08,0x05,0x04,0xc8,0x89,0x08,0x05,0x04,0xc7,0x82,0x07,0x05,0x04,0xc7,
+   0x02,0x07,0x05,0x02,0xc6,0x07,0x05,0x04,0xc6,0x07,0x05,0x02,0xc6,0x89,0x07,0x05,0x02,0xc5,0x81,0x07,0x04,0x03,0xc5,0x82,0x06,0x04,0x03,0xc4,0x86,0x06,0x04,0x03,
+   0xc3,0x83,0x06,0x04,0x03,0xc2,0x00,0x05,0x04,0x03,0xc1,0x81,0x06,0x04,0x03,0xc1,0x01,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x01,0x05,
+   0x04,0x03,0xc0,0x05,0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x83,0x05,0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x81,0x04,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbd,
+   0x82,0x04,0x02,0x02,0xbc,0x81,0x03,0x02,0x02,0xbc,0x01,0x04,0x02,0x02,0xbc,0x03,0x02,0x02,0xbc,0x82,0x03,0x02,0x02,0xbb,0x85,0x03,0x02,0x01,0xba,0x85,0x02,0x02,
+   0x01,0xb9,0x82,0x02,0x01,0x01,0xb8,0x84,0x02,0x01,0x01,0xb7,0x82,0x01,0x01,0x01,0xb7,0x83,0x01,0x01,0x01,0xb6,0x82,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,
+   0x81,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x87,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0x99,0x00,0x00,0x00,0xb3,0x8d,0x00,0x00,0x00,0xb4,0x85,0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x87,0x01,0x01,0x01,
+   0xb6,0x00,0x01,0x01,0x01,0xb7,0x82,0x02,0x01,0x01,0xb7,0x83,0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb9,0x84,0x03,0x02,0x01,0xb9,0x84,0x03,0x02,0x01,0xba,0x02,
+   0x03,0x02,0x02,0xbb,0x03,0x02,0x01,0xbb,0x03,0x02,0x02,0xbb,0x81,0x04,0x02,0x02,0xbc,0x01,0x04,0x03,0x02,0xbc,0x04,0x02,0x02,0xbc,0x85,0x04,0x03,0x02,0xbd,0x02,
+   0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbf,0x83,0x05,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xc0,0x81,0x05,0x03,0x03,0xc0,0x81,0x05,0x04,0x03,0xc0,
+   0x81,0x05,0x04,0x03,0xc1,0x86,0x06,0x04,0x03,0xc2,0x81,0x06,0x04,0x03,0xc3,0x00,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc4,0x81,0x07,0x04,0x03,0xc4,0x82,0x06,
+   0x04,0x03,0xc4,0x00,0x07,0x04,0x03,0xc5,0x84,0x07,0x05,0x02,0xc5,0x81,0x07,0x05,0x04,0xc6,0x02,0x07,0x05,0x04,0xc7,0x08,0x05,0x04,0xc7,0x07,0x05,0x02,0xc7,0x81,
+   0x08,0x05,0x04,0xc7,0x81,0x07,0x05,0x04,0xc7,0x82,0x08,0x05,0x04,0xc7,0x87,0x08,0x05,0x04,0xc8,0x00,0x08,0x05,0x04,0xc9,0x89,0x08,0x06,0x03,0xc9,0x00,0x09,0x06,
+   0x03,0xca,0x88,0x08,0x06,0x03,0xca,0x02,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x85,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0xff,0x09,
+   0x06,0x03,0xcb,0xa1,0x09,0x06,0x03,0xcb,0x01,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x86,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x82,0x08,0x06,0x03,0xca,
+   0x02,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x83,0x08,0x06,0x03,0xca,0x89,0x08,0x06,0x03,0xc9,0x00,0x08,0x05,0x04,0xc9,0x83,0x08,0x05,0x04,
+   0xc8,0x00,0x08,0x06,0x03,0xc8,0x82,0x08,0x05,0x04,0xc8,0x81,0x08,0x05,0x04,0xc7,0x81,0x07,0x05,0x04,0xc7,0x02,0x08,0x05,0x04,0xc7,0x07,0x05,0x04,0xc7,0x08,0x05,
+   0x04,0xc7,0x82,0x07,0x05,0x04,0xc7,0x81,0x07,0x05,0x04,0xc6,0x84,0x07,0x05,0x02,0xc5,0x00,0x07,0x04,0x03,0xc5,0x81,0x06,0x04,0x03,0xc4,0x03,0x07,0x04,0x03,0xc4,
+   0x06,0x04,0x03,0xc4,0x07,0x05,0x02,0xc4,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc3,0x86,0x06,0x04,0x03,0xc2,0x81,0x05,0x04,0x03,0xc1,
+   0x81,0x05,0x04,0x03,0xc0,0x81,0x05,0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x83,0x05,0x03,0x02,0xbf,0x02,0x04,0x03,0x02,0xbf,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,
+   0xbe,0x85,0x04,0x03,0x02,0xbd,0x82,0x04,0x02,0x02,0xbc,0x00,0x03,0x02,0x02,0xbc,0x82,0x03,0x02,0x02,0xbb,0x84,0x03,0x02,0x01,0xba,0x83,0x03,0x02,0x01,0xb9,0x81,
+   0x02,0x02,0x01,0xb9,0x83,0x02,0x01,0x01,0xb8,0x82,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,0x01,0xb7,0x87,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,
+   0x00,0xb5,0x85,0x01,0x00,0x00,0xb4,0x8d,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x87,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0x99,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb4,0x81,0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x87,0x01,
+   0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x82,0x02,0x01,0x01,0xb7,0x83,0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb9,0x84,0x03,0x02,0x01,0xb9,0x84,0x03,0x02,0x01,
+   0xba,0x82,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,0xbc,0x82,0x04,0x02,0x02,0xbc,0x85,0x04,0x03,0x02,0xbd,0x01,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x82,0x04,
+   0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xbf,0x02,0x05,0x04,0x01,0xc0,0x05,0x03,0x02,0xc0,0x05,0x03,0x03,0xc0,0x82,0x05,0x04,0x03,0xc0,0x81,0x06,0x04,0x03,0xc1,0x86,
+   0x06,0x04,0x03,0xc2,0x81,0x06,0x04,0x03,0xc3,0x84,0x06,0x04,0x03,0xc4,0x03,0x07,0x04,0x03,0xc4,0x06,0x04,0x03,0xc4,0x07,0x04,0x03,0xc4,0x07,0x05,0x02,0xc4,0x82,
+   0x07,0x05,0x02,0xc5,0x00,0x07,0x05,0x02,0xc6,0x81,0x07,0x05,0x04,0xc6,0x00,0x08,0x05,0x04,0xc6,0x81,0x07,0x05,0x04,0xc7,0x87,0x08,0x05,0x04,0xc7,0x83,0x08,0x05,
+   0x04,0xc8,0x8b,0x08,0x06,0x03,0xc9,0x01,0x09,0x06,0x03,0xc9,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x81,
+   0x09,0x06,0x03,0xca,0x85,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0xff,0x09,0x06,0x03,0xcb,0xa7,0x09,0x06,0x03,0xcb,0x81,0x09,0x06,0x03,0xca,0x81,0x08,0x06,
+   0x03,0xca,0x06,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x81,
+   0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x02,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x8c,0x08,0x06,0x03,0xc9,
+   0x83,0x08,0x05,0x04,0xc8,0x87,0x08,0x05,0x04,0xc7,0x81,0x07,0x05,0x04,0xc7,0x82,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x82,0x07,0x05,0x02,0xc5,0x83,0x06,
+   0x04,0x03,0xc4,0x02,0x07,0x05,0x02,0xc4,0x07,0x04,0x03,0xc4,0x06,0x04,0x03,0xc4,0x81,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc3,0x86,0x06,0x04,0x03,0xc2,0x81,
+   0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc0,0x81,0x05,0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x81,0x05,0x03,0x02,0xbf,0x82,0x04,0x03,0x02,0xbf,0x01,0x04,0x03,
+   0x02,0xbe,0x05,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbd,0x82,0x04,0x02,0x02,0xbc,0x00,0x03,0x02,0x02,0xbc,0x81,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x84,
+   0x03,0x02,0x01,0xba,0x83,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x83,0x02,0x01,0x01,0xb8,0x82,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,0x01,0xb7,0x87,0x01,0x01,
+   0x01,0xb6,0x00,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,0x81,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0x87,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9b,0x00,0x00,0x00,0xb3,0x8f,0x00,0x00,0x00,0xb4,0x81,0x01,0x00,0x00,0xb4,0x85,0x01,
+   0x00,0x00,0xb5,0x01,0x01,0x01,0x00,0xb5,0x01,0x00,0x00,0xb5,0x82,0x01,0x01,0x00,0xb5,0x86,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x84,0x02,0x01,0x01,0xb7,
+   0x81,0x02,0x01,0x01,0xb8,0x86,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x83,0x03,0x02,0x01,0xba,0x81,0x03,0x02,0x02,0xbb,0x86,0x04,0x02,0x02,0xbc,0x82,0x04,
+   0x03,0x02,0xbd,0x00,0x04,0x03,0x02,0xbe,0x82,0x05,0x03,0x02,0xbe,0x00,0x04,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xbf,0x84,0x05,0x03,0x02,0xc0,0x01,0x05,0x03,0x03,
+   0xc0,0x05,0x04,0x03,0xc0,0x81,0x05,0x04,0x03,0xc1,0x87,0x06,0x04,0x03,0xc2,0x82,0x06,0x04,0x03,0xc3,0x81,0x07,0x04,0x03,0xc4,0x00,0x06,0x04,0x03,0xc4,0x84,0x07,
+   0x04,0x03,0xc5,0x81,0x07,0x05,0x02,0xc5,0x82,0x07,0x05,0x02,0xc6,0x83,0x07,0x05,0x04,0xc6,0x00,0x08,0x05,0x04,0xc6,0x81,0x07,0x05,0x04,0xc7,0x00,0x08,0x05,0x04,
+   0xc7,0x83,0x07,0x05,0x04,0xc7,0x00,0x08,0x05,0x04,0xc7,0x8e,0x08,0x05,0x04,0xc8,0x02,0x08,0x06,0x03,0xc8,0x08,0x05,0x04,0xc8,0x08,0x05,0x04,0xc9,0x87,0x08,0x06,
+   0x03,0xc9,0x00,0x08,0x06,0x03,0xca,0x82,0x09,0x06,0x03,0xca,0x04,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,
+   0xca,0x81,0x09,0x06,0x03,0xca,0x85,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x03,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,
+   0x03,0xca,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x06,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,
+   0xca,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x87,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x82,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,
+   0xca,0x81,0x08,0x06,0x03,0xca,0x02,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x88,0x08,0x06,
+   0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,
+   0x81,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x01,0x09,0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x00,0x09,0x06,
+   0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x82,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,
+   0x81,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x01,0x08,0x06,0x03,0xca,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x82,0x08,0x06,
+   0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x85,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x81,0x08,0x06,0x03,0xca,
+   0x00,0x09,0x06,0x03,0xca,0x8a,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x83,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x84,0x08,0x06,0x03,0xca,0x01,0x09,
+   0x06,0x03,0xca,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,0x82,0x08,0x06,0x03,0xca,0x00,0x09,0x06,0x03,0xca,0x83,0x08,0x06,0x03,0xca,0x81,0x09,0x06,0x03,0xca,
+   0x82,0x08,0x06,0x03,0xca,0x01,0x08,0x06,0x03,0xc9,0x09,0x06,0x03,0xc9,0x85,0x08,0x06,0x03,0xc9,0x00,0x08,0x05,0x04,0xc9,0x90,0x08,0x05,0x04,0xc8,0x05,0x08,0x05,
+   0x04,0xc7,0x07,0x05,0x04,0xc7,0x08,0x05,0x04,0xc7,0x07,0x05,0x04,0xc7,0x07,0x05,0x02,0xc7,0x07,0x05,0x04,0xc7,0x81,0x08,0x05,0x04,0xc7,0x00,0x08,0x05,0x04,0xc6,
+   0x83,0x07,0x05,0x04,0xc6,0x82,0x07,0x05,0x02,0xc6,0x81,0x07,0x05,0x02,0xc5,0x84,0x07,0x04,0x03,0xc5,0x00,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc4,0x82,0x06,
+   0x04,0x03,0xc3,0x87,0x06,0x04,0x03,0xc2,0x03,0x06,0x04,0x03,0xc1,0x05,0x04,0x03,0xc1,0x05,0x04,0x03,0xc0,0x05,0x03,0x03,0xc0,0x84,0x05,0x03,0x02,0xc0,0x81,0x05,
+   0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x81,0x04,0x03,0x02,0xbe,0x01,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbd,0x84,0x04,0x02,0x02,0xbc,
+   0x01,0x04,0x03,0x02,0xbc,0x03,0x02,0x02,0xbc,0x81,0x03,0x02,0x02,0xbb,0x83,0x03,0x02,0x01,0xba,0x81,0x03,0x02,0x01,0xb9,0x85,0x02,0x02,0x01,0xb9,0x81,0x02,0x01,
+   0x01,0xb8,0x85,0x02,0x01,0x01,0xb7,0x86,0x01,0x01,0x01,0xb6,0x82,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,0x81,0x01,0x00,0x00,0xb4,0x8f,0x00,0x00,0x00,0xb4,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x89,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9b,0x00,0x00,0x00,0xb3,0x91,0x00,
+   0x00,0x00,0xb4,0x81,0x01,0x00,0x00,0xb4,0x85,0x01,0x00,0x00,0xb5,0x85,0x01,0x01,0x00,0xb5,0x83,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x84,0x02,0x01,0x01,
+   0xb7,0x87,0x02,0x01,0x01,0xb8,0x81,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x83,0x03,0x02,0x01,0xba,0x84,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,0xbc,0x84,
+   0x04,0x02,0x02,0xbc,0x82,0x04,0x03,0x02,0xbd,0x83,0x04,0x03,0x02,0xbe,0x01,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x82,0x05,0x03,0x02,0xbf,0x83,0x05,0x03,0x02,
+   0xc0,0x81,0x05,0x03,0x03,0xc0,0x82,0x05,0x04,0x03,0xc0,0x81,0x05,0x04,0x03,0xc1,0x86,0x06,0x04,0x03,0xc2,0x81,0x06,0x04,0x03,0xc3,0x00,0x07,0x05,0x02,0xc4,0x82,
+   0x06,0x04,0x03,0xc4,0x02,0x07,0x04,0x03,0xc4,0x06,0x04,0x03,0xc4,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc4,0x89,0x07,0x05,0x02,0xc5,0x00,0x07,0x05,0x02,0xc6,
+   0x89,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc7,0x81,0x07,0x05,0x04,0xc7,0x02,0x07,0x05,0x02,0xc7,0x08,0x05,0x04,0xc7,0x07,0x05,0x02,0xc7,0x81,0x07,0x05,0x04,
+   0xc7,0x85,0x08,0x05,0x04,0xc7,0x88,0x08,0x05,0x04,0xc8,0x00,0x08,0x05,0x02,0xc8,0xb5,0x08,0x05,0x04,0xc8,0x00,0x08,0x06,0x03,0xc8,0x81,0x08,0x05,0x04,0xc8,0x00,
+   0x08,0x06,0x03,0xc8,0xbd,0x08,0x05,0x04,0xc8,0x00,0x08,0x06,0x03,0xc8,0xa7,0x08,0x05,0x04,0xc8,0x00,0x08,0x05,0x02,0xc8,0x83,0x08,0x05,0x04,0xc8,0x00,0x08,0x05,
+   0x02,0xc8,0x84,0x08,0x05,0x04,0xc8,0x01,0x08,0x05,0x02,0xc8,0x08,0x05,0x04,0xc8,0x85,0x08,0x05,0x04,0xc7,0x85,0x07,0x05,0x04,0xc7,0x81,0x08,0x05,0x04,0xc7,0x81,
+   0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x86,0x07,0x05,0x04,0xc6,0x00,0x07,0x05,0x02,0xc6,0x88,0x07,0x05,0x02,0xc5,0x01,0x07,0x04,0x03,0xc5,0x07,0x04,0x03,
+   0xc4,0x87,0x06,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc3,0x86,0x06,0x04,0x03,0xc2,0x81,0x05,0x04,0x03,0xc1,0x82,0x05,0x04,0x03,0xc0,0x81,0x05,0x03,0x03,0xc0,0x83,
+   0x05,0x03,0x02,0xc0,0x81,0x05,0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x85,0x04,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbd,0x83,0x04,0x02,0x02,0xbc,0x01,0x03,0x02,
+   0x02,0xbc,0x04,0x02,0x02,0xbc,0x84,0x03,0x02,0x02,0xbb,0x83,0x03,0x02,0x01,0xba,0x00,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x87,0x02,0x01,0x01,0xb8,0x85,
+   0x02,0x01,0x01,0xb7,0x83,0x01,0x01,0x01,0xb6,0x85,0x01,0x01,0x00,0xb5,0x85,0x01,0x00,0x00,0xb5,0x81,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x89,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9d,0x00,0x00,0x00,0xb3,0x8f,0x00,0x00,0x00,0xb4,
+   0x87,0x01,0x00,0x00,0xb4,0x83,0x01,0x00,0x00,0xb5,0x86,0x01,0x01,0x00,0xb5,0x84,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x86,0x02,0x01,0x01,0xb7,0x84,0x02,
+   0x01,0x01,0xb8,0x01,0x02,0x02,0x01,0xb9,0x03,0x02,0x01,0xb9,0x83,0x03,0x02,0x01,0xba,0x85,0x03,0x02,0x02,0xbb,0x01,0x03,0x02,0x02,0xbc,0x04,0x03,0x02,0xbc,0x81,
+   0x04,0x02,0x02,0xbc,0x01,0x04,0x03,0x02,0xbc,0x04,0x02,0x02,0xbc,0x85,0x04,0x03,0x02,0xbd,0x88,0x04,0x03,0x02,0xbe,0x82,0x05,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,
+   0xc0,0x03,0x05,0x03,0x03,0xc0,0x05,0x04,0x03,0xc0,0x05,0x04,0x03,0xc1,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,
+   0xc1,0x8a,0x06,0x04,0x03,0xc2,0x87,0x06,0x04,0x03,0xc3,0x84,0x06,0x04,0x03,0xc4,0x00,0x07,0x04,0x03,0xc4,0x81,0x06,0x04,0x03,0xc4,0x89,0x07,0x04,0x03,0xc5,0x9f,
+   0x07,0x05,0x02,0xc5,0xff,0x07,0x05,0x02,0xc6,0x83,0x07,0x05,0x02,0xc6,0x9f,0x07,0x05,0x02,0xc5,0x83,0x07,0x04,0x03,0xc5,0x00,0x07,0x05,0x02,0xc5,0x84,0x07,0x04,
+   0x03,0xc5,0x87,0x06,0x04,0x03,0xc4,0x00,0x06,0x05,0x02,0xc3,0x86,0x06,0x04,0x03,0xc3,0x8a,0x06,0x04,0x03,0xc2,0x00,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,
+   0x81,0x06,0x04,0x03,0xc1,0x01,0x05,0x04,0x03,0xc0,0x05,0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x81,0x05,0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x83,0x04,0x03,
+   0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x83,0x04,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbd,0x85,0x04,0x02,0x02,0xbc,0x85,0x03,0x02,0x02,0xbb,0x83,0x03,0x02,0x01,0xba,
+   0x01,0x03,0x02,0x01,0xb9,0x02,0x02,0x01,0xb9,0x84,0x02,0x01,0x01,0xb8,0x86,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,0x01,0xb7,0x84,0x01,0x01,0x01,0xb6,0x86,0x01,0x01,
+   0x00,0xb5,0x83,0x01,0x00,0x00,0xb5,0x87,0x01,0x00,0x00,0xb4,0x8f,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x8b,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa2,0x00,0x00,0x00,0xb3,0x92,0x00,0x00,0x00,0xb4,0x83,0x01,0x00,0x00,0xb4,0x00,0x01,0x00,0x00,0xb5,0x85,0x01,
+   0x01,0x00,0xb5,0x88,0x01,0x01,0x01,0xb6,0x83,0x01,0x01,0x01,0xb7,0x85,0x02,0x01,0x01,0xb7,0x82,0x02,0x01,0x01,0xb8,0x82,0x02,0x02,0x01,0xb9,0x82,0x03,0x02,0x01,
+   0xb9,0x82,0x03,0x02,0x01,0xba,0x88,0x03,0x02,0x02,0xbb,0x83,0x04,0x02,0x02,0xbc,0x8a,0x04,0x03,0x02,0xbd,0x00,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x00,
+   0x04,0x03,0x02,0xbe,0x87,0x05,0x03,0x02,0xbf,0x81,0x05,0x03,0x02,0xc0,0x86,0x05,0x03,0x03,0xc0,0x00,0x05,0x04,0x03,0xc0,0x81,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,
+   0x01,0xc1,0x82,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x81,0x05,0x04,0x03,0xc1,0xa0,0x06,0x04,0x03,0xc2,0xcf,0x06,0x04,0x03,0xc3,0x00,0x06,0x05,0x02,0xc3,
+   0xd0,0x06,0x04,0x03,0xc3,0xa0,0x06,0x04,0x03,0xc2,0x83,0x05,0x04,0x03,0xc1,0x00,0x06,0x04,0x03,0xc1,0x83,0x05,0x04,0x03,0xc1,0x00,0x05,0x04,0x01,0xc0,0x86,0x05,
+   0x03,0x03,0xc0,0x81,0x05,0x03,0x02,0xc0,0x86,0x05,0x03,0x02,0xbf,0x00,0x04,0x03,0x02,0xbf,0x83,0x04,0x03,0x02,0xbe,0x8a,0x04,0x03,0x02,0xbd,0x82,0x04,0x02,0x02,
+   0xbc,0x00,0x03,0x02,0x02,0xbc,0x85,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x81,0x03,0x02,0x02,0xbb,0x82,0x03,0x02,0x01,0xba,0x83,0x03,0x02,0x01,0xb9,0x81,
+   0x02,0x02,0x01,0xb9,0x82,0x02,0x01,0x01,0xb8,0x86,0x02,0x01,0x01,0xb7,0x82,0x01,0x01,0x01,0xb7,0x88,0x01,0x01,0x01,0xb6,0x85,0x01,0x01,0x00,0xb5,0x00,0x01,0x00,
+   0x00,0xb5,0x83,0x01,0x00,0x00,0xb4,0x92,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x90,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xa6,0x00,0x00,0x00,0xb3,0x8e,0x00,0x00,0x00,0xb4,0x82,0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x86,0x01,0x01,0x00,0xb5,0x87,0x01,
+   0x01,0x01,0xb6,0x86,0x02,0x01,0x01,0xb7,0x86,0x02,0x01,0x01,0xb8,0x01,0x02,0x02,0x01,0xb8,0x02,0x01,0x01,0xb8,0x81,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,
+   0x88,0x03,0x02,0x01,0xba,0x85,0x03,0x02,0x02,0xbb,0x02,0x03,0x02,0x01,0xbb,0x04,0x02,0x02,0xbc,0x03,0x02,0x02,0xbc,0x85,0x04,0x02,0x02,0xbc,0x89,0x04,0x03,0x02,
+   0xbd,0x8d,0x04,0x03,0x02,0xbe,0x00,0x04,0x03,0x02,0xbf,0x89,0x05,0x03,0x02,0xbf,0x8c,0x05,0x03,0x02,0xc0,0x90,0x05,0x03,0x03,0xc0,0x00,0x05,0x04,0x03,0xc0,0x87,
+   0x05,0x03,0x03,0xc0,0x83,0x05,0x04,0x03,0xc0,0x02,0x05,0x04,0x01,0xc0,0x05,0x04,0x03,0xc0,0x05,0x04,0x01,0xc0,0x88,0x05,0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,
+   0x86,0x05,0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,0x8e,0x05,0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,0xa1,0x05,0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,0x98,0x05,
+   0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,0x92,0x05,0x04,0x03,0xc0,0x00,0x05,0x04,0x01,0xc0,0x8d,0x05,0x04,0x03,0xc0,0x99,0x05,0x03,0x03,0xc0,0x8c,0x05,0x03,0x02,
+   0xc0,0x8a,0x05,0x03,0x02,0xbf,0x02,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x00,0x04,0x03,0x02,0xbe,0x83,0x05,0x03,
+   0x02,0xbe,0x01,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x89,0x04,0x03,0x02,0xbd,0x85,0x04,0x02,0x02,0xbc,0x81,0x03,0x02,0x02,0xbc,0x86,
+   0x03,0x02,0x02,0xbb,0x88,0x03,0x02,0x01,0xba,0x81,0x03,0x02,0x01,0xb9,0x00,0x02,0x02,0x01,0xb9,0x88,0x02,0x01,0x01,0xb8,0x85,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,
+   0x01,0xb7,0x87,0x01,0x01,0x01,0xb6,0x86,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,0x82,0x01,0x00,0x00,0xb4,0x8e,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0x94,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa6,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb4,0x85,0x01,
+   0x00,0x00,0xb4,0x88,0x01,0x00,0x00,0xb5,0x81,0x01,0x01,0x00,0xb5,0x8c,0x01,0x01,0x01,0xb6,0x00,0x01,0x01,0x01,0xb7,0x87,0x02,0x01,0x01,0xb7,0x89,0x02,0x01,0x01,
+   0xb8,0x85,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x8b,0x03,0x02,0x01,0xba,0x89,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,0xbc,0x8c,0x04,0x02,0x02,0xbc,0xaf,
+   0x04,0x03,0x02,0xbd,0x83,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x88,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x83,0x04,0x03,0x02,0xbe,0x02,0x05,0x03,
+   0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x84,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x83,0x04,
+   0x03,0x02,0xbe,0x04,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x88,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,
+   0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x04,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,
+   0xbe,0x00,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x81,
+   0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,
+   0x02,0xbe,0x85,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x82,0x04,0x03,0x02,0xbe,0x81,0x05,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,
+   0x86,0x04,0x03,0x02,0xbe,0x02,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x81,0x04,0x03,0x02,0xbe,0x00,0x05,0x03,0x02,0xbe,0x85,0x04,0x03,0x02,
+   0xbe,0x81,0x05,0x03,0x02,0xbe,0x03,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x04,0x03,0x02,0xbe,0x05,0x03,0x02,0xbe,0x84,0x04,0x03,0x02,0xbe,0xaf,0x04,0x03,0x02,
+   0xbd,0x8a,0x04,0x02,0x02,0xbc,0x00,0x04,0x03,0x02,0xbc,0x81,0x04,0x02,0x02,0xbc,0x86,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x81,0x03,0x02,0x02,0xbb,0x8b,
+   0x03,0x02,0x01,0xba,0x00,0x03,0x02,0x01,0xb9,0x85,0x02,0x02,0x01,0xb9,0x89,0x02,0x01,0x01,0xb8,0x87,0x02,0x01,0x01,0xb7,0x00,0x01,0x01,0x01,0xb7,0x8c,0x01,0x01,
+   0x01,0xb6,0x81,0x01,0x01,0x00,0xb5,0x88,0x01,0x00,0x00,0xb5,0x85,0x01,0x00,0x00,0xb4,0x91,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0x94,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa8,0x00,0x00,0x00,0xb3,0x95,0x00,0x00,0x00,0xb4,0x83,0x01,0x00,0x00,0xb4,0x81,0x00,
+   0x00,0x00,0xb4,0x81,0x01,0x00,0x00,0xb4,0x00,0x01,0x00,0x00,0xb5,0x8c,0x01,0x01,0x00,0xb5,0x87,0x01,0x01,0x01,0xb6,0x01,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,
+   0x8c,0x02,0x01,0x01,0xb7,0x83,0x02,0x01,0x01,0xb8,0x00,0x02,0x02,0x01,0xb8,0x87,0x02,0x01,0x01,0xb8,0x83,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x9b,0x03,
+   0x02,0x01,0xba,0xa0,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x8f,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x8c,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x02,
+   0xbc,0x96,0x04,0x02,0x02,0xbc,0x00,0x04,0x03,0x02,0xbc,0xb0,0x04,0x02,0x02,0xbc,0x00,0x04,0x03,0x02,0xbc,0x92,0x04,0x02,0x02,0xbc,0x82,0x03,0x02,0x02,0xbb,0x00,
+   0x03,0x02,0x01,0xbb,0x8e,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0x82,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,0x01,0xbb,0xa2,0x03,0x02,0x02,0xbb,0x00,0x03,0x02,
+   0x01,0xbb,0x83,0x03,0x02,0x02,0xbb,0x9b,0x03,0x02,0x01,0xba,0x00,0x03,0x02,0x01,0xb9,0x83,0x02,0x02,0x01,0xb9,0x8c,0x02,0x01,0x01,0xb8,0x8e,0x02,0x01,0x01,0xb7,
+   0x87,0x01,0x01,0x01,0xb6,0x8c,0x01,0x01,0x00,0xb5,0x00,0x01,0x00,0x00,0xb5,0x81,0x01,0x00,0x00,0xb4,0x81,0x00,0x00,0x00,0xb4,0x83,0x01,0x00,0x00,0xb4,0x95,0x00,
+   0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x96,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb1,0x00,0x00,0x00,
+   0xb3,0x99,0x00,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb4,0x86,0x01,0x00,0x00,0xb5,0x81,0x01,0x01,0x00,0xb5,0x8e,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x01,0xb7,0x01,
+   0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,0x8a,0x02,0x01,0x01,0xb7,0x92,0x02,0x01,0x01,0xb8,0x02,0x02,0x02,0x01,0xb8,0x02,0x01,0x01,0xb8,0x02,0x02,0x01,0xb8,0x89,
+   0x02,0x01,0x01,0xb8,0x82,0x02,0x02,0x01,0xb9,0x00,0x03,0x02,0x01,0xb9,0x89,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0xff,0x03,0x02,0x01,0xba,0xbb,0x03,0x02,
+   0x01,0xba,0x81,0x03,0x02,0x01,0xb9,0x82,0x02,0x02,0x01,0xb9,0x81,0x03,0x02,0x01,0xb9,0x01,0x02,0x02,0x01,0xb9,0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x82,
+   0x03,0x02,0x01,0xb9,0x81,0x02,0x02,0x01,0xb9,0x9f,0x02,0x01,0x01,0xb8,0x8a,0x02,0x01,0x01,0xb7,0x03,0x01,0x01,0x01,0xb7,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,
+   0x02,0x01,0x01,0xb7,0x8e,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x00,0xb5,0x86,0x01,0x00,0x00,0xb5,0x87,0x01,0x00,0x00,0xb4,0x99,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x9f,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0x99,0x00,0x00,0x00,0xb4,
+   0x88,0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x89,0x01,0x01,0x00,0xb5,0x96,0x01,0x01,0x01,0xb6,0x01,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0xb7,0x9f,0x02,0x01,
+   0x01,0xb7,0xff,0x02,0x01,0x01,0xb8,0xc1,0x02,0x01,0x01,0xb8,0x9f,0x02,0x01,0x01,0xb7,0x01,0x01,0x01,0x01,0xb7,0x02,0x01,0x01,0xb7,0x96,0x01,0x01,0x01,0xb6,0x89,
+   0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,0x88,0x01,0x00,0x00,0xb4,0x99,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa7,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x9c,0x00,0x00,0x00,0xb4,0x8c,0x01,0x00,0x00,0xb4,0x8f,0x01,0x00,0x00,0xb5,
+   0x89,0x01,0x01,0x00,0xb5,0xd1,0x01,0x01,0x01,0xb6,0x81,0x01,0x01,0x01,0xb7,0xe1,0x02,0x01,0x01,0xb7,0x81,0x01,0x01,0x01,0xb7,0xd1,0x01,0x01,0x01,0xb6,0x89,0x01,
+   0x01,0x00,0xb5,0x88,0x01,0x00,0x00,0xb5,0x02,0x01,0x01,0x00,0xb5,0x01,0x00,0x00,0xb5,0x01,0x01,0x00,0xb5,0x83,0x01,0x00,0x00,0xb5,0x8c,0x01,0x00,0x00,0xb4,0x9c,
+   0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc7,0x00,0x00,
+   0x00,0xb3,0xa1,0x00,0x00,0x00,0xb4,0x93,0x01,0x00,0x00,0xb4,0x86,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x9e,0x01,0x00,0x00,0xb5,0xff,0x01,0x01,0x00,0xb5,
+   0xc7,0x01,0x01,0x00,0xb5,0x87,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x81,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x9a,0x01,0x00,0x00,0xb5,0x93,0x01,
+   0x00,0x00,0xb4,0xa1,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xd2,0x00,0x00,0x00,0xb3,0x87,0x00,0x00,0x00,0xb4,0x83,0x00,0x00,0x00,0xb3,0x9e,0x00,0x00,0x00,0xb4,0x91,0x01,0x00,0x00,0xb4,0x94,0x00,0x00,0x00,0xb4,0x8e,
+   0x01,0x00,0x00,0xb4,0x87,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x9a,0x01,0x00,0x00,0xb5,0xe1,0x01,0x00,0x00,0xb4,0x01,0x01,0x00,0x00,0xb5,0x01,0x01,0x00,
+   0xb5,0x9b,0x01,0x00,0x00,0xb5,0x00,0x01,0x01,0x00,0xb5,0x84,0x01,0x00,0x00,0xb5,0x8e,0x01,0x00,0x00,0xb4,0x94,0x00,0x00,0x00,0xb4,0x91,0x01,0x00,0x00,0xb4,0x9e,
+   0x00,0x00,0x00,0xb4,0x83,0x00,0x00,0x00,0xb3,0x87,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xeb,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb4,0xb9,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xd9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb4,0xff,0x00,
+   0x00,0x00,0xb4,0x93,0x00,0x00,0x00,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xec,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfc,0x00,0x00,0x00,0xb3,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfa,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,
+   0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf9,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x85,
+   0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfb,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfa,0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xff,0xff,0xff,0xff,0xbb,0xbb,
+   0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xfb,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x86,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,
+   0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x8d,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0xc2,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,
+   0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,
+   0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x8b,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x00,0x52,
+   0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x8b,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x84,
+   0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x92,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,
+   0xeb,0x52,0x52,0x52,0xbd,0x95,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0xa7,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x02,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xc7,0xc7,
+   0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,
+   0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,
+   0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,
+   0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,
+   0xc2,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,
+   0xe6,0x82,0xff,0xff,0xff,0xff,0x04,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,
+   0x01,0xc7,0xc7,0xc7,0xe1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,
+   0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x06,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,
+   0xbd,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,
+   0x04,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,
+   0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0xdc,0xdc,0xdc,0xeb,0xff,0xff,
+   0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,
+   0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x05,0x90,0x90,0x90,0xcc,0xe6,
+   0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,
+   0xc2,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,
+   0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x87,0x00,
+   0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,
+   0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x03,0x00,
+   0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0xff,0xff,0xff,0xff,0x03,
+   0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,
+   0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,
+   0xe1,0x82,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x87,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,
+   0xe6,0xf0,0x81,0x90,0x90,0x90,0xcc,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,
+   0xdc,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,
+   0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,
+   0xbd,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,
+   0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,
+   0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x07,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,
+   0xb8,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x05,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,
+   0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,
+   0xd6,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,
+   0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x06,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,
+   0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x90,0x90,0x90,0xcc,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0x7e,0x7e,
+   0x7e,0xc7,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0x84,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,
+   0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x83,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x82,
+   0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,
+   0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,
+   0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,
+   0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x82,
+   0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x52,0x52,0x52,0xbd,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,
+   0xc7,0xe1,0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0x84,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x0e,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,
+   0x81,0xf7,0xf7,0xf7,0xfa,0x03,0xff,0xff,0xff,0xff,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8b,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,
+   0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,
+   0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x09,
+   0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,
+   0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,
+   0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,
+   0x85,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,
+   0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,
+   0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xbb,0xbb,
+   0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,
+   0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,
+   0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x81,0xc7,0xc7,0xc7,0xe1,0x03,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,
+   0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,
+   0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x87,0x00,
+   0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,
+   0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,
+   0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,
+   0xbb,0xdc,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x84,0x00,0x00,0x00,0xb3,0x03,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,
+   0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xaf,
+   0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,
+   0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,
+   0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf3,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,
+   0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,
+   0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0xf7,0xf7,
+   0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,
+   0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,
+   0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,
+   0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,
+   0xc7,0xe1,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,
+   0xfa,0x81,0xff,0xff,0xff,0xff,0x05,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,
+   0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,
+   0xeb,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,
+   0xff,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,
+   0xdc,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xf3,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x03,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xd2,0xd2,0xd2,0xe6,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x85,0xff,0xff,
+   0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x03,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x03,0xe6,0xe6,
+   0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0x00,0x00,0x00,0xb3,0x01,0x33,
+   0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,
+   0x01,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,
+   0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x85,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0xc7,
+   0xc7,0xc7,0xe1,0x85,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,
+   0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x84,0xff,
+   0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,
+   0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,
+   0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,
+   0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x0b,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,
+   0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,
+   0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,
+   0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,
+   0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,
+   0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x06,0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,
+   0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,
+   0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,
+   0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,
+   0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x04,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xef,0xef,0xef,0xf5,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x05,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x6a,0x6a,
+   0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x82,0x00,
+   0x00,0x00,0xb3,0x05,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xf6,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0xbe,0x00,0x00,0x00,0xb3,0x03,0x90,0x90,0x90,0xcc,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0xab,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,
+   0xb8,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x91,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,
+   0xf0,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xf6,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbf,0x00,0x00,0x00,0xb3,0x02,
+   0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xa0,0xa0,0xa0,0xd1,0xaa,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,
+   0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x90,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xf2,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xf6,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbf,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,
+   0xd6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0xaa,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x90,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,
+   0x83,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x83,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0xf6,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbf,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0xaa,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0x90,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf9,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0xaf,0xaf,0xaf,0xd6,0xc0,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x03,0x00,
+   0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x8a,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,
+   0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,
+   0x7e,0x7e,0x7e,0xc7,0x9e,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x8d,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x88,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x9e,0x00,0x00,0x00,0xb3,
+   0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x84,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x8b,0x00,0x00,0x00,
+   0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x9a,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,
+   0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,
+   0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x84,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,
+   0x52,0x52,0x52,0xbd,0x8f,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0x85,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x82,
+   0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x04,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x6a,
+   0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,
+   0x01,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x01,
+   0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,
+   0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x05,0xdc,
+   0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x84,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,
+   0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,
+   0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x03,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,
+   0xfa,0xef,0xef,0xef,0xf5,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x84,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,
+   0x6a,0x6a,0x6a,0xc2,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x85,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x85,
+   0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,
+   0xff,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x09,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xef,0xef,
+   0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x85,0xff,0xff,0xff,0xff,0x03,
+   0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x06,0xf7,0xf7,0xf7,0xfa,0xa0,
+   0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,
+   0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x90,0x90,0x90,0xcc,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,
+   0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x07,0xef,0xef,0xef,0xf5,0xff,0xff,
+   0xff,0xff,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,
+   0xb3,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,
+   0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xe6,
+   0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,
+   0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,
+   0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x04,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,
+   0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,
+   0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xaf,0xaf,0xaf,0xd6,0x05,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,
+   0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,
+   0x00,0x00,0x00,0xb3,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,
+   0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0x52,0x52,0x52,0xbd,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,
+   0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,
+   0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x82,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,
+   0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x03,0xef,0xef,0xef,0xf5,
+   0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,
+   0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,
+   0xbb,0xbb,0xdc,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,
+   0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x82,0x00,0x00,0x00,0xb3,
+   0x01,0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x84,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,
+   0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,
+   0x52,0x52,0x52,0xbd,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,
+   0xff,0x05,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xbb,0xbb,
+   0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x04,0xdc,0xdc,
+   0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,
+   0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x85,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,
+   0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,
+   0xd1,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x09,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,
+   0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,
+   0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,
+   0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x06,0x52,0x52,0x52,0xbd,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,
+   0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x01,
+   0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0xaf,0xaf,
+   0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,
+   0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x83,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,
+   0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x85,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,
+   0x85,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,
+   0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x85,0xff,0xff,0xff,0xff,0x02,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x85,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,
+   0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,
+   0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0xff,0xff,0xff,0xff,0x01,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x86,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,
+   0x84,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x04,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,
+   0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,
+   0xff,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x82,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xfe,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,
+   0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x0a,
+   0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x06,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x33,0x33,
+   0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x02,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,
+   0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,
+   0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,
+   0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,
+   0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,
+   0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,
+   0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,
+   0xd6,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x0b,0xbb,0xbb,0xbb,0xdc,
+   0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,
+   0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xd2,0xd2,0xd2,0xe6,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x08,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,
+   0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,
+   0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,
+   0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,
+   0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x82,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,
+   0xbd,0x6a,0x6a,0x6a,0xc2,0xad,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x94,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x9f,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9a,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xaf,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa1,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x83,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0xac,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x94,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x9f,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9a,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xaf,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x83,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0xac,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xaf,0xaf,0xaf,0xd6,0x92,0x00,
+   0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x9f,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x9a,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xaf,0x00,0x00,0x00,0xb3,
+   0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,
+   0xf5,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xad,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xb6,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9a,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xb6,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,
+   0xff,0xff,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0xb2,0x00,0x00,
+   0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0xb6,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xaf,0xaf,0xaf,0xd6,0x9a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xda,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa7,0x00,0x00,0x00,
+   0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0x97,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,
+   0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb8,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xe4,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xbe,0x00,0x00,0x00,0xb3,0x00,0xf7,
+   0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0xb4,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xdd,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xe4,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xbe,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xb3,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xdd,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xe4,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xbe,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,
+   0xc2,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0xb3,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xdd,0x00,0x00,0x00,
+   0xb3,0x81,0x33,0x33,0x33,0xb8,0x01,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,
+   0x52,0x52,0x52,0xbd,0x97,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x90,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,
+   0x00,0x33,0x33,0x33,0xb8,0x94,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x91,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,
+   0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x88,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0xa7,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,
+   0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,
+   0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,
+   0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x8a,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x86,0x00,
+   0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,
+   0xb8,0x9b,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,
+   0x52,0x52,0x52,0xbd,0x85,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x8d,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,
+   0x81,0x7e,0x7e,0x7e,0xc7,0x8e,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x04,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,
+   0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x92,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,
+   0x81,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,
+   0xc7,0x00,0x33,0x33,0x33,0xb8,0x8a,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb4,0x00,0x00,
+   0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,
+   0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x87,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xbb,
+   0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x86,0x00,
+   0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,
+   0xfa,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,
+   0xc7,0xc7,0xe1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x01,0xdc,
+   0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,
+   0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,
+   0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x01,
+   0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x87,0x00,0x00,0x00,0xb3,
+   0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x07,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,
+   0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x83,
+   0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,
+   0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,
+   0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x05,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,
+   0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,
+   0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb3,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,
+   0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x86,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,
+   0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,
+   0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,
+   0xef,0xf5,0x83,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x85,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,
+   0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,
+   0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x07,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0xff,0xff,
+   0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,
+   0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x02,
+   0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x85,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,
+   0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xb4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,
+   0xff,0xff,0xff,0xff,0x06,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,
+   0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,
+   0xfa,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,
+   0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,
+   0xf7,0xfa,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,
+   0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,
+   0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,
+   0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,
+   0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x03,
+   0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x6a,0x6a,
+   0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x04,0xbb,0xbb,0xbb,0xdc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x07,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,
+   0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,
+   0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x05,
+   0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,
+   0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb4,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,
+   0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,
+   0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,
+   0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x8a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x33,0x33,
+   0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,
+   0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,
+   0x82,0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,
+   0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x01,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,
+   0xe6,0xe6,0xe6,0xf0,0x01,0xff,0xff,0xff,0xff,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x82,0x00,0x00,0x00,0xb3,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,
+   0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x81,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,
+   0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb3,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x8b,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x92,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,
+   0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,
+   0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x02,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0x87,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x01,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x06,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,0xdc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb3,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xb2,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,
+   0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x8b,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x8f,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0xef,0xef,0xef,0xf5,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,
+   0x00,0x00,0xb3,0x03,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x05,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,
+   0xc7,0xe1,0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,
+   0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x86,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,
+   0xe6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x52,0x52,0x52,0xbd,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,
+   0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,
+   0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,
+   0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x88,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,
+   0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb3,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x05,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,
+   0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x03,0xc7,
+   0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,
+   0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,
+   0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,
+   0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x8d,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x04,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x05,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x33,
+   0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,
+   0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x05,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,
+   0xc2,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,
+   0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,
+   0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x87,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0x52,0x52,
+   0x52,0xbd,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb3,
+   0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x85,0xff,0xff,0xff,0xff,0x01,0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,
+   0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,
+   0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,
+   0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,
+   0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x89,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x8c,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xbb,0xbb,0xbb,0xdc,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,
+   0x86,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,
+   0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,
+   0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,
+   0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,
+   0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,
+   0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,
+   0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,
+   0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb4,0x00,0x00,0x00,0xb3,0x07,0x6a,0x6a,0x6a,0xc2,
+   0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x04,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,
+   0x81,0xdc,0xdc,0xdc,0xeb,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,
+   0xb3,0x05,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,
+   0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x02,
+   0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,
+   0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x05,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,
+   0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0xa0,0xa0,0xa0,
+   0xd1,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0x8a,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x8b,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x85,0x00,0x00,0x00,0xb3,0x01,0xdc,0xdc,0xdc,0xeb,0xe6,
+   0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x05,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,
+   0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x01,0xa0,
+   0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x03,
+   0xbb,0xbb,0xbb,0xdc,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,
+   0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,
+   0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,
+   0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,
+   0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,
+   0x05,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x05,0x52,
+   0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,
+   0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0x7e,0x7e,0x7e,0xc7,0xdc,0xdc,0xdc,0xeb,0xff,
+   0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,
+   0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x88,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,
+   0xf5,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x07,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb1,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,
+   0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbd,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9d,
+   0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x8b,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0xc0,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xdd,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbd,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x98,0x00,0x00,0x00,0xb3,0x85,0xdc,0xdc,0xdc,0xeb,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x8a,
+   0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x05,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xe6,
+   0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xbf,0x00,0x00,0x00,0xb3,
+   0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x7e,0x7e,0x7e,0xc7,0xdc,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xbd,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x98,0x00,0x00,0x00,0xb3,0x88,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x8b,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,
+   0xbd,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0x90,0x90,0x90,0xcc,0xda,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x90,
+   0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0xbd,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x98,0x00,0x00,0x00,0xb3,0x88,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x8c,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xc7,0xc7,0xc7,0xe1,0x52,0x52,
+   0x52,0xbd,0xc6,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,
+   0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xda,0x00,0x00,0x00,0xb3,0x03,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x90,0x90,
+   0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x8a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,
+   0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0xbd,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,
+   0xd6,0xff,0x00,0x00,0x00,0xb3,0x83,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xdc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc9,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,
+   0xc7,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc8,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,
+   0xf5,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc8,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc8,0x00,0x00,0x00,0xb3,0x81,0x33,0x33,0x33,0xb8,0x01,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xaf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xae,
+   0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x6a,0x6a,0x6a,0xc2,0x90,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,
+   0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x8c,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,
+   0x7e,0xc7,0x33,0x33,0x33,0xb8,0x8e,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x87,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x8b,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x02,0x52,
+   0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x92,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x8c,0x00,0x00,
+   0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x83,0x00,0x00,0x00,0xb3,
+   0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x94,0x00,0x00,0x00,
+   0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x94,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x84,0x00,0x00,
+   0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x88,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x92,0x00,
+   0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x87,
+   0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0xa5,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,
+   0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x90,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x92,0x00,
+   0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x86,
+   0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x8d,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,
+   0x85,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xaf,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,
+   0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,
+   0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,
+   0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,
+   0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x33,0x33,
+   0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,
+   0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x33,0x33,
+   0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,
+   0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xd2,
+   0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x03,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,
+   0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,
+   0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,
+   0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,
+   0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,
+   0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,
+   0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x03,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xf7,
+   0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xef,0xef,
+   0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,
+   0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,
+   0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,
+   0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,
+   0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xaf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x04,0xaf,
+   0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,
+   0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x86,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,
+   0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,
+   0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,
+   0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,
+   0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x86,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,
+   0xe6,0xf0,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,
+   0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xbb,0xbb,0xbb,0xdc,0x85,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x86,
+   0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x88,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x86,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,
+   0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,
+   0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xae,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0x03,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x90,0x90,
+   0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,
+   0x90,0x90,0x90,0xcc,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x7e,
+   0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xa0,
+   0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,
+   0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x07,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,
+   0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,
+   0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,
+   0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,
+   0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x88,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x90,0x90,
+   0x90,0xcc,0x03,0xd2,0xd2,0xd2,0xe6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,
+   0x90,0x90,0x90,0xcc,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,
+   0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,
+   0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x7e,
+   0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,
+   0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xae,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,
+   0xb3,0x02,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,
+   0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x02,0xdc,
+   0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,
+   0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,
+   0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,
+   0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x02,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x88,0x00,0x00,0x00,0xb3,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,
+   0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,
+   0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x01,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x6a,0x6a,0x6a,0xc2,0x87,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,
+   0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,
+   0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x88,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,
+   0x04,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0x86,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x01,0x52,
+   0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,
+   0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0x85,0xff,
+   0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x87,
+   0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,
+   0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,
+   0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0x6a,
+   0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x8c,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,
+   0x02,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x06,
+   0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,0xdc,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,
+   0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,
+   0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,
+   0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,
+   0xf7,0xfa,0x85,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,
+   0x83,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,
+   0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xc7,0xc7,0xc7,
+   0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,
+   0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,
+   0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,
+   0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,
+   0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,
+   0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,
+   0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,
+   0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,
+   0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xe6,0xe6,0xe6,0xf0,0x8c,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,
+   0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x03,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x03,
+   0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,
+   0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x09,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x03,0x52,0x52,0x52,0xbd,
+   0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x85,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x09,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,
+   0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,
+   0x03,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,
+   0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,
+   0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,
+   0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,
+   0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,
+   0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,
+   0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0xaf,0xaf,
+   0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,
+   0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x86,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,
+   0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xac,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,
+   0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,
+   0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x85,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,
+   0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x06,0xbb,
+   0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,
+   0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xf7,
+   0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,
+   0xe1,0x00,0x00,0x00,0xb3,0x86,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,
+   0xf0,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x84,
+   0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,
+   0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x85,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,
+   0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,
+   0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xa0,
+   0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x7e,0x7e,
+   0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x03,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,
+   0xe6,0xe6,0xe6,0xf0,0x87,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x82,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xac,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xad,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0x81,0xff,
+   0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,
+   0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,0x90,0xcc,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x88,0x00,0x00,0x00,0xb3,0x0a,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x07,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x05,0xef,0xef,0xef,
+   0xf5,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,
+   0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,
+   0xc7,0xe1,0x33,0x33,0x33,0xb8,0x83,0x00,0x00,0x00,0xb3,0x04,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,
+   0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x06,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,
+   0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,
+   0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,
+   0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0xa0,
+   0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,
+   0xf5,0x90,0x90,0x90,0xcc,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,
+   0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,
+   0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,
+   0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,
+   0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x06,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,
+   0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x84,0x00,0x00,0x00,0xb3,0x01,
+   0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x06,
+   0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,
+   0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,
+   0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,
+   0x81,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,
+   0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,
+   0xf0,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xab,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9b,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x98,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x93,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xb6,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xb9,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x84,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xdc,0xdc,0xdc,0xeb,0xbc,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbd,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9b,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x04,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x98,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x93,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xb6,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0xb9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xbc,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9b,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa9,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x98,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x93,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x81,0xbb,0xbb,
+   0xbb,0xdc,0xb4,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xb9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x01,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8c,0x00,0x00,
+   0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x88,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,
+   0x81,0xbb,0xbb,0xbb,0xdc,0xba,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbd,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x9b,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0xb0,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,
+   0xff,0xb4,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xb9,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x99,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0xba,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xbd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb5,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x9b,0x00,
+   0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,
+   0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0xa9,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0xb0,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x88,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xd2,0xd2,0xd2,0xe6,0x81,0xdc,0xdc,0xdc,0xeb,0xb4,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xaf,0xaf,0xaf,0xd6,0xe1,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xd2,0xd2,0xd2,0xe6,0x81,0xdc,0xdc,0xdc,0xeb,0xba,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,
+   0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc9,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,
+   0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x87,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x88,0x00,0x00,0x00,0xb3,0x00,
+   0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0xa0,0x00,0x00,0x00,0xb3,
+   0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x92,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x8f,0x00,
+   0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x99,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x84,
+   0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,
+   0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,
+   0xc7,0x86,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x8a,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,
+   0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x8c,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,
+   0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x8e,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x8a,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,
+   0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,
+   0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x9f,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x84,0x00,
+   0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x87,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,
+   0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,
+   0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,
+   0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,
+   0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,
+   0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,
+   0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x06,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,
+   0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x01,
+   0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,
+   0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,
+   0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,
+   0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x83,0xff,
+   0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,
+   0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x03,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0xef,0xef,0xef,0xf5,0x52,0x52,0x52,0xbd,0x86,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,
+   0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,
+   0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,
+   0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,
+   0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x82,
+   0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xb6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,
+   0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,
+   0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,
+   0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,
+   0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,
+   0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0xff,0xff,
+   0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0xe6,
+   0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,
+   0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,
+   0xff,0xff,0x06,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x05,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,
+   0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,
+   0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x7e,0x7e,
+   0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,
+   0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,
+   0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,
+   0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0x87,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x04,0x6a,0x6a,0x6a,0xc2,0xbb,0xbb,
+   0xbb,0xdc,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,
+   0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,
+   0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x90,
+   0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,
+   0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x90,0x90,
+   0x90,0xcc,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,
+   0xd1,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,
+   0xf0,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0x6a,
+   0x6a,0x6a,0xc2,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x86,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,
+   0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,0xef,
+   0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,
+   0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x03,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,
+   0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,
+   0xef,0xf5,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,
+   0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x02,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,
+   0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,
+   0xd6,0x87,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,
+   0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,
+   0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x01,0x52,
+   0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x90,0x90,0x90,0xcc,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x02,0xc7,0xc7,0xc7,0xe1,0xff,
+   0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,
+   0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,
+   0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x02,0x7e,0x7e,0x7e,0xc7,0xbb,0xbb,0xbb,0xdc,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0x52,0x52,0x52,0xbd,0x87,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,
+   0x7e,0xc7,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x85,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,
+   0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,
+   0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,
+   0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,
+   0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,
+   0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x87,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,
+   0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x86,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x8b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x87,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xd2,
+   0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x05,
+   0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x05,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,
+   0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,
+   0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,
+   0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,
+   0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0xff,0xff,
+   0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,
+   0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,
+   0xf7,0xf7,0xfa,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xc7,0xc7,
+   0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,
+   0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,
+   0x00,0xb3,0x03,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x86,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x8b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x84,0xaf,0xaf,0xaf,0xd6,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x7e,0x7e,0x7e,0xc7,0x02,0xe6,
+   0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,0x04,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,
+   0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,
+   0xe6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0xbb,0xbb,0xbb,0xdc,0x82,
+   0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,
+   0xc7,0xc7,0xe1,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,
+   0xd1,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,
+   0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,
+   0xdc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,
+   0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x89,0xff,0xff,0xff,0xff,0x0a,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,
+   0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x08,0xaf,0xaf,0xaf,
+   0xd6,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,
+   0xb8,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,
+   0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xa0,0xa0,0xa0,
+   0xd1,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x85,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xff,0xff,0xff,0xff,0x0d,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,
+   0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,
+   0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x03,0xc7,0xc7,0xc7,0xe1,
+   0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x0d,0x52,0x52,0x52,0xbd,0x33,0x33,0x33,
+   0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,
+   0xb8,0x52,0x52,0x52,0xbd,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x8c,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x09,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,
+   0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,
+   0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,
+   0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x05,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,
+   0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,
+   0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,
+   0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x87,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x04,0xe6,0xe6,0xe6,0xf0,0xff,
+   0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xb3,0x86,0xff,0xff,0xff,0xff,0x01,0x00,
+   0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,
+   0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x85,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,
+   0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x03,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,
+   0xf0,0x84,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,
+   0x01,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x85,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x85,0xff,0xff,0xff,0xff,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0x90,0x90,0x90,0xcc,0x84,0xff,0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x85,0xff,0xff,0xff,0xff,0x00,
+   0x90,0x90,0x90,0xcc,0x8c,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0xff,0xff,
+   0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x04,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,
+   0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x03,0xaf,
+   0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x04,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,
+   0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x85,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,
+   0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x05,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,
+   0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xa0,0xa0,
+   0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,
+   0x05,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,
+   0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,
+   0x82,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x01,
+   0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x02,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,
+   0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x85,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,
+   0xff,0xff,0xff,0x04,0xe6,0xe6,0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x04,0x90,0x90,
+   0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x04,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,
+   0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x06,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,
+   0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x0a,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,
+   0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,
+   0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x83,
+   0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x03,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,
+   0xd1,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,
+   0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,
+   0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x8d,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xe6,0xe6,0xe6,0xf0,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,
+   0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xd2,
+   0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0xc7,
+   0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xdc,0xdc,0xdc,
+   0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb6,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb8,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x94,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x91,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x96,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x8c,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x96,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x9b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x94,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xcb,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x9a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x94,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,
+   0x33,0x33,0x33,0xb8,0x93,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x91,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x95,0x00,0x00,0x00,0xb3,0x05,0xdc,0xdc,0xdc,0xeb,
+   0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x96,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x84,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x9b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x94,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xcb,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x9a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x94,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb7,0x00,0x00,
+   0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x93,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x91,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x95,0x00,
+   0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x8c,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,
+   0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x96,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x9b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x94,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,
+   0xaf,0xaf,0xaf,0xd6,0xc9,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x9a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x94,0x00,0x00,0x00,0xb3,
+   0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xb9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xb7,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x94,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x91,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x95,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x88,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x93,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x96,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x9b,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xa0,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x92,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xc9,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x84,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x9a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd1,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xcf,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0x91,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x91,
+   0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0xa1,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,
+   0xaf,0xd6,0x93,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0xbe,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,
+   0xa0,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x92,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0xf0,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd1,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa3,0x00,0x00,0x00,0xb3,0x82,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xd8,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa0,0x00,0x00,
+   0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x84,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xd6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa0,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xd5,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xa1,0x00,0x00,0x00,0xb3,0x05,0xef,
+   0xef,0xef,0xf5,0xe6,0xe6,0xe6,0xf0,0xa0,0xa0,0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,
+   0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xce,
+   0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,
+   0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x8c,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,
+   0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x91,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0x94,0x00,0x00,0x00,0xb3,0x02,0x6a,
+   0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x90,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x9a,0x00,0x00,0x00,0xb3,0x02,
+   0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0xa3,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0xa6,0x00,
+   0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x6a,0x6a,0x6a,0xc2,0x8a,0x00,0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x91,0x00,0x00,
+   0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0x9a,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x86,0x00,
+   0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x8a,0x00,0x00,0x00,0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,
+   0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x88,0x00,0x00,0x00,0xb3,0x02,
+   0x6a,0x6a,0x6a,0xc2,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x8f,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc1,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,
+   0xe1,0x81,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,
+   0xb3,0x01,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x03,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,
+   0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xef,0xef,
+   0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,0xdc,0xeb,0x82,
+   0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,
+   0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xef,
+   0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,
+   0x01,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x05,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,
+   0xeb,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,
+   0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x86,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,
+   0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x01,
+   0x7e,0x7e,0x7e,0xc7,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,
+   0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,
+   0x01,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0xdc,0xdc,
+   0xdc,0xeb,0x83,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x09,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x87,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,
+   0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,
+   0x86,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,
+   0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,
+   0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x06,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,
+   0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,
+   0xf7,0xf7,0xf7,0xfa,0x81,0xbb,0xbb,0xbb,0xdc,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,
+   0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,
+   0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,
+   0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x86,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x84,
+   0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x86,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x33,0x33,0x33,0xb8,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0x81,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x07,0xef,0xef,0xef,
+   0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,
+   0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,
+   0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,
+   0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,
+   0xa0,0xd1,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,
+   0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,
+   0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,
+   0xb8,0x83,0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,
+   0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,
+   0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,
+   0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,
+   0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x03,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,
+   0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,
+   0xff,0xff,0xff,0x03,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,0xcc,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x03,0xa0,0xa0,0xa0,0xd1,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,
+   0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,
+   0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x04,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xaf,0xaf,0xaf,0xd6,
+   0x05,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,
+   0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,
+   0x00,0x00,0xb3,0x02,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,
+   0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,
+   0xff,0xff,0x06,0x33,0x33,0x33,0xb8,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,
+   0x00,0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,0xdc,0x33,0x33,0x33,0xb8,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x7e,0x7e,0x7e,0xc7,0x04,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,
+   0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,
+   0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,
+   0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,
+   0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,
+   0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,
+   0x04,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,
+   0xc2,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x6a,0x6a,0x6a,0xc2,0x00,
+   0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x81,0x00,0x00,0x00,0xb3,0x02,0xa0,0xa0,0xa0,0xd1,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,
+   0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,
+   0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,
+   0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,
+   0xcc,0x81,0xff,0xff,0xff,0xff,0x09,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xbb,
+   0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,0xf0,0x86,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,
+   0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x06,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,0xff,0xff,0xff,0xff,0xe6,0xe6,0xe6,
+   0xf0,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x03,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,
+   0xb8,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x05,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,
+   0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xe6,0xe6,0xe6,0xf0,0x85,0xff,
+   0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,
+   0xeb,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x01,0xf7,
+   0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,
+   0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x82,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,
+   0xbd,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x88,0x00,0x00,0x00,0xb3,0x01,
+   0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,0x04,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xdc,0xdc,
+   0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,
+   0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,
+   0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,
+   0xd1,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x03,0x52,0x52,0x52,0xbd,0xbb,0xbb,0xbb,0xdc,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,
+   0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,0xff,0x01,
+   0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x06,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xef,0xef,
+   0xef,0xf5,0xff,0xff,0xff,0xff,0xd2,0xd2,0xd2,0xe6,0x82,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x90,0x90,0x90,0xcc,0x81,0xaf,0xaf,0xaf,0xd6,0x04,0xef,0xef,
+   0xef,0xf5,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,
+   0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,
+   0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,0x6a,0xc2,0x89,0x00,0x00,0x00,0xb3,0x01,
+   0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,
+   0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,
+   0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,
+   0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x05,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,
+   0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,
+   0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc0,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0x00,0x00,0x00,0xb3,0x05,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x33,0x33,0x33,0xb8,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,
+   0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xc7,
+   0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x87,0x00,0x00,0x00,0xb3,0x09,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,
+   0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,
+   0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x82,0xff,0xff,0xff,0xff,0x02,
+   0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x04,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x81,
+   0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,
+   0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,
+   0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x86,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x02,
+   0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x81,0xff,
+   0xff,0xff,0xff,0x0b,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,
+   0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x04,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,
+   0xaf,0xd6,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,
+   0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,
+   0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x02,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x6a,0x6a,
+   0x6a,0xc2,0x87,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x01,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,
+   0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0xbb,0xbb,0xbb,0xdc,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,
+   0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,
+   0xff,0xff,0xff,0xff,0x06,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xaf,0xaf,0xaf,0xd6,0x01,0x52,0x52,0x52,0xbd,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x06,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,
+   0xd6,0xc7,0xc7,0xc7,0xe1,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xaf,0xaf,0xaf,0xd6,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x02,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,
+   0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x03,0xe6,
+   0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xc0,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xaf,0xaf,0xaf,
+   0xd6,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x03,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,
+   0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x04,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x87,0x00,0x00,0x00,0xb3,0x04,0xdc,
+   0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,
+   0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0xff,0xff,0xff,0xff,0x03,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x03,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,
+   0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x02,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,
+   0xff,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x04,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,
+   0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x02,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x81,0xff,0xff,0xff,0xff,0x06,0xa0,0xa0,0xa0,0xd1,0x00,
+   0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,
+   0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,
+   0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,
+   0xd6,0x81,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,
+   0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,
+   0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x85,
+   0x00,0x00,0x00,0xb3,0x04,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xef,
+   0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xdc,0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x81,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,
+   0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,
+   0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x81,0x00,0x00,0x00,0xb3,0x05,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x83,0x00,
+   0x00,0x00,0xb3,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xd2,0xd2,0xd2,0xe6,0x52,0x52,0x52,0xbd,
+   0x82,0x00,0x00,0x00,0xb3,0x05,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0x87,0x00,0x00,0x00,0xb3,0x02,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,
+   0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,
+   0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x04,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,
+   0xcc,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x02,0xf7,
+   0xf7,0xf7,0xfa,0xdc,0xdc,0xdc,0xeb,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x06,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,
+   0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,
+   0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,
+   0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,
+   0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x52,0x52,0x52,0xbd,0x85,0x00,0x00,0x00,0xb3,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,
+   0xf7,0xf7,0xf7,0xfa,0xd2,0xd2,0xd2,0xe6,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0xaf,0xaf,0xaf,
+   0xd6,0x00,0x00,0x00,0xb3,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x7e,0x7e,0x7e,0xc7,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x05,0x7e,0x7e,0x7e,0xc7,0xc7,0xc7,0xc7,0xe1,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x00,
+   0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x04,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,
+   0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,
+   0xdc,0xeb,0x04,0x6a,0x6a,0x6a,0xc2,0xef,0xef,0xef,0xf5,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xf5,0x90,0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,
+   0xb8,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,
+   0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xaf,0xaf,0xaf,0xd6,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,
+   0x00,0xb3,0x06,0x7e,0x7e,0x7e,0xc7,0xd2,0xd2,0xd2,0xe6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xd2,0xd2,0xd2,0xe6,0x52,0x52,0x52,0xbd,0x81,
+   0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x05,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,
+   0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x05,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xaf,0xaf,0xaf,0xd6,
+   0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,
+   0xc2,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x81,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,
+   0x00,0xb3,0x08,0x33,0x33,0x33,0xb8,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0xbb,
+   0xbb,0xbb,0xdc,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xdc,0xdc,0xdc,0xeb,0x81,0x6a,0x6a,0x6a,0xc2,0x81,0xdc,0xdc,0xdc,0xeb,
+   0x04,0xa0,0xa0,0xa0,0xd1,0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,
+   0xf0,0x81,0xff,0xff,0xff,0xff,0x03,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,
+   0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x01,0x00,0x00,0x00,0xb3,0xbb,0xbb,0xbb,0xdc,0x81,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x06,0x52,0x52,0x52,0xbd,0xc7,0xc7,
+   0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xf7,0xf7,0xf7,0xfa,0xc7,0xc7,0xc7,0xe1,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x81,0xdc,0xdc,0xdc,0xeb,
+   0x05,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x01,0xaf,
+   0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x9a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0xa1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0xb1,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0x52,0x52,0x52,0xbd,0xbe,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x95,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x9d,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x33,
+   0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xdd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x9a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,
+   0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xb0,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0xbd,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x03,0x33,0x33,
+   0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0x94,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x9d,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x03,0xdc,0xdc,0xdc,0xeb,0xff,0xff,0xff,0xff,0xf7,
+   0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xdc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xbf,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x9b,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,
+   0xff,0xff,0xff,0xa1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x81,0xbb,0xbb,0xbb,0xdc,0x8b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x81,0xff,0xff,
+   0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0xb0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0xbd,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x94,0x00,0x00,0x00,
+   0xb3,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x6a,0x6a,0x6a,0xc2,0x9d,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x52,0x52,0x52,0xbd,0x82,
+   0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xdc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbf,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x85,0xdc,0xdc,0xdc,0xeb,0x01,0xbb,0xbb,0xbb,0xdc,0x7e,0x7e,0x7e,0xc7,0x9c,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0xa1,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,
+   0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x8b,0x00,0x00,0x00,0xb3,0x81,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xaf,
+   0xaf,0xaf,0xd6,0x81,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xa9,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,
+   0xb3,0x81,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xb0,0x00,0x00,0x00,0xb3,0x03,0x90,0x90,0x90,0xcc,0xf7,0xf7,0xf7,0xfa,0xef,0xef,0xef,0xf5,0x52,0x52,0x52,
+   0xbd,0xbd,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x02,0xdc,0xdc,0xdc,0xeb,0xff,
+   0xff,0xff,0xff,0xaf,0xaf,0xaf,0xd6,0xbc,0x00,0x00,0x00,0xb3,0x02,0xaf,0xaf,0xaf,0xd6,0xff,0xff,0xff,0xff,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xdd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xe5,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,
+   0xd6,0xa1,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,0xa0,0xd1,0x88,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xd2,0xd2,0xd2,0xe6,0x81,0xdc,
+   0xdc,0xdc,0xeb,0x8b,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x81,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x52,0x52,0x52,0xbd,0xa9,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0xa0,0xa0,
+   0xa0,0xd1,0xf2,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x81,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xa7,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xbb,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xaf,0xaf,0xaf,0xd6,
+   0x01,0x90,0x90,0x90,0xcc,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x89,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xa0,0xa0,0xa0,
+   0xd1,0x82,0xaf,0xaf,0xaf,0xd6,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xcb,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0x7e,0x7e,0x7e,0xc7,0x83,0xaf,
+   0xaf,0xaf,0xd6,0x01,0x7e,0x7e,0x7e,0xc7,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8b,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xe6,0xe6,0xe6,0xf0,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x01,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,
+   0xb3,0x8a,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,
+   0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,
+   0x7e,0xc7,0xef,0xef,0xef,0xf5,0x84,0xff,0xff,0xff,0xff,0x04,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x88,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x01,0xef,0xef,
+   0xef,0xf5,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,
+   0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x89,0x00,0x00,0x00,0xb3,0x8b,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x91,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,
+   0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x88,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x02,0xc7,0xc7,0xc7,0xe1,0x00,0x00,0x00,
+   0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,
+   0xff,0xff,0x02,0xd2,0xd2,0xd2,0xe6,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x01,0x33,
+   0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0xff,
+   0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0xc7,0xc7,0xc7,0xe1,0x87,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0xbb,0xbb,0xbb,0xdc,0x52,
+   0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,
+   0x00,0x00,0x00,0xb3,0x8b,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,
+   0x87,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x88,0xff,0xff,0xff,0xff,0x01,
+   0xd2,0xd2,0xd2,0xe6,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0xff,0xff,0xff,
+   0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x87,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x8b,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x90,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x85,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,
+   0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x86,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x83,0xff,0xff,0xff,0xff,0x02,
+   0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x82,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x85,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x01,0x52,0x52,0x52,
+   0xbd,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x8c,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8b,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,
+   0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x82,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x83,
+   0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x88,0x00,0x00,0x00,0xb3,
+   0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x88,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x90,
+   0x90,0x90,0xcc,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x8b,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x90,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x83,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x85,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x8d,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x87,0xaf,0xaf,0xaf,0xd6,0x00,
+   0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x86,0xaf,0xaf,0xaf,0xd6,
+   0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,
+   0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,
+   0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,
+   0xe6,0xf0,0x33,0x33,0x33,0xb8,0x8a,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0xf7,0xf7,0xf7,0xfa,0x04,0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0x00,0x00,
+   0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x87,
+   0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,
+   0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x90,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x84,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x83,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,
+   0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x85,0x7e,0x7e,0x7e,0xc7,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,
+   0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,
+   0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x86,0xff,0xff,
+   0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x02,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x52,0x52,0x52,0xbd,0x81,0x00,
+   0x00,0x00,0xb3,0x02,0x6a,0x6a,0x6a,0xc2,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,
+   0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x8a,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8c,0x00,0x00,0x00,0xb3,0x01,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x83,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,
+   0xff,0xff,0x8f,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x84,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x83,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,
+   0x84,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x84,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x8c,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x86,
+   0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8b,0x00,0x00,0x00,0xb3,
+   0x00,0xc7,0xc7,0xc7,0xe1,0x8b,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x91,0x00,0x00,0x00,
+   0xb3,0x00,0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x8b,0xff,0xff,0xff,0xff,0x01,
+   0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,
+   0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x8f,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,
+   0x8c,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,
+   0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8b,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x8b,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,0xfa,
+   0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,
+   0x33,0x33,0x33,0xb8,0x8f,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x8b,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,
+   0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x8f,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x81,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x81,0xff,
+   0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x8b,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,
+   0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x90,0x90,0x90,0xcc,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,
+   0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x87,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x7e,0x7e,0x7e,0xc7,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,
+   0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x84,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,
+   0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x86,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x83,0xff,
+   0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0xff,0xff,0xff,0xff,0x01,0xa0,0xa0,0xa0,0xd1,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,
+   0x8c,0x00,0x00,0x00,0xb3,0x02,0x90,0x90,0x90,0xcc,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0x00,0x00,0x00,
+   0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x81,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,
+   0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,
+   0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x8d,0x00,0x00,
+   0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0xc7,0xc7,0xc7,0xe1,0x81,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x81,
+   0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,
+   0xf5,0x84,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x88,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x90,0x90,0x90,
+   0xcc,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,
+   0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x02,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0x7e,
+   0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,
+   0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,
+   0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x84,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x01,0x33,
+   0x33,0x33,0xb8,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,0xb3,0x01,0x90,0x90,0x90,0xcc,0xef,0xef,0xef,0xf5,0x86,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0x00,0x00,
+   0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xd2,0xd2,0xd2,0xe6,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,
+   0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0x00,0x00,0x00,
+   0xb3,0x00,0x90,0x90,0x90,0xcc,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x8d,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x01,
+   0xaf,0xaf,0xaf,0xd6,0x90,0x90,0x90,0xcc,0x82,0xff,0xff,0xff,0xff,0x02,0x52,0x52,0x52,0xbd,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,
+   0x52,0x52,0x52,0xbd,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x84,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,
+   0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x83,0x00,
+   0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x8a,0xff,0xff,0xff,0xff,0x01,0xdc,0xdc,0xdc,0xeb,0x33,0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x82,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,
+   0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,
+   0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x83,
+   0xff,0xff,0xff,0xff,0x02,0x90,0x90,0x90,0xcc,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x01,
+   0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,
+   0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8b,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x83,0x7e,0x7e,0x7e,0xc7,0x88,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,
+   0xb8,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x89,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,
+   0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x01,
+   0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x84,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x8c,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,
+   0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xdc,0xdc,0xdc,0xeb,
+   0x81,0xff,0xff,0xff,0xff,0x02,0xe6,0xe6,0xe6,0xf0,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,
+   0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x90,0x90,0x90,0xcc,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x8b,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x82,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,
+   0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0xb3,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,0xdc,0xeb,
+   0x00,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,0xc7,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8b,0x00,0x00,0x00,0xb3,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x86,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x8d,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x84,0xff,0xff,0xff,0xff,0x03,0xf7,0xf7,0xf7,
+   0xfa,0xc7,0xc7,0xc7,0xe1,0x90,0x90,0x90,0xcc,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x01,0x7e,0x7e,0x7e,
+   0xc7,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x85,0xaf,0xaf,0xaf,0xd6,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x88,0x00,0x00,0x00,0xb3,0x00,
+   0xd2,0xd2,0xd2,0xe6,0x85,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x33,0x33,0x33,0xb8,0x8b,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,
+   0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0xff,0xff,0xff,0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x84,0x00,0x00,0x00,
+   0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0x7e,0x7e,0x7e,0xc7,0x01,0x90,0x90,0x90,0xcc,
+   0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,
+   0xaf,0xd6,0x52,0x52,0x52,0xbd,0x83,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xb3,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x81,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0xaf,0xaf,0xaf,0xd6,0x00,0x52,0x52,0x52,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcc,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x7e,0x7e,
+   0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,
+   0x8d,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,
+   0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x7e,0x7e,0x7e,0xc7,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0xff,0xff,0xff,0xff,0x01,0xbb,0xbb,0xbb,0xdc,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xaf,0xaf,0xaf,0xd6,0x8b,0x00,0x00,
+   0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xbb,0xbb,0xbb,0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x85,
+   0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,
+   0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x81,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,
+   0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x85,0x00,0x00,0x00,0xb3,0x00,0xc7,
+   0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,
+   0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x01,0xaf,0xaf,0xaf,0xd6,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x33,
+   0x33,0x33,0xb8,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,
+   0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,
+   0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8e,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,
+   0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,
+   0xc7,0xc7,0xc7,0xe1,0x82,0xff,0xff,0xff,0xff,0x03,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,
+   0xe6,0xe6,0xe6,0xf0,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x8d,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,
+   0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8d,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xef,0xef,0xef,0xf5,0x82,
+   0xff,0xff,0xff,0xff,0x02,0xa0,0xa0,0xa0,0xd1,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x89,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,
+   0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,
+   0xcc,0x84,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,
+   0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,
+   0xff,0xff,0x02,0x7e,0x7e,0x7e,0xc7,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x83,0xff,0xff,0xff,0xff,0x00,0x90,
+   0x90,0x90,0xcc,0x82,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,
+   0x52,0xbd,0x83,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd8,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x8e,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x86,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x89,0x00,0x00,0x00,0xb3,0x00,
+   0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x8c,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x83,0x00,
+   0x00,0x00,0xb3,0x01,0x52,0x52,0x52,0xbd,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x8d,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x89,
+   0x00,0x00,0x00,0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x84,0xff,0xff,
+   0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x85,0x00,0x00,0x00,0xb3,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0x33,0x33,0x33,0xb8,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x83,0x00,0x00,0x00,0xb3,0x01,0x6a,0x6a,0x6a,0xc2,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x02,0x6a,0x6a,0x6a,0xc2,0x00,0x00,0x00,0xb3,0x7e,
+   0x7e,0x7e,0xc7,0x86,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,
+   0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x86,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x83,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,
+   0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x01,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,0xd1,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xcf,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x82,
+   0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,0xdc,0x87,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x84,0xff,0xff,
+   0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,
+   0x83,0xdc,0xdc,0xdc,0xeb,0x00,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x84,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,
+   0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,
+   0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x8c,0x00,0x00,0x00,0xb3,0x00,
+   0x52,0x52,0x52,0xbd,0x83,0xff,0xff,0xff,0xff,0x06,0xc7,0xc7,0xc7,0xe1,0x90,0x90,0x90,0xcc,0x7e,0x7e,0x7e,0xc7,0xaf,0xaf,0xaf,0xd6,0xef,0xef,0xef,0xf5,0xe6,0xe6,
+   0xe6,0xf0,0x33,0x33,0x33,0xb8,0x87,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x84,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,
+   0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xe6,0xe6,0xe6,0xf0,0x86,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x86,0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x83,0xdc,0xdc,0xdc,0xeb,0x00,0xe6,
+   0xe6,0xe6,0xf0,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x83,0xdc,0xdc,0xdc,0xeb,0x02,0xa0,0xa0,0xa0,0xd1,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x83,
+   0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x87,0x00,0x00,
+   0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x82,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,0xfa,0x83,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x84,0xff,0xff,0xff,0xff,
+   0x00,0x90,0x90,0x90,0xcc,0x83,0x00,0x00,0x00,0xb3,0x00,0xf7,0xf7,0xf7,0xfa,0x81,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x00,0xa0,
+   0xa0,0xa0,0xd1,0x84,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x82,0xaf,0xaf,0xaf,0xd6,0x01,0xc7,0xc7,0xc7,0xe1,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,
+   0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x52,0x52,0x52,0xbd,0x83,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x85,0xff,0xff,0xff,0xff,0x00,0xbb,0xbb,0xbb,0xdc,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,
+   0xb3,0x01,0x52,0x52,0x52,0xbd,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x01,0xc7,0xc7,0xc7,0xe1,0xa0,0xa0,0xa0,0xd1,0x81,0x7e,0x7e,0x7e,0xc7,0x01,0xaf,0xaf,
+   0xaf,0xd6,0xef,0xef,0xef,0xf5,0x81,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xce,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,
+   0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,
+   0x00,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x87,0x00,0x00,0x00,0xb3,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,
+   0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8c,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,
+   0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x01,
+   0xdc,0xdc,0xdc,0xeb,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x8d,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x88,0xff,0xff,0xff,
+   0xff,0x01,0xe6,0xe6,0xe6,0xf0,0x33,0x33,0x33,0xb8,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x83,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x87,0x00,
+   0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,
+   0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x8c,0xff,0xff,0xff,0xff,0x02,0xaf,0xaf,0xaf,0xd6,0x00,0x00,0x00,0xb3,0xef,0xef,0xef,0xf5,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xdc,0xdc,0xdc,0xeb,0x83,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x86,0x00,0x00,0x00,0xb3,0x00,0xa0,
+   0xa0,0xa0,0xd1,0x82,0xff,0xff,0xff,0xff,0x00,0xd2,0xd2,0xd2,0xe6,0x83,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x83,0xff,0xff,0xff,0xff,0x00,0xf7,0xf7,0xf7,
+   0xfa,0x84,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x85,0x00,0x00,0x00,0xb3,0x00,0xef,0xef,0xef,0xf5,0x83,
+   0xff,0xff,0xff,0xff,0x00,0x6a,0x6a,0x6a,0xc2,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x8b,0xff,0xff,0xff,0xff,0x00,0x90,0x90,0x90,0xcc,0x81,0x00,0x00,
+   0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x84,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x33,0x33,0x33,0xb8,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x83,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x8b,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xcd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,
+   0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x87,0x00,0x00,0x00,0xb3,
+   0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x84,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x8c,0xff,0xff,0xff,0xff,0x81,0x00,0x00,0x00,0xb3,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x86,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x8b,0x00,0x00,0x00,
+   0xb3,0x00,0xe6,0xe6,0xe6,0xf0,0x86,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0x6a,0x6a,0x6a,0xc2,0x8e,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x88,0xff,
+   0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x86,0x00,0x00,0x00,0xb3,0x01,0x33,0x33,0x33,0xb8,0xf7,0xf7,0xf7,0xfa,0x82,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,
+   0x87,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x8a,0xff,0xff,0xff,0xff,0x00,0x7e,0x7e,0x7e,0xc7,0x81,0x00,0x00,0x00,0xb3,0x8a,0xff,0xff,0xff,0xff,0x02,0xdc,
+   0xdc,0xdc,0xeb,0x00,0x00,0x00,0xb3,0x7e,0x7e,0x7e,0xc7,0x8c,0xff,0xff,0xff,0xff,0x81,0xaf,0xaf,0xaf,0xd6,0x83,0xff,0xff,0xff,0xff,0x00,0x52,0x52,0x52,0xbd,0x84,
+   0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,0xdc,0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,
+   0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x84,0x00,0x00,0x00,0xb3,0x00,0xd2,0xd2,0xd2,0xe6,0x82,0xff,0xff,0xff,0xff,0x00,0xc7,0xc7,0xc7,0xe1,0x84,0x00,0x00,0x00,0xb3,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0xff,0xff,0xff,0xff,0x00,0xdc,
+   0xdc,0xdc,0xeb,0x87,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x89,0xff,0xff,0xff,0xff,0x01,0xf7,0xf7,0xf7,0xfa,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,
+   0x00,0x7e,0x7e,0x7e,0xc7,0x84,0xff,0xff,0xff,0xff,0x00,0xef,0xef,0xef,0xf5,0x85,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,
+   0xaf,0xaf,0xd6,0x81,0x00,0x00,0x00,0xb3,0x00,0x7e,0x7e,0x7e,0xc7,0x82,0xff,0xff,0xff,0xff,0x00,0xaf,0xaf,0xaf,0xd6,0x82,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,
+   0xeb,0x84,0xff,0xff,0xff,0xff,0x00,0xa0,0xa0,0xa0,0xd1,0x85,0x00,0x00,0x00,0xb3,0x00,0xdc,0xdc,0xdc,0xeb,0x82,0xff,0xff,0xff,0xff,0x84,0x00,0x00,0x00,0xb3,0x01,
+   0x7e,0x7e,0x7e,0xc7,0xef,0xef,0xef,0xf5,0x89,0xff,0xff,0xff,0xff,0x01,0xef,0xef,0xef,0xf5,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xcd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd0,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xdc,0xdc,0xdc,0xeb,0x86,0x00,
+   0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x82,0x00,0x00,0x00,0xb3,0x8a,0xdc,0xdc,0xdc,0xeb,0x00,0xbb,0xbb,0xbb,
+   0xdc,0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,0xeb,0x00,0xd2,0xd2,0xd2,0xe6,0x88,0x00,0x00,0x00,0xb3,0x82,0xdc,0xdc,0xdc,0xeb,0x00,
+   0xbb,0xbb,0xbb,0xdc,0x84,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x8c,0xdc,0xdc,0xdc,0xeb,0x81,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,0xdc,0xdc,
+   0xdc,0xeb,0x86,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x8b,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,
+   0xaf,0xaf,0xaf,0xd6,0xf7,0xf7,0xf7,0xfa,0x83,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x6a,0x6a,0x6a,0xc2,0x90,0x00,0x00,0x00,0xb3,0x01,0xa0,0xa0,0xa0,0xd1,
+   0xe6,0xe6,0xe6,0xf0,0x84,0xff,0xff,0xff,0xff,0x01,0xd2,0xd2,0xd2,0xe6,0x7e,0x7e,0x7e,0xc7,0x88,0x00,0x00,0x00,0xb3,0x00,0xaf,0xaf,0xaf,0xd6,0x81,0xdc,0xdc,0xdc,
+   0xeb,0x00,0xd2,0xd2,0xd2,0xe6,0x88,0x00,0x00,0x00,0xb3,0x00,0xa0,0xa0,0xa0,0xd1,0x8a,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x00,0x00,0x00,0xb3,0x8a,
+   0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0x00,0x00,0x00,0xb3,0x6a,0x6a,0x6a,0xc2,0x8c,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x83,0xdc,0xdc,0xdc,0xeb,
+   0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x52,0x52,0x52,0xbd,0x83,0xdc,0xdc,0xdc,0xeb,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0xd2,
+   0xd2,0xd2,0xe6,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0x6a,0x6a,0x6a,0xc2,0x84,0x00,0x00,0x00,0xb3,0x00,0x90,0x90,0x90,0xcc,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0x7e,0x7e,0x7e,
+   0xc7,0x84,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0xaf,0xaf,0xaf,0xd6,0x85,0x00,0x00,0x00,0xb3,0x00,0x33,0x33,0x33,0xb8,0x82,
+   0xdc,0xdc,0xdc,0xeb,0x00,0x90,0x90,0x90,0xcc,0x87,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x87,0xdc,0xdc,0xdc,0xeb,0x02,0xbb,0xbb,0xbb,0xdc,0xa0,0xa0,0xa0,
+   0xd1,0x33,0x33,0x33,0xb8,0x83,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x84,0xdc,0xdc,0xdc,0xeb,0x00,0x7e,0x7e,0x7e,0xc7,0x85,0x00,0x00,0x00,0xb3,0x00,0x6a,
+   0x6a,0x6a,0xc2,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,0xd1,0x81,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x82,0xdc,0xdc,0xdc,0xeb,0x00,0xa0,0xa0,0xa0,
+   0xd1,0x82,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x83,0xdc,0xdc,0xdc,0xeb,0x00,0xc7,0xc7,0xc7,0xe1,0x86,0x00,0x00,0x00,0xb3,0x00,0xbb,0xbb,0xbb,0xdc,0x82,
+   0xdc,0xdc,0xdc,0xeb,0x85,0x00,0x00,0x00,0xb3,0x02,0x33,0x33,0x33,0xb8,0xaf,0xaf,0xaf,0xd6,0xe6,0xe6,0xe6,0xf0,0x85,0xff,0xff,0xff,0xff,0x02,0xdc,0xdc,0xdc,0xeb,
+   0xa0,0xa0,0xa0,0xd1,0x33,0x33,0x33,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xce,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xbd,0x00,0x00,0x00,0xb3,0x00,0x6a,0x6a,0x6a,0xc2,0x81,0x7e,0x7e,0x7e,0xc7,0x00,0x33,0x33,0x33,0xb8,0x94,0x00,0x00,0x00,0xb3,0x00,
+   0x33,0x33,0x33,0xb8,0x82,0x7e,0x7e,0x7e,0xc7,0xff,0x00,0x00,0x00,0xb3,0xcd,0x00,0x00,0x00,0xb3,0x82,0x7e,0x7e,0x7e,0xc7,0x00,0x6a,0x6a,0x6a,0xc2,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xd2,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,
+   0x02,0x04,0x04,0x13,0xb7,0x20,0x24,0xa9,0xdf,0x26,0x2e,0xd7,0xef,0x91,0x28,0x2f,0xd9,0xf0,0x02,0x26,0x2e,0xd7,0xef,0x1f,0x25,0xa8,0xde,0x04,0x04,0x13,0xb7,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x23,0x28,0xbb,0xe5,0x95,0x2e,0x37,0xff,0xff,0x00,0x22,0x27,0xb6,0xe4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x2d,
+   0x35,0xf7,0xfb,0x88,0x2e,0x37,0xff,0xff,0x00,0x26,0x2b,0xcb,0xea,0x81,0x20,0x25,0xad,0xe1,0x00,0x26,0x2b,0xcc,0xea,0x88,0x2e,0x37,0xff,0xff,0x00,0x2c,0x34,0xf2,
+   0xf9,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x28,0x30,0xde,0xf1,0x87,0x2e,0x37,0xff,0xff,0x00,0x24,0x2b,0xc4,0xe8,0x83,0x00,0x00,0x00,0xb3,0x00,0x25,0x2a,
+   0xc7,0xea,0x87,0x2e,0x37,0xff,0xff,0x00,0x26,0x2e,0xd7,0xef,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf2,0x00,0x00,0x00,0xb3,0x00,0x13,0x17,0x68,0xcb,0x87,0x2e,0x37,0xff,0xff,0x00,0x1f,
+   0x25,0xab,0xe0,0x83,0x00,0x00,0x00,0xb3,0x00,0x1f,0x25,0xab,0xe0,0x87,0x2e,0x37,0xff,0xff,0x00,0x13,0x16,0x61,0xca,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf3,0x00,0x00,0x00,0xb3,0x00,
+   0x25,0x2c,0xcd,0xec,0x86,0x2e,0x37,0xff,0xff,0x01,0x26,0x2d,0xd2,0xed,0x01,0x01,0x05,0xb4,0x81,0x00,0x00,0x00,0xb3,0x01,0x01,0x01,0x06,0xb4,0x27,0x2e,0xd6,0xef,
+   0x86,0x2e,0x37,0xff,0xff,0x00,0x26,0x2b,0xcb,0xea,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf5,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf3,0x00,0x00,0x00,0xb3,0x01,0x0d,0x0e,0x40,0xc1,0x2e,0x37,0xfd,0xfe,0x86,0x2e,0x37,0xff,0xff,
+   0x00,0x2b,0x31,0xe9,0xf5,0x81,0x28,0x2f,0xd9,0xf0,0x00,0x2b,0x31,0xe9,0xf6,0x86,0x2e,0x37,0xff,0xff,0x01,0x2d,0x36,0xfc,0xfe,0x0c,0x0d,0x3b,0xc0,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf5,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xf4,0x00,0x00,0x00,0xb3,0x00,0x20,0x26,0xb0,0xe1,0x91,0x2e,0x37,0xff,0xff,0x00,0x20,0x24,0xa9,0xdf,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xf6,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf4,0x00,0x00,0x00,0xb3,0x01,0x06,0x07,0x1e,
+   0xb9,0x2c,0x34,0xf4,0xfb,0x84,0x2e,0x37,0xff,0xff,0x01,0x2e,0x37,0xfe,0xff,0x24,0x2b,0xc5,0xe8,0x81,0x20,0x25,0xad,0xe1,0x00,0x25,0x2a,0xc6,0xe9,0x85,0x2e,0x37,
+   0xff,0xff,0x01,0x2c,0x34,0xf2,0xfa,0x05,0x06,0x1b,0xb9,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf6,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf5,0x00,0x00,0x00,0xb3,0x00,0x19,0x1f,0x8b,0xd5,0x84,0x2e,0x37,0xff,0xff,0x00,0x24,0x2a,
+   0xc4,0xe8,0x83,0x00,0x00,0x00,0xb3,0x00,0x25,0x2a,0xc7,0xe9,0x84,0x2e,0x37,0xff,0xff,0x00,0x19,0x1d,0x85,0xd4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xf7,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf5,0x00,0x00,0x00,0xb3,0x01,0x02,
+   0x02,0x09,0xb5,0x2a,0x30,0xe4,0xf4,0x83,0x2e,0x37,0xff,0xff,0x00,0x1f,0x25,0xab,0xe0,0x83,0x00,0x00,0x00,0xb3,0x00,0x1f,0x25,0xab,0xe0,0x83,0x2e,0x37,0xff,0xff,
+   0x01,0x29,0x31,0xe2,0xf3,0x01,0x01,0x06,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf7,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf6,0x00,0x00,0x00,0xb3,0x00,0x13,0x16,0x62,0xca,0x83,0x2e,0x37,0xff,0xff,0x00,0x1f,0x25,0xab,0xe0,
+   0x83,0x00,0x00,0x00,0xb3,0x00,0x1f,0x25,0xab,0xe0,0x83,0x2e,0x37,0xff,0xff,0x00,0x11,0x14,0x5c,0xc8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xf8,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf7,0x00,0x00,0x00,0xb3,0x00,0x26,0x2b,0xcc,
+   0xea,0x82,0x2e,0x37,0xff,0xff,0x00,0x1f,0x25,0xab,0xe0,0x83,0x00,0x00,0x00,0xb3,0x00,0x1f,0x25,0xab,0xe0,0x82,0x2e,0x37,0xff,0xff,0x00,0x24,0x2b,0xc5,0xe9,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xf7,0x00,0x00,0x00,0xb3,0x01,0x0c,0x0d,0x3b,0xc0,0x2d,0x36,0xfc,0xfe,0x81,0x2e,0x37,0xff,0xff,0x00,0x1f,0x25,0xab,0xe0,0x83,0x00,0x00,0x00,0xb3,0x00,
+   0x1f,0x25,0xab,0xe0,0x81,0x2e,0x37,0xff,0xff,0x01,0x2d,0x36,0xfb,0xfe,0x0a,0x0c,0x36,0xbf,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xf9,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf8,0x00,0x00,0x00,0xb3,0x00,0x20,0x24,0xa9,0xdf,0x81,
+   0x2e,0x37,0xff,0xff,0x00,0x21,0x26,0xb2,0xe2,0x83,0x00,0x00,0x00,0xb3,0x00,0x21,0x26,0xb2,0xe2,0x81,0x2e,0x37,0xff,0xff,0x00,0x1f,0x24,0xa4,0xde,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfa,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xf8,0x00,0x00,0x00,0xb3,0x04,0x05,0x06,0x1b,0xb9,0x2c,0x34,0xf3,0xfa,0x2e,0x37,0xff,0xff,0x2c,0x34,0xf3,0xfa,0x14,0x16,0x65,0xcb,0x81,0x0d,0x0f,0x44,0xc2,0x04,
+   0x14,0x17,0x67,0xcb,0x2c,0x34,0xf4,0xfb,0x2e,0x37,0xff,0xff,0x2b,0x33,0xf1,0xf9,0x05,0x05,0x17,0xb8,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xfa,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf9,0x00,0x00,0x00,0xb3,0x00,0x19,0x1d,0x85,
+   0xd4,0x87,0x2e,0x37,0xff,0xff,0x00,0x18,0x1c,0x81,0xd2,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfb,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xf9,0x00,0x00,0x00,0xb3,0x01,0x02,0x02,0x07,0xb4,0x29,0x31,0xe2,0xf3,0x85,0x2e,0x37,0xff,
+   0xff,0x01,0x28,0x30,0xdf,0xf2,0x01,0x01,0x05,0xb4,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfb,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfa,0x00,0x00,0x00,0xb3,0x00,0x12,0x14,0x5d,0xc8,0x85,0x2e,0x37,0xff,0xff,0x00,0x10,0x13,0x56,
+   0xc7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfc,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xfb,0x00,0x00,0x00,0xb3,0x00,0x25,0x2a,0xc6,0xe9,0x83,0x2e,0x37,0xff,0xff,0x00,0x23,0x2a,0xc2,0xe7,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfb,0x00,0x00,0x00,0xb3,
+   0x01,0x0a,0x0c,0x36,0xbf,0x2e,0x36,0xf9,0xfc,0x81,0x2e,0x37,0xff,0xff,0x01,0x2c,0x35,0xf8,0xfc,0x09,0x0a,0x30,0xbd,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xfd,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfc,0x00,0x00,0x00,0xb3,0x03,
+   0x10,0x12,0x52,0xc6,0x25,0x2a,0xc7,0xe9,0x25,0x2a,0xc6,0xe9,0x0f,0x10,0x4d,0xc5,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xfe,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,
+   0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,
+   0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,
+   0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,
+   0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,0x00,0x00,0x00,0xb3,0xff,
+   0x00,0x00,0x00,0xb3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x52,0x55,0x45,0x56,0x49,0x53,0x49,0x4f,0x4e,0x2d,0x58,0x46,0x49,0x4c,0x45,0x2e,0x00
+};
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Display.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,202 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Display.h
+Content     :   Contains platform independent display management
+Created     :   May 6, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Display_h
+#define OVR_Display_h
+
+#include "../Sensors/OVR_DeviceConstants.h" // Required for HmdTypeEnum
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_RefCount.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_String.h"
+#include "../Kernel/OVR_Math.h"
+
+namespace OVR {
+
+
+class DisplaySearchHandle : virtual public RefCountBaseV<DisplaySearchHandle>
+{
+public:
+	DisplaySearchHandle() {}
+
+	virtual ~DisplaySearchHandle() {}
+
+	void operator= (const DisplaySearchHandle&) {}
+};
+
+//-------------------------------------------------------------------------------------
+// ***** Display
+
+// Display object describes an Oculus HMD screen in LibOVR, providing information such
+// as EDID serial number and resolution in platform-independent manner.
+//
+// Display is an abstract base class to support OS and driver specific implementations.
+// It support HMD screen enumeration through GetDisplayCount/GetDisplay static functions.
+//
+// Examples of implementations of Display are the following:
+// Display_Win32_Generic - Compatibly mode implementation that maintains operation on
+//						   systems without drivers.
+// Display_Win32_Driver  - Driver-Based display
+// Display_OSX_Generic   - Additional compatibility mode implementation for OS X
+
+class Display : public RefCountBase<Display>
+{
+protected:
+	enum MirrorMode
+	{
+		MirrorEnabled = 0,
+		MirrorDisabled = 1
+	};
+
+	MirrorMode mirrorMode;
+
+	Display(
+            HmdTypeEnum deviceTypeGuess,
+#ifdef OVR_OS_MAC
+            uint32_t displayID,
+#else
+			const String& displayID,
+#endif
+			const String& modelName,
+			const String& editSerial,
+            const Sizei& logicalRes,
+			const Sizei& nativeRes,
+			const Vector2i& displayOffset, 
+			const uint64_t devNumber,
+			const uint32_t rotation,
+			const bool appExclusive):
+		DeviceTypeGuess(deviceTypeGuess),
+        DisplayID(displayID),
+		ModelName(modelName),
+		EdidSerialNumber(editSerial),
+		LogicalResolutionInPixels(logicalRes),
+		NativeResolutionInPixels(nativeRes),
+		DesktopDisplayOffset(displayOffset),
+		DeviceNumber(devNumber),
+		Rotation(rotation),
+		ApplicationExclusive(appExclusive)
+    {
+	}
+
+    void operator = (const Display&) { } // Quiet warning.
+
+public:
+	virtual ~Display() { }
+
+	// ----- Platform specific static Display functionality -----
+
+	// Mandatory function that sets up the display environment with
+	// any necessary shimming and function hooks. This should be one
+	// of the very first things your application does when it
+	// initializes LibOVR
+	static bool         Initialize();
+
+	// Returns a count of the detected displays. These are Rift displays
+	// attached directly to an active display port
+	static int          GetDisplayCount( DisplaySearchHandle* handle = NULL, bool extended = true, bool applicationOnly = true, bool extendedEDIDSerials = false );
+	// Returns a specific index of a display. Displays are sorted in no particular order.
+	static Ptr<Display> GetDisplay( int index = 0, DisplaySearchHandle* handle = NULL ); 
+
+
+    // Returns true if we are referencing the same display; useful for matching display
+    // objects with the ones already detected.
+    bool MatchDisplay(const Display* other)
+    {
+		// Note this is not checking the DeviceName, which corresponds to which monitor the device is.
+		// This allows matching to match a display that has changed how it is plugged in.
+		return (DisplayID == other->DisplayID) &&
+               (EdidSerialNumber == other->EdidSerialNumber) &&
+               (NativeResolutionInPixels == other->NativeResolutionInPixels) &&
+               (DesktopDisplayOffset == other->DesktopDisplayOffset) &&
+               (ApplicationExclusive == other->ApplicationExclusive);
+    }
+
+
+	// ----- Device independent instance based Display functionality -----
+
+    // Device type guess based on display info.
+    const HmdTypeEnum   DeviceTypeGuess;
+#if defined(OVR_OS_MAC)
+    // CGDirectDisplayID for the rift.
+    const uint32_t      DisplayID; 
+#else
+	// A string denoting the display device name so that apps can recognize the monitor
+	const String        DisplayID;
+#endif
+    // A literal string containing the name of the model, i.e. Rift DK2
+    const String        ModelName;
+    // Part of the serial number encoded in Edid, used for monitor <-> sensor matching.
+    const String        EdidSerialNumber;
+    // Logical resolution is the display resolution in presentation terms.
+    // That is to say, the resolution that represents the orientation the
+    // display is projected to the user. For DK2, while being a portrait display
+    // the display is held in landscape and therefore the logical resolution
+    // is 1920x1080
+    const Sizei         LogicalResolutionInPixels;
+    // Native resolution is the resolution reported by the EDID and represents the
+    // exact hardware resolution of the Rift. For example, on DK2
+    // this is 1080x1920
+    // In theory, an OS rotated Rift's native and logical resolutions should match
+    const Sizei         NativeResolutionInPixels;
+    // For displays that are attached to the desktop, this return value has meaning.
+    // Otherwise it should always return origin
+    const Vector2i      DesktopDisplayOffset;
+	// For Windows machines this value stores the ChildUid used to identify this display
+	const uint64_t	    DeviceNumber;
+	// Stores the device specific default rotation of the screen
+	// E.g. DK2 is rotated 90 degrees as it is a portrait display
+	const uint32_t	    Rotation;
+	// Is set if the Display is capable in Application-Only mode
+	const bool			ApplicationExclusive;
+
+	// Functionality for rendering within the window
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode ) = 0;
+
+	// Functionality for enabling/disabling display
+    virtual bool SetDisplaySleep(bool off)
+    {
+        // Override to implement if supported
+        OVR_UNUSED(off);
+        return false;
+    }
+
+    // Check if right now the current rendering application should be in compatibility mode
+    static bool InCompatibilityMode( bool displaySearch = true );
+
+    // Get/set the mode for all applications
+    static bool GetDriverMode(bool& driverInstalled, bool& compatMode, bool& hideDK1Mode);
+    static bool SetDriverMode(bool compatMode, bool hideDK1Mode);
+
+    static DisplaySearchHandle* GetDisplaySearchHandle();
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Display.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,169 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_Display.h
+Content     :   Win32-specific Display declarations
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_Display_h
+#define OVR_Win32_Display_h
+
+#include "OVR_Display.h"
+
+namespace OVR { namespace Win32 {
+
+
+//-------------------------------------------------------------------------------------
+// DisplayDesc
+
+// Display information enumerable through Win32.
+// TBD: Should we just move this to public header, so it's a const member of Display?
+struct DisplayDesc
+{
+    HmdTypeEnum DeviceTypeGuess; // This is a guess about what type of HMD it is connected to
+	String      DisplayID;       // This is the device identifier string from MONITORINFO (for app usage)
+    String      ModelName;       // This is a "DK2" type string
+    String      EdidSerialNumber;
+    Sizei       LogicalResolutionInPixels;
+    Sizei       NativeResolutionInPixels;
+    Vector2i    DesktopDisplayOffset;
+};
+
+
+//-------------------------------------------------------------------------------------
+// DisplayEDID
+
+// Describes EDID information as reported from our display driver.
+struct DisplayEDID
+{
+	String MonitorName;
+	UINT16 ModelNumber;
+	String VendorName;
+	String SerialNumber;
+};
+
+class Win32DisplaySearchHandle : public DisplaySearchHandle
+{
+public:
+    static const int ArraySize = 16;
+
+    Win32::DisplayDesc cachedDescriptorArray[ArraySize];
+    bool			   extended;
+    bool			   application;
+    int				   extendedDisplayCount;
+    int				   applicationDisplayCount;
+    int				   displayCount;
+
+    Win32DisplaySearchHandle()
+    {
+    }
+	virtual ~Win32DisplaySearchHandle()
+    {
+    }
+};
+
+//-------------------------------------------------------------------------------------
+// Win32DisplayGeneric
+
+// Describes Win32 display in Compatibility mode, containing basic data
+class Win32DisplayGeneric : public Display
+{
+public:
+	Win32DisplayGeneric( const DisplayDesc& dd ) :
+		Display(dd.DeviceTypeGuess,
+				dd.DisplayID,
+				dd.ModelName,
+				dd.EdidSerialNumber,
+				dd.LogicalResolutionInPixels,
+				dd.NativeResolutionInPixels,
+				dd.DesktopDisplayOffset,
+				0,
+				0,
+				false)
+    {
+	}
+
+	virtual ~Win32DisplayGeneric()
+	{
+	}
+
+	// Generic displays are not capable of mirroring
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode ) 
+	{ 
+		OVR_UNUSED( newMode ); 
+		return MirrorDisabled; 
+	} 
+};
+
+
+//-------------------------------------------------------------------------------------
+// Win32DisplayDriver
+
+// Oculus driver based display object.
+class Win32DisplayDriver : public Display
+{
+	HANDLE		hDevice;
+	ULONG		ChildId;
+	DisplayEDID Edid;
+
+public:
+    Win32DisplayDriver(const HmdTypeEnum  deviceTypeGuess,
+                       const String&      displayID,
+					   const String&      modelName,
+					   const String&      edidSerial,
+                       const Sizei&       logicalRes,
+					   const Sizei&       nativeRes,
+					   const Vector2i&    displayOffset,
+                       const DisplayEDID& edid,
+					   HANDLE hdevice,
+					   ULONG child,
+					   uint32_t rotation) :
+		Display(deviceTypeGuess,
+				displayID,
+				modelName,
+				edidSerial,
+				logicalRes,
+				nativeRes,
+				displayOffset,
+				child,
+				rotation,
+				true),
+		hDevice(hdevice),
+		ChildId(child),
+		Edid(edid)
+    {
+	}
+
+	virtual ~Win32DisplayDriver()
+	{
+	}
+
+	virtual MirrorMode SetMirrorMode( MirrorMode newMode );
+
+    // Support sleep/wake
+	virtual bool SetDisplaySleep(bool off);
+};
+
+
+}} // namespace OVR::Win32
+
+#endif // OVR_Win32_Display_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Dxgi_Display.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_Dxgi_Display.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,425 @@
+/************************************************************************************
+ 
+PublicHeader:   None
+Filename    :   dxgi_ovr_filter.h
+Content     :   Shared usermode/kernel mode definitions for IOCTL functionality.
+                Also used from LibOVR to access the driver.
+Created     :   January 27, 2014
+Authors     :   Dean Beeler
+ 
+Copyright   :   Copyright 2013 Oculus, LLC. All Rights reserved.
+ 
+Use of this software is subject to the terms of the Oculus LLC license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+ 
+/************************************************************************************/
+
+#ifndef OVR_dxgi_ovr_filter_h
+#define OVR_dxgi_ovr_filter_h
+
+#include <InitGuid.h>
+
+#define USERMODE_TEST_ROTATION 1
+
+#if USERMODE_TEST_ROTATION // Used only by the um test application
+#define USERMODE_SURFACE_WIDTH 1920
+#define USERMODE_SURFACE_HEIGHT 1080
+#else
+#define USERMODE_SURFACE_WIDTH 1080
+#define USERMODE_SURFACE_HEIGHT 1920
+#endif
+
+#define TEST_ROTATION 0 // Kernel-mode parameters
+
+#if TEST_ROTATION
+#define SURFACE_WIDTH 1920
+#define SURFACE_HEIGHT 1080
+#else
+#define SURFACE_WIDTH 1080
+#define SURFACE_HEIGHT 1920
+#endif
+
+// {46231713-49FD-4922-84E3-9FF907C06803}
+DEFINE_GUID(GUID_DEVINTERFACE_OVRRIFTMGR, 
+	0x46231713, 0x49fd, 0x4922, 0x84, 0xe3, 0x9f, 0xf9, 0x7, 0xc0, 0x68, 0x3);
+
+#define QUERYADAPTER_MAGICSIZE		17836
+#define QUERYADAPTER_MAGICHEADER	0x4f565246 // OVRF
+#define QUERYADAPTER_MAXPATH		2048
+
+#define FUNCTION_INDEX 0xb800
+
+#pragma pack(push,1)
+
+#define OVR_RIFT_MODE_OFF			0	// Disabled
+#define OVR_RIFT_MODE_ENABLED		1   // Enabled
+#define OVR_RIFT_MODE_EXTEND		2   // Extending 2D displays. Without this flag
+										//	2D displays are disabled when the Rift
+										//	is active
+#define OVR_RIFT_MODE_FRONTBUFFER	4	// Enable front buffer only for Rift
+#define OVR_RIFT_MODE_LOCKMOUSE		8	// Prevent mouse from entering bounds
+
+#define OVR_ESCAPE_TYPE_HANDLE		1   // Escape to notify driver of our collected handles
+
+#define OVR_FlipImmediate			0x2
+#define OVR_FlipOnNextVSync			0x4
+
+//-----------------------------------------------------------------------------------
+// Structures for application to UM driver
+
+// Kernel32.dll functionality
+typedef HMODULE  (WINAPI *WinLoadLibraryA) ( LPCSTR  );
+typedef HMODULE  (WINAPI *WinLoadLibraryW) ( LPCWSTR  );
+typedef HMODULE  (WINAPI *WinLoadLibraryExA) ( LPCSTR, HANDLE, DWORD  );
+typedef HMODULE  (WINAPI *WinLoadLibraryExW) ( LPCWSTR, HANDLE, DWORD  );
+typedef BOOL     (WINAPI *WinGetModuleHandleExA)( DWORD, LPCSTR, HMODULE* );
+typedef BOOL     (WINAPI *WinGetModuleHandleExW)( DWORD, LPCWSTR, HMODULE* );
+
+// Overridden DirectX 9 entry points
+typedef void*	 (WINAPI *WinDirect3DCreate9)(UINT SDKVersion);
+typedef HRESULT  (WINAPI *WinDirect3DCreate9Ex)(UINT SDKVersion, void** aDevice);
+
+// Overridden DXGI entry points
+typedef HRESULT (WINAPI *WinCreateDXGIFactory)(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	);
+
+typedef HRESULT (WINAPI *WinCreateDXGIFactory1)(
+	__in   REFIID riid,
+	__out  void **ppFactory
+	);
+
+typedef HRESULT (WINAPI *WinCreateDXGIFactory2)(
+	__in   UINT flags,
+	__in   const IID &riid,
+	__out  void **ppFactory
+	);
+
+// Application usermode callbacks from usermode driver. These 
+// functions are all provided by the calling application that uses
+// the filter mode driver
+
+// IsInitializingDisplay is used at runtime to validate that
+// the created resource (RT or bind_present) matches the resolution
+// of our expected backbuffer. If the application returns true,
+// our usermode driver will convert this to a primary
+typedef BOOL  (WINAPI *IsInitializingDisplay) ( PVOID, UINT, UINT );
+// RiftForContext is a function that will return the Rift device of
+// the concerned context. This is for targeting a particular
+// device instance with a particular Rift for rendering
+typedef ULONG (WINAPI *RiftForContext)( PVOID, HANDLE );
+// CloseRiftForContext is a function that informs the application
+// the created device is shutting down and the context
+// can freedly disassociate with the particular
+typedef BOOL (WINAPI *CloseRiftForContext)( PVOID, HANDLE, ULONG );
+typedef BOOL (WINAPI *WindowDisplayResolution)( PVOID, UINT*, UINT*, UINT*, UINT*, BOOL* );
+// IsCreatingBackBuffer is a function directed at the runtime shim
+// to confirm that the runtime is actively creating the additional
+// swapchain for rotation and display out to the rift.
+// When creating the original swapchain this function should return false
+// so the orignal swapchain isn't inadvertantly coopted.
+typedef BOOL (WINAPI *IsCreatingBackBuffer)( PVOID );
+// Callback from the usermode driver to obtain the desire to see debug statements from
+// the usermode drivers on the output console. Only called one per usermode driver shim
+// and usermode runtime.
+typedef BOOL (WINAPI *ShouldEnableDebug)( VOID );
+// Callback from the usermode driver to the runtime obtain the vsync status
+typedef BOOL (WINAPI *ShouldVSync)( VOID );
+// Callback from usermode mode and runtime driver to obtain expected native width, 
+// height and degrees rotation of the rift
+typedef BOOL (WINAPI *ExpectedResolution)( PVOID, UINT*, UINT*, UINT* );
+// Usermode callback that reports whether or not mirroring is enabled
+typedef BOOL (WINAPI *MirroringEnabled)( PVOID );
+// Callback from the shim for Unity and other plugins used to
+// report the swapchain that was created by the application
+typedef void* (WINAPI *GetDX11SwapChain)( PVOID );
+// Callback to report the HWND associated with this context
+typedef HWND (WINAPI* GetWindowForContext)( PVOID );
+// Should present Rift on context
+typedef BOOL (WINAPI* PresentRiftOnContext)( PVOID );
+// Used by a pre-loaded shim (d3d9, dxgi, opengl32) to
+// identify which api version we loaded
+// 1 = OpenGL
+// 9 = DirectX 9
+// 10 = DirectX 1X
+typedef int (WINAPI* ActiveAPIVersion)( PVOID );
+
+#pragma warning(push)
+#pragma warning(disable: 4201)
+
+typedef struct _LINK_APPLICATION_DRIVER
+{
+	UINT32                      version;
+	PVOID						context;
+
+	union 
+	{
+		struct  
+		{
+			IsInitializingDisplay		pfnInitializingDisplay;
+			RiftForContext				pfnRiftForContext;
+			CloseRiftForContext			pfnCloseRiftForContext;
+			WindowDisplayResolution		pfnWindowDisplayResolution;
+			IsCreatingBackBuffer		pfnIsCreatingBackBuffer;
+			ShouldEnableDebug			pfnShouldEnableDebug;
+			ShouldVSync					pfnShouldVSync;
+			ExpectedResolution			pfnExpectedResolution;
+			MirroringEnabled			pfnMirroringEnabled;
+			GetDX11SwapChain			pfnGetDX11SwapChain;
+			GetWindowForContext			pfnGetWindowForContext;
+			PresentRiftOnContext		pfnPresentRiftOnContext;
+			ActiveAPIVersion			pfnActiveAPIVersion;
+		};
+
+		PROC	placeholders[128];
+	};
+
+
+	// Used by Runtime filter for linking with original libraries
+	WinDirect3DCreate9			pfnDirect3DCreate9;
+	WinDirect3DCreate9Ex		pfnDirect3DCreate9Ex;
+	WinCreateDXGIFactory		pfnCreateDXGIFactory;
+	WinCreateDXGIFactory1		pfnCreateDXGIFactory1;
+	WinCreateDXGIFactory2		pfnCreateDXGIFactory2;
+} LINK_APPLICATION_DRIVER, *PLINK_APPLICATION_DRIVER;
+
+#pragma warning(pop)
+
+
+// OVRDisplay.dll functionality
+typedef HRESULT (WINAPI *PreloadLibraryFn) ( WinLoadLibraryA , LPCSTR, PLINK_APPLICATION_DRIVER appDriver );
+typedef HRESULT (WINAPI *PreloadLibraryRTFn) ( PLINK_APPLICATION_DRIVER appDriver );
+
+//-----------------------------------------------------------------------------------
+// Structures for UM driver to KM driver
+
+typedef struct _QUERY_KM_DRIVER
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+												// See: QUERYADAPTER_MAGICHEADER
+	UINT32 maxVidPnSources;						// Returns the maximum number of video present network sources
+} QUERY_KM_DRIVER, *PQUERY_KM_DRIVER;
+
+#ifndef _D3DUKMDT_H_
+typedef UINT D3DKMT_HANDLE;
+#endif
+
+typedef struct _HandleNotepad
+{
+	// These are assigned around CreateResource
+	HANDLE			hUsermodeInResource;
+	HANDLE			hUsermodeOutResource;
+
+	// These are assigned within the kernel with
+	// DxgkDdiCreateAllocation and
+	// DxgkDdiOpenAllocation
+	D3DKMT_HANDLE	hAllocation;
+	PVOID			hDeviceSpecificHandle;
+	PVOID			hKernelDriverHandle;
+
+	// These are assigned around pfnAllocateCb
+	HANDLE			hUsermodeSharedResource;
+	D3DKMT_HANDLE	hKernelModeSharedResource;
+
+	ULONG			childUid;
+
+	UINT			pitch;
+
+} HandleNotepad, *PHandleNotepad;
+
+
+typedef struct _ALLOC_PRIVATE_STRUCTURE
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+
+	PVOID originalPrivataDataPtr;				// Location in usermode of the original private data structure
+	UINT  originalPrivateSize;					// Size of private data structure at the end of this header
+
+	PVOID hAllocationHandle;					// User-mode-assigned allocation handle for CreateAllocation
+	PVOID hDeviceSpecificHandle;				// Assigned in kernal OpenAllocation
+	PVOID hInternalHandle;						// Assigned in kernal CreateAllocation
+	UINT  pitch;								// Hinted surface pitch
+
+	BYTE originalPrivateData[1];				// Variable length
+
+
+} ALLOC_PRIVATE_STRUCTURE, *PALLOC_PRIVATE_STRUCTURE;
+
+typedef struct _ESCAPE_STRUCTURE
+{
+	UINT32 magic;								// Friend or foe identifier for our filter driver
+
+	UINT32 escapeType;							// Specifier for individual type of escape message
+												// Type 1 for notepad
+	union {
+		HandleNotepad notepad;
+	};
+} ESCAPE_STRUCTURE, *PESCAPE_STRUCTURE;
+
+// Structures for internal operation of KM driver
+
+typedef struct _RIFT_SYNC
+{
+	ULONG	childUid;				// ChildUid as reported by RIFT_STATUS
+	ULONG   vsync;					// 1 for vsync, 0 for immediate
+} RIFT_SYNC, *PRIFT_SYNC;
+
+typedef struct _RIFT_MODE
+{
+	ULONG	childUid;				// ChildUid as reported by RIFT_STATUS
+	ULONG	mode;					// Bitmap of mode values, defined by OVR_RIFT_HOME_*
+	HANDLE	userModeHandle;			// Handle of render target created in user mode
+									// that's usable as a primary 
+} RIFT_MODE, *PRIFT_MODE;
+
+typedef struct _RIFT_STATUS
+{
+	ULONG childUid;				// Display driver assigned Uid for this display
+	ULONG mode;					// Active rift mode, see OVR_RIFT_MODE_*
+	ULONG serialNumber;			// Serial number as reported in the Rift's EDID
+	ULONG textureHandle;		// Handle of shared render resource -- NULL if not shared 
+} RIFT_STATUS, *PRIFT_STATUS;
+
+typedef struct _RIFT_STATUS_ARRAY
+{
+	ULONG arraySize;			// Size of pre-allocated RIFT_STATUS structures. 
+	RIFT_STATUS status[1];		// Array of status blocks containing connection information on each Rift
+} RIFT_STATUS_ARRAY, *PRIFT_STATUS_ARRAY;
+
+#pragma pack(pop)
+
+// IOCTL for UM application to KM driver
+
+#define OVR_STATUS_SUCCESS					 0
+#define OVR_STATUS_FAIL						-1
+#define OVR_STATUS_DRIVER_IN_USE			-2
+#define OVR_STATUS_MODE_ALREADY_ACTIVE		-3
+#define OVR_STATUS_RIFT_NOT_PRESENT			-4
+
+//
+// Returns the number of Rift displays attached to the video adapter
+// If 0, no Rift displays have been connected.
+// If greater than 0, use this size to pre-allocate space for an array
+// of rift statuses
+//
+// Input Buffer: Nothing
+// Output Buffer: LONG - count of Rift displays attached to video adapter
+//
+#define IOCTL_RIFTMGR_GET_RIFT_COUNT CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+//
+// Fills out a pre-allocated array with information on the individually attached
+// screens.
+// 
+// On Input, specify the arraySize as the size of the allocation.
+//
+// On Output, the arraySize will be updated with the actual number of Rifts
+// reported. Use IOCTL_RIFTMGR_GET_RIFT_COUNT to query the number of Rifts.
+// If the count changes (added or removed) between calls, the function will either fail
+// due to the buffer being too small, or the arraySize count will be updated
+// with a new count of devices along with their respective parameters.
+//
+// Input Buffer: PRIFT_STATUS - Pointer to allocated status array
+// Output Buffer: LONG - Count of Rift displays reported in the structure. -1 if out of
+//						 memory						
+//
+#define IOCTL_RIFTMGR_GET_RIFT_ARRAY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 1, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Changes the mode of an attached Rift (DEPRECATED)
+// Input Buffer: PRIFT_MODE - Pointer to a mode structure specifying the childUid and
+//							  mode for a particular Rift
+// Output Buffer: LONG		- Non-zero on error, 0 on successful mode change
+//
+#define IOCTL_RIFTMGR_SET_RIFT_MODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 2, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Lock the primary of the rift and obtain an address
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: ULONG_PTR		- Pointer to a usermode mapped address of the primary
+#define IOCTL_RIFTMGR_GET_RIFT_PRIMARY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 3, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Release Rift primary
+// Input Buffer: PULONG_PTR		- ChildUid of a Rift as previously discovered and virtual pointer
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_RELEASE_RIFT_PRIMARY CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 4, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+
+// Point the rift to another render target
+// Input Buffer: PHANDLE		- Array of handles, rift and the render target resource
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_SETRIFTBUFFER CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 5, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Enable or disable vsync on Rift present
+// Input Buffer: PRIFT_SYNC		- Pointer to a mode structure specifying the childUid and
+//								  and sync
+// Output Buffer: NOTHING
+#define IOCTL_RIFTMGR_SETVSYNCMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 6, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Get scan line
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: ULONG			- 31st bit is set if in vertical blank, high 15 bits has per second 
+//								  frame number (0-74), low 16 bits has scanline (0-1919)
+#define IOCTL_RIFTMGR_GETSCANLINE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 7, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Enable or disable compatibility mode. Entering compatibility mode will fail if
+// the Rift is already actively scanning out a surface
+// Input Buffer: LONG			- Bit assignments:
+// LSB (bit 0) is a flag for compatibility mode itself.
+//      1 means compatibility mode.
+//      0 means application direct mode.
+// Bit 1 means "Hide DK1's".
+//      1 means operate DK1's in synchronous with the compatibility mode exactly.
+//      0 means operate in DK1 legacy mode.
+// Output Buffer: LONG			- Result value (see OVR statuses)
+//								   0 = success
+//								  -1 = general failure
+//								  -2 = failure, rift scanning out
+//                                -3 = already active
+//                                -4 = rift not present
+#define IOCTL_RIFTMGR_SETCOMPATIBILITYMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 8, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Call to obtain the current status of compatibility mode
+// Input Buffer: NOTHING
+// Output Buffer: LONG			- Bit assignments:
+// LSB (bit 0) is a flag for compatibility mode itself.
+//      1 means compatibility mode.
+//      0 means application direct mode.
+// Bit 1 means "Hide DK1's".
+//      1 means operate DK1's in synchronous with the compatibility mode exactly.
+//      0 means operate in DK1 legacy mode.
+#define IOCTL_RIFTMGR_GETCOMPATIBILITYMODE CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 9, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Call to set the power mode of a particular Rift
+// Input Buffer: PULONG_PTR		- ChildUid of a Rift as previously discovered and ULONG value
+//							      second ULONG has value of 
+//								  0 to simply obtain the power status of the display
+//								  1 to set the display into a full power state (needs a primary to fully scan out)
+//								  2 to set the display into sleep mode
+//								  3 to set the display into full power off mode (WARNING: Will potentially trash primary)
+// Output Buffer: LONG			- Result value 
+//								  0 = Failure to obtain power status
+//								  1 = Full power
+//								  2 = Sleep
+//								  3 = Power off
+#define IOCTL_RIFTMGR_DISPLAYPOWER CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 10, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+// Return the EDID of the display in the output buffer. The driver
+// will copy as many bytes as possible to fill the buffer.
+// Input Buffer: ULONG			- ChildUid of a Rift as previously discovered
+// Output Buffer: PCHAR			- Preallocated buffer of a variable size to store the EDID from the display
+#define IOCTL_RIFTMGR_GETEDID CTL_CODE(FILE_DEVICE_VIDEO, \
+	FUNCTION_INDEX + 11, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_FocusReader.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,82 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_FocusReader.h
+Content     :   Reader for current app with focus on Windows
+Created     :   July 2, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_FocusReader_h
+#define OVR_Win32_FocusReader_h
+
+#include "../Kernel/OVR_System.h"
+#include "../Kernel/OVR_Lockless.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_SharedMemory.h"
+
+namespace OVR { namespace Win32 {
+
+
+#define OVR_FOCUS_OBSERVER_SHARE_NAME "OVRAppFocus"
+
+//-----------------------------------------------------------------------------
+// LocklessFocusState
+
+#pragma pack(push, 8)
+
+// Focus state data
+struct LocklessFocusState
+{
+    LocklessFocusState(DWORD pid = 0) :
+        ActiveProcessId(pid),
+        ActiveWindowHandle(NULL)
+    {
+    }
+
+    DWORD ActiveProcessId;
+    void * POINTER_64 ActiveWindowHandle;
+};
+
+#pragma pack(pop)
+
+typedef SharedObjectWriter< LocklessFocusState > SharedFocusWriter;
+typedef SharedObjectReader< LocklessFocusState > SharedFocusReader;
+
+
+//-----------------------------------------------------------------------------
+// RenderFocusReader
+
+class RenderFocusReader : public OVR::SystemSingletonBase<RenderFocusReader>, public NewOverrideBase
+{
+    OVR_DECLARE_SINGLETON(RenderFocusReader);
+
+    SharedFocusReader         Reader;         // Shared memory reader
+    const LocklessFocusState* FocusState;     // Pointer to the current focus state
+    bool                      NoSharedMemory; // Flag reporting that no shared memory has been detected;
+
+public:
+    HWND ReadActiveWindow();
+};
+
+
+}} // namespace OVR::Win32
+
+#endif // OVR_Win32_FocusReader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Displays/OVR_Win32_ShimFunctions.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,79 @@
+/************************************************************************************
+
+Filename    :   OVR_Win32_ShimFunctions.h
+Content     :   Client-side shim callbacks for usermode/rt hooks
+Created     :   May 6, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Win32_ShimFunctions_h
+#define OVR_Win32_ShimFunctions_h
+
+#include "OVR_Win32_Display.h"
+
+namespace OVR {
+
+struct Win32ShimInfo;
+
+namespace Win32 {  
+
+
+class DisplayShim
+{
+public:
+
+public:
+	static DisplayShim& GetInstance()
+	{
+		static DisplayShim instance;
+		return instance;
+	}
+
+	bool Initialize( bool inCompatibility );
+	bool Shutdown();
+
+	bool Update( Win32ShimInfo* shimInfo );
+
+	void* GetDX11SwapChain();
+
+	ULONG   ChildUid;
+	int		ExpectedWidth;
+	int		ExpectedHeight;
+	int		Rotation;
+	HWND    hWindow;
+	bool	UseMirroring;
+	bool	Active;
+
+private:
+
+	DisplayShim();
+
+	virtual ~DisplayShim();
+
+	DisplayShim(DisplayShim const&);    // Don't Implement
+	void operator=(DisplayShim const&); // Don't implement
+
+};
+
+
+}} // namespace OVR::Win32
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Alg.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,1062 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Alg.h
+Content     :   Simple general purpose algorithms: Sort, Binary Search, etc.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Alg_h
+#define OVR_Alg_h
+
+#include "OVR_Types.h"
+#include <string.h>
+
+namespace OVR { namespace Alg {
+
+
+//-----------------------------------------------------------------------------------
+// ***** Operator extensions
+
+template <typename T> OVR_FORCE_INLINE void Swap(T &a, T &b) 
+{  T temp(a); a = b; b = temp; }
+
+
+// ***** min/max are not implemented in Visual Studio 6 standard STL
+
+template <typename T> OVR_FORCE_INLINE const T Min(const T a, const T b)
+{ return (a < b) ? a : b; }
+
+template <typename T> OVR_FORCE_INLINE const T Max(const T a, const T b)
+{ return (b < a) ? a : b; }
+
+template <typename T> OVR_FORCE_INLINE const T Clamp(const T v, const T minVal, const T maxVal)
+{ return Max<T>(minVal, Min<T>(v, maxVal)); }
+
+template <typename T> OVR_FORCE_INLINE int     Chop(T f)
+{ return (int)f; }
+
+template <typename T> OVR_FORCE_INLINE T       Lerp(T a, T b, T f) 
+{ return (b - a) * f + a; }
+
+
+// These functions stand to fix a stupid VC++ warning (with /Wp64 on):
+// "warning C4267: 'argument' : conversion from 'size_t' to 'const unsigned', possible loss of data"
+// Use these functions instead of gmin/gmax if the argument has size
+// of the pointer to avoid the warning. Though, functionally they are
+// absolutelly the same as regular gmin/gmax.
+template <typename T>   OVR_FORCE_INLINE const T PMin(const T a, const T b)
+{
+    OVR_COMPILER_ASSERT(sizeof(T) == sizeof(size_t));
+    return (a < b) ? a : b;
+}
+template <typename T>   OVR_FORCE_INLINE const T PMax(const T a, const T b)
+{
+    OVR_COMPILER_ASSERT(sizeof(T) == sizeof(size_t));
+    return (b < a) ? a : b;
+}
+
+
+template <typename T>   OVR_FORCE_INLINE const T Abs(const T v)
+{ return (v>=0) ? v : -v; }
+
+
+//-----------------------------------------------------------------------------------
+// ***** OperatorLess
+//
+template<class T> struct OperatorLess
+{
+    static bool Compare(const T& a, const T& b)
+    {
+        return a < b;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The comparison predicate must be specified.
+template<class Array, class Less> 
+void QuickSortSliced(Array& arr, size_t start, size_t end, Less less)
+{
+    enum 
+    {
+        Threshold = 9
+    };
+
+    if(end - start <  2) return;
+
+    intptr_t  stack[80];
+    intptr_t* top   = stack; 
+    intptr_t  base  = (intptr_t)start;
+    intptr_t  limit = (intptr_t)end;
+
+    for(;;)
+    {
+        intptr_t len = limit - base;
+        intptr_t i, j, pivot;
+
+        if(len > Threshold)
+        {
+            // we use base + len/2 as the pivot
+            pivot = base + len / 2;
+            Swap(arr[base], arr[pivot]);
+
+            i = base + 1;
+            j = limit - 1;
+
+            // now ensure that *i <= *base <= *j 
+            if(less(arr[j],    arr[i])) Swap(arr[j],    arr[i]);
+            if(less(arr[base], arr[i])) Swap(arr[base], arr[i]);
+            if(less(arr[j], arr[base])) Swap(arr[j], arr[base]);
+
+            for(;;)
+            {
+                do i++; while( less(arr[i], arr[base]) );
+                do j--; while( less(arr[base], arr[j]) );
+
+                if( i > j )
+                {
+                    break;
+                }
+
+                Swap(arr[i], arr[j]);
+            }
+
+            Swap(arr[base], arr[j]);
+
+            // now, push the largest sub-array
+            if(j - base > limit - i)
+            {
+                top[0] = base;
+                top[1] = j;
+                base   = i;
+            }
+            else
+            {
+                top[0] = i;
+                top[1] = limit;
+                limit  = j;
+            }
+            top += 2;
+        }
+        else
+        {
+            // the sub-array is small, perform insertion sort
+            j = base;
+            i = j + 1;
+
+            for(; i < limit; j = i, i++)
+            {
+                for(; less(arr[j + 1], arr[j]); j--)
+                {
+                    Swap(arr[j + 1], arr[j]);
+                    if(j == base)
+                    {
+                        break;
+                    }
+                }
+            }
+            if(top > stack)
+            {
+                top  -= 2;
+                base  = top[0];
+                limit = top[1];
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The data type must have a defined "<" operator.
+template<class Array> 
+void QuickSortSliced(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    QuickSortSliced(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+// Same as corresponding G_QuickSortSliced but with checking array limits to avoid
+// crash in the case of wrong comparator functor.
+template<class Array, class Less> 
+bool QuickSortSlicedSafe(Array& arr, size_t start, size_t end, Less less)
+{
+    enum 
+    {
+        Threshold = 9
+    };
+
+    if(end - start <  2) return true;
+
+    intptr_t  stack[80];
+    intptr_t* top   = stack; 
+    intptr_t  base  = (intptr_t)start;
+    intptr_t  limit = (intptr_t)end;
+
+    for(;;)
+    {
+        intptr_t len = limit - base;
+        intptr_t i, j, pivot;
+
+        if(len > Threshold)
+        {
+            // we use base + len/2 as the pivot
+            pivot = base + len / 2;
+            Swap(arr[base], arr[pivot]);
+
+            i = base + 1;
+            j = limit - 1;
+
+            // now ensure that *i <= *base <= *j 
+            if(less(arr[j],    arr[i])) Swap(arr[j],    arr[i]);
+            if(less(arr[base], arr[i])) Swap(arr[base], arr[i]);
+            if(less(arr[j], arr[base])) Swap(arr[j], arr[base]);
+
+            for(;;)
+            {
+                do 
+                {   
+                    i++; 
+                    if (i >= limit)
+                        return false;
+                } while( less(arr[i], arr[base]) );
+                do 
+                {
+                    j--; 
+                    if (j < 0)
+                        return false;
+                } while( less(arr[base], arr[j]) );
+
+                if( i > j )
+                {
+                    break;
+                }
+
+                Swap(arr[i], arr[j]);
+            }
+
+            Swap(arr[base], arr[j]);
+
+            // now, push the largest sub-array
+            if(j - base > limit - i)
+            {
+                top[0] = base;
+                top[1] = j;
+                base   = i;
+            }
+            else
+            {
+                top[0] = i;
+                top[1] = limit;
+                limit  = j;
+            }
+            top += 2;
+        }
+        else
+        {
+            // the sub-array is small, perform insertion sort
+            j = base;
+            i = j + 1;
+
+            for(; i < limit; j = i, i++)
+            {
+                for(; less(arr[j + 1], arr[j]); j--)
+                {
+                    Swap(arr[j + 1], arr[j]);
+                    if(j == base)
+                    {
+                        break;
+                    }
+                }
+            }
+            if(top > stack)
+            {
+                top  -= 2;
+                base  = top[0];
+                limit = top[1];
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    return true;
+}
+
+template<class Array> 
+bool QuickSortSlicedSafe(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    return QuickSortSlicedSafe(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The comparison predicate must be specified.
+template<class Array, class Less> 
+void QuickSort(Array& arr, Less less)
+{
+    QuickSortSliced(arr, 0, arr.GetSize(), less);
+}
+
+// checks for boundaries
+template<class Array, class Less> 
+bool QuickSortSafe(Array& arr, Less less)
+{
+    return QuickSortSlicedSafe(arr, 0, arr.GetSize(), less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** QuickSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The data type must have a defined "<" operator.
+template<class Array> 
+void QuickSort(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    QuickSortSliced(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+template<class Array> 
+bool QuickSortSafe(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    return QuickSortSlicedSafe(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The comparison predicate must be specified.
+// Unlike Quick Sort, the Insertion Sort works much slower in average, 
+// but may be much faster on almost sorted arrays. Besides, it guarantees
+// that the elements will not be swapped if not necessary. For example, 
+// an array with all equal elements will remain "untouched", while 
+// Quick Sort will considerably shuffle the elements in this case.
+template<class Array, class Less> 
+void InsertionSortSliced(Array& arr, size_t start, size_t end, Less less)
+{
+    size_t j = start;
+    size_t i = j + 1;
+    size_t limit = end;
+
+    for(; i < limit; j = i, i++)
+    {
+        for(; less(arr[j + 1], arr[j]); j--)
+        {
+            Swap(arr[j + 1], arr[j]);
+            if(j <= start)
+            {
+                break;
+            }
+        }
+    }
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSortSliced
+//
+// Sort any part of any array: plain, Array, ArrayPaged, ArrayUnsafe.
+// The range is specified with start, end, where "end" is exclusive!
+// The data type must have a defined "<" operator.
+template<class Array> 
+void InsertionSortSliced(Array& arr, size_t start, size_t end)
+{
+    typedef typename Array::ValueType ValueType;
+    InsertionSortSliced(arr, start, end, OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The comparison predicate must be specified.
+
+template<class Array, class Less> 
+void InsertionSort(Array& arr, Less less)
+{
+    InsertionSortSliced(arr, 0, arr.GetSize(), less);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** InsertionSort
+//
+// Sort an array Array, ArrayPaged, ArrayUnsafe.
+// The array must have GetSize() function.
+// The data type must have a defined "<" operator.
+template<class Array> 
+void InsertionSort(Array& arr)
+{
+    typedef typename Array::ValueType ValueType;
+    InsertionSortSliced(arr, 0, arr.GetSize(), OperatorLess<ValueType>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Median
+// Returns a median value of the input array.
+// Caveats: partially sorts the array, returns a reference to the array element
+// TBD: This needs to be optimized and generalized
+//
+template<class Array> 
+typename Array::ValueType& Median(Array& arr)
+{
+    size_t count = arr.GetSize();
+    size_t mid = (count - 1) / 2;
+    OVR_ASSERT(count > 0);
+
+	for (size_t j = 0; j <= mid; j++)
+    {
+		size_t min = j;
+		for (size_t k = j + 1; k < count; k++)
+            if (arr[k] < arr[min]) 
+                min = k;
+        Swap(arr[j], arr[min]);
+    }
+    return arr[mid];
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSliced
+//
+template<class Array, class Value, class Less>
+size_t LowerBoundSliced(const Array& arr, size_t start, size_t end, const Value& val, Less less)
+{
+    intptr_t first = (intptr_t)start;
+    intptr_t len   = (intptr_t)(end - start);
+    intptr_t half;
+    intptr_t middle;
+    
+    while(len > 0) 
+    {
+        half = len >> 1;
+        middle = first + half;
+        if(less(arr[middle], val)) 
+        {
+            first = middle + 1;
+            len   = len - half - 1;
+        }
+        else
+        {
+            len = half;
+        }
+    }
+    return (size_t)first;
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSliced
+//
+template<class Array, class Value>
+size_t LowerBoundSliced(const Array& arr, size_t start, size_t end, const Value& val)
+{
+    return LowerBoundSliced(arr, start, end, val, OperatorLess<Value>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBoundSized
+//
+template<class Array, class Value>
+size_t LowerBoundSized(const Array& arr, size_t size, const Value& val)
+{
+    return LowerBoundSliced(arr, 0, size, val, OperatorLess<Value>::Compare);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBound
+//
+template<class Array, class Value, class Less>
+size_t LowerBound(const Array& arr, const Value& val, Less less)
+{
+    return LowerBoundSliced(arr, 0, arr.GetSize(), val, less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** LowerBound
+//
+template<class Array, class Value>
+size_t LowerBound(const Array& arr, const Value& val)
+{
+    return LowerBoundSliced(arr, 0, arr.GetSize(), val, OperatorLess<Value>::Compare);
+}
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSliced
+//
+template<class Array, class Value, class Less>
+size_t UpperBoundSliced(const Array& arr, size_t start, size_t end, const Value& val, Less less)
+{
+    intptr_t first = (intptr_t)start;
+    intptr_t len   = (intptr_t)(end - start);
+    intptr_t half;
+    intptr_t middle;
+    
+    while(len > 0) 
+    {
+        half = len >> 1;
+        middle = first + half;
+        if(less(val, arr[middle]))
+        {
+            len = half;
+        }
+        else 
+        {
+            first = middle + 1;
+            len   = len - half - 1;
+        }
+    }
+    return (size_t)first;
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSliced
+//
+template<class Array, class Value>
+size_t UpperBoundSliced(const Array& arr, size_t start, size_t end, const Value& val)
+{
+    return UpperBoundSliced(arr, start, end, val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBoundSized
+//
+template<class Array, class Value>
+size_t UpperBoundSized(const Array& arr, size_t size, const Value& val)
+{
+    return UpperBoundSliced(arr, 0, size, val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBound
+//
+template<class Array, class Value, class Less>
+size_t UpperBound(const Array& arr, const Value& val, Less less)
+{
+    return UpperBoundSliced(arr, 0, arr.GetSize(), val, less);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** UpperBound
+//
+template<class Array, class Value>
+size_t UpperBound(const Array& arr, const Value& val)
+{
+    return UpperBoundSliced(arr, 0, arr.GetSize(), val, OperatorLess<Value>::Compare);
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** ReverseArray
+//
+template<class Array> void ReverseArray(Array& arr)
+{
+    intptr_t from = 0;
+    intptr_t to   = arr.GetSize() - 1;
+    while(from < to)
+    {
+        Swap(arr[from], arr[to]);
+        ++from;
+        --to;
+    }
+}
+
+
+// ***** AppendArray
+//
+template<class CDst, class CSrc> 
+void AppendArray(CDst& dst, const CSrc& src)
+{
+    size_t i;
+    for(i = 0; i < src.GetSize(); i++) 
+        dst.PushBack(src[i]);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayAdaptor
+//
+// A simple adapter that provides the GetSize() method and overloads 
+// operator []. Used to wrap plain arrays in QuickSort and such.
+template<class T> class ArrayAdaptor
+{
+public:
+    typedef T ValueType;
+    ArrayAdaptor() : Data(0), Size(0) {}
+    ArrayAdaptor(T* ptr, size_t size) : Data(ptr), Size(size) {}
+    size_t GetSize() const { return Size; }
+	int GetSizeI() const { return (int)GetSize(); }
+    const T& operator [] (size_t i) const { return Data[i]; }
+          T& operator [] (size_t i)       { return Data[i]; }
+private:
+    T*      Data;
+    size_t  Size;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** GConstArrayAdaptor
+//
+// A simple const adapter that provides the GetSize() method and overloads 
+// operator []. Used to wrap plain arrays in LowerBound and such.
+template<class T> class ConstArrayAdaptor
+{
+public:
+    typedef T ValueType;
+    ConstArrayAdaptor() : Data(0), Size(0) {}
+    ConstArrayAdaptor(const T* ptr, size_t size) : Data(ptr), Size(size) {}
+    size_t GetSize() const { return Size; }
+	int GetSizeI() const { return (int)GetSize(); }
+	const T& operator [] (size_t i) const { return Data[i]; }
+private:
+    const T* Data;
+    size_t   Size;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+extern const uint8_t UpperBitTable[256];
+extern const uint8_t LowerBitTable[256];
+
+
+
+//-----------------------------------------------------------------------------------
+inline uint8_t UpperBit(size_t val)
+{
+#ifndef OVR_64BIT_POINTERS
+
+    if (val & 0xFFFF0000)
+    {
+        return (val & 0xFF000000) ? 
+            UpperBitTable[(val >> 24)       ] + 24: 
+            UpperBitTable[(val >> 16) & 0xFF] + 16;
+    }
+    return (val & 0xFF00) ?
+        UpperBitTable[(val >> 8) & 0xFF] + 8:
+        UpperBitTable[(val     ) & 0xFF];
+
+#else
+
+    if (val & 0xFFFFFFFF00000000)
+    {
+        if (val & 0xFFFF000000000000)
+        {
+            return (val & 0xFF00000000000000) ?
+                UpperBitTable[(val >> 56)       ] + 56: 
+                UpperBitTable[(val >> 48) & 0xFF] + 48;
+        }
+        return (val & 0xFF0000000000) ?
+            UpperBitTable[(val >> 40) & 0xFF] + 40:
+            UpperBitTable[(val >> 32) & 0xFF] + 32;
+    }
+    else
+    {
+        if (val & 0xFFFF0000)
+        {
+            return (val & 0xFF000000) ? 
+                UpperBitTable[(val >> 24)       ] + 24: 
+                UpperBitTable[(val >> 16) & 0xFF] + 16;
+        }
+        return (val & 0xFF00) ?
+            UpperBitTable[(val >> 8) & 0xFF] + 8:
+            UpperBitTable[(val     ) & 0xFF];
+    }
+
+#endif
+}
+
+//-----------------------------------------------------------------------------------
+inline uint8_t LowerBit(size_t val)
+{
+#ifndef OVR_64BIT_POINTERS
+
+    if (val & 0xFFFF)
+    {
+        return (val & 0xFF) ?
+            LowerBitTable[ val & 0xFF]:
+            LowerBitTable[(val >> 8) & 0xFF] + 8;
+    }
+    return (val & 0xFF0000) ?
+            LowerBitTable[(val >> 16) & 0xFF] + 16:
+            LowerBitTable[(val >> 24) & 0xFF] + 24;
+
+#else
+
+    if (val & 0xFFFFFFFF)
+    {
+        if (val & 0xFFFF)
+        {
+            return (val & 0xFF) ?
+                LowerBitTable[ val & 0xFF]:
+                LowerBitTable[(val >> 8) & 0xFF] + 8;
+        }
+        return (val & 0xFF0000) ?
+                LowerBitTable[(val >> 16) & 0xFF] + 16:
+                LowerBitTable[(val >> 24) & 0xFF] + 24;
+    }
+    else
+    {
+        if (val & 0xFFFF00000000)
+        {
+             return (val & 0xFF00000000) ?
+                LowerBitTable[(val >> 32) & 0xFF] + 32:
+                LowerBitTable[(val >> 40) & 0xFF] + 40;
+        }
+        return (val & 0xFF000000000000) ?
+            LowerBitTable[(val >> 48) & 0xFF] + 48:
+            LowerBitTable[(val >> 56) & 0xFF] + 56;
+    }
+
+#endif
+}
+
+
+
+// ******* Special (optimized) memory routines
+// Note: null (bad) pointer is not tested
+class MemUtil
+{
+public:
+                                    
+    // Memory compare
+    static int      Cmp  (const void* p1, const void* p2, size_t byteCount)      { return memcmp(p1, p2, byteCount); }
+    static int      Cmp16(const void* p1, const void* p2, size_t int16Count);
+    static int      Cmp32(const void* p1, const void* p2, size_t int32Count);
+    static int      Cmp64(const void* p1, const void* p2, size_t int64Count); 
+};
+
+// ** Inline Implementation
+
+inline int MemUtil::Cmp16(const void* p1, const void* p2, size_t int16Count)
+{
+    int16_t*  pa  = (int16_t*)p1; 
+    int16_t*  pb  = (int16_t*)p2;
+    unsigned ic  = 0;
+    if (int16Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int16Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+inline int MemUtil::Cmp32(const void* p1, const void* p2, size_t int32Count)
+{
+    int32_t*  pa  = (int32_t*)p1;
+    int32_t*  pb  = (int32_t*)p2;
+    unsigned ic  = 0;
+    if (int32Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int32Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+inline int MemUtil::Cmp64(const void* p1, const void* p2, size_t int64Count)
+{
+    int64_t*  pa  = (int64_t*)p1;
+    int64_t*  pb  = (int64_t*)p2;
+    unsigned ic  = 0;
+    if (int64Count == 0)
+        return 0;
+    while (pa[ic] == pb[ic])
+        if (++ic==int64Count)
+            return 0;
+    return pa[ic] > pb[ic] ? 1 : -1;
+}
+
+// ** End Inline Implementation
+
+
+//-----------------------------------------------------------------------------------
+// ******* Byte Order Conversions
+namespace ByteUtil {
+
+    // *** Swap Byte Order
+
+    // Swap the byte order of a byte array
+    inline void     SwapOrder(void* pv, int size)
+    {
+        uint8_t*  pb = (uint8_t*)pv;
+        uint8_t temp;
+        for (int i = 0; i < size>>1; i++)
+        { 
+            temp            = pb[size-1-i];
+            pb[size-1-i]    = pb[i];
+            pb[i]           = temp; 
+        }
+    }
+
+    // Swap the byte order of primitive types
+    inline uint8_t  SwapOrder(uint8_t v)    { return v; }
+    inline int8_t   SwapOrder(int8_t v)     { return v; }
+    inline uint16_t SwapOrder(uint16_t v)   { return uint16_t(v>>8)|uint16_t(v<<8); }
+    inline int16_t  SwapOrder(int16_t v)    { return int16_t((uint16_t(v)>>8)|(v<<8)); }
+    inline uint32_t SwapOrder(uint32_t v)   { return (v>>24)|((v&0x00FF0000)>>8)|((v&0x0000FF00)<<8)|(v<<24); }
+    inline int32_t  SwapOrder(int32_t p)    { return (int32_t)SwapOrder(uint32_t(p)); }
+    inline uint64_t SwapOrder(uint64_t v)
+    { 
+        return   (v>>56) |
+                 ((v&uint64_t(0x00FF000000000000ULL))>>40) |
+                 ((v&uint64_t(0x0000FF0000000000ULL))>>24) |
+                 ((v&uint64_t(0x000000FF00000000ULL))>>8)  |
+                 ((v&uint64_t(0x00000000FF000000ULL))<<8)  |
+                 ((v&uint64_t(0x0000000000FF0000ULL))<<24) |
+                 ((v&uint64_t(0x000000000000FF00ULL))<<40) |
+                 (v<<56); 
+    }
+    inline int64_t  SwapOrder(int64_t v)     { return (int64_t)SwapOrder(uint64_t(v)); }
+    inline float    SwapOrder(float p)      
+    { 
+        union {
+            float p;
+            uint32_t v;
+        } u;
+        u.p = p;
+        u.v = SwapOrder(u.v);
+        return u.p;
+    }
+
+    inline double   SwapOrder(double p)
+    { 
+        union {
+            double p;
+            uint64_t v;
+        } u;
+        u.p = p;
+        u.v = SwapOrder(u.v);
+        return u.p;
+    }
+    
+    // *** Byte-order conversion
+
+#if (OVR_BYTE_ORDER == OVR_LITTLE_ENDIAN)
+    // Little Endian to System (LE)
+    inline uint8_t  LEToSystem(uint8_t v)   { return v; }
+    inline int8_t   LEToSystem(int8_t v)    { return v; }
+    inline uint16_t LEToSystem(uint16_t v)  { return v; }
+    inline int16_t  LEToSystem(int16_t v)   { return v; }
+    inline uint32_t LEToSystem(uint32_t v)  { return v; }
+    inline int32_t  LEToSystem(int32_t v)   { return v; }
+    inline uint64_t LEToSystem(uint64_t v)  { return v; }
+    inline int64_t  LEToSystem(int64_t v)    { return v; }
+    inline float    LEToSystem(float  v)    { return v; }
+    inline double   LEToSystem(double v)    { return v; }
+
+    // Big Endian to System (LE)
+    inline uint8_t  BEToSystem(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   BEToSystem(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t BEToSystem(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  BEToSystem(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t BEToSystem(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  BEToSystem(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t BEToSystem(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  BEToSystem(int64_t v)    { return SwapOrder(v); }
+    inline float    BEToSystem(float  v)    { return SwapOrder(v); }
+    inline double   BEToSystem(double v)    { return SwapOrder(v); }
+
+    // System (LE) to Little Endian
+    inline uint8_t  SystemToLE(uint8_t v)   { return v; }
+    inline int8_t   SystemToLE(int8_t v)    { return v; }
+    inline uint16_t SystemToLE(uint16_t v)  { return v; }
+    inline int16_t  SystemToLE(int16_t v)   { return v; }
+    inline uint32_t SystemToLE(uint32_t v)  { return v; }
+    inline int32_t  SystemToLE(int32_t v)   { return v; }
+    inline uint64_t SystemToLE(uint64_t v)  { return v; }
+    inline int64_t  SystemToLE(int64_t v)    { return v; }
+    inline float    SystemToLE(float  v)    { return v; }
+    inline double   SystemToLE(double v)    { return v; }   
+
+    // System (LE) to Big Endian
+    inline uint8_t  SystemToBE(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   SystemToBE(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t SystemToBE(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  SystemToBE(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t SystemToBE(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  SystemToBE(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t SystemToBE(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  SystemToBE(int64_t v)    { return SwapOrder(v); }
+    inline float    SystemToBE(float  v)    { return SwapOrder(v); }
+    inline double   SystemToBE(double v)    { return SwapOrder(v); }
+
+#elif (OVR_BYTE_ORDER == OVR_BIG_ENDIAN)
+    // Little Endian to System (BE)
+    inline uint8_t  LEToSystem(uint8_t  v)  { return SwapOrder(v); }
+    inline int8_t   LEToSystem(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t LEToSystem(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  LEToSystem(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t LEToSystem(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  LEToSystem(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t LEToSystem(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  LEToSystem(int64_t v)    { return SwapOrder(v); }
+    inline float    LEToSystem(float  v)    { return SwapOrder(v); }
+    inline double   LEToSystem(double v)    { return SwapOrder(v); }
+
+    // Big Endian to System (BE)
+    inline uint8_t  BEToSystem(uint8_t v)   { return v; }
+    inline int8_t   BEToSystem(int8_t v)    { return v; }
+    inline uint16_t BEToSystem(uint16_t v)  { return v; }
+    inline int16_t  BEToSystem(int16_t v)   { return v; }
+    inline uint32_t BEToSystem(uint32_t v)  { return v; }
+    inline int32_t  BEToSystem(int32_t v)   { return v; }
+    inline uint64_t BEToSystem(uint64_t v)  { return v; }
+    inline int64_t  BEToSystem(int64_t v)    { return v; }
+    inline float    BEToSystem(float  v)    { return v; }
+    inline double   BEToSystem(double v)    { return v; }
+
+    // System (BE) to Little Endian
+    inline uint8_t  SystemToLE(uint8_t v)   { return SwapOrder(v); }
+    inline int8_t   SystemToLE(int8_t v)    { return SwapOrder(v); }
+    inline uint16_t SystemToLE(uint16_t v)  { return SwapOrder(v); }
+    inline int16_t  SystemToLE(int16_t v)   { return SwapOrder(v); }
+    inline uint32_t SystemToLE(uint32_t v)  { return SwapOrder(v); }
+    inline int32_t  SystemToLE(int32_t v)   { return SwapOrder(v); }
+    inline uint64_t SystemToLE(uint64_t v)  { return SwapOrder(v); }
+    inline int64_t  SystemToLE(int64_t v)    { return SwapOrder(v); }
+    inline float    SystemToLE(float  v)    { return SwapOrder(v); }
+    inline double   SystemToLE(double v)    { return SwapOrder(v); }
+
+    // System (BE) to Big Endian
+    inline uint8_t  SystemToBE(uint8_t v)   { return v; }
+    inline int8_t   SystemToBE(int8_t v)    { return v; }
+    inline uint16_t SystemToBE(uint16_t v)  { return v; }
+    inline int16_t  SystemToBE(int16_t v)   { return v; }
+    inline uint32_t SystemToBE(uint32_t v)  { return v; }
+    inline int32_t  SystemToBE(int32_t v)   { return v; }
+    inline uint64_t SystemToBE(uint64_t v)  { return v; }
+    inline int64_t  SystemToBE(int64_t v)    { return v; }
+    inline float    SystemToBE(float  v)    { return v; }
+    inline double   SystemToBE(double v)    { return v; }
+
+#else
+    #error "OVR_BYTE_ORDER must be defined to OVR_LITTLE_ENDIAN or OVR_BIG_ENDIAN"
+#endif
+
+} // namespace ByteUtil
+
+
+
+// Used primarily for hardware interfacing such as sensor reports, firmware, etc.
+// Reported data is all little-endian.
+inline uint16_t DecodeUInt16(const uint8_t* buffer)
+{
+    return ByteUtil::LEToSystem ( *(const uint16_t*)buffer );
+}
+
+inline int16_t DecodeSInt16(const uint8_t* buffer)
+{
+    return ByteUtil::LEToSystem ( *(const int16_t*)buffer );
+}
+
+inline uint32_t DecodeUInt32(const uint8_t* buffer)
+{    
+    return ByteUtil::LEToSystem ( *(const uint32_t*)buffer );
+}
+
+inline int32_t DecodeSInt32(const uint8_t* buffer)
+{    
+    return ByteUtil::LEToSystem ( *(const int32_t*)buffer );
+}
+
+inline float DecodeFloat(const uint8_t* buffer)
+{
+    union {
+        uint32_t U;
+        float  F;
+    };
+
+    U = DecodeUInt32(buffer);
+    return F;
+}
+
+inline void EncodeUInt16(uint8_t* buffer, uint16_t val)
+{
+    *(uint16_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeSInt16(uint8_t* buffer, int16_t val)
+{
+    *(int16_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeUInt32(uint8_t* buffer, uint32_t val)
+{
+    *(uint32_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeSInt32(uint8_t* buffer, int32_t val)
+{
+    *(int32_t*)buffer = ByteUtil::SystemToLE ( val );
+}
+
+inline void EncodeFloat(uint8_t* buffer, float val)
+{
+    union {
+        uint32_t U;
+        float  F;
+    };
+
+    F = val;
+    EncodeUInt32(buffer, U);
+}
+
+// Converts an 8-bit binary-coded decimal
+inline int8_t DecodeBCD(uint8_t byte)
+{
+    uint8_t digit1 = (byte >> 4) & 0x0f;
+    uint8_t digit2 = byte & 0x0f;
+    int decimal = digit1 * 10 + digit2;   // maximum value = 99
+    return (int8_t)decimal;
+}
+
+
+}} // OVR::Alg
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Allocator.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,347 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Allocator.h
+Content     :   Installable memory allocator
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Allocator_h
+#define OVR_Allocator_h
+
+#include "OVR_Types.h"
+
+//-----------------------------------------------------------------------------------
+
+// ***** Disable template-unfriendly MS VC++ warnings
+#if defined(OVR_CC_MSVC)
+// Pragma to prevent long name warnings in in VC++
+#pragma warning(disable : 4503)
+#pragma warning(disable : 4786)
+// In MSVC 7.1, warning about placement new POD default initializer
+#pragma warning(disable : 4345)
+#endif
+
+// Un-define new so that placement constructors work
+#undef new
+
+
+//-----------------------------------------------------------------------------------
+// ***** Placement new overrides
+
+// Calls constructor on own memory created with "new(ptr) type"
+#ifndef __PLACEMENT_NEW_INLINE
+#define __PLACEMENT_NEW_INLINE
+
+#   if defined(OVR_CC_MWERKS) || defined(OVR_CC_BORLAND) || defined(OVR_CC_GNU)
+#      include <new>
+#   else
+    // Useful on MSVC
+    OVR_FORCE_INLINE void* operator new     (size_t n, void *ptr) { OVR_UNUSED(n); return ptr; }
+    OVR_FORCE_INLINE void  operator delete  (void *, void *)     { }
+#   endif
+
+#endif // __PLACEMENT_NEW_INLINE
+
+
+
+//------------------------------------------------------------------------
+// ***** Macros to redefine class new/delete operators
+
+// Types specifically declared to allow disambiguation of address in
+// class member operator new.
+
+#define OVR_MEMORY_REDEFINE_NEW_IMPL(class_name, check_delete)                          \
+    void*   operator new(size_t sz)                                                      \
+    { void *p = OVR_ALLOC_DEBUG(sz, __FILE__, __LINE__); return p; }                                              \
+    void*   operator new(size_t sz, const char* file, int line)                          \
+    { void* p = OVR_ALLOC_DEBUG(sz, file, line); OVR_UNUSED2(file, line); return p; }   \
+    void    operator delete(void *p)                                                    \
+    { check_delete(class_name, p); OVR_FREE(p); }                                       \
+    void    operator delete(void *p, const char*, int)                                  \
+    { check_delete(class_name, p); OVR_FREE(p); }                          
+
+#define OVR_MEMORY_DEFINE_PLACEMENT_NEW                                                 \
+    void*   operator new        (size_t n, void *ptr)    { OVR_UNUSED(n); return ptr; }  \
+    void    operator delete     (void *ptr, void *ptr2) { OVR_UNUSED2(ptr,ptr2); }
+
+
+#define OVR_MEMORY_CHECK_DELETE_NONE(class_name, p)
+
+// Redefined all delete/new operators in a class without custom memory initialization
+#define OVR_MEMORY_REDEFINE_NEW(class_name) \
+    OVR_MEMORY_REDEFINE_NEW_IMPL(class_name, OVR_MEMORY_CHECK_DELETE_NONE)
+
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Construct / Destruct
+
+// Construct/Destruct functions are useful when new is redefined, as they can
+// be called instead of placement new constructors.
+
+
+template <class T>
+OVR_FORCE_INLINE T*  Construct(void *p)
+{
+    return ::new(p) T();
+}
+
+template <class T>
+OVR_FORCE_INLINE T*  Construct(void *p, const T& source)
+{
+    return ::new(p) T(source);
+}
+
+// Same as above, but allows for a different type of constructor.
+template <class T, class S>
+OVR_FORCE_INLINE T*  ConstructAlt(void *p, const S& source)
+{
+    return ::new(p) T(source);
+}
+
+template <class T, class S1, class S2>
+OVR_FORCE_INLINE T*  ConstructAlt(void *p, const S1& src1, const S2& src2)
+{
+    return ::new(p) T(src1, src2);
+}
+
+template <class T>
+OVR_FORCE_INLINE void ConstructArray(void *p, size_t count)
+{
+    uint8_t *pdata = (uint8_t*)p;
+    for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+    {
+        Construct<T>(pdata);
+    }
+}
+
+template <class T>
+OVR_FORCE_INLINE void ConstructArray(void *p, size_t count, const T& source)
+{
+    uint8_t *pdata = (uint8_t*)p;
+    for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+    {
+        Construct<T>(pdata, source);
+    }
+}
+
+template <class T>
+OVR_FORCE_INLINE void Destruct(T *pobj)
+{
+    pobj->~T();
+    OVR_UNUSED1(pobj); // Fix incorrect 'unused variable' MSVC warning.
+}
+
+template <class T>
+OVR_FORCE_INLINE void DestructArray(T *pobj, size_t count)
+{   
+    for (size_t i=0; i<count; ++i, ++pobj)
+        pobj->~T();
+}
+
+
+//-----------------------------------------------------------------------------------
+// ***** Allocator
+
+// Allocator defines a memory allocation interface that developers can override
+// to to provide memory for OVR; an instance of this class is typically created on
+// application startup and passed into System or OVR::System constructor.
+// 
+//
+// Users implementing this interface must provide three functions: Alloc, Free,
+// and Realloc. Implementations of these functions must honor the requested alignment.
+// Although arbitrary alignment requests are possible, requested alignment will
+// typically be small, such as 16 bytes or less.
+
+class Allocator
+{
+    friend class System;
+public:
+
+    // *** Standard Alignment Alloc/Free
+
+    // Allocate memory of specified size with default alignment.
+    // Alloc of size==0 will allocate a tiny block & return a valid pointer;
+    // this makes it suitable for new operator.
+    virtual void*   Alloc(size_t size) = 0;
+    // Same as Alloc, but provides an option of passing debug data.
+    virtual void*   AllocDebug(size_t size, const char* file, unsigned line)
+    { OVR_UNUSED2(file, line); return Alloc(size); }
+
+    // Reallocate memory block to a new size, copying data if necessary. Returns the pointer to
+    // new memory block, which may be the same as original pointer. Will return 0 if reallocation
+    // failed, in which case previous memory is still valid.
+    // Realloc to decrease size will never fail.
+    // Realloc of pointer == 0 is equivalent to Alloc
+    // Realloc to size == 0, shrinks to the minimal size, pointer remains valid and requires Free().
+    virtual void*   Realloc(void* p, size_t newSize) = 0;
+
+    // Frees memory allocated by Alloc/Realloc.
+    // Free of null pointer is valid and will do nothing.
+    virtual void    Free(void *p) = 0;
+
+
+    // *** Standard Alignment Alloc/Free
+
+    // Allocate memory of specified alignment.
+    // Memory allocated with AllocAligned MUST be freed with FreeAligned.
+    // Default implementation will delegate to Alloc/Free after doing rounding.
+    virtual void*   AllocAligned(size_t size, size_t align);    
+    // Frees memory allocated with AllocAligned.
+    virtual void    FreeAligned(void* p);
+    
+    // Returns the pointer to the current globally installed Allocator instance.
+    // This pointer is used for most of the memory allocations.
+    static Allocator* GetInstance() { return pInstance; }
+
+
+protected:
+    // onSystemShutdown is called on the allocator during System::Shutdown.
+    // At this point, all allocations should've been freed.
+    virtual void    onSystemShutdown() { }
+
+public:
+    static  void    setInstance(Allocator* palloc)    
+    {
+        OVR_ASSERT((pInstance == 0) || (palloc == 0));
+        pInstance = palloc;
+    }
+
+private:
+
+    static Allocator* pInstance;
+};
+
+
+
+//------------------------------------------------------------------------
+// ***** Allocator_SingletonSupport
+
+// Allocator_SingletonSupport is a Allocator wrapper class that implements
+// the InitSystemSingleton static function, used to create a global singleton
+// used for the OVR::System default argument initialization.
+//
+// End users implementing custom Allocator interface don't need to make use of this base
+// class; they can just create an instance of their own class on stack and pass it to System.
+
+template<class D>
+class Allocator_SingletonSupport : public Allocator
+{
+    struct AllocContainer
+    {        
+        size_t Data[(sizeof(D) + sizeof(size_t)-1) / sizeof(size_t)];
+        bool  Initialized;
+        AllocContainer() : Initialized(0) { }
+    };
+
+    AllocContainer* pContainer;
+
+public:
+    Allocator_SingletonSupport() : pContainer(0) { }
+
+    // Creates a singleton instance of this Allocator class used
+    // on OVR_DEFAULT_ALLOCATOR during System initialization.
+    static  D*  InitSystemSingleton()
+    {
+        static AllocContainer Container;
+        OVR_ASSERT(Container.Initialized == false);
+
+        Allocator_SingletonSupport<D> *presult = Construct<D>((void*)Container.Data);
+        presult->pContainer   = &Container;
+        Container.Initialized = true;
+        return (D*)presult;
+    }
+
+protected:
+    virtual void onSystemShutdown()
+    {
+        Allocator::onSystemShutdown();
+        if (pContainer)
+        {
+            pContainer->Initialized = false;
+            Destruct((D*)this);
+            pContainer = 0;
+        }
+    }
+};
+
+//------------------------------------------------------------------------
+// ***** Default Allocator
+
+// This allocator is created and used if no other allocator is installed.
+// Default allocator delegates to system malloc.
+
+class DefaultAllocator : public Allocator_SingletonSupport<DefaultAllocator>
+{
+public:
+    virtual void*   Alloc(size_t size);
+    virtual void*   AllocDebug(size_t size, const char* file, unsigned line);
+    virtual void*   Realloc(void* p, size_t newSize);
+    virtual void    Free(void *p);
+};
+
+
+//------------------------------------------------------------------------
+// ***** Memory Allocation Macros
+
+// These macros should be used for global allocation. In the future, these
+// macros will allows allocation to be extended with debug file/line information
+// if necessary.
+
+#define OVR_REALLOC(p,s)        OVR::Allocator::GetInstance()->Realloc((p),(s))
+#define OVR_FREE(p)             OVR::Allocator::GetInstance()->Free((p))
+#define OVR_ALLOC_ALIGNED(s,a)  OVR::Allocator::GetInstance()->AllocAligned((s),(a))
+#define OVR_FREE_ALIGNED(p)     OVR::Allocator::GetInstance()->FreeAligned((p))
+
+#ifdef OVR_BUILD_DEBUG
+#define OVR_ALLOC(s)            OVR::Allocator::GetInstance()->AllocDebug((s), __FILE__, __LINE__)
+#define OVR_ALLOC_DEBUG(s,f,l)  OVR::Allocator::GetInstance()->AllocDebug((s), f, l)
+#else
+#define OVR_ALLOC(s)            OVR::Allocator::GetInstance()->Alloc((s))
+#define OVR_ALLOC_DEBUG(s,f,l)  OVR::Allocator::GetInstance()->Alloc((s))
+#endif
+
+//------------------------------------------------------------------------
+
+// Base class that overrides the new and delete operators.
+// Deriving from this class, even as a multiple base, incurs no space overhead.
+class NewOverrideBase
+{
+public:
+
+    // Redefine all new & delete operators.
+    OVR_MEMORY_REDEFINE_NEW(NewOverrideBase)
+};
+
+
+} // OVR
+
+
+// Redefine operator 'new' if necessary.
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif
+
+
+#endif // OVR_Memory
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Array.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Array.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,834 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Array.h
+Content     :   Template implementation for Array
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Array_h
+#define OVR_Array_h
+
+#include "OVR_ContainerAllocator.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDefaultPolicy
+//
+// Default resize behavior. No minimal capacity, Granularity=4, 
+// Shrinking as needed. ArrayConstPolicy actually is the same as 
+// ArrayDefaultPolicy, but parametrized with constants. 
+// This struct is used only in order to reduce the template "matroska".
+struct ArrayDefaultPolicy
+{
+    ArrayDefaultPolicy() : Capacity(0) {}
+    ArrayDefaultPolicy(const ArrayDefaultPolicy&) : Capacity(0) {}
+
+    size_t GetMinCapacity() const { return 0; }
+    size_t GetGranularity() const { return 4; }
+    bool  NeverShrinking() const { return 0; }
+
+    size_t GetCapacity()    const      { return Capacity; }
+    void  SetCapacity(size_t capacity) { Capacity = capacity; }
+private:
+    size_t Capacity;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayConstPolicy
+//
+// Statically parametrized resizing behavior:
+// MinCapacity, Granularity, and Shrinking flag.
+template<int MinCapacity=0, int Granularity=4, bool NeverShrink=false>
+struct ArrayConstPolicy
+{
+    typedef ArrayConstPolicy<MinCapacity, Granularity, NeverShrink> SelfType;
+
+    ArrayConstPolicy() : Capacity(0) {}
+    ArrayConstPolicy(const SelfType&) : Capacity(0) {}
+
+    size_t GetMinCapacity() const { return MinCapacity; }
+    size_t GetGranularity() const { return Granularity; }
+    bool  NeverShrinking() const { return NeverShrink; }
+
+    size_t GetCapacity()    const      { return Capacity; }
+    void  SetCapacity(size_t capacity) { Capacity = capacity; }
+private:
+    size_t Capacity;
+};
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDataBase
+//
+// Basic operations with array data: Reserve, Resize, Free, ArrayPolicy.
+// For internal use only: ArrayData,ArrayDataCC and others.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayDataBase
+{
+    typedef T                                           ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     SelfType;
+
+    ArrayDataBase()
+        : Data(0), Size(0), Policy() {}
+
+    ArrayDataBase(const SizePolicy& p)
+        : Data(0), Size(0), Policy(p) {}
+
+    ~ArrayDataBase() 
+    {
+        Allocator::DestructArray(Data, Size);
+        Allocator::Free(Data);
+    }
+
+    size_t GetCapacity() const 
+    { 
+        return Policy.GetCapacity(); 
+    }
+
+    void ClearAndRelease()
+    {
+        Allocator::DestructArray(Data, Size);
+        Allocator::Free(Data);
+        Data = 0;
+        Size = 0;
+        Policy.SetCapacity(0);
+    }
+
+    void Reserve(size_t newCapacity)
+    {
+        if (Policy.NeverShrinking() && newCapacity < GetCapacity())
+            return;
+
+        if (newCapacity < Policy.GetMinCapacity())
+            newCapacity = Policy.GetMinCapacity();
+
+        // Resize the buffer.
+        if (newCapacity == 0)
+        {
+            if (Data)
+            {
+                Allocator::Free(Data);
+                Data = 0;
+            }
+            Policy.SetCapacity(0);
+        }
+        else
+        {
+            size_t gran = Policy.GetGranularity();
+            newCapacity = (newCapacity + gran - 1) / gran * gran;
+            if (Data)
+            {
+                if (Allocator::IsMovable())
+                {
+                    Data = (T*)Allocator::Realloc(Data, sizeof(T) * newCapacity);
+                }
+                else
+                {
+                    T* newData = (T*)Allocator::Alloc(sizeof(T) * newCapacity);
+                    size_t i, s;
+                    s = (Size < newCapacity) ? Size : newCapacity;
+                    for (i = 0; i < s; ++i)
+                    {
+                        Allocator::Construct(&newData[i], Data[i]);
+                        Allocator::Destruct(&Data[i]);
+                    }
+                    for (i = s; i < Size; ++i)
+                    {
+                        Allocator::Destruct(&Data[i]);
+                    }
+                    Allocator::Free(Data);
+                    Data = newData;
+                }
+            }
+            else
+            {
+                Data = (T*)Allocator::Alloc(sizeof(T) * newCapacity);
+                //memset(Buffer, 0, (sizeof(ValueType) * newSize)); // Do we need this?
+            }
+            Policy.SetCapacity(newCapacity);
+            // OVR_ASSERT(Data); // need to throw (or something) on alloc failure!
+        }
+    }
+
+    // This version of Resize DOES NOT construct the elements.
+    // It's done to optimize PushBack, which uses a copy constructor 
+    // instead of the default constructor and assignment
+    void ResizeNoConstruct(size_t newSize)
+    {
+        size_t oldSize = Size;
+
+        if (newSize < oldSize)
+        {
+            Allocator::DestructArray(Data + newSize, oldSize - newSize);
+            if (newSize < (Policy.GetCapacity() >> 1))
+            {
+                Reserve(newSize);
+            }
+        }
+        else if(newSize >= Policy.GetCapacity())
+        {
+            Reserve(newSize + (newSize >> 2));
+        }
+        //! IMPORTANT to modify Size only after Reserve completes, because garbage collectable
+        // array may use this array and may traverse it during Reserve (in the case, if 
+        // collection occurs because of heap limit exceeded).
+        Size = newSize;
+    }
+
+    ValueType*  Data;
+    size_t      Size;
+    SizePolicy  Policy;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayData
+//
+// General purpose array data.
+// For internal use only in Array, ArrayLH, ArrayPOD and so on.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayData : ArrayDataBase<T, Allocator, SizePolicy>
+{
+    typedef T ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     BaseType;
+    typedef ArrayData    <T, Allocator, SizePolicy>     SelfType;
+
+    ArrayData()
+        : BaseType() { }
+
+    ArrayData(size_t size)
+        : BaseType() { Resize(size); }
+
+    ArrayData(const SelfType& a)
+        : BaseType(a.Policy) { Append(a.Data, a.Size); }
+
+
+    void Resize(size_t newSize)
+    {
+        size_t oldSize = this->Size;
+        BaseType::ResizeNoConstruct(newSize);
+        if(newSize > oldSize)
+            Allocator::ConstructArray(this->Data + oldSize, newSize - oldSize);
+    }
+
+    void PushBack(const ValueType& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::Construct(this->Data + this->Size - 1, val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::ConstructAlt(this->Data + this->Size - 1, val);
+    }
+
+    // Append the given data to the array.
+    void Append(const ValueType other[], size_t count)
+    {
+        if (count)
+        {
+            size_t oldSize = this->Size;
+            BaseType::ResizeNoConstruct(this->Size + count);
+            Allocator::ConstructArray(this->Data + oldSize, count, other);
+        }
+    }
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayDataCC
+//
+// A modification of ArrayData that always copy-constructs new elements
+// using a specified DefaultValue. For internal use only in ArrayCC.
+template<class T, class Allocator, class SizePolicy>
+struct ArrayDataCC : ArrayDataBase<T, Allocator, SizePolicy>
+{
+    typedef T                                           ValueType;
+    typedef Allocator                                   AllocatorType;
+    typedef SizePolicy                                  SizePolicyType;
+    typedef ArrayDataBase<T, Allocator, SizePolicy>     BaseType;
+    typedef ArrayDataCC  <T, Allocator, SizePolicy>     SelfType;
+
+    ArrayDataCC(const ValueType& defval)
+        : BaseType(), DefaultValue(defval) { }
+
+    ArrayDataCC(const ValueType& defval, size_t size)
+        : BaseType(), DefaultValue(defval) { Resize(size); }
+
+    ArrayDataCC(const SelfType& a)
+        : BaseType(a.Policy), DefaultValue(a.DefaultValue) { Append(a.Data, a.Size); }
+
+
+    void Resize(size_t newSize)
+    {
+        size_t oldSize = this->Size;
+        BaseType::ResizeNoConstruct(newSize);
+        if(newSize > oldSize)
+            Allocator::ConstructArray(this->Data + oldSize, newSize - oldSize, DefaultValue);
+    }
+
+    void PushBack(const ValueType& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::Construct(this->Data + this->Size - 1, val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        BaseType::ResizeNoConstruct(this->Size + 1);
+        Allocator::ConstructAlt(this->Data + this->Size - 1, val);
+    }
+
+    // Append the given data to the array.
+    void Append(const ValueType other[], size_t count)
+    {
+        if (count)
+        {
+            size_t oldSize = this->Size;
+            BaseType::ResizeNoConstruct(this->Size + count);
+            Allocator::ConstructArray(this->Data + oldSize, count, other);
+        }
+    }
+
+    ValueType   DefaultValue;
+};
+
+
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** ArrayBase
+//
+// Resizable array. The behavior can be POD (suffix _POD) and 
+// Movable (no suffix) depending on the allocator policy.
+// In case of _POD the constructors and destructors are not called.
+// 
+// Arrays can't handle non-movable objects! Don't put anything in here 
+// that can't be moved around by bitwise copy. 
+// 
+// The addresses of elements are not persistent! Don't keep the address 
+// of an element; the array contents will move around as it gets resized.
+template<class ArrayData>
+class ArrayBase
+{
+public:
+    typedef typename ArrayData::ValueType       ValueType;
+    typedef typename ArrayData::AllocatorType   AllocatorType;
+    typedef typename ArrayData::SizePolicyType  SizePolicyType;
+    typedef ArrayBase<ArrayData>                SelfType;
+
+
+#undef new
+    OVR_MEMORY_REDEFINE_NEW(ArrayBase)
+// Redefine operator 'new' if necessary.
+#if defined(OVR_DEFINE_NEW)
+#define new OVR_DEFINE_NEW
+#endif
+
+
+    ArrayBase()
+        : Data() {}
+    ArrayBase(size_t size)
+        : Data(size) {}
+    ArrayBase(const SelfType& a)
+        : Data(a.Data) {}
+
+    ArrayBase(const ValueType& defval)
+        : Data(defval) {}
+    ArrayBase(const ValueType& defval, size_t size)
+        : Data(defval, size) {}
+  
+    SizePolicyType* GetSizePolicy() const                  { return Data.Policy; }
+    void            SetSizePolicy(const SizePolicyType& p) { Data.Policy = p; }
+
+    bool    NeverShrinking()const       { return Data.Policy.NeverShrinking(); }
+	size_t  GetSize()       const       { return Data.Size; }
+	int     GetSizeI()      const       { return (int)Data.Size; }
+	bool    IsEmpty()       const       { return Data.Size == 0; }
+    size_t  GetCapacity()   const       { return Data.GetCapacity(); }
+    size_t  GetNumBytes()   const       { return Data.GetCapacity() * sizeof(ValueType); }
+
+    void    ClearAndRelease()           { Data.ClearAndRelease(); }
+    void    Clear()                     { Data.Resize(0); }
+    void    Resize(size_t newSize)       { Data.Resize(newSize); }
+
+    // Reserve can only increase the capacity
+    void    Reserve(size_t newCapacity)  
+    { 
+        if (newCapacity > Data.GetCapacity())
+            Data.Reserve(newCapacity); 
+    }
+
+    // Basic access.
+    ValueType& At(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+    const ValueType& At(size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    ValueType ValueAt(size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    // Basic access.
+    ValueType& operator [] (size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+    const ValueType& operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < Data.Size);
+        return Data.Data[index]; 
+    }
+
+    // Raw pointer to the data. Use with caution!
+    const ValueType* GetDataPtr() const { return Data.Data; }
+          ValueType* GetDataPtr()       { return Data.Data; }
+
+    // Insert the given element at the end of the array.
+    void    PushBack(const ValueType& val)
+    {
+        // DO NOT pass elements of your own vector into
+        // push_back()!  Since we're using references,
+        // resize() may munge the element storage!
+        // OVR_ASSERT(&val < &Buffer[0] || &val > &Buffer[BufferSize]);
+        Data.PushBack(val);
+    }
+
+    template<class S>
+    void PushBackAlt(const S& val)
+    {
+        Data.PushBackAlt(val);
+    }
+
+    // Remove the last element.
+    void    PopBack(size_t count = 1)
+    {
+        OVR_ASSERT(Data.Size >= count);
+        Data.Resize(Data.Size - count);
+    }
+
+    ValueType& PushDefault()
+    {
+        Data.PushBack(ValueType());
+        return Back();
+    }
+
+    ValueType Pop()
+    {
+        ValueType t = Back();
+        PopBack();
+        return t;
+    }
+
+
+    // Access the first element.
+    ValueType&          Front()         { return At(0); }
+    const ValueType&    Front() const   { return At(0); }
+
+    // Access the last element.
+    ValueType&          Back()          { return At(Data.Size - 1); }
+    const ValueType&    Back() const    { return At(Data.Size - 1); }
+
+    // Array copy.  Copies the contents of a into this array.
+    const SelfType& operator = (const SelfType& a)   
+    {
+        Resize(a.GetSize());
+        for (size_t i = 0; i < Data.Size; i++) {
+            *(Data.Data + i) = a[i];
+        }
+        return *this;
+    }
+
+    // Removing multiple elements from the array.
+    void    RemoveMultipleAt(size_t index, size_t num)
+    {
+        OVR_ASSERT(index + num <= Data.Size);
+        if (Data.Size == num)
+        {
+            Clear();
+        }
+        else
+        {
+            AllocatorType::DestructArray(Data.Data + index, num);
+            AllocatorType::CopyArrayForward(
+                Data.Data + index, 
+                Data.Data + index + num,
+                Data.Size - num - index);
+            Data.Size -= num;
+        }
+    }
+
+    // Removing an element from the array is an expensive operation!
+    // It compacts only after removing the last element.
+    // If order of elements in the array is not important then use 
+    // RemoveAtUnordered, that could be much faster than the regular
+    // RemoveAt.
+    void    RemoveAt(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        if (Data.Size == 1)
+        {
+            Clear();
+        }
+        else
+        {
+            AllocatorType::Destruct(Data.Data + index);
+            AllocatorType::CopyArrayForward(
+                Data.Data + index, 
+                Data.Data + index + 1,
+                Data.Size - 1 - index);
+            --Data.Size;
+        }
+    }
+
+    // Removes an element from the array without respecting of original order of 
+    // elements for better performance. Do not use on array where order of elements
+    // is important, otherwise use it instead of regular RemoveAt().
+    void    RemoveAtUnordered(size_t index)
+    {
+        OVR_ASSERT(index < Data.Size);
+        if (Data.Size == 1)
+        {
+            Clear();
+        }
+        else
+        {
+            // copy the last element into the 'index' position 
+            // and decrement the size (instead of moving all elements
+            // in [index + 1 .. size - 1] range).
+            const size_t lastElemIndex = Data.Size - 1;
+            if (index < lastElemIndex)
+            {
+                AllocatorType::Destruct(Data.Data + index);
+                AllocatorType::Construct(Data.Data + index, Data.Data[lastElemIndex]);
+            }
+            AllocatorType::Destruct(Data.Data + lastElemIndex);
+            --Data.Size;
+        }
+    }
+
+    // Insert the given object at the given index shifting all the elements up.
+    void    InsertAt(size_t index, const ValueType& val = ValueType())
+    {
+        OVR_ASSERT(index <= Data.Size);
+
+        Data.Resize(Data.Size + 1);
+        if (index < Data.Size - 1)
+        {
+            AllocatorType::CopyArrayBackward(
+                Data.Data + index + 1, 
+                Data.Data + index, 
+                Data.Size - 1 - index);
+        }
+        AllocatorType::Construct(Data.Data + index, val);
+    }
+
+    // Insert the given object at the given index shifting all the elements up.
+    void    InsertMultipleAt(size_t index, size_t num, const ValueType& val = ValueType())
+    {
+        OVR_ASSERT(index <= Data.Size);
+
+        Data.Resize(Data.Size + num);
+        if (index < Data.Size - num)
+        {
+            AllocatorType::CopyArrayBackward(
+                Data.Data + index + num,
+                Data.Data + index,
+                Data.Size - num - index);
+        }
+        for (size_t i = 0; i < num; ++i)
+            AllocatorType::Construct(Data.Data + index + i, val);
+    }
+
+    // Append the given data to the array.
+    void    Append(const SelfType& other)
+    {
+        Append(other.Data.Data, other.GetSize());
+    }
+
+    // Append the given data to the array.
+    void    Append(const ValueType other[], size_t count)
+    {
+        Data.Append(other, count);
+    }
+
+    class Iterator
+    {
+        SelfType*       pArray;
+        intptr_t        CurIndex;
+
+    public:
+        Iterator() : pArray(0), CurIndex(-1) {}
+        Iterator(SelfType* parr, intptr_t idx = 0) : pArray(parr), CurIndex(idx) {}
+
+        bool operator==(const Iterator& it) const { return pArray == it.pArray && CurIndex == it.CurIndex; }
+        bool operator!=(const Iterator& it) const { return pArray != it.pArray || CurIndex != it.CurIndex; }
+
+        Iterator& operator++()
+        {
+            if (pArray)
+            {
+                if (CurIndex < (intptr_t)pArray->GetSize())
+                    ++CurIndex;
+            }
+            return *this;
+        }
+        Iterator operator++(int)
+        {
+            Iterator it(*this);
+            operator++();
+            return it;
+        }
+        Iterator& operator--()
+        {
+            if (pArray)
+            {
+                if (CurIndex >= 0)
+                    --CurIndex;
+            }
+            return *this;
+        }
+        Iterator operator--(int)
+        {
+            Iterator it(*this);
+            operator--();
+            return it;
+        }
+        Iterator operator+(int delta) const
+        {
+            return Iterator(pArray, CurIndex + delta);
+        }
+        Iterator operator-(int delta) const
+        {
+            return Iterator(pArray, CurIndex - delta);
+        }
+        intptr_t operator-(const Iterator& right) const
+        {
+            OVR_ASSERT(pArray == right.pArray);
+            return CurIndex - right.CurIndex;
+        }
+        ValueType& operator*() const    { OVR_ASSERT(pArray); return  (*pArray)[CurIndex]; }
+        ValueType* operator->() const   { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+        ValueType* GetPtr() const       { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+
+        bool IsFinished() const { return !pArray || CurIndex < 0 || CurIndex >= (int)pArray->GetSize(); }
+
+        void Remove()
+        {
+            if (!IsFinished())
+                pArray->RemoveAt(CurIndex);
+        }
+
+        intptr_t GetIndex() const { return CurIndex; }
+    };
+
+    Iterator Begin() { return Iterator(this); }
+    Iterator End()   { return Iterator(this, (intptr_t)GetSize()); }
+    Iterator Last()  { return Iterator(this, (intptr_t)GetSize() - 1); }
+
+    class ConstIterator
+    {
+        const SelfType* pArray;
+        intptr_t        CurIndex;
+
+    public:
+        ConstIterator() : pArray(0), CurIndex(-1) {}
+        ConstIterator(const SelfType* parr, intptr_t idx = 0) : pArray(parr), CurIndex(idx) {}
+
+        bool operator==(const ConstIterator& it) const { return pArray == it.pArray && CurIndex == it.CurIndex; }
+        bool operator!=(const ConstIterator& it) const { return pArray != it.pArray || CurIndex != it.CurIndex; }
+
+        ConstIterator& operator++()
+        {
+            if (pArray)
+            {
+                if (CurIndex < (int)pArray->GetSize())
+                    ++CurIndex;
+            }
+            return *this;
+        }
+        ConstIterator operator++(int)
+        {
+            ConstIterator it(*this);
+            operator++();
+            return it;
+        }
+        ConstIterator& operator--()
+        {
+            if (pArray)
+            {
+                if (CurIndex >= 0)
+                    --CurIndex;
+            }
+            return *this;
+        }
+        ConstIterator operator--(int)
+        {
+            ConstIterator it(*this);
+            operator--();
+            return it;
+        }
+        ConstIterator operator+(int delta) const
+        {
+            return ConstIterator(pArray, CurIndex + delta);
+        }
+        ConstIterator operator-(int delta) const
+        {
+            return ConstIterator(pArray, CurIndex - delta);
+        }
+        intptr_t operator-(const ConstIterator& right) const
+        {
+            OVR_ASSERT(pArray == right.pArray);
+            return CurIndex - right.CurIndex;
+        }
+        const ValueType& operator*() const  { OVR_ASSERT(pArray); return  (*pArray)[CurIndex]; }
+        const ValueType* operator->() const { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+        const ValueType* GetPtr() const     { OVR_ASSERT(pArray); return &(*pArray)[CurIndex]; }
+
+        bool IsFinished() const { return !pArray || CurIndex < 0 || CurIndex >= (int)pArray->GetSize(); }
+
+        intptr_t GetIndex()  const { return CurIndex; }
+    };
+    ConstIterator Begin() const { return ConstIterator(this); }
+    ConstIterator End() const   { return ConstIterator(this, (intptr_t)GetSize()); }
+    ConstIterator Last() const  { return ConstIterator(this, (intptr_t)GetSize() - 1); }
+
+protected:
+    ArrayData   Data;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Array
+//
+// General purpose array for movable objects that require explicit 
+// construction/destruction.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class Array : public ArrayBase<ArrayData<T, ContainerAllocator<T>, SizePolicy> >
+{
+public:
+    typedef T                                                           ValueType;
+    typedef ContainerAllocator<T>                                       AllocatorType;
+    typedef SizePolicy                                                  SizePolicyType;
+    typedef Array<T, SizePolicy>                                        SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator<T>, SizePolicy> > BaseType;
+
+    Array() : BaseType() {}
+    Array(size_t size) : BaseType(size) {}
+    Array(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    Array(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+// ***** ArrayPOD
+//
+// General purpose array for movable objects that DOES NOT require  
+// construction/destruction. Constructors and destructors are not called! 
+// Global heap is in use.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayPOD : public ArrayBase<ArrayData<T, ContainerAllocator_POD<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator_POD<T>                                       AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayPOD<T, SizePolicy>                                         SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator_POD<T>, SizePolicy> > BaseType;
+
+    ArrayPOD() : BaseType() {}
+    ArrayPOD(size_t size) : BaseType(size) {}
+    ArrayPOD(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    ArrayPOD(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+
+// ***** ArrayCPP
+//
+// General purpose, fully C++ compliant array. Can be used with non-movable data.
+// Global heap is in use.
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayCPP : public ArrayBase<ArrayData<T, ContainerAllocator_CPP<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator_CPP<T>                                       AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayCPP<T, SizePolicy>                                         SelfType;
+    typedef ArrayBase<ArrayData<T, ContainerAllocator_CPP<T>, SizePolicy> > BaseType;
+
+    ArrayCPP() : BaseType() {}
+    ArrayCPP(size_t size) : BaseType(size) {}
+    ArrayCPP(const SizePolicyType& p) : BaseType() { SetSizePolicy(p); }
+    ArrayCPP(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+
+// ***** ArrayCC
+//
+// A modification of the array that uses the given default value to
+// construct the elements. The constructors and destructors are 
+// properly called, the objects must be movable.
+
+template<class T, class SizePolicy=ArrayDefaultPolicy>
+class ArrayCC : public ArrayBase<ArrayDataCC<T, ContainerAllocator<T>, SizePolicy> >
+{
+public:
+    typedef T                                                               ValueType;
+    typedef ContainerAllocator<T>                                           AllocatorType;
+    typedef SizePolicy                                                      SizePolicyType;
+    typedef ArrayCC<T, SizePolicy>                                          SelfType;
+    typedef ArrayBase<ArrayDataCC<T, ContainerAllocator<T>, SizePolicy> >   BaseType;
+
+    ArrayCC(const ValueType& defval) : BaseType(defval) {}
+    ArrayCC(const ValueType& defval, size_t size) : BaseType(defval, size) {}
+    ArrayCC(const ValueType& defval, const SizePolicyType& p) : BaseType(defval) { SetSizePolicy(p); }
+    ArrayCC(const SelfType& a) : BaseType(a) {}
+    const SelfType& operator=(const SelfType& a) { BaseType::operator=(a); return *this; }
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Atomic.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,911 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Atomic.h
+Content     :   Contains atomic operations and inline fastest locking
+                functionality. Will contain #ifdefs for OS efficiency.
+                Have non-thread-safe implementaion if not available.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Atomic_h
+#define OVR_Atomic_h
+
+#include "OVR_Types.h"
+
+// Include System thread functionality.
+#if defined(OVR_OS_WIN32)
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#include <Windows.h>
+#else
+#include <pthread.h>
+#endif
+
+#ifdef OVR_CC_MSVC
+#include <intrin.h>
+#pragma intrinsic(_ReadBarrier, _WriteBarrier, _ReadWriteBarrier)
+#endif
+
+namespace OVR {
+
+
+// ****** Declared classes
+
+// If there is NO thread support we implement AtomicOps and
+// Lock objects as no-ops. The other classes are not defined.
+template<class C> class AtomicOps;
+template<class T> class AtomicInt;
+template<class T> class AtomicPtr;
+
+class Lock;
+
+
+//-----------------------------------------------------------------------------------
+// ***** AtomicOps
+
+// Atomic operations are provided by the AtomicOps templates class,
+// implemented through system-specific AtomicOpsRaw specializations.
+// It provides several fundamental operations such as Exchange, ExchangeAdd
+// CompareAndSet, and Store_Release. Each function includes several memory
+// synchronization versions, important for multiprocessing CPUs with weak
+// memory consistency. The following memory fencing strategies are supported:
+//
+//  - NoSync.  No memory synchronization is done for atomic op.
+//  - Release. All other memory writes are completed before atomic op
+//             writes its results.
+//  - Acquire. Further memory reads are forced to wait until atomic op
+//             executes, guaranteeing that the right values will be seen.
+//  - Sync.    A combination of Release and Acquire.
+
+
+// *** AtomicOpsRaw
+
+// AtomicOpsRaw is a specialized template that provides atomic operations 
+// used by AtomicOps. This class has two fundamental qualities: (1) it
+// defines a type T of correct size, and (2) provides operations that work
+// atomically, such as Exchange_Sync and CompareAndSet_Release.
+
+// AtomicOpsRawBase class contains shared constants/classes for AtomicOpsRaw.
+// The primary thing is does is define sync class objects, whose destructor and
+// constructor provide places to insert appropriate synchronization calls, on 
+// systems where such calls are necessary. So far, the breakdown is as follows:
+// 
+//  - X86 systems don't need custom syncs, since their exchange/atomic
+//    instructions are implicitly synchronized.
+//  - PowerPC requires lwsync/isync instructions that can use this mechanism.
+//  - If some other systems require a mechanism where syncing type is associated
+//    with a particular instruction, the default implementation (which implements
+//    all Sync, Acquire, and Release modes in terms of NoSync and fence) may not
+//    work. Ii that case it will need to be #ifdef-ed conditionally.
+
+struct AtomicOpsRawBase
+{
+#if !defined(OVR_ENABLE_THREADS) || defined(OVR_CPU_X86) || defined(OVR_OS_WIN32) || defined(OVR_OS_IPHONE)
+    // Need to have empty constructor to avoid class 'unused' variable warning.
+    struct FullSync { inline FullSync() { } };
+    struct AcquireSync { inline AcquireSync() { } };
+    struct ReleaseSync { inline ReleaseSync() { } };
+
+#elif defined(OVR_CPU_PPC64) || defined(OVR_CPU_PPC)
+    struct FullSync { inline FullSync() { asm volatile("sync\n"); } ~FullSync() { asm volatile("isync\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("isync\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("sync\n"); } };
+
+#elif defined(OVR_CPU_MIPS)
+    struct FullSync { inline FullSync() { asm volatile("sync\n"); } ~FullSync() { asm volatile("sync\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("sync\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("sync\n"); } };
+
+#elif defined(OVR_CPU_ARM)
+    struct FullSync { inline FullSync() { asm volatile("dmb\n"); } ~FullSync() { asm volatile("dmb\n"); } };
+    struct AcquireSync { inline AcquireSync() { } ~AcquireSync() { asm volatile("dmb\n"); } };
+    struct ReleaseSync { inline ReleaseSync() { asm volatile("dmb\n"); } };
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4)
+    // __sync functions are already full sync
+    struct FullSync { inline FullSync() { } };
+    struct AcquireSync { inline AcquireSync() { } };
+    struct ReleaseSync { inline ReleaseSync() { } };
+#endif
+};
+
+
+// 4-Byte raw data atomic op implementation class.
+struct AtomicOpsRaw_4ByteImpl : public AtomicOpsRawBase
+{
+#if !defined(OVR_ENABLE_THREADS)
+
+    // Provide a type for no-thread-support cases. Used by AtomicOpsRaw_DefImpl.
+    typedef uint32_t T;   
+
+    // *** Thread - Safe Atomic Versions.
+
+#elif defined(OVR_OS_WIN32) 
+
+    // Use special defined for VC6, where volatile is not used and
+    // InterlockedCompareExchange is declared incorrectly.
+    typedef LONG T;      
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC < 1300)
+    typedef T* InterlockTPtr;
+    typedef LPVOID ET;
+    typedef ET* InterlockETPtr;
+#else
+    typedef volatile T* InterlockTPtr;
+    typedef T ET;
+    typedef InterlockTPtr InterlockETPtr;
+#endif
+    inline static T     Exchange_NoSync(volatile T* p, T val)            { return InterlockedExchange((InterlockTPtr)p, val); }
+    inline static T     ExchangeAdd_NoSync(volatile T* p, T val)         { return InterlockedExchangeAdd((InterlockTPtr)p, val); }
+    inline static bool  CompareAndSet_NoSync(volatile T* p, T c, T val)  { return InterlockedCompareExchange((InterlockETPtr)p, (ET)val, (ET)c) == (ET)c; }
+
+#elif defined(OVR_CPU_PPC64) || defined(OVR_CPU_PPC)
+    typedef uint32_t T;
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "stwcx. %[j],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret) : [i] "b" (i), [j] "b" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "add    %[o],%[r],%[j]\n\t"
+                     "stwcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "lwarx  %[r],0,%[i]\n\t"
+                     "cmpw   0,%[r],%[cmp]\n\t"
+                     "mfcr   %[r]\n\t"
+                     "bne-   2f\n\t"
+                     "stwcx. %[val],0,%[i]\n\t"
+                     "bne-   1b\n\t"
+                     "2:\n"
+                     : "+m" (*i), [r] "=&b" (ret) : [i] "b" (i), [cmp] "b" (c), [val] "b" (value) : "cc", "memory");
+
+        return (ret & 0x20000000) ? 1 : 0;
+    }
+
+#elif defined(OVR_CPU_MIPS)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "ll     %[r],0(%[i])\n\t"
+                     "sc     %[j],0(%[i])\n\t"
+                     "beq    %[j],$0,1b\n\t"
+                     "nop    \n"
+                     : "+m" (*i), [r] "=&d" (ret) : [i] "d" (i), [j] "d" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret;
+
+        asm volatile("1:\n\t"
+                     "ll     %[r],0(%[i])\n\t"
+                     "addu   %[j],%[r],%[j]\n\t"
+                     "sc     %[j],0(%[i])\n\t"
+                     "beq    %[j],$0,1b\n\t"
+                     "nop    \n"
+                     : "+m" (*i), [r] "=&d" (ret) : [i] "d" (i), [j] "d" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret, dummy;
+
+        asm volatile("1:\n\t"
+                     "move   %[r],$0\n\t"
+                     "ll     %[o],0(%[i])\n\t"
+                     "bne    %[o],%[c],2f\n\t"
+                     "move   %[r],%[v]\n\t"
+                     "sc     %[r],0(%[i])\n\t"
+                     "beq    %[r],$0,1b\n\t"
+                     "nop    \n\t"
+                     "2:\n"
+                     : "+m" (*i),[r] "=&d" (ret), [o] "=&d" (dummy) : [i] "d" (i), [c] "d" (c), [v] "d" (value)
+                     : "cc", "memory");
+
+        return ret;
+    }
+
+#elif defined(OVR_CPU_ARM) && defined(OVR_CC_ARM)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (__strex(j, i) == 0)
+                return r;
+        }
+    }
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (__strex(r + j, i) == 0)
+                return r;
+        }
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        for(;;)
+        {
+            T r = __ldrex(i);
+            if (r != c)
+                return 0;
+            if (__strex(value, i) == 0)
+                return 1;
+        }
+    }
+
+#elif defined(OVR_CPU_ARM)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret, dummy;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[r],[%[i]]\n\t"
+            "strex  %[t],%[j],[%[i]]\n\t"
+            "cmp    %[t],#0\n\t"
+            "bne    1b\n\t"
+            : "+m" (*i), [r] "=&r" (ret), [t] "=&r" (dummy) : [i] "r" (i), [j] "r" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        uint32_t ret, dummy, test;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[r],[%[i]]\n\t"
+            "add    %[o],%[r],%[j]\n\t"
+            "strex  %[t],%[o],[%[i]]\n\t"
+            "cmp    %[t],#0\n\t"
+            "bne    1b\n\t"
+            : "+m" (*i), [r] "=&r" (ret), [o] "=&r" (dummy), [t] "=&r" (test)  : [i] "r" (i), [j] "r" (j) : "cc", "memory");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret = 1, dummy, test;
+
+        asm volatile("1:\n\t"
+            "ldrex  %[o],[%[i]]\n\t"
+            "cmp    %[o],%[c]\n\t"
+            "bne    2f\n\t"
+            "strex  %[r],%[v],[%[i]]\n\t"
+            "cmp    %[r],#0\n\t"
+            "bne    1b\n\t"
+            "2:\n"
+            : "+m" (*i),[r] "=&r" (ret), [o] "=&r" (dummy), [t] "=&r" (test) : [i] "r" (i), [c] "r" (c), [v] "r" (value)
+            : "cc", "memory");
+
+        return !ret;
+    }
+
+#elif defined(OVR_CPU_X86)
+    typedef uint32_t T;
+
+    static inline uint32_t Exchange_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        asm volatile("xchgl %1,%[i]\n"
+                     : "+m" (*i), "=q" (j) : [i] "m" (*i), "1" (j) : "cc", "memory");
+
+        return j;
+    }
+
+    static inline uint32_t ExchangeAdd_NoSync(volatile uint32_t *i, uint32_t j)
+    {
+        asm volatile("lock; xaddl %1,%[i]\n"
+                     : "+m" (*i), "+q" (j) : [i] "m" (*i) : "cc", "memory");
+
+        return j;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint32_t *i, uint32_t c, uint32_t value)
+    {
+        uint32_t ret;
+
+        asm volatile("lock; cmpxchgl %[v],%[i]\n"
+                     : "+m" (*i), "=a" (ret) : [i] "m" (*i), "1" (c), [v] "q" (value) : "cc", "memory");
+
+        return (ret == c);
+    }
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4 && __GNUC_MINOR__ >= 1)
+
+    typedef uint32_t T;
+
+    static inline T   Exchange_NoSync(volatile T *i, T j)
+    {
+        T v;
+        do {
+            v = *i;
+        } while (!__sync_bool_compare_and_swap(i, v, j));
+        return v;
+    }
+
+    static inline T   ExchangeAdd_NoSync(volatile T *i, T j)
+    {
+        return __sync_fetch_and_add(i, j);
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile T *i, T c, T value)
+    {
+        return __sync_bool_compare_and_swap(i, c, value);
+    }
+
+#endif // OS
+};
+
+
+// 8-Byte raw data data atomic op implementation class.
+// Currently implementation is provided only on systems with 64-bit pointers.
+struct AtomicOpsRaw_8ByteImpl : public AtomicOpsRawBase
+{    
+#if !defined(OVR_64BIT_POINTERS) || !defined(OVR_ENABLE_THREADS)
+
+    // Provide a type for no-thread-support cases. Used by AtomicOpsRaw_DefImpl.
+    typedef uint64_t T;
+
+    // *** Thread - Safe OS specific versions.
+#elif defined(OVR_OS_WIN32)
+
+    // This is only for 64-bit systems.
+    typedef LONG64      T;
+    typedef volatile T* InterlockTPtr;    
+    inline static T     Exchange_NoSync(volatile T* p, T val)            { return InterlockedExchange64((InterlockTPtr)p, val); }
+    inline static T     ExchangeAdd_NoSync(volatile T* p, T val)         { return InterlockedExchangeAdd64((InterlockTPtr)p, val); }
+    inline static bool  CompareAndSet_NoSync(volatile T* p, T c, T val)  { return InterlockedCompareExchange64((InterlockTPtr)p, val, c) == c; }
+
+#elif defined(OVR_CPU_PPC64)
+ 
+    typedef uint64_t T;
+
+    static inline uint64_t Exchange_NoSync(volatile uint64_t *i, uint64_t j)
+    {
+        uint64_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "mr     %[o],%[j]\n\t"
+                     "stdcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc");
+
+        return ret;
+    }
+
+    static inline uint64_t ExchangeAdd_NoSync(volatile uint64_t *i, uint64_t j)
+    {
+        uint64_t dummy, ret;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "add    %[o],%[r],%[j]\n\t"
+                     "stdcx. %[o],0,%[i]\n\t"
+                     "bne-   1b\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [j] "b" (j) : "cc");
+
+        return ret;
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile uint64_t *i, uint64_t c, uint64_t value)
+    {
+        uint64_t ret, dummy;
+
+        asm volatile("1:\n\t"
+                     "ldarx  %[r],0,%[i]\n\t"
+                     "cmpw   0,%[r],%[cmp]\n\t"
+                     "mfcr   %[r]\n\t"
+                     "bne-   2f\n\t"
+                     "stdcx. %[val],0,%[i]\n\t"
+                     "bne-   1b\n\t"
+                     "2:\n"
+                     : "+m" (*i), [r] "=&b" (ret), [o] "=&r" (dummy) : [i] "b" (i), [cmp] "b" (c), [val] "b" (value) : "cc");
+
+        return (ret & 0x20000000) ? 1 : 0;
+    }
+
+#elif defined(OVR_CC_GNU) && (__GNUC__ >= 4 && __GNUC_MINOR__ >= 1)
+
+    typedef uint64_t T;
+
+    static inline T   Exchange_NoSync(volatile T *i, T j)
+    {
+        T v;
+        do {
+            v = *i;
+        } while (!__sync_bool_compare_and_swap(i, v, j));
+        return v;
+    }
+
+    static inline T   ExchangeAdd_NoSync(volatile T *i, T j)
+    {
+        return __sync_fetch_and_add(i, j);
+    }
+
+    static inline bool     CompareAndSet_NoSync(volatile T *i, T c, T value)
+    {
+        return __sync_bool_compare_and_swap(i, c, value);
+    }
+
+#endif // OS
+};
+
+
+// Default implementation for AtomicOpsRaw; provides implementation of mem-fenced
+// atomic operations where fencing is done with a sync object wrapped around a NoSync
+// operation implemented in the base class. If such implementation is not possible
+// on a given platform, #ifdefs can be used to disable it and then op functions can be
+// implemented individually in the appropriate AtomicOpsRaw<size> class.
+
+template<class O>
+struct AtomicOpsRaw_DefImpl : public O
+{
+    typedef typename O::T O_T;
+    typedef typename O::FullSync    O_FullSync;
+    typedef typename O::AcquireSync O_AcquireSync;
+    typedef typename O::ReleaseSync O_ReleaseSync;
+
+    // If there is no thread support, provide the default implementation. In this case,
+    // the base class (0) must still provide the T declaration.
+#ifndef OVR_ENABLE_THREADS
+
+    // Atomic exchange of val with argument. Returns old val.
+    inline static O_T   Exchange_NoSync(volatile O_T* p, O_T val)           { O_T old = *p; *p = val; return old; }
+    // Adds a new val to argument; returns its old val.
+    inline static O_T   ExchangeAdd_NoSync(volatile O_T* p, O_T val)        { O_T old = *p; *p += val; return old; }
+    // Compares the argument data with 'c' val.
+    // If succeeded, stores val int '*p' and returns true; otherwise returns false.
+    inline static bool  CompareAndSet_NoSync(volatile O_T* p, O_T c, O_T val) { if (*p==c) { *p = val; return 1; } return 0; }
+
+#endif
+
+    // If NoSync wrapped implementation may not be possible, it this block should be
+    //  replaced with per-function implementation in O.
+    // "AtomicOpsRaw_DefImpl<O>::" prefix in calls below.
+    inline static O_T   Exchange_Sync(volatile O_T* p, O_T val)                { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }
+    inline static O_T   Exchange_Release(volatile O_T* p, O_T val)             { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }
+    inline static O_T   Exchange_Acquire(volatile O_T* p, O_T val)             { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::Exchange_NoSync(p, val); }  
+    inline static O_T   ExchangeAdd_Sync(volatile O_T* p, O_T val)             { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static O_T   ExchangeAdd_Release(volatile O_T* p, O_T val)          { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static O_T   ExchangeAdd_Acquire(volatile O_T* p, O_T val)          { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::ExchangeAdd_NoSync(p, val); }
+    inline static bool  CompareAndSet_Sync(volatile O_T* p, O_T c, O_T val)    { O_FullSync    sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+    inline static bool  CompareAndSet_Release(volatile O_T* p, O_T c, O_T val) { O_ReleaseSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+    inline static bool  CompareAndSet_Acquire(volatile O_T* p, O_T c, O_T val) { O_AcquireSync sync; OVR_UNUSED(sync); return AtomicOpsRaw_DefImpl<O>::CompareAndSet_NoSync(p,c,val); }
+
+    // Loads and stores with memory fence. These have only the relevant versions.
+#ifdef OVR_CPU_X86
+    // On X86, Store_Release is implemented as exchange. Note that we can also
+    // consider 'sfence' in the future, although it is not as compatible with older CPUs.
+    inline static void  Store_Release(volatile O_T* p, O_T val)  { Exchange_Release(p, val); }
+#else
+    inline static void  Store_Release(volatile O_T* p, O_T val)  { O_ReleaseSync sync; OVR_UNUSED(sync); *p = val; }
+#endif
+    inline static O_T   Load_Acquire(const volatile O_T* p)
+    {
+        O_AcquireSync sync;
+        OVR_UNUSED(sync);
+
+#if defined(OVR_CC_MSVC)
+        _ReadBarrier(); // Compiler fence and load barrier
+#elif defined(OVR_CC_INTEL)
+        __memory_barrier(); // Compiler fence
+#else
+        // GCC-compatible:
+        asm volatile ("" : : : "memory"); // Compiler fence
+#endif
+
+        return *p;
+    }
+};
+
+
+template<int size>
+struct AtomicOpsRaw : public AtomicOpsRawBase { };
+
+template<>
+struct AtomicOpsRaw<4> : public AtomicOpsRaw_DefImpl<AtomicOpsRaw_4ByteImpl>
+{   
+    // Ensure that assigned type size is correct.
+    AtomicOpsRaw()
+    { OVR_COMPILER_ASSERT(sizeof(AtomicOpsRaw_DefImpl<AtomicOpsRaw_4ByteImpl>::T) == 4); }
+};
+template<>
+struct AtomicOpsRaw<8> : public AtomicOpsRaw_DefImpl<AtomicOpsRaw_8ByteImpl>
+{
+    AtomicOpsRaw()
+    { OVR_COMPILER_ASSERT(sizeof(AtomicOpsRaw_DefImpl<AtomicOpsRaw_8ByteImpl>::T) == 8); }
+};
+
+
+// *** AtomicOps - implementation of atomic Ops for specified class
+
+// Implements atomic ops on a class, provided that the object is either
+// 4 or 8 bytes in size (depending on the AtomicOpsRaw specializations
+// available). Relies on AtomicOpsRaw for much of implementation.
+
+template<class C>
+class AtomicOps
+{
+    typedef AtomicOpsRaw<sizeof(C)>       Ops;
+    typedef typename Ops::T               T;
+    typedef volatile typename Ops::T*     PT;
+    // We cast through unions to (1) avoid pointer size compiler warnings
+    // and (2) ensure that there are no problems with strict pointer aliasing.
+    union C2T_union { C c; T t; };
+
+public:
+    // General purpose implementation for standard syncs.    
+    inline static C     Exchange_Sync(volatile C* p, C val)             { C2T_union u; u.c = val; u.t = Ops::Exchange_Sync((PT)p, u.t); return u.c; }
+    inline static C     Exchange_Release(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::Exchange_Release((PT)p, u.t); return u.c; }
+    inline static C     Exchange_Acquire(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::Exchange_Acquire((PT)p, u.t); return u.c; }
+    inline static C     Exchange_NoSync(volatile C* p, C val)           { C2T_union u; u.c = val; u.t = Ops::Exchange_NoSync((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Sync(volatile C* p, C val)          { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Sync((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Release(volatile C* p, C val)       { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Release((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_Acquire(volatile C* p, C val)       { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_Acquire((PT)p, u.t); return u.c; }
+    inline static C     ExchangeAdd_NoSync(volatile C* p, C val)        { C2T_union u; u.c = val; u.t = Ops::ExchangeAdd_NoSync((PT)p, u.t); return u.c; }
+    inline static bool  CompareAndSet_Sync(volatile C* p, C c, C val)   { C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Sync((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_Release(volatile C* p, C c, C val){ C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Release((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_Relse(volatile C* p, C c, C val){ C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_Acquire((PT)p, cu.t, u.t); }
+    inline static bool  CompareAndSet_NoSync(volatile C* p, C c, C val) { C2T_union u,cu; u.c = val; cu.c = c; return Ops::CompareAndSet_NoSync((PT)p, cu.t, u.t); }
+    // Loads and stores with memory fence. These have only the relevant versions.    
+    inline static void  Store_Release(volatile C* p, C val)             { C2T_union u; u.c = val; Ops::Store_Release((PT)p, u.t); }    
+    inline static C     Load_Acquire(const volatile C* p)               { C2T_union u; u.t = Ops::Load_Acquire((PT)p); return u.c; }
+};
+
+
+
+// Atomic value base class - implements operations shared for integers and pointers.
+template<class T>
+class AtomicValueBase
+{
+protected:
+    typedef AtomicOps<T> Ops;
+public:
+
+    volatile T  Value;
+
+    inline AtomicValueBase()                  { }
+    explicit inline AtomicValueBase(T val)    { Ops::Store_Release(&Value, val); }
+
+    // Most libraries (TBB and Joshua Scholar's) library do not do Load_Acquire
+    // here, since most algorithms do not require atomic loads. Needs some research.    
+    inline operator T() const { return Value; }
+
+    // *** Standard Atomic inlines
+    inline T     Exchange_Sync(T val)               { return Ops::Exchange_Sync(&Value,  val); }
+    inline T     Exchange_Release(T val)            { return Ops::Exchange_Release(&Value, val); }
+    inline T     Exchange_Acquire(T val)            { return Ops::Exchange_Acquire(&Value, val); }
+    inline T     Exchange_NoSync(T val)             { return Ops::Exchange_NoSync(&Value, val); }
+    inline bool  CompareAndSet_Sync(T c, T val)     { return Ops::CompareAndSet_Sync(&Value, c, val); }
+    inline bool  CompareAndSet_Release(T c, T val)  { return Ops::CompareAndSet_Release(&Value, c, val); }
+    inline bool  CompareAndSet_Acquire(T c, T val)  { return Ops::CompareAndSet_Relse(&Value, c, val); }
+    inline bool  CompareAndSet_NoSync(T c, T val)   { return Ops::CompareAndSet_NoSync(&Value, c, val); }
+    // Load & Store.
+    inline void  Store_Release(T val)               { Ops::Store_Release(&Value, val); }
+    inline T     Load_Acquire() const               { return Ops::Load_Acquire(&Value);  }
+};
+
+
+// ***** AtomicPtr - Atomic pointer template
+
+// This pointer class supports atomic assignments with release,
+// increment / decrement operations, and conditional compare + set.
+
+template<class T>
+class AtomicPtr : public AtomicValueBase<T*>
+{
+    typedef typename AtomicValueBase<T*>::Ops Ops;
+
+public:
+    // Initialize pointer value to 0 by default; use Store_Release only with explicit constructor.
+    inline AtomicPtr() : AtomicValueBase<T*>()                     { this->Value = 0; }
+    explicit inline AtomicPtr(T* val) : AtomicValueBase<T*>(val)   { }
+        
+    // Pointer access.
+    inline T* operator -> () const     { return this->Load_Acquire(); }
+
+    // It looks like it is convenient to have Load_Acquire characteristics
+    // for this, since that is convenient for algorithms such as linked
+    // list traversals that can be added to bu another thread.
+    inline operator T* () const        { return this->Load_Acquire(); }
+
+
+    // *** Standard Atomic inlines (applicable to pointers)
+
+    // ExhangeAdd considers pointer size for pointers.
+    template<class I>
+    inline T*     ExchangeAdd_Sync(I incr)      { return Ops::ExchangeAdd_Sync(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_Release(I incr)   { return Ops::ExchangeAdd_Release(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_Acquire(I incr)   { return Ops::ExchangeAdd_Acquire(&this->Value, ((T*)0) + incr); }
+    template<class I>
+    inline T*     ExchangeAdd_NoSync(I incr)    { return Ops::ExchangeAdd_NoSync(&this->Value, ((T*)0) + incr); }
+
+    // *** Atomic Operators
+
+    inline T* operator = (T* val)  { this->Store_Release(val); return val; }
+
+    template<class I>
+    inline T* operator += (I val) { return ExchangeAdd_Sync(val) + val; }
+    template<class I>
+    inline T* operator -= (I val) { return operator += (-val); }
+
+    inline T* operator ++ ()      { return ExchangeAdd_Sync(1) + 1; }
+    inline T* operator -- ()      { return ExchangeAdd_Sync(-1) - 1; }
+    inline T* operator ++ (int)   { return ExchangeAdd_Sync(1); }
+    inline T* operator -- (int)   { return ExchangeAdd_Sync(-1); }
+};
+
+
+// ***** AtomicInt - Atomic integer template
+
+// Implements an atomic integer type; the exact type to use is provided 
+// as an argument. Supports atomic Acquire / Release semantics, atomic
+// arithmetic operations, and atomic conditional compare + set.
+
+template<class T>
+class AtomicInt : public AtomicValueBase<T>
+{
+    typedef typename AtomicValueBase<T>::Ops Ops;
+
+public:
+    inline AtomicInt() : AtomicValueBase<T>()                     { }
+    explicit inline AtomicInt(T val) : AtomicValueBase<T>(val)    { }
+
+
+    // *** Standard Atomic inlines (applicable to int)   
+    inline T     ExchangeAdd_Sync(T val)            { return Ops::ExchangeAdd_Sync(&this->Value, val); }
+    inline T     ExchangeAdd_Release(T val)         { return Ops::ExchangeAdd_Release(&this->Value, val); }
+    inline T     ExchangeAdd_Acquire(T val)         { return Ops::ExchangeAdd_Acquire(&this->Value, val); }
+    inline T     ExchangeAdd_NoSync(T val)          { return Ops::ExchangeAdd_NoSync(&this->Value, val); }
+    // These increments could be more efficient because they don't return a value.
+    inline void  Increment_Sync()                   { ExchangeAdd_Sync((T)1); }
+    inline void  Increment_Release()                { ExchangeAdd_Release((T)1); }
+    inline void  Increment_Acquire()                { ExchangeAdd_Acquire((T)1); }    
+    inline void  Increment_NoSync()                 { ExchangeAdd_NoSync((T)1); }
+
+    // *** Atomic Operators
+
+    inline T operator = (T val)  { this->Store_Release(val); return val; }
+    inline T operator += (T val) { return ExchangeAdd_Sync(val) + val; }
+    inline T operator -= (T val) { return ExchangeAdd_Sync(0 - val) - val; }
+
+    inline T operator ++ ()      { return ExchangeAdd_Sync((T)1) + 1; }
+    inline T operator -- ()      { return ExchangeAdd_Sync(((T)0)-1) - 1; }
+    inline T operator ++ (int)   { return ExchangeAdd_Sync((T)1); }
+    inline T operator -- (int)   { return ExchangeAdd_Sync(((T)0)-1); }
+
+    // More complex atomic operations. Leave it to compiler whether to optimize them or not.
+    T operator &= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp & arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator |= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp | arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator ^= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp ^ arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator *= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp * arg;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator /= (T arg)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp / arg;
+        } while(!CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator >>= (unsigned bits)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp >> bits;
+        } while(!CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+
+    T operator <<= (unsigned bits)
+    {
+        T comp, newVal;
+        do {
+            comp   = this->Value;
+            newVal = comp << bits;
+        } while(!this->CompareAndSet_Sync(comp, newVal));
+        return newVal;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Lock
+
+// Lock is a simplest and most efficient mutual-exclusion lock class.
+// Unlike Mutex, it cannot be waited on.
+
+class Lock
+{
+    // NOTE: Locks are not allocatable and they themselves should not allocate 
+    // memory by standard means. This is the case because StandardAllocator
+    // relies on this class.
+    // Make 'delete' private. Don't do this for 'new' since it can be redefined.  
+    void    operator delete(void*) {}
+
+
+    // *** Lock implementation for various platforms.
+    
+#if !defined(OVR_ENABLE_THREADS)
+
+public:
+    // With no thread support, lock does nothing.
+    inline Lock() { }
+    inline Lock(unsigned) { }
+    inline ~Lock() { }    
+    inline void DoLock() { }
+    inline void Unlock() { }
+
+   // Windows.   
+#elif defined(OVR_OS_WIN32)
+
+    CRITICAL_SECTION cs;
+public:   
+    Lock(unsigned spinCount = 0);      
+    ~Lock();
+    // Locking functions.
+    inline void DoLock()    { ::EnterCriticalSection(&cs); }
+    inline void Unlock()    { ::LeaveCriticalSection(&cs); }
+
+#else
+    pthread_mutex_t mutex;
+
+public:
+    static pthread_mutexattr_t RecursiveAttr;
+    static bool                RecursiveAttrInit;
+
+    Lock (unsigned dummy = 0)
+    {
+        OVR_UNUSED(dummy);
+        if (!RecursiveAttrInit)
+        {
+            pthread_mutexattr_init(&RecursiveAttr);
+            pthread_mutexattr_settype(&RecursiveAttr, PTHREAD_MUTEX_RECURSIVE);
+            RecursiveAttrInit = 1;
+        }
+        pthread_mutex_init(&mutex,&RecursiveAttr);
+    }
+    ~Lock ()                { pthread_mutex_destroy(&mutex); }
+    inline void DoLock()    { pthread_mutex_lock(&mutex); }
+    inline void Unlock()    { pthread_mutex_unlock(&mutex); }
+
+#endif // OVR_ENABLE_THREDS
+
+
+public:
+    // Locker class, used for automatic locking
+    class Locker
+    {
+    public:     
+        Lock *pLock;
+        inline Locker(Lock *plock)
+        { pLock = plock; pLock->DoLock(); }
+        inline ~Locker()
+        { pLock->Unlock();  }
+    };
+};
+
+
+//-------------------------------------------------------------------------------------
+// Globally shared Lock implementation used for MessageHandlers, etc.
+
+class SharedLock
+{    
+public:
+    SharedLock() : UseCount(0) {}
+
+    Lock* GetLockAddRef();
+    void  ReleaseLock(Lock* plock);
+   
+private:
+    Lock* toLock() { return (Lock*)Buffer; }
+
+    // UseCount and max alignment.
+    volatile int    UseCount;
+    uint64_t        Buffer[(sizeof(Lock)+sizeof(uint64_t)-1)/sizeof(uint64_t)];
+};
+
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Color.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Color.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,68 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Color.h
+Content     :   Contains color struct.
+Created     :   February 7, 2013
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_Color_h
+#define OVR_Color_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+struct Color
+{
+    uint8_t R,G,B,A;
+
+    Color() {}
+
+    // Constructs color by channel. Alpha is set to 0xFF (fully visible)
+    // if not specified.
+    Color(unsigned char r,unsigned char g,unsigned char b, unsigned char a = 0xFF)
+        : R(r), G(g), B(b), A(a) { }
+
+    // 0xAARRGGBB - Common HTML color Hex layout
+    Color(unsigned c)
+        : R((unsigned char)(c>>16)), G((unsigned char)(c>>8)),
+        B((unsigned char)c), A((unsigned char)(c>>24)) { }
+
+    bool operator==(const Color& b) const
+    {
+        return R == b.R && G == b.G && B == b.B && A == b.A;
+    }
+
+    void  GetRGBA(float *r, float *g, float *b, float* a) const
+    {
+        *r = R / 255.0f;
+        *g = G / 255.0f;
+        *b = B / 255.0f;
+        *a = A / 255.0f;
+    }
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Compiler.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Compiler.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,1523 @@
+/************************************************************************************
+
+PublicHeader:   OVR.h
+Filename    :   OVR_Compiler.h
+Content     :   Compiler-specific feature identification and utilities
+Created     :   June 19, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+
+#ifndef OVR_Compiler_h
+#define OVR_Compiler_h
+
+#pragma once
+
+
+// References
+//    https://gcc.gnu.org/projects/cxx0x.html
+//    https://gcc.gnu.org/projects/cxx1y.html
+//    http://clang.llvm.org/cxx_status.html
+//    http://msdn.microsoft.com/en-us/library/hh567368.aspx
+//    https://docs.google.com/spreadsheet/pub?key=0AoBblDsbooe4dHZuVTRoSTFBejk5eFBfVk1GWlE5UlE&output=html
+//    http://nadeausoftware.com/articles/2012/10/c_c_tip_how_detect_compiler_name_and_version_using_compiler_predefined_macros
+
+
+//-----------------------------------------------------------------------------------
+// ***** Compiler
+//
+//  The following compilers are defined: (OVR_CC_x)
+//
+//     MSVC     - Microsoft Visual C/C++
+//     INTEL    - Intel C++ for Linux / Windows
+//     GNU      - GNU C++
+//     ARM      - ARM C/C++
+
+#if defined(__INTEL_COMPILER)
+// Intel 4.0                    = 400
+// Intel 5.0                    = 500
+// Intel 6.0                    = 600
+// Intel 8.0                    = 800
+// Intel 9.0                    = 900
+#  define OVR_CC_INTEL       __INTEL_COMPILER
+
+#elif defined(_MSC_VER)
+// MSVC 5.0                     = 1100
+// MSVC 6.0                     = 1200
+// MSVC 7.0 (VC2002)            = 1300
+// MSVC 7.1 (VC2003)            = 1310
+// MSVC 8.0 (VC2005)            = 1400
+// MSVC 9.0 (VC2008)            = 1500
+// MSVC 10.0 (VC2010)           = 1600
+// MSVC 11.0 (VC2012)           = 1700
+// MSVC 12.0 (VC2013)           = 1800
+#  define OVR_CC_MSVC        _MSC_VER
+
+#if _MSC_VER == 0x1600
+#  if _MSC_FULL_VER < 160040219
+#     error "Oculus does not support VS2010 without SP1 installed."
+#  endif
+#endif
+
+#elif defined(__GNUC__)
+#  define OVR_CC_GNU
+
+#elif defined(__clang__)
+#  define OVR_CC_CLANG
+
+#elif defined(__CC_ARM)
+#  define OVR_CC_ARM
+
+#else
+#  error "Oculus does not support this Compiler"
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_VERSION
+//
+//    M = major version
+//    m = minor version
+//    p = patch release
+//    b = build number
+//
+//    Compiler      Format   Example
+//    ----------------------------
+//    OVR_CC_GNU    Mmm      408 means GCC 4.8
+//    OVR_CC_CLANG  Mmm      305 means clang 3.5 
+//    OVR_CC_MSVC   MMMM     1700 means VS2012
+//    OVR_CC_ARM    Mmpbbb   401677 means 4.0, patch 1, build 677
+//    OVR_CC_INTEL  MMmm     1210 means 12.10
+//    OVR_CC_EDG    Mmm      407 means EDG 4.7
+//
+#if defined(OVR_CC_GNU)
+    #define OVR_CC_VERSION ((__GNUC__ * 100) + __GNUC_MINOR__)
+#elif defined(OVR_CC_CLANG)
+    #define OVR_CC_VERSION ((__clang_major__ * 100) + __clang_minor__)
+#elif defined(OVR_CC_MSVC)
+    #define OVR_CC_VERSION _MSC_VER // Question: Should we recognize _MSC_FULL_VER?
+#elif defined(OVR_CC_ARM)
+    #define OVR_CC_VERSION __ARMCC_VERSION
+#elif defined(OVR_CC_INTEL)
+    #if defined(__INTEL_COMPILER)
+        #define OVR_CC_VERSION __INTEL_COMPILER
+    #elif defined(__ICL)
+        #define OVR_CC_VERSION __ICL
+    #elif defined(__ICC)
+        #define OVR_CC_VERSION __ICC
+    #elif defined(__ECC)
+        #define OVR_CC_VERSION __ECC
+    #endif
+#elif defined(OVR_CC_EDG)
+    #define OVR_CC_VERSION __EDG_VERSION__  // This is a generic fallback for EDG-based compilers which aren't specified above (e.g. as OVR_CC_ARM)
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_OPTIMIZATION / OVR_RESTORE_OPTIMIZATION
+//
+// Allows for the dynamic disabling and restoring of compiler optimizations in code.
+// This is useful for helping deal with potential compiler code generation problems.
+// With VC++ the usage must be outside of function bodies. This can be used only to
+// temporarily disable optimization for a block of code and not to temporarily enable
+// optimization for a block of code.
+//
+// Clang doesn't support this as of June 2014, though function __attribute__((optimize(0))
+// is supposedly supported by clang in addition to GCC. To consider: Make a wrapper for
+// this attribute-based functionality.
+//
+// Example usage:
+//     OVR_DISABLE_OPTIMIZATION()
+//     void Test() { ... }
+//     OVR_RESTORE_OPTIMIZATION()
+//
+#if !defined(OVR_DISABLE_OPTIMIZATION)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION > 404) && (defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64))
+        #define OVR_DISABLE_OPTIMIZATION() \
+            _Pragma("GCC push_options")    \
+            _Pragma("GCC optimize 0")
+    #elif defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_OPTIMIZATION() __pragma(optimize("", off))
+    #else
+        #define OVR_DISABLE_OPTIMIZATION()
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_OPTIMIZATION)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION > 404) && (defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64))
+        #define OVR_RESTORE_OPTIMIZATION() _Pragma("GCC pop_options")
+    #elif defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_OPTIMIZATION() __pragma(optimize("", on))
+    #else
+        #define OVR_RESTORE_OPTIMIZATION()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// *****  OVR_DISABLE_GNU_WARNING / OVR_RESTORE_GNU_WARNING
+//
+// Portable wrapper for disabling GCC compiler warnings, one at a time. See example
+// usage for usage by example.
+//
+// Example usage:
+//     OVR_DISABLE_GNU_WARNING(-Wmissing-braces)  // Only one warning per usage.
+//     OVR_DISABLE_GNU_WARNING(-Wunused-variable)
+//     <code>
+//     OVR_RESTORE_GNU_WARNINGS()
+//     OVR_RESTORE_GNU_WARNINGS()                 // Must match each disable with a restore.
+//
+#if !defined(OVR_DISABLE_GNU_WARNING)
+    #if defined(OVR_CC_GNU)
+        #define ODGW1(x) #x
+        #define ODGW2(x) ODGW1(GCC diagnostic ignored x)
+        #define ODGW3(x) ODGW2(#x)
+    #endif
+
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 406)
+        #define OVR_DISABLE_GNU_WARNING(w)  \
+            _Pragma("GCC diagnostic push")  \
+            _Pragma(ODGW3(w))
+    #elif defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 404)  // GCC 4.4 doesn't support diagnostic push, but supports disabling warnings.
+        #define OVR_DISABLE_GNU_WARNING(w)  \
+            _Pragma(ODGW3(w))
+    #else
+        #define OVR_DISABLE_GNU_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_GNU_WARNING)
+    #if defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 4006)
+        #define OVR_RESTORE_GNU_WARNINGS()  \
+            _Pragma("GCC diagnostic pop")
+    #else
+        #define OVR_RESTORE_GNU_WARNING()
+    #endif
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// *****  OVR_DISABLE_CLANG_WARNING / OVR_RESTORE_CLANG_WARNING
+//
+// Portable wrapper for disabling GCC compiler warnings, one at a time. See example
+// usage for usage by example.
+//
+// Example usage:
+//     OVR_DISABLE_CLANG_WARNING(-Wmissing-braces)  // Only one warning per usage.
+//     OVR_DISABLE_CLANG_WARNING(-Wunused-variable)
+//     <code>
+//     OVR_RESTORE_CLANG_WARNINGS()
+//     OVR_RESTORE_CLANG_WARNINGS()                 // Must match each disable with a restore.
+//
+//
+#if !defined(OVR_DISABLE_CLANG_WARNING)
+    #if defined(OVR_CC_CLANG)
+        #define ODCW1(x) #x
+        #define ODCW2(x) ODCW1(clang diagnostic ignored x)
+        #define ODCW3(x) ODCW2(#x)
+
+        #define OVR_DISABLE_CLANG_WARNING(w)   \
+            _Pragma("clang diagnostic push")  \
+            _Pragma(ODCW3(w))
+    #else
+        #define OVR_DISABLE_CLANG_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_CLANG_WARNING)
+    #if defined(OVR_CC_CLANG)
+        #define OVR_RESTORE_CLANG_WARNING()    \
+            _Pragma("clang diagnostic pop")
+    #else
+        #define OVR_RESTORE_CLANG_WARNING()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_MSVC_WARNING / OVR_RESTORE_MSVC_WARNING
+//
+// Portable wrapper for disabling VC++ compiler warnings. See example usage for usage
+// by example.
+//
+// Example usage:
+//     OVR_DISABLE_MSVC_WARNING(4556 4782 4422)
+//     <code>
+//     OVR_RESTORE_MSVC_WARNING()
+//
+#if !defined(OVR_DISABLE_MSVC_WARNING)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_MSVC_WARNING(w) \
+            __pragma(warning(push))         \
+            __pragma(warning(disable:w))
+    #else
+        #define OVR_DISABLE_MSVC_WARNING(w)
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_MSVC_WARNING)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_MSVC_WARNING() \
+            __pragma(warning(pop))
+    #else
+        #define OVR_RESTORE_MSVC_WARNING()
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_DISABLE_ALL_MSVC_WARNINGS / OVR_RESTORE_ALL_MSVC_WARNINGS
+//
+// Portable wrapper for disabling all VC++ compiler warnings.
+// OVR_RESTORE_ALL_MSVC_WARNINGS restores warnings that were disabled by 
+// OVR_DISABLE_ALL_MSVC_WARNINGS. Any previously enabled warnings will still be 
+// enabled after OVR_RESTORE_ALL_MSVC_WARNINGS.
+//
+// Example usage:
+//     OVR_DISABLE_ALL_MSVC_WARNINGS()
+//     <code>
+//     OVR_RESTORE_ALL_MSVC_WARNINGS()
+
+#if !defined(OVR_DISABLE_ALL_MSVC_WARNINGS)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_DISABLE_ALL_MSVC_WARNINGS() \
+            __pragma(warning(push, 0))
+    #else
+        #define OVR_DISABLE_ALL_MSVC_WARNINGS()
+    #endif
+#endif
+
+#if !defined(OVR_RESTORE_ALL_MSVC_WARNINGS)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_RESTORE_ALL_MSVC_WARNINGS() \
+            __pragma(warning(pop))
+    #else
+        #define OVR_RESTORE_ALL_MSVC_WARNINGS()
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_HAS_FEATURE
+//
+// This is a portable way to use compile-time feature identification available 
+// with some compilers in a clean way. Direct usage of __has_feature in preprocessing
+// statements of non-supporting compilers results in a preprocessing error.
+//
+// Example usage:
+//     #if OVR_CC_HAS_FEATURE(is_pod)
+//         if(__is_pod(T)) // If the type is plain data then we can safely memcpy it.
+//             memcpy(&destObject, &srcObject, sizeof(object));
+//     #endif
+//
+#if !defined(OVR_CC_HAS_FEATURE)
+    #if defined(__clang__) // http://clang.llvm.org/docs/LanguageExtensions.html#id2
+        #define OVR_CC_HAS_FEATURE(x) __has_feature(x)
+    #else
+        #define OVR_CC_HAS_FEATURE(x) 0
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CC_HAS_BUILTIN
+//
+//
+// This is a portable way to use compile-time builtin identification available 
+// with some compilers in a clean way. Direct usage of __has_builtin in preprocessing
+// statements of non-supporting compilers results in a preprocessing error.
+//
+// Example usage:
+//     #if OVR_CC_HAS_BUILTIN(__builtin_trap)
+//         #define DEBUG_BREAK __builtin_trap
+//     #endif
+//  
+#if !defined(OVR_CC_HAS_BUILTIN)
+    #if defined(__clang__) 
+        #define OVR_CC_HAS_BUILTIN(x) __has_builtin(x) // http://clang.llvm.org/docs/LanguageExtensions.html#id2
+    #else
+        #define OVR_CC_HAS_BUILTIN(x) 0
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP11_ENABLED / OVR_CPP_CPP14_ENABLED
+//
+// Defined as 1 if the compiler has its available C++11 support enabled, else undefined.
+// This does not mean that all of C++11 or any particular feature of C++11 is supported
+// by the compiler. It means that whatever C++11 support the compiler has is enabled.
+// This also includes existing and older compilers that still identify C++11 as C++0x.
+//
+#if !defined(OVR_CPP11_ENABLED) && defined(__cplusplus)
+    #if defined(__GNUC__) && defined(__GXX_EXPERIMENTAL_CXX0X__)
+        #define OVR_CPP11_ENABLED 1
+    #elif defined(_MSC_VER) && (_MSC_VER >= 1500)   // VS2010+, the first version with any significant C++11 support. 
+        #define OVR_CPP11_ENABLED 1
+    #elif (__cplusplus >= 201103L)                  // 201103 is the first C++11 version.
+        #define OVR_CPP11_ENABLED 1
+    #else
+        // Leave undefined
+    #endif
+#endif
+
+#if !defined(OVR_CPP_CPP14_ENABLED) && defined(__cplusplus)
+    #if defined(_MSC_VER) && (_MSC_VER >= 1800)     // VS2013+, the first version with any significant C++14 support. 
+        #define OVR_CPP_CPP14_ENABLED 1
+    #elif (__cplusplus > 201103L)
+        #define OVR_CPP_CPP14_ENABLED 1
+    #else
+        // Leave undefined
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXCEPTIONS / OVR_CPP_NO_UNWIND
+//
+// OVR_CPP_NO_EXCEPTIONS is defined as 1 if the compiler doesn't support C++ 
+// exceptions or is configured to disable support for them. Else not defined.
+// If OVR_CPP_NO_EXCEPTIONS is defined then attempts to use try/catch
+// related C++ statements result in a compilation error with many
+// compilers.
+//
+// OVR_CPP_NO_UNWIND is defined as 1 if the compiler supports exceptions but 
+// doesn't support stack unwinding in the presence of an exception. Else not defined.
+// For the Microsoft compiler, disabling exceptions means disabling stack unwinding
+// and not disabling exceptions themselves.
+//
+// Example usage:
+//     void Test() {
+//         #if !defined(OVR_CPP_NO_EXCEPTIONS)
+//             try {
+//         #endif
+//             void* ptr = new Object;
+//         #if !defined(OVR_CPP_NO_EXCEPTIONS)
+//             catch(...) { ... }
+//         #endif
+
+#if !defined(OVR_CPP_NO_EXCEPTIONS)
+    #if defined(OVR_CPP_GNUC) && defined(_NO_EX)
+        #define OVR_CPP_NO_EXCEPTIONS 1
+    #elif (defined(OVR_CC_GNU) || defined(OVR_CC_CLANG) || defined(OVR_CC_INTEL) || defined(OVR_CC_ARM)) && !defined(__EXCEPTIONS)
+        #define OVR_CPP_NO_EXCEPTIONS 1
+    #elif defined(OVR_CC_MSVC) && !defined(_CPPUNWIND)
+        #define OVR_CPP_NO_UNWIND 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RTTI
+//
+// Defined as 1 if C++ run-time type information support is unavailable or disabled
+// by the compiler. Else undefined. Allows you to write portable code in the face
+// of the possibility that RTTI is disabled.
+//
+// Example usage:
+//     #if !OVR_CPP_NO_RTTI
+//         #include <typeinfo>
+//         int x = std::dynamic_cast<int>(3.4f);
+//     #endif
+
+#if defined(__clang__) && !OVR_CC_HAS_FEATURE(cxx_rtti)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(__GNUC__) && !defined(__GXX_RTTI)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(_MSC_VER) && !defined(_CPPRTTI)
+    #define OVR_CPP_NO_RTTI 1
+#elif defined(__CC_ARM) && defined(__TARGET_CPU_MPCORE) && !defined(__RTTI)
+    #define OVR_CPP_NO_RTTI 1
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STATIC_ASSERT
+//
+// Defined as 1 if C++ run-time type information support is available and enabled
+// by the compiler. Else undefined.
+//
+// Example usage:
+//     #if OVR_CPP_NO_STATIC_ASSERT
+//         #define MY_ASSERT(x) { int zero = 0; switch(zero) {case 0: case (x):;} }
+//     #else
+//         #define MY_ASSERT(x) static_assert((x), #x)
+//     #endif
+
+#if !defined(OVR_CPP_NO_STATIC_ASSERT)
+    #if !(defined(__GNUC__) && (defined(__GXX_EXPERIMENTAL_CXX0X__) || (defined(__cplusplus) && (__cplusplus >= 201103L)))) && \
+        !(defined(__clang__) && defined(__cplusplus) && OVR_CC_HAS_FEATURE(cxx_static_assert)) &&                              \
+        !(defined(_MSC_VER) && (_MSC_VER >= 1600) && defined(__cplusplus)) &&                 /* VS2010+  */                   \
+        !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401) && defined(OVR_CPP11_ENABLED)) /* EDG 4.1+ */
+	    #define OVR_CPP_NO_STATIC_ASSERT 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NULLPTR
+//
+// Defined as 1 if the compiler doesn't support C++11 nullptr built in type. 
+// Otherwise undefined. Does not identify if the standard library defines 
+// std::nullptr_t, as some standard libraries are further behind in standardization 
+// than the compilers using them (e.g. Apple clang with the supplied libstdc++). 
+//
+// OVR_Nullptr.h provides a portable nullptr and std::nullptr_t for when the 
+// compiler or standard library do not.
+
+#if !defined(OVR_CPP_NO_NULLPTR)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_nullptr))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))          /* GCC 4.6+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))  /* EDG 4.3+  */    
+        #define OVR_CPP_NO_NULLPTR 1
+    #endif
+#endif  
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RVALUE_REFERENCES
+//
+// Defined as 1 if the compiler doesn't support C++11 rvalue references and move semantics.
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_RVALUE_REFERENCES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_rvalue_references)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                   /* GCC 4.5+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                         /* VS2010+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))           /* EDG 4.3+ */    
+        #define OVR_CPP_NO_RVALUE_REFERENCES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_AUTO
+// 
+// Defined as 1 if the compiler doesn't support C++11 auto keyword. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_AUTO)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_auto_type))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))            /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                  /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 309)))    /* EDG 3.9+  */  
+        #define OVR_CPP_NO_AUTO 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RANGE_BASED_FOR_LOOP
+//
+// Defined as 1 if the compiler doesn't support C++11 range-based for loops.
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_RANGE_BASED_FOR_LOOP)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_range_for)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))           /* GCC 4.6+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                 /* VS2012+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))   /* EDG 4.5+ */    
+        #define OVR_CPP_NO_RANGE_BASED_FOR_LOOP 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_CONSTEXPR / OVR_CPP_NO_RELAXED_CONSTEXPR
+//
+// OVR_CPP_NO_CONSTEXPR is defined as 1 if the compiler doesn't support C++11 constexpr.
+// OVR_CPP_NO_RELAXED_CONSTEXPR is defined as 1 if the compiler doesn't support C++14 constexpr.
+// Otherwise undefined.
+// See the OVR_CONSTEXPR / OVR_CONSTEXPR_OR_CONST macros for portable wrappers of this functionality.
+
+#if !defined(OVR_CPP_NO_CONSTEXPR)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_constexpr))  /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))            /* GCC 4.6+ */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))    /* EDG 4.6+ */    
+        // Not supported by VC++ through at least VS2013.
+        #define OVR_CPP_NO_CONSTEXPR 1
+    #endif
+#endif
+
+#if !defined(OVR_CPP_NO_RELAXED_CONSTEXPR)
+    #if !defined(OVR_CPP14_ENABLED) || \
+        !(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_relaxed_constexpr)) /* clang */
+        // Supported only by clang as of this writing.
+        #define OVR_CPP_NO_RELAXED_CONSTEXPR 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_LAMBDA_EXPRESSIONS
+//
+// Defined as 1 if the compiler doesn't support C++11 lambda expressions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_LAMBDA_EXPRESSIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_lambdas))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))          /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))  /* EDG 4.1+  */ 
+        // Conversion of lambdas to function pointers is not supported until EDG 4.5.
+        #define OVR_CPP_NO_LAMBDA_EXPRESSIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_ALIGNOF
+//
+// Defined as 1 if the compiler supports C++11 alignof. Otherwise undefined.
+// Some compilers support __alignof__ instead of alignof, so for portability you 
+// should use OVR_ALIGNOF instead of directly using C++11 alignof.
+
+#if !defined(OVR_CPP_NO_ALIGNOF)
+    #if (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 300))  /* Apple clang 3.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 401))                    /* GCC 4.1+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 400)))            /* EDG 4.0+         */
+        #define OVR_CPP_NO_ALIGNOF 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_ALIGNAS
+//
+// Defined as 1 if the compiler supports C++11 alignas. Otherwise undefined.
+// See the OVR_ALIGNAS for a portable wrapper for alignas functionality.
+
+#if !defined(OVR_CPP_NO_ALIGNAS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300))  /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                    /* GCC 4.8+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        #define OVR_CPP_NO_ALIGNAS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_OVERRIDE
+//
+// Defined as 1 if the compiler doesn't support C++11 override. Otherwise undefined.
+// See the OVR_OVERRIDE and OVR_FINALOVERRIDE macros for a portable wrapper.
+
+#if !defined(OOVR_CPP_NO_OVERRIDE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209)) /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400)) /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                   /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                         /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))           /* EDG 4.8+         */     
+        #define OVR_CPP_NO_OVERRIDE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FINAL
+// 
+// Defined as 1 if the compiler doesn't support C++11 final attribute. Otherwise undefined.
+// See the OVR_FINAL and OVR_FINALOVERRIDE macros for a portable wrapper.
+
+#if !defined(OOVR_CPP_NO_FINAL)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                          /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */    
+        #define OVR_CPP_NO_FINAL 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTERN_TEMPLATE
+//
+// Defined as 1 if the compiler doesn't support C++11 extern template.
+// Otherwise undefined. See OVR_EXTERN_TEMPLATE for wrapper macro.
+
+#if !defined(OVR_CPP_NO_EXTERN_TEMPLATE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                          /* VS2012+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */ 
+        #define OVR_CPP_NO_EXTERN_TEMPLATE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_VARIADIC_TEMPLATES
+//
+// Defined as 1 if the compiler doesn't support C++11 variadic templates. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_VARIADIC_TEMPLATES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_variadic_templates)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))            /* EDG 4.3+  */   
+        #define OVR_CPP_NO_VARIADIC_TEMPLATES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NOEXCEPT
+//
+// Defined as 1 if the compiler supports C++11 noexcept. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/noexcept
+// See OVR_NOEXCEPT / OVR_NOEXCEPT_IF / OVR_NOEXCEPT_EXPR for a portable wrapper
+// for noexcept functionality.
+
+#if !defined(OVR_CPP_NO_NOEXCEPT)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_noexcept))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))           /* GCC 4.6+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                 /* VS2014+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))   /* EDG 4.5+  */
+        #define OVR_CPP_NO_NOEXCEPT 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DECLTYPE
+//
+// Defined as 1 if the compiler doesn't support C++11 decltype. Otherwise undefined.
+// Some compilers (e.g. VS2012) support most uses of decltype but don't support 
+// decltype with incomplete types (which is an uncommon usage seen usually in 
+// template metaprogramming).  We don't include this support as a requirement for
+// our definition of decltype support here.
+
+#if !defined(OVR_CPP_NO_DECLTYPE)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_decltype))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))           /* GCC 4.3+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                 /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))   /* EDG 4.2+  */       
+        // VC++ fails to support decltype for incomplete types until VS2013.
+        // EDG fails to support decltype for incomplete types until v4.8.
+        #define OVR_CPP_NO_DECLTYPE 1
+    #endif
+#endif  
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DEFAULTED_FUNCTIONS
+// 
+// Defined as 1 if the compiler doesn't support C++11 defaulted functions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_DEFAULTED_FUNCTIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_defaulted_functions))/* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+ */
+        // Up through at least VS2013 it's unsupported for defaulted move constructors and move assignment operators.
+        // Until EDG 4.8 it's unsupported for defaulted move constructors and move assigment operators.
+        #define OVR_CPP_NO_DEFAULTED_FUNCTIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DELETED_FUNCTIONS
+// 
+// Defined as 1 if the compiler doesn't support C++11 deleted functions. Otherwise undefined.
+// Some compilers have slightly crippled versions of this.
+
+#if !defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_defaulted_functions)) /* clang    */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                     /* GCC 4.4+ */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                           /* VS2013+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))             /* EDG 4.1+ */  
+        // Up through at least VS2013 it's unsupported for defaulted move constructors and move assignment operators.
+        // Until EDG 4.8 it's unsupported for defaulted move constructors and move assigment operators.
+        #define OVR_CPP_NO_DELETED_FUNCTIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STANDARD_LAYOUT_TYPES
+// 
+// Defined as 1 if the compiler doesn't support C++11 standard layout (relaxed POD). Otherwise undefined.
+// http://en.cppreference.com/w/cpp/types/is_standard_layout
+
+#if !defined(OVR_CPP_NO_STANDARD_LAYOUT_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300)) /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401)) /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                   /* GCC 4.5+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                         /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))           /* EDG 4.6+         */  
+        #define OVR_CPP_NO_STANDARD_LAYOUT_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FORWARD_DECLARED_ENUMS
+//
+// Defined as 1 if the compiler doesn't support C++11 forward declared enums. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_FORWARD_DECLARED_ENUMS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                          /* VS2012+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */ 
+        #define OVR_CPP_NO_FORWARD_DECLARED_ENUMS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_STRONGLY_TYPED_ENUMS
+//
+// Defined as 1 if the compiler doesn't support C++11 strongly typed enums. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_STRONGLY_TYPED_ENUMS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_strong_enums))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))               /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1700))                     /* VS2012+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 400)))       /* EDG 4.0+ */ 
+        #define OVR_CPP_NO_STRONGLY_TYPED_ENUMS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_TRAILING_RETURN_TYPES
+//
+// Defined as 1 if the compiler doesn't support C++11 trailing return types. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#Alternative_function_syntax
+
+#if !defined(OVR_CPP_NO_TRAILING_RETURN_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_trailing_return)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                 /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                       /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))         /* EDG 4.1+ */    
+        #define OVR_CPP_NO_TRAILING_RETURN_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_TEMPLATE_ALIASES
+//
+// Defined as 1 if the compiler doesn't support C++11 template aliases. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_TEMPLATE_ALIASES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_alias_templates)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                 /* GCC 4.7+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                       /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))         /* EDG 4.2+  */ 
+        #define OVR_CPP_NO_TEMPLATE_ALIASES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INITIALIZER_LISTS
+//
+// Defined as 1 if the compiler doesn't support C++11 initializer lists. Otherwise undefined.
+// This refers to the compiler support for this and not the Standard Library support for std::initializer_list,
+// as a new compiler with an old standard library (e.g. Apple clang with libstdc++) may not support std::initializer_list.
+
+#if !defined(OVR_CPP_NO_INITIALIZER_LISTS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_generalized_initializers)) /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                          /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                                /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))                  /* EDG 4.5+  */
+        #define OVR_CPP_NO_INITIALIZER_LISTS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NORETURN
+//
+// Defined as 1 if the compiler doesn't support the C++11 noreturn attribute. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/attributes
+//
+#if !defined(OVR_CPP_NO_NORETURN)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                    /* GCC 4.8+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1500))                          /* VS2008+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))            /* EDG 4.2+         */
+        // Supported with VC++ only via __declspec(noreturn) (see OVR_NORETURN).
+        #define OVR_CPP_NO_NORETURN 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS
+//
+// Defined as 1 if the compiler doesn't support C++11 in-class non-static member initializers. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/data_members
+
+#if !defined(OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))            /* EDG 4.6+         */
+        #define OVR_CPP_NO_NONSTATIC_MEMBER_INITIALIZERS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DOUBLE_TEMPLATE_BRACKETS
+//
+// Defined as 1 if the compiler supports nested template declarations with >>, 
+// as supported by C++11. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_DOUBLE_TEMPLATE_ANGLE_BRACKETS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))                    /* GCC 4.3+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                          /* VS2010+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */
+        #define OVR_CPP_NO_DOUBLE_TEMPLATE_BRACKETS 1
+    #endif
+#endif
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INHERITING_CONSTRUCTORS
+//
+// Defined as 1 if the compiler supports C++11 inheriting constructors. Otherwise undefined.
+// Example usage:
+//     struct A { explicit A(int x){} };
+//     struct B : public A { using A::A; }; // As if B redeclared A::A(int).
+
+#if !defined(OVR_CPP_NO_INHERITING_CONSTRUCTORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_inheriting_constructors))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))                          /* GCC 4.8+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                                /* VS2014+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))                  /* EDG 4.8+  */
+        #define OVR_CPP_NO_INHERITING_CONSTRUCTORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_DELEGATING_CONSTRUCTORS
+//
+// Defined as 1 if the compiler supports C++11 delegating constructors. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_DELEGATING_CONSTRUCTORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 300))  /* clang 3.0+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))            /* EDG 4.7+         */
+        #define OVR_CPP_NO_DELEGATING_CONSTRUCTORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS
+//  
+// Defined as 1 if the compiler supports C++11 function template default arguments. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 403))                    /* GCC 4.3+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                          /* VS2013+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 403)))            /* EDG 4.3+         */
+        #define OVR_CPP_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNRESTRICTED_UNIONS
+//
+// Defined as 1 if the compiler supports C++11 unrestricted unions. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_UNRESTRICTED_UNIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 406))                    /* GCC 4.6+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))            /* EDG 4.6+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_UNRESTRICTED_UNIONS 1
+    #endif
+#endif
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTENDED_SIZEOF
+//
+// Defined as 1 if the compiler supports C++11 class sizeof extensions (e.g. sizeof SomeClass::someMember). 
+// Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_EXTENDED_SIZEOF)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                    /* GCC 4.5+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1900))                          /* VS2014+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */
+        #define OVR_CPP_NO_EXTENDED_SIZEOF 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_INLINE_NAMESPACES
+//
+// Defined as 1 if the compiler supports C++11 inlined namespaces. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/namespace#Inline_namespaces
+
+#if !defined(OVR_CPP_NO_INLINE_NAMESPACES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                    /* GCC 4.4+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 405)))            /* EDG 4.5+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_INLINE_NAMESPACES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS
+//
+// Defined as 1 if the compiler supports C++11 explicit conversion operators. Otherwise undefined.
+// http://en.cppreference.com/w/cpp/language/explicit
+
+#if !defined(OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_explicit_conversions))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                       /* GCC 4.5+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                             /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 404)))               /* EDG 4.4+  */
+        #define OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS
+//
+// Defined as 1 if the compiler supports C++11 local class template parameters. Otherwise undefined.
+// Example:
+//     void Test() {   
+//         struct LocalClass{ };
+//         SomeTemplateClass<LocalClass> t; // Allowed only in C++11
+//     }
+
+#if !defined(OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS) 
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_local_type_template_args))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                           /* GCC 4.5+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                                 /* VS2010+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 402)))                   /* EDG 4.2+  */
+        #define OVR_CPP_NO_LOCAL_CLASS_TEMPLATE_PARAMETERS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_NEW_CHARACTER_TYPES
+//
+// Defined as 1 if the compiler natively supports C++11 char16_t and char32_t. Otherwise undefined.
+// VC++ through at least VS2013 defines char16_t as unsigned short in its standard library,
+// but it is not a native type or unique type, nor can you for a string literal with it.
+
+#if !defined(OVR_CPP_NO_NEW_CHARACTER_TYPES)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_unicode_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                   /* GCC 4.4+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))           /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_NEW_CHARACTER_TYPES 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 \u and \U character literals for 
+// native char16_t and char32_t types.
+//
+#if !defined(OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                    /* GCC 4.5+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        // Not supported by VC++ as of VS2013. VC++'s existing \U and \u are non-conforming.
+        #define OVR_CPP_NO_UNICODE_CHAR_NAME_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_USER_DEFINED_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 user-defined literals. Otherwise undefined.
+
+#if !defined(OVR_CPP_NO_USER_DEFINED_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 301))  /* clang 3.1+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 401))  /* Apple clang 4.1+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))            /* EDG 4.8+         */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_USER_DEFINED_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNICODE_STRING_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 Unicode string literals. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#New_string_literals
+
+#if !defined(OVR_CPP_NO_UNICODE_STRING_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_unicode_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                   /* GCC 4.4+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))           /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_UNICODE_STRING_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_RAW_STRING_LITERALS
+//
+// Defined as 1 if the compiler supports C++11 raw literals. Otherwise undefined.
+// http://en.wikipedia.org/wiki/C%2B%2B11#New_string_literals
+
+#if !defined(OVR_CPP_NO_RAW_STRING_LITERALS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_raw_string_literals))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 405))                      /* GCC 4.5+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 407)))              /* EDG 4.7+  */
+        // Not supported by VC++ as of VS2013.
+        #define OVR_CPP_NO_RAW_STRING_LITERALS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX
+//
+// Defined as 1 if the compiler supports C++11 unified initialization.
+// http://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization
+
+#if !defined(OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_generalized_initializers))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 404))                           /* GCC 4.4+  */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1800))                                 /* VS2013+   */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 406)))                   /* EDG 4.6+  */
+        #define OVR_CPP_NO_UNIFIED_INITIALIZATION_SYNTAX 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS
+//
+// Defined as 1 if the compiler supports C++11 extended friends.
+
+#if !defined(OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && !defined(__APPLE__) && (__clang__ >= 209))  /* clang 2.9+       */ && \
+         !(defined(__clang__) &&  defined(__APPLE__) && (__clang__ >= 400))  /* Apple clang 4.0+ */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 407))                    /* GCC 4.7+         */ && \
+         !(defined(_MSC_VER) && (_MSC_VER >= 1600))                          /* VS2010+          */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 401)))            /* EDG 4.1+         */
+        #define OVR_CPP_NO_EXTENDED_FRIEND_DECLARATIONS 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_CPP_NO_THREAD_LOCAL
+//
+// Defined as 1 if the compiler supports C++11 thread_local. Else undefined. Does not
+// indicate if the compiler supports C thread-local compiler extensions such as __thread
+// and declspec(thread). Use OVR_THREAD_LOCAL if you want to declare a thread-local 
+// variable that supports C++11 thread_local when available but the C extension when 
+// it's available. The primary difference between C++11 thread_local and C extensions is
+// that C++11 thread_local supports non-PODs and calls their constructors and destructors.
+//
+// Note that thread_local requires both compiler and linker support, and so it's possible
+// that the compiler may support thread_local but the linker does not.
+
+#if !defined(OVR_CPP_NO_THREAD_LOCAL)
+    #if !defined(OVR_CPP11_ENABLED) || \
+        (!(defined(__clang__) && OVR_CC_HAS_FEATURE(cxx_thread_local))  /* clang     */ && \
+         !(defined(__GNUC__) && (OVR_CPP_VERSION >= 408))               /* GCC 4.8+  */ && \
+         !(defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 408)))       /* EDG 4.8+  */
+        #define OVR_CPP_NO_THREAD_LOCAL 1
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_ALIGNAS / OVR_ALIGNOF
+//
+//    OVR_ALIGNAS(n)        // Specifies a size_t power of two alignment for a type or instance.
+//    OVR_ALIGNOF(type)     // Returns the size_t alignment of a type or instance.
+//
+// Example usage:
+//    OVR_ALIGNAS(8) char c = 'c';                      // Specifies that the instance c be aligned to an 8 byte boundary.
+//    typedef OVR_ALIGNAS(8) char C;                    // Specifies that the type C be aligned to an 8 byte boundary.
+//    struct OVR_ALIGNAS(64) S{ char array[16]; };      // Specfies that the struct S have a natural alignment of 64.
+//    OVR_ALIGNAS(32) S s;                              // Specifies that the instance s of struct S be aligned to an 32 byte boundary.
+//    OVR_ALIGNAS(32) struct T{ char array[16]; } t;    // Specfies that the instance t of struct T have a natural alignment of 32.
+//    struct OVR_ALIGNAS(T) U{};                        // Specifes that U be aligned the same as T. Supported only by C++11 compilers (see OVR_CPP_NO_ALIGNAS).
+//
+//    size_t a = OVR_ALIGNOF(double);                   // Returns the natural alignment of the double type.
+//    size_t a = OVR_ALIGNOF(S);                        // Returns the natural alignment of the struct S type.
+//
+// Note: If C++11 alignas is supported, then alignas/OVR_ALIGNAS may take a const expression in addition to a constant.
+// Note: The C11 Standard species the _Alignas keyword and alignas as a macro for it in <stdalign.h>
+
+#if !defined(OVR_ALIGNAS)
+    #if defined(OVR_CC_GNU) && !defined(OVR_CPP_NO_ALIGNAS)     // If C++11 alignas is supported...
+        #define OVR_ALIGNAS(n) alignas(n)
+    #elif defined(__clang__) && !defined(OVR_CPP_NO_ALIGNAS)
+        #define OVR_ALIGNAS(n) alignas(n)
+    #elif defined(OVR_CC_GNU) || defined(__clang__)
+        #define OVR_ALIGNAS(n) __attribute__((aligned(n)))
+    #elif defined(OVR_CC_MSVC) || defined(OVR_CC_INTEL)
+        #define OVR_ALIGNAS(n) __declspec(align(n))             // For Microsoft the alignment must be a literal integer.
+    #elif defined(OVR_CC_ARM)
+        #define OVR_ALIGNAS(n) __align(n)
+    #else
+        #error Need to define OVR_ALIGNAS
+    #endif
+#endif
+
+#if !defined(OVR_ALIGNOF)
+    #if defined(OVR_CC_GNU) && !defined(OVR_CPP_NO_ALIGNOF)     // If C++11 alignof is supported...
+        #define OVR_ALIGNOF(type) alignof(t)
+    #elif defined(__clang__) && !defined(OVR_CPP_NO_ALIGNOF)
+        #define OVR_ALIGNOF(type) alignof(t)
+    #elif defined(OVR_CC_GNU) || defined(__clang__)
+        #define OVR_ALIGNOF(type) ((size_t)__alignof__(type))
+    #elif defined(OVR_CC_MSVC) || defined(OVR_CC_INTEL)
+        #define OVR_ALIGNOF(type) ((size_t)__alignof(type))
+    #elif defined(OVR_CC_ARM)
+        #define OVR_ALIGNOF(type) ((size_t)__ALIGNOF__(type))
+    #else
+        #error Need to define OVR_ALIGNOF
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_ASSUME / OVR_ANALYSIS_ASSUME
+//
+// This is a portable wrapper for VC++'s __assume and __analysis_assume.
+// __analysis_assume is typically used to quell VC++ static analysis warnings.
+//
+// Example usage:
+//    void Test(char c){
+//       switch(c){
+//          case 'a':
+//          case 'b':
+//          case 'c':
+//          case 'd':
+//             break;
+//          default:
+//             OVR_ASSUME(0); // Unreachable code.
+//       }
+//    }
+//
+//    size_t Test(char* str){
+//       OVR_ANALYSIS_ASSUME(str != nullptr);
+//       return strlen(str);
+//    }
+
+#if !defined(OVR_ASSUME)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_ASSUME(x)          __assume(x)
+        #define OVR_ANALYSIS_ASSUME(x) __analysis_assume(!!(x))
+    #else
+        #define OVR_ASSUME(x)
+        #define OVR_ANALYSIS_ASSUME(x)
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_RESTRICT
+//
+// Wraps the C99 restrict keyword in a portable way.
+// C++11 and C++14 don't have restrict but this functionality is supported by 
+// all C++ compilers.
+//
+// Example usage:
+//    void* memcpy(void* OVR_RESTRICT s1, const void* OVR_RESTRICT s2, size_t n);
+
+#if !defined(OVR_RESTRICT)
+    #define OVR_RESTRICT __restrict // Currently supported by all compilers of significance to us.
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_NOEXCEPT / OVR_NOEXCEPT_IF(predicate) / OVR_NOEXCEPT_EXPR(expression)
+//
+// Implements a portable wrapper for C++11 noexcept.
+// http://en.cppreference.com/w/cpp/language/noexcept
+//
+// Example usage:
+//     void Test() OVR_NOEXCEPT {} // This function doesn't throw.
+//
+//     template <typename T>
+//     void DoNothing() OVR_NOEXCEPT_IF(OVR_NOEXCEPT_EXPR(T())) // Throws an if and only if T::T(int) throws.
+//         { T t(3); }
+//
+#if !defined(OVR_NOEXCEPT)
+    #if defined(OVR_CPP_NOEXCEPT)
+        #define OVR_NOEXCEPT
+        #define OVR_NOEXCEPT_IF(predicate)
+        #define OVR_NOEXCEPT_EXPR(expression) false
+    #else
+        #define OVR_NOEXCEPT noexcept
+        #define OVR_NOEXCEPT_IF(predicate) noexcept((predicate))
+        #define OVR_NOEXCEPT_EXPR(expression) noexcept((expression))
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FINAL
+//
+// Wraps the C++11 final keyword in a portable way.
+// http://en.cppreference.com/w/cpp/language/final
+//
+// Example usage:
+//     struct Test { virtual int GetValue() OVR_FINAL; };
+
+#if !defined(OVR_FINAL)
+    #if defined(OVR_CC_MSVC) && (OVR_CC_VERSION < 1700) // VC++ 2012 and earlier
+        #define OVR_FINAL sealed
+    #elif defined(OVR_CPP_INHERITANCE_FINAL)
+        #define OVR_FINAL
+    #else
+        #define OVR_FINAL final
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_OVERRIDE
+//
+// Wraps the C++11 override keyword in a portable way.
+// http://en.cppreference.com/w/cpp/language/override
+//
+// Example usage:
+//        struct Parent { virtual void Func(int); };
+//        struct Child : public Parent { void Func(int) OVR_OVERRIDE; };
+
+#if !defined(OVR_CPP11_ENABLED)
+#define OVR_OVERRIDE
+#elif !defined(OVR_OVERRIDE)
+    #if defined(OVR_CPP_OVERRIDE)
+        #define OVR_OVERRIDE
+    #else
+        #if (defined(_MSC_VER) && (_MSC_VER <= 1600))
+            #pragma warning(disable : 4481)
+        #endif
+        #define OVR_OVERRIDE override
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FINAL_OVERRIDE
+//
+// Wraps the C++11 final+override keywords (a common combination) in a portable way.
+//
+// Example usage:
+//     struct Parent { virtual void Func(); };
+//     struct Child : public Parent { virtual void Func() OVR_FINAL_OVERRIDE; };
+
+#if !defined(OVR_FINAL_OVERRIDE)
+    #define OVR_FINAL_OVERRIDE OVR_FINAL OVR_OVERRIDE
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_EXTERN_TEMPLATE
+//
+// Portable wrapper for C++11 extern template. This tells the compiler to not instantiate
+// the template in the current translation unit, which can significantly speed up 
+// compilation and avoid problems due to two translation units compiling code with 
+// different settings.
+//
+// Example usage:
+//     OVR_EXTERN_TEMPLATE(class basic_string<char>); // Nothing to do for non-C++11 compilers.
+
+#if !defined(OVR_EXTERN_TEMPLATE)
+    #if defined(OVR_CPP_EXTERN_TEMPLATE)
+        #define OVR_EXTERN_TEMPLATE(decl)
+    #else
+        #define OVR_EXTERN_TEMPLATE(decl) extern template decl
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_CONSTEXPR  / OVR_CONSTEXPR_OR_CONST
+//
+// Portable wrapper for C++11 constexpr. Doesn't include C++14 relaxed constexpr,
+// for which a different wrapper name is reserved.
+//
+// Example usage:
+//     OVR_CONSTEXPR int Test() { return 15; }          // This can be optimized better by a C++11 compiler that supports constexpr.
+//     OVR_CONSTEXPR_OR_CONST float x = 3.14159f;       // This can be optimized better by a C++11 compiler, but if not then at least make it const.
+
+#if !defined(OVR_CONSTEXPR)
+    #if defined(OVR_CPP_NO_CONSTEXPR)
+        #define OVR_CONSTEXPR
+    #else
+        #define OVR_CONSTEXPR constexpr
+    #endif
+#endif
+
+#if !defined(OVR_CONSTEXPR_OR_CONST)
+    #if defined(OVR_CPP_NO_CONSTEXPR)
+        #define OVR_CONSTEXPR_OR_CONST const
+    #else
+        #define OVR_CONSTEXPR_OR_CONST constexpr
+    #endif
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_FUNCTION_DELETE / OVR_FUNCTION_DEFAULT
+//
+// Wraps the C++11 delete and default keywords in a way that allows for cleaner code
+// while making for a better version of uncallable or default functions.
+//
+// Example usage:
+//     struct Test{
+//         Test() OVR_FUNCTION_DEFAULT;            // Non-C++11 compilers will require a separate definition for Test().
+//     private:                                   // Users should put OVR_FUNCTION_DELETE usage in a private 
+//         void Uncallable() OVR_FUNCTION_DELETE;  // area for compatibility with pre-C++11 compilers.
+//     };
+
+#if defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+    #define OVR_FUNCTION_DELETE
+#else
+    #define OVR_FUNCTION_DELETE = delete
+#endif
+
+#if defined(OVR_CPP_NO_DEFAULTED_FUNCTIONS)
+    #define OVR_FUNCTION_DEFAULT
+#else
+    #define OVR_FUNCTION_DEFAULT = default
+#endif
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_NON_COPYABLE
+//
+// Allows you to specify a class as being neither copy-constructible nor assignable,
+// which is a commonly needed pattern in C++ programming. Classes with this declaration
+// are required to be default constructible (as are most classes). For pre-C++11
+// compilers this macro declares a private section for the class, which will be
+// inherited by whatever code is directly below the macro invocation by default.
+//
+// Example usage:
+//    struct Test {
+//       Test();
+//       ...
+//       OVR_NON_COPYABLE(Test)
+//    };
+
+#if !defined(OVR_NON_COPYABLE)
+    #if defined(OVR_CPP_NO_DELETED_FUNCTIONS)
+        #define OVR_NON_COPYABLE(Type)   \
+            private:                     \
+            Type(const Type&);           \
+            void operator=(const Type&);
+    #else
+        #define OVR_NON_COPYABLE(Type)   \
+            Type(const Type&) = delete;  \
+            void operator=(const Type&) = delete;
+    #endif
+#endif
+
+
+
+#endif  // header include guard
+
+
+
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ContainerAllocator.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ContainerAllocator.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,267 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_ContainerAllocator.h
+Content     :   Template allocators and constructors for containers.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_ContainerAllocator_h
+#define OVR_ContainerAllocator_h
+
+#include "OVR_Allocator.h"
+#include <string.h>
+
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------------
+// ***** Container Allocator
+
+// ContainerAllocator serves as a template argument for allocations done by
+// containers, such as Array and Hash; replacing it could allow allocator
+// substitution in containers.
+
+class ContainerAllocatorBase
+{
+public:
+    static void* Alloc(size_t size)                { return OVR_ALLOC(size); }
+    static void* Realloc(void* p, size_t newSize)  { return OVR_REALLOC(p, newSize); }
+    static void  Free(void *p)                    { OVR_FREE(p); }
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Constructors, Destructors, Copiers
+
+// Plain Old Data - movable, no special constructors/destructor.
+template<class T> 
+class ConstructorPOD
+{
+public:
+    static void Construct(void *) {}
+    static void Construct(void *p, const T& source) 
+    { 
+        *(T*)p = source;
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void *p, const S& source)
+    {
+        *(T*)p = source;
+    }
+
+    static void ConstructArray(void*, size_t) {}
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t *pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            *(T*)pdata = source;
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        memcpy(p, psource, sizeof(T) * count);
+    }
+
+    static void Destruct(T*) {}
+    static void DestructArray(T*, size_t) {}
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static bool IsMovable() { return true; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ConstructorMov
+//
+// Correct C++ construction and destruction for movable objects
+template<class T> 
+class ConstructorMov
+{
+public:
+    static void Construct(void* p) 
+    { 
+        OVR::Construct<T>(p);
+    }
+
+    static void Construct(void* p, const T& source) 
+    { 
+        OVR::Construct<T>(p, source);
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void* p, const S& source)
+    {
+        OVR::ConstructAlt<T,S>(p, source);
+    }
+
+    static void ConstructArray(void* p, size_t count)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, source);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, *psource++);
+    }
+
+    static void Destruct(T* p)
+    {
+        p->~T();
+        OVR_UNUSED(p); // Suppress silly MSVC warning
+    }
+
+    static void DestructArray(T* p, size_t count)
+    {   
+        p += count - 1;
+        for (size_t i=0; i<count; ++i, --p)
+            p->~T();
+    }
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        memmove(dst, src, count * sizeof(T));
+    }
+
+    static bool IsMovable() { return true; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ConstructorCPP
+//
+// Correct C++ construction and destruction for movable objects
+template<class T> 
+class ConstructorCPP
+{
+public:
+    static void Construct(void* p) 
+    { 
+        OVR::Construct<T>(p);        
+    }
+
+    static void Construct(void* p, const T& source) 
+    { 
+        OVR::Construct<T>(p, source);        
+    }
+
+    // Same as above, but allows for a different type of constructor.
+    template <class S> 
+    static void ConstructAlt(void* p, const S& source)
+    {
+        OVR::ConstructAlt<T,S>(p, source);        
+    }
+
+    static void ConstructArray(void* p, size_t count)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T& source)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, source);
+    }
+
+    static void ConstructArray(void* p, size_t count, const T* psource)
+    {
+        uint8_t* pdata = (uint8_t*)p;
+        for (size_t i=0; i< count; ++i, pdata += sizeof(T))
+            Construct(pdata, *psource++);
+    }
+
+    static void Destruct(T* p)
+    {
+        p->~T();
+        OVR_UNUSED(p); // Suppress silly MSVC warning
+    }
+
+    static void DestructArray(T* p, size_t count)
+    {   
+        p += count - 1;
+        for (size_t i=0; i<count; ++i, --p)
+            p->~T();
+    }
+
+    static void CopyArrayForward(T* dst, const T* src, size_t count)
+    {
+        for(size_t i = 0; i < count; ++i)
+            dst[i] = src[i];
+    }
+
+    static void CopyArrayBackward(T* dst, const T* src, size_t count)
+    {
+        for(size_t i = count; i; --i)
+            dst[i-1] = src[i-1];
+    }
+
+    static bool IsMovable() { return false; }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Container Allocator with movement policy
+//
+// Simple wraps as specialized allocators
+template<class T> struct ContainerAllocator_POD : ContainerAllocatorBase, ConstructorPOD<T> {};
+template<class T> struct ContainerAllocator     : ContainerAllocatorBase, ConstructorMov<T> {};
+template<class T> struct ContainerAllocator_CPP : ContainerAllocatorBase, ConstructorCPP<T> {};
+
+
+} // OVR
+
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_CRC32.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,45 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_CRC32.h
+Content     :   CRC-32 with polynomial used for sensor devices
+Created     :   June 20, 2014
+Author      :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_CRC32_h
+#define OVR_CRC32_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------------
+// ***** CRC-32
+
+// Polynomial used and algorithm details are proprietary to our sensor board
+uint32_t CRC32_Calculate(const void* data, int bytes, uint32_t prevCRC = 0);
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Delegates.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Delegates.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,541 @@
+/************************************************************************************
+
+Filename    :   OVR_Delegates.h
+Content     :   C++ Delegates
+Created     :   June 15, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+/*
+	Based on The Impossibly Fast C++ Delegates by Sergey Ryazanov from
+	http://www.codeproject.com/KB/cpp/ImpossiblyFastCppDelegate.aspx (2005)
+*/
+
+/*
+	Usage:
+
+	Declare a delegate with a void (int) signature, also known as a
+	function that returns void and has one parameter that is an int:
+		typedef Delegate1<void, int> MyDelegate;
+		MyDelegate d;
+
+	Point the delegate to a member function:
+		d.SetMember<A, &A::TestFunctionA>(&a);
+		d = MyDelegate::FromMember<A, &A::TestFunctionA>(&a);
+
+	Point the delegate to a const member function:
+		d.SetConstMember<C, &C::TestFunctionA>(&c);
+		d = MyDelegate::FromConstMember<C, &C::TestFunctionA>(&c);
+
+	Point the delegate to a free function:
+		d.SetFree<&FreeFunctionX>();
+		d = MyDelegate::FromFree<&FreeFunctionX>();
+
+	Invoke the function via the delegate (works for all 3 cases):
+		d(1000);
+
+	By default the delegates are uninitialized.
+	To clear an array of delegates quickly just zero the memory.
+
+	This implementation is nicer than FastDelegates in my opinion
+	because it is simple and easy to read.  It is a little slower
+	for virtual functions, but the size of the delegate is small,
+	and it will only get better as compilers improve.
+*/
+
+#ifndef OVR_Delegates_h
+#define OVR_Delegates_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+
+template <class ret_type>
+class Delegate0
+{
+	typedef ret_type (*StubPointer)(void *);
+	typedef Delegate0<ret_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate0(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)()>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object)
+	{
+		return (F)();
+	}
+
+	template <class T, ret_type (T::*F)()>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)();
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)();
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate0() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()() const
+	{
+		return (*_stub)(_object);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)()>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)()>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)()>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)()>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)() const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type>
+class Delegate1
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type);
+	typedef Delegate1<ret_type, arg1_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate1(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1)
+	{
+		return (F)(a1);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate1() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1) const
+	{
+		return (*_stub)(_object, a1);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type, class arg2_type>
+class Delegate2
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type, arg2_type);
+	typedef Delegate2<ret_type, arg1_type, arg2_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate2(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		return (F)(a1, a2);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1, arg2_type a2)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate2() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1, arg2_type a2) const
+	{
+		return (*_stub)(_object, a1, a2);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type, arg2_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+
+template <class ret_type, class arg1_type, class arg2_type, class arg3_type>
+class Delegate3
+{
+	typedef ret_type (*StubPointer)(void *, arg1_type, arg2_type, arg3_type);
+	typedef Delegate3<ret_type, arg1_type, arg2_type, arg3_type> this_type;
+
+	void *_object;
+	StubPointer _stub;
+
+	OVR_FORCE_INLINE Delegate3(void *object, StubPointer stub)
+	{
+		_object = object;
+		_stub = stub;
+	}
+
+	// Stubs
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE ret_type FreeStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		return (F)(a1, a2, a3);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE ret_type MemberStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2, a3);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	static OVR_FORCE_INLINE ret_type ConstMemberStub(void *object, arg1_type a1, arg2_type a2, arg3_type a3)
+	{
+		T *p = static_cast<T*>(object);
+		return (p->*F)(a1, a2, a3);
+	}
+
+public:
+	OVR_FORCE_INLINE Delegate3() {}
+
+	// Function invocation
+
+	OVR_FORCE_INLINE ret_type operator()(arg1_type a1, arg2_type a2, arg3_type a3) const
+	{
+		return (*_stub)(_object, a1, a2, a3);
+	}
+
+	// Use stub pointer as a validity flag and equality checker
+
+	OVR_FORCE_INLINE bool operator==(const this_type &rhs) const
+	{
+		return _object == rhs._object && _stub == rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool operator!=(const this_type &rhs) const
+	{
+		return _object != rhs._object || _stub != rhs._stub;
+	}
+
+	OVR_FORCE_INLINE bool IsValid() const
+	{
+		return _stub != 0;
+	}
+
+	OVR_FORCE_INLINE bool operator!() const
+	{
+		return _stub == 0;
+	}
+
+	OVR_FORCE_INLINE void Invalidate()
+	{
+		_stub = 0;
+	}
+
+	// Delegate creation from a function
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE this_type FromFree()
+	{
+		return this_type(0, &FreeStub<F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	static OVR_FORCE_INLINE this_type FromMember(T *object)
+	{
+		return this_type(object, &MemberStub<T, F>);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	static OVR_FORCE_INLINE this_type FromConstMember(T const *object)
+	{
+		return this_type(const_cast<T*>( object ), &ConstMemberStub<T, F>);
+	}
+
+	// In-place assignment to a different function
+
+	template <ret_type (*F)(arg1_type, arg2_type, arg3_type)>
+	OVR_FORCE_INLINE void SetFree()
+	{
+		*this = FromFree<F>();
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type)>
+	OVR_FORCE_INLINE void SetMember(T *object)
+	{
+		*this = FromMember<T, F>(object);
+	}
+
+	template <class T, ret_type (T::*F)(arg1_type, arg2_type, arg3_type) const>
+	OVR_FORCE_INLINE void SetConstMember(T const *object)
+	{
+		*this = FromConstMember<T, F>(object);
+	}
+};
+
+// Add more here if needed, but keep in mind that a short, simple interface
+// is rewarded by making the delegates faster...
+
+
+} // namespace OVR
+
+#endif // OVR_Delegates_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Deque.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Deque.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,316 @@
+/************************************************************************************
+
+Filename    :   OVR_Deque.h
+Content     :   Deque container
+Created     :   Nov. 15, 2013
+Authors     :   Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Deque_h
+#define OVR_Deque_h
+
+#include "OVR_ContainerAllocator.h"
+
+namespace OVR{ 
+
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class Deque
+{
+public:
+    enum
+    {
+        DefaultCapacity = 500
+    };
+
+    Deque(int capacity = DefaultCapacity);
+    virtual ~Deque(void);
+
+    virtual void         PushBack   (const Elem &Item);    // Adds Item to the end
+    virtual void         PushFront  (const Elem &Item);    // Adds Item to the beginning
+    virtual Elem         PopBack    (void);                // Removes Item from the end
+    virtual Elem         PopFront   (void);                // Removes Item from the beginning
+    virtual const Elem&  PeekBack   (int count = 0) const; // Returns count-th Item from the end
+    virtual const Elem&  PeekFront  (int count = 0) const; // Returns count-th Item from the beginning
+
+	virtual inline size_t GetSize    (void)          const; // Returns Number of Elements
+	OVR_FORCE_INLINE int GetSizeI   (void)          const
+	{
+		return (int)GetSize();
+	}
+    virtual inline size_t GetCapacity(void)          const; // Returns the maximum possible number of elements
+    virtual void         Clear      (void);				   // Remove all elements
+    virtual inline bool  IsEmpty    ()              const;
+    virtual inline bool  IsFull     ()              const;
+
+protected:
+    Elem        *Data;          // The actual Data array
+    const int   Capacity;       // Deque capacity
+    int         Beginning;      // Index of the first element
+    int         End;            // Index of the next after last element
+
+    // Instead of calculating the number of elements, using this variable
+    // is much more convenient.
+    int         ElemCount;
+
+private:
+    Deque&      operator= (const Deque& q) { }; // forbidden
+    Deque(const Deque<Elem, Allocator> &OtherDeque) { };
+};
+
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class InPlaceMutableDeque : public Deque<Elem, Allocator>
+{
+    typedef Deque<Elem, Allocator> BaseType;
+
+public:
+    InPlaceMutableDeque( int capacity = BaseType::DefaultCapacity ) : BaseType( capacity ) {}
+	virtual ~InPlaceMutableDeque() {};
+
+    using BaseType::PeekBack;
+    using BaseType::PeekFront;
+	virtual Elem& PeekBack  (int count = 0); // Returns count-th Item from the end
+	virtual Elem& PeekFront (int count = 0); // Returns count-th Item from the beginning
+};
+
+// Same as Deque, but allows to write more elements than maximum capacity
+// Old elements are lost as they are overwritten with the new ones
+template <class Elem, class Allocator = ContainerAllocator<Elem> >
+class CircularBuffer : public InPlaceMutableDeque<Elem, Allocator>
+{
+    typedef InPlaceMutableDeque<Elem, Allocator> BaseType;
+
+public:
+    CircularBuffer(int MaxSize = BaseType::DefaultCapacity) : BaseType(MaxSize) { };
+
+    // The following methods are inline as a workaround for a VS bug causing erroneous C4505 warnings
+    // See: http://stackoverflow.com/questions/3051992/compiler-warning-at-c-template-base-class
+    inline virtual void PushBack  (const Elem &Item);    // Adds Item to the end, overwriting the oldest element at the beginning if necessary
+    inline virtual void PushFront (const Elem &Item);    // Adds Item to the beginning, overwriting the oldest element at the end if necessary
+};
+
+//----------------------------------------------------------------------------------
+
+// Deque Constructor function
+template <class Elem, class Allocator>
+Deque<Elem, Allocator>::Deque(int capacity) :
+Capacity( capacity ), Beginning(0), End(0), ElemCount(0)
+{
+    Data = (Elem*) Allocator::Alloc(Capacity * sizeof(Elem));
+}
+
+// Deque Destructor function
+template <class Elem, class Allocator>
+Deque<Elem, Allocator>::~Deque(void)
+{
+    Clear();
+    Allocator::Free(Data);
+}
+
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::Clear()
+{
+    if (!IsEmpty())
+    {
+        if (Beginning < End)
+        {
+            // no wrap-around
+            Allocator::DestructArray(Data + Beginning, End - Beginning);
+        }
+        else
+        {
+            // wrap-around
+            Allocator::DestructArray(Data + Beginning, Capacity - Beginning);
+            Allocator::DestructArray(Data, End);
+        }
+    }
+    
+    Beginning = 0;
+    End       = 0;
+    ElemCount = 0;
+}
+
+// Push functions
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::PushBack(const Elem &Item)
+{
+    // Error Check: Make sure we aren't  
+    // exceeding our maximum storage space
+    OVR_ASSERT( ElemCount < Capacity );
+
+    Allocator::Construct(Data + End, Item);
+    ++End;
+    ++ElemCount;
+
+    // Check for wrap-around
+    if (End >= Capacity)
+        End -= Capacity;
+}
+
+template <class Elem, class Allocator>
+void Deque<Elem, Allocator>::PushFront(const Elem &Item)
+{
+    // Error Check: Make sure we aren't  
+    // exceeding our maximum storage space
+    OVR_ASSERT( ElemCount < Capacity );
+
+    --Beginning;
+    // Check for wrap-around
+    if (Beginning < 0)
+        Beginning += Capacity;
+
+    Allocator::Construct(Data + Beginning, Item);
+    ++ElemCount;
+}
+
+// Pop functions
+template <class Elem, class Allocator>
+Elem Deque<Elem, Allocator>::PopFront(void)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > 0 );
+
+	Elem ReturnValue = Data[ Beginning ];
+    Allocator::Destruct(Data + Beginning);
+
+	++Beginning;
+    --ElemCount;
+
+    // Check for wrap-around
+    if (Beginning >= Capacity)
+        Beginning -= Capacity;
+
+    return ReturnValue;
+}
+
+template <class Elem, class Allocator>
+Elem Deque<Elem, Allocator>::PopBack(void)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > 0 );
+
+    --End;
+    --ElemCount;
+
+    // Check for wrap-around
+    if (End < 0)
+        End += Capacity;
+
+    Elem ReturnValue = Data[ End ];
+    Allocator::Destruct(Data + End);
+
+    return ReturnValue;
+}
+
+// Peek functions
+template <class Elem, class Allocator>
+const Elem& Deque<Elem, Allocator>::PeekFront(int count) const
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > count );
+
+    int idx = Beginning + count;
+    if (idx >= Capacity)
+        idx -= Capacity;
+    return Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+const Elem& Deque<Elem, Allocator>::PeekBack(int count) const
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( ElemCount > count );
+
+    int idx = End - count - 1;
+    if (idx < 0)
+        idx += Capacity;
+    return Data[ idx ];
+}
+
+// Mutable Peek functions
+template <class Elem, class Allocator>
+Elem& InPlaceMutableDeque<Elem, Allocator>::PeekFront(int count)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( BaseType::ElemCount > count );
+
+    int idx = BaseType::Beginning + count;
+    if (idx >= BaseType::Capacity)
+        idx -= BaseType::Capacity;
+    return BaseType::Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+Elem& InPlaceMutableDeque<Elem, Allocator>::PeekBack(int count)
+{
+    // Error Check: Make sure we aren't reading from an empty Deque
+    OVR_ASSERT( BaseType::ElemCount > count );
+
+    int idx = BaseType::End - count - 1;
+    if (idx < 0)
+        idx += BaseType::Capacity;
+    return BaseType::Data[ idx ];
+}
+
+template <class Elem, class Allocator>
+inline size_t Deque<Elem, Allocator>::GetCapacity(void) const
+{
+    return Capacity;
+}
+
+template <class Elem, class Allocator>
+inline size_t Deque<Elem, Allocator>::GetSize(void) const
+{
+    return ElemCount;
+}
+
+template <class Elem, class Allocator>
+inline bool Deque<Elem, Allocator>::IsEmpty(void) const
+{
+    return ElemCount == 0;
+}
+
+template <class Elem, class Allocator>
+inline bool Deque<Elem, Allocator>::IsFull(void) const
+{
+    return ElemCount == Capacity;
+}
+
+// ******* CircularBuffer<Elem> *******
+// Push functions
+template <class Elem, class Allocator>
+void CircularBuffer<Elem, Allocator>::PushBack(const Elem &Item)
+{
+    if (this->IsFull())
+        this->PopFront();
+    BaseType::PushBack(Item);
+}
+
+template <class Elem, class Allocator>
+void CircularBuffer<Elem, Allocator>::PushFront(const Elem &Item)
+{
+    if (this->IsFull())
+        this->PopBack();
+    BaseType::PushFront(Item);
+}
+
+};   
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_File.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,529 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_File.h
+Content     :   Header for all internal file management - functions and structures
+                to be inherited by OS specific subclasses.
+Created     :   September 19, 2012
+Notes       : 
+
+Notes       :   errno may not be preserved across use of BaseFile member functions
+            :   Directories cannot be deleted while files opened from them are in use
+                (For the GetFullName function)
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_File_h
+#define OVR_File_h
+
+#include "OVR_RefCount.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+#include <stdio.h>
+#include "OVR_String.h"
+
+namespace OVR {
+
+// ***** Declared classes
+class   FileConstants;
+class   File;
+class   DelegatedFile;
+class   BufferedFile;
+
+
+// ***** Flags for File & Directory accesses
+
+class FileConstants
+{
+public:
+
+    // *** File open flags
+    enum OpenFlags
+    {
+        Open_Read       = 1,
+        Open_Write      = 2,
+        Open_ReadWrite  = 3,
+
+        // Opens file and truncates it to zero length
+        // - file must have write permission
+        // - when used with Create, it opens an existing 
+        //   file and empties it or creates a new file
+        Open_Truncate   = 4,
+
+        // Creates and opens new file 
+        // - does not erase contents if file already
+        //   exists unless combined with Truncate
+        Open_Create     = 8,
+
+         // Returns an error value if the file already exists
+        Open_CreateOnly = 24,
+
+        // Open file with buffering
+        Open_Buffered    = 32
+    };
+
+    // *** File Mode flags
+    enum Modes
+    {
+        Mode_Read       = 0444,
+        Mode_Write      = 0222,
+        Mode_Execute    = 0111,
+
+        Mode_ReadWrite  = 0666
+    };
+
+    // *** Seek operations
+    enum SeekOps
+    {
+        Seek_Set        = 0,
+        Seek_Cur        = 1,
+        Seek_End        = 2
+    };
+
+    // *** Errors
+    enum Errors
+    {
+        Error_FileNotFound  = 0x1001,
+        Error_Access        = 0x1002,
+        Error_IOError       = 0x1003,
+        Error_DiskFull      = 0x1004
+    };
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** File Class
+
+// The pure virtual base random-access file
+// This is a base class to all files
+
+class File : public RefCountBase<File>, public FileConstants
+{   
+public:
+    File() { }
+    // ** Location Information
+
+    // Returns a file name path relative to the 'reference' directory
+    // This is often a path that was used to create a file
+    // (this is not a global path, global path can be obtained with help of directory)
+    virtual const char* GetFilePath() = 0;
+                                                                                        
+
+    // ** File Information
+
+    // Return 1 if file's usable (open)
+    virtual bool        IsValid() = 0;
+    // Return 1 if file's writable, otherwise 0                                         
+    virtual bool        IsWritable() = 0;
+                                                                                        
+    // Return position
+    virtual int         Tell() = 0;
+    virtual int64_t     LTell() = 0;
+    
+    // File size                                                                        
+    virtual int         GetLength() = 0;
+    virtual int64_t     LGetLength() = 0;
+                                                                                        
+    // Returns file stats                                                               
+    // 0 for failure                                                                    
+    //virtual bool      Stat(FileStats *pfs) = 0;
+                                                                                        
+    // Return errno-based error code                                                    
+    // Useful if any other function failed                                              
+    virtual int         GetErrorCode() = 0;
+                                                                                        
+                                                                                        
+    // ** Stream implementation & I/O
+
+    // Blocking write, will write in the given number of bytes to the stream
+    // Returns : -1 for error
+    //           Otherwise number of bytes read 
+    virtual int         Write(const uint8_t *pbufer, int numBytes) = 0;
+    // Blocking read, will read in the given number of bytes or less from the stream
+    // Returns : -1 for error
+    //           Otherwise number of bytes read,
+    //           if 0 or < numBytes, no more bytes available; end of file or the other side of stream is closed
+    virtual int         Read(uint8_t *pbufer, int numBytes) = 0;
+
+    // Skips (ignores) a given # of bytes
+    // Same return values as Read
+    virtual int         SkipBytes(int numBytes) = 0;
+        
+    // Returns the number of bytes available to read from a stream without blocking
+    // For a file, this should generally be number of bytes to the end
+    virtual int         BytesAvailable() = 0;
+
+    // Causes any implementation's buffered data to be delivered to destination
+    // Return 0 for error
+    virtual bool        Flush() = 0;
+                                                                                            
+
+    // Need to provide a more optimized implementation that doe snot necessarily involve a lot of seeking
+    inline bool         IsEOF() { return !BytesAvailable(); }
+    
+
+    // Seeking                                                                              
+    // Returns new position, -1 for error                                                   
+    virtual int         Seek(int offset, int origin=Seek_Set) = 0;
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set) = 0;
+    // Seek simplification
+    int                 SeekToBegin()           {return Seek(0); }
+    int                 SeekToEnd()             {return Seek(0,Seek_End); }
+    int                 Skip(int numBytes)     {return Seek(numBytes,Seek_Cur); }
+                        
+
+    // Appends other file data from a stream
+    // Return -1 for error, else # of bytes written
+    virtual int         CopyFromStream(File *pstream, int byteSize) = 0;
+
+    // Closes the file
+    // After close, file cannot be accessed 
+    virtual bool        Close() = 0;
+
+
+    // ***** Inlines for convenient primitive type serialization
+
+    // Read/Write helpers
+private:
+    uint64_t  PRead64()           { uint64_t v = 0; Read((uint8_t*)&v, 8); return v; }
+    uint32_t  PRead32()           { uint32_t v = 0; Read((uint8_t*)&v, 4); return v; }
+    uint16_t  PRead16()           { uint16_t v = 0; Read((uint8_t*)&v, 2); return v; }
+    uint8_t PRead8()            { uint8_t  v = 0; Read((uint8_t*)&v, 1); return v; }
+    void    PWrite64(uint64_t v)  { Write((uint8_t*)&v, 8); }
+    void    PWrite32(uint32_t v)  { Write((uint8_t*)&v, 4); }
+    void    PWrite16(uint16_t v)  { Write((uint8_t*)&v, 2); }
+    void    PWrite8(uint8_t v)  { Write((uint8_t*)&v, 1); }
+
+public:
+
+    // Writing primitive types - Little Endian
+    inline void    WriteUByte(uint8_t v)       { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteSByte(int8_t v)        { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteUInt8(uint8_t v)       { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteSInt8(int8_t v)        { PWrite8((uint8_t)Alg::ByteUtil::SystemToLE(v));     }
+    inline void    WriteUInt16(uint16_t v)       { PWrite16((uint16_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt16(int16_t v)       { PWrite16((uint16_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteUInt32(uint32_t v)       { PWrite32((uint32_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt32(int32_t v)       { PWrite32((uint32_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteUInt64(uint64_t v)       { PWrite64((uint64_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteSInt64(int64_t v)       { PWrite64((uint64_t)Alg::ByteUtil::SystemToLE(v));   }
+    inline void    WriteFloat(float v)         { v = Alg::ByteUtil::SystemToLE(v); Write((uint8_t*)&v, 4); } 
+    inline void    WriteDouble(double v)       { v = Alg::ByteUtil::SystemToLE(v); Write((uint8_t*)&v, 8); }
+    // Writing primitive types - Big Endian
+    inline void    WriteUByteBE(uint8_t v)     { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteSByteBE(int8_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteUInt8BE(uint16_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteSInt8BE(int16_t v)      { PWrite8((uint8_t)Alg::ByteUtil::SystemToBE(v));     }
+    inline void    WriteUInt16BE(uint16_t v)     { PWrite16((uint16_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt16BE(uint16_t v)     { PWrite16((uint16_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteUInt32BE(uint32_t v)     { PWrite32((uint32_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt32BE(uint32_t v)     { PWrite32((uint32_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteUInt64BE(uint64_t v)     { PWrite64((uint64_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteSInt64BE(uint64_t v)     { PWrite64((uint64_t)Alg::ByteUtil::SystemToBE(v));   }
+    inline void    WriteFloatBE(float v)       { v = Alg::ByteUtil::SystemToBE(v); Write((uint8_t*)&v, 4); }
+    inline void    WriteDoubleBE(double v)     { v = Alg::ByteUtil::SystemToBE(v); Write((uint8_t*)&v, 8); }
+        
+    // Reading primitive types - Little Endian
+    inline uint8_t ReadUByte()                 { return (uint8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline int8_t  ReadSByte()                 { return (int8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline uint8_t ReadUInt8()                 { return (uint8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline int8_t  ReadSInt8()                 { return (int8_t)Alg::ByteUtil::LEToSystem(PRead8());    }
+    inline uint16_t  ReadUInt16()                { return (uint16_t)Alg::ByteUtil::LEToSystem(PRead16());  }
+    inline int16_t ReadSInt16()                { return (int16_t)Alg::ByteUtil::LEToSystem(PRead16());  }
+    inline uint32_t  ReadUInt32()                { return (uint32_t)Alg::ByteUtil::LEToSystem(PRead32());  }
+    inline int32_t ReadSInt32()                { return (int32_t)Alg::ByteUtil::LEToSystem(PRead32());  }
+    inline uint64_t  ReadUInt64()                { return (uint64_t)Alg::ByteUtil::LEToSystem(PRead64());  }
+    inline int64_t ReadSInt64()                { return (int64_t)Alg::ByteUtil::LEToSystem(PRead64());  }
+    inline float   ReadFloat()                 { float v = 0.0f; Read((uint8_t*)&v, 4); return Alg::ByteUtil::LEToSystem(v); }
+    inline double  ReadDouble()                { double v = 0.0; Read((uint8_t*)&v, 8); return Alg::ByteUtil::LEToSystem(v); }
+    // Reading primitive types - Big Endian
+    inline uint8_t ReadUByteBE()               { return (uint8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline int8_t  ReadSByteBE()               { return (int8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline uint8_t ReadUInt8BE()               { return (uint8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline int8_t  ReadSInt8BE()               { return (int8_t)Alg::ByteUtil::BEToSystem(PRead8());    }
+    inline uint16_t  ReadUInt16BE()              { return (uint16_t)Alg::ByteUtil::BEToSystem(PRead16());  }
+    inline int16_t ReadSInt16BE()              { return (int16_t)Alg::ByteUtil::BEToSystem(PRead16());  }
+    inline uint32_t  ReadUInt32BE()              { return (uint32_t)Alg::ByteUtil::BEToSystem(PRead32());  }
+    inline int32_t ReadSInt32BE()              { return (int32_t)Alg::ByteUtil::BEToSystem(PRead32());  }
+    inline uint64_t  ReadUInt64BE()              { return (uint64_t)Alg::ByteUtil::BEToSystem(PRead64());  }
+    inline int64_t ReadSInt64BE()              { return (int64_t)Alg::ByteUtil::BEToSystem(PRead64());  }
+    inline float   ReadFloatBE()               { float v = 0.0f; Read((uint8_t*)&v, 4); return Alg::ByteUtil::BEToSystem(v); }
+    inline double  ReadDoubleBE()              { double v = 0.0; Read((uint8_t*)&v, 8); return Alg::ByteUtil::BEToSystem(v); }
+};
+
+
+// *** Delegated File
+
+class DelegatedFile : public File
+{
+protected:
+    // Delegating file pointer
+    Ptr<File>     pFile;
+
+    // Hidden default constructor
+    DelegatedFile() : pFile(0)                             { }
+    DelegatedFile(const DelegatedFile &source) : File()    { OVR_UNUSED(source); }
+public:
+    // Constructors
+    DelegatedFile(File *pfile) : pFile(pfile)     { }
+
+    // ** Location Information  
+    virtual const char* GetFilePath()                               { return pFile->GetFilePath(); }    
+
+    // ** File Information                                                      
+    virtual bool        IsValid()                                   { return pFile && pFile->IsValid(); }   
+    virtual bool        IsWritable()                                { return pFile->IsWritable(); }
+//  virtual bool        IsRecoverable()                             { return pFile->IsRecoverable(); }          
+                                                                    
+    virtual int         Tell()                                      { return pFile->Tell(); }
+    virtual int64_t     LTell()                                     { return pFile->LTell(); }
+    
+    virtual int         GetLength()                                 { return pFile->GetLength(); }
+    virtual int64_t     LGetLength()                                { return pFile->LGetLength(); }
+    
+    //virtual bool      Stat(FileStats *pfs)                        { return pFile->Stat(pfs); }
+    
+    virtual int         GetErrorCode()                              { return pFile->GetErrorCode(); }
+    
+    // ** Stream implementation & I/O
+    virtual int         Write(const uint8_t *pbuffer, int numBytes)   { return pFile->Write(pbuffer,numBytes); }  
+    virtual int         Read(uint8_t *pbuffer, int numBytes)          { return pFile->Read(pbuffer,numBytes); }   
+    
+    virtual int         SkipBytes(int numBytes)                     { return pFile->SkipBytes(numBytes); }      
+    
+    virtual int         BytesAvailable()                            { return pFile->BytesAvailable(); } 
+    
+    virtual bool        Flush()                                     { return pFile->Flush(); }
+                                                                    
+    // Seeking                                                      
+    virtual int         Seek(int offset, int origin=Seek_Set)       { return pFile->Seek(offset,origin); }
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set)   { return pFile->LSeek(offset,origin); }
+
+    virtual int         CopyFromStream(File *pstream, int byteSize) { return pFile->CopyFromStream(pstream,byteSize); }
+                        
+    // Closing the file 
+    virtual bool        Close()                                     { return pFile->Close(); }    
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Buffered File
+
+// This file class adds buffering to an existing file
+// Buffered file never fails by itself; if there's not
+// enough memory for buffer, no buffer's used
+
+class BufferedFile : public DelegatedFile
+{   
+protected:  
+    enum BufferModeType
+    {
+        NoBuffer,
+        ReadBuffer,
+        WriteBuffer
+    };
+
+    // Buffer & the mode it's in
+    uint8_t*          pBuffer;
+    BufferModeType  BufferMode;
+    // Position in buffer
+    unsigned        Pos;
+    // Data in buffer if reading
+    unsigned        DataSize;
+    // Underlying file position 
+    uint64_t        FilePos;
+
+    // Initializes buffering to a certain mode
+    bool    SetBufferMode(BufferModeType mode);
+    // Flushes buffer
+    // WriteBuffer - write data to disk, ReadBuffer - reset buffer & fix file position  
+    void    FlushBuffer();
+    // Loads data into ReadBuffer
+    // WARNING: Right now LoadBuffer() assumes the buffer's empty
+    void    LoadBuffer();
+
+    // Hidden constructor
+    BufferedFile();
+    inline BufferedFile(const BufferedFile &source) : DelegatedFile() { OVR_UNUSED(source); }
+public:
+
+    // Constructor
+    // - takes another file as source
+    BufferedFile(File *pfile);
+    ~BufferedFile();
+    
+    
+    // ** Overridden functions
+
+    // We override all the functions that can possibly
+    // require buffer mode switch, flush, or extra calculations
+    virtual int         Tell();
+    virtual int64_t     LTell();
+
+    virtual int         GetLength();
+    virtual int64_t     LGetLength();
+
+//  virtual bool        Stat(GFileStats *pfs);  
+
+    virtual int         Write(const uint8_t *pbufer, int numBytes);
+    virtual int         Read(uint8_t *pbufer, int numBytes);
+
+    virtual int         SkipBytes(int numBytes);
+
+    virtual int         BytesAvailable();
+
+    virtual bool        Flush();
+
+    virtual int         Seek(int offset, int origin=Seek_Set);
+    virtual int64_t     LSeek(int64_t offset, int origin=Seek_Set);
+
+    virtual int         CopyFromStream(File *pstream, int byteSize);
+    
+    virtual bool        Close();    
+};                          
+
+
+//-----------------------------------------------------------------------------------
+// ***** Memory File
+
+class MemoryFile : public File
+{
+public:
+
+    const char* GetFilePath()       { return FilePath.ToCStr(); }
+
+    bool        IsValid()           { return Valid; }
+    bool        IsWritable()        { return false; }
+
+    bool        Flush()             { return true; }
+    int         GetErrorCode()      { return 0; }
+
+    int         Tell()              { return FileIndex; }
+    int64_t     LTell()             { return (int64_t) FileIndex; }
+
+    int         GetLength()         { return FileSize; }
+    int64_t     LGetLength()        { return (int64_t) FileSize; }
+
+    bool        Close()
+    {
+        Valid = false;
+        return false;
+    }
+
+    int         CopyFromStream(File *pstream, int byteSize)
+    {   OVR_UNUSED2(pstream, byteSize);
+        return 0;
+    }
+
+    int         Write(const uint8_t *pbuffer, int numBytes)
+    {   OVR_UNUSED2(pbuffer, numBytes);
+        return 0;
+    }
+
+    int         Read(uint8_t *pbufer, int numBytes)
+    {
+        if (FileIndex + numBytes > FileSize)
+        {
+            numBytes = FileSize - FileIndex;
+        }
+
+        if (numBytes > 0)
+        {
+            ::memcpy (pbufer, &FileData [FileIndex], numBytes);
+
+            FileIndex += numBytes;
+        }
+
+        return numBytes;
+    }
+
+    int         SkipBytes(int numBytes)
+    {
+        if (FileIndex + numBytes > FileSize)
+        {
+            numBytes = FileSize - FileIndex;
+        }
+
+        FileIndex += numBytes;
+
+        return numBytes;
+    }
+
+    int         BytesAvailable()
+    {
+        return (FileSize - FileIndex);
+    }
+
+    int         Seek(int offset, int origin = Seek_Set)
+    {
+        switch (origin)
+        {
+        case Seek_Set : FileIndex  = offset;               break;
+        case Seek_Cur : FileIndex += offset;               break;
+        case Seek_End : FileIndex  = FileSize - offset;  break;
+        }
+
+        return FileIndex;
+    }
+
+    int64_t     LSeek(int64_t offset, int origin = Seek_Set)
+    {
+        return (int64_t) Seek((int) offset, origin);
+    }
+
+public:
+
+    MemoryFile (const String& fileName, const uint8_t *pBuffer, int buffSize)
+        : FilePath(fileName)
+    {
+        FileData  = pBuffer;
+        FileSize  = buffSize;
+        FileIndex = 0;
+        Valid     = (!fileName.IsEmpty() && pBuffer && buffSize > 0) ? true : false;
+    }
+
+    // pfileName should be encoded as UTF-8 to support international file names.
+    MemoryFile (const char* pfileName, const uint8_t *pBuffer, int buffSize)
+        : FilePath(pfileName)
+    {
+        FileData  = pBuffer;
+        FileSize  = buffSize;
+        FileIndex = 0;
+        Valid     = (pfileName && pBuffer && buffSize > 0) ? true : false;
+    }
+private:
+
+    String       FilePath;
+    const uint8_t *FileData;
+    int          FileSize;
+    int          FileIndex;
+    bool         Valid;
+};
+
+
+// ***** Global path helpers
+
+// Find trailing short filename in a path.
+const char* OVR_CDECL GetShortFilename(const char* purl);
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Hash.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Hash.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,1304 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Hash.h
+Content     :   Template hash-table/set implementation
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Hash_h
+#define OVR_Hash_h
+
+#include "OVR_ContainerAllocator.h"
+#include "OVR_Alg.h"
+
+// 'new' operator is redefined/used in this file.
+#undef new
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Hash Table Implementation
+
+// HastSet and Hash.
+//
+// Hash table, linear probing, internal chaining.  One  interesting/nice thing
+// about this implementation is that the table itself is a flat chunk of memory
+// containing no pointers, only relative indices. If the key and value types
+// of the Hash contain no pointers, then the Hash can be serialized using raw IO.
+//
+// Never shrinks, unless you explicitly Clear() it.  Expands on
+// demand, though.  For best results, if you know roughly how big your
+// table will be, default it to that size when you create it.
+//
+// Key usability feature:
+//
+//   1. Allows node hash values to either be cached or not.
+//
+//   2. Allows for alternative keys with methods such as GetAlt(). Handy
+//      if you need to search nodes by their components; no need to create
+//      temporary nodes.
+//
+
+
+// *** Hash functors:
+//
+//  IdentityHash  - use when the key is already a good hash
+//  HFixedSizeHash - general hash based on object's in-memory representation.
+
+
+// Hash is just the input value; can use this for integer-indexed hash tables.
+template<class C>
+class IdentityHash
+{
+public:
+    size_t operator()(const C& data) const
+    { return (size_t) data; }
+};
+
+// Computes a hash of an object's representation.
+template<class C>
+class FixedSizeHash
+{
+public:
+    // Alternative: "sdbm" hash function, suggested at same web page
+    // above, http::/www.cs.yorku.ca/~oz/hash.html
+    // This is somewhat slower then Bernstein, but it works way better than the above
+    // hash function for hashing large numbers of 32-bit ints.
+    static OVR_FORCE_INLINE size_t SDBM_Hash(const void* data_in, size_t size, size_t seed = 5381)     
+    {
+        const uint8_t* data = (const uint8_t*) data_in;
+        size_t       h = seed;
+        while (size > 0)
+        {
+            size--;
+            h = (h << 16) + (h << 6) - h + (size_t)data[size];
+        }   
+        return h;
+    }
+
+    size_t operator()(const C& data) const
+    {
+        unsigned char*  p = (unsigned char*) &data;
+        int size = sizeof(C);
+
+        return SDBM_Hash(p, size);
+    }
+};
+
+
+
+// *** HashsetEntry Entry types. 
+
+// Compact hash table Entry type that re-computes hash keys during hash traversal.
+// Good to use if the hash function is cheap or the hash value is already cached in C.
+template<class C, class HashF>
+class HashsetEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t    NextInChain;
+    C           Value;
+
+    HashsetEntry()
+        : NextInChain(-2) { }
+    HashsetEntry(const HashsetEntry& e)
+        : NextInChain(e.NextInChain), Value(e.Value) { }
+    HashsetEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+
+    bool    IsEmpty() const          { return NextInChain == -2;  }
+    bool    IsEndOfChain() const     { return NextInChain == -1;  }
+
+    // Cached hash value access - can be optimized bu storing hash locally.
+    // Mask value only needs to be used if SetCachedHash is not implemented.
+    size_t  GetCachedHash(size_t maskValue) const  { return HashF()(Value) & maskValue; }
+    void    SetCachedHash(size_t)                  {}
+
+    void    Clear()
+    {        
+        Value.~C(); // placement delete
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+// Hash table Entry type that caches the Entry hash value for nodes, so that it
+// does not need to be re-computed during access.
+template<class C, class HashF>
+class HashsetCachedEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t    NextInChain;
+    size_t      HashValue;
+    C           Value;
+
+    HashsetCachedEntry()
+        : NextInChain(-2) { }
+    HashsetCachedEntry(const HashsetCachedEntry& e)
+        : NextInChain(e.NextInChain), HashValue(e.HashValue), Value(e.Value) { }
+    HashsetCachedEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+
+    bool    IsEmpty() const          { return NextInChain == -2;  }
+    bool    IsEndOfChain() const     { return NextInChain == -1;  }
+
+    // Cached hash value access - can be optimized bu storing hash locally.
+    // Mask value only needs to be used if SetCachedHash is not implemented.
+    size_t  GetCachedHash(size_t maskValue) const  { OVR_UNUSED(maskValue); return HashValue; }
+    void    SetCachedHash(size_t hashValue)        { HashValue = hashValue; }
+
+    void    Clear()
+    {
+        Value.~C();
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+
+//-----------------------------------------------------------------------------------
+// *** HashSet implementation - relies on either cached or regular entries.
+//
+// Use: Entry = HashsetCachedEntry<C, HashF> if hashes are expensive to
+//              compute and thus need caching in entries.
+//      Entry = HashsetEntry<C, HashF> if hashes are already externally cached.
+//
+template<class C, class HashF = FixedSizeHash<C>,
+         class AltHashF = HashF, 
+         class Allocator = ContainerAllocator<C>,
+         class Entry = HashsetCachedEntry<C, HashF> >
+class HashSetBase
+{
+    enum { HashMinSize = 8 };
+
+public:
+    OVR_MEMORY_REDEFINE_NEW(HashSetBase)
+
+    typedef HashSetBase<C, HashF, AltHashF, Allocator, Entry>    SelfType;
+
+    HashSetBase() : pTable(NULL)                       {   }
+    HashSetBase(int sizeHint) : pTable(NULL)           { SetCapacity(this, sizeHint);  }
+    HashSetBase(const SelfType& src) : pTable(NULL)    { Assign(this, src); }
+
+    ~HashSetBase()                                     
+    { 
+        if (pTable)
+        {
+            // Delete the entries.
+            for (size_t i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (!e->IsEmpty())             
+                    e->Free();
+            }            
+
+            Allocator::Free(pTable);
+            pTable = NULL;
+        }
+    }
+
+
+    void Assign(const SelfType& src)
+    {
+        Clear();
+        if (src.IsEmpty() == false)
+        {
+            SetCapacity(src.GetSize());
+
+            for (ConstIterator it = src.Begin(); it != src.End(); ++it)
+            {
+                Add(*it);
+            }
+        }
+    }
+
+
+    // Remove all entries from the HashSet table.
+    void Clear() 
+    {
+        if (pTable)
+        {
+            // Delete the entries.
+            for (size_t i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (!e->IsEmpty())             
+                    e->Clear();
+            }            
+                
+            Allocator::Free(pTable);
+            pTable = NULL;
+        }
+    }
+
+    // Returns true if the HashSet is empty.
+    bool IsEmpty() const
+    {
+        return pTable == NULL || pTable->EntryCount == 0;
+    }
+
+
+    // Set a new or existing value under the key, to the value.
+    // Pass a different class of 'key' so that assignment reference object
+    // can be passed instead of the actual object.
+    template<class CRef>
+    void Set(const CRef& key)
+    {
+        size_t hashValue = HashF()(key);
+        intptr_t  index     = (intptr_t)-1;
+
+        if (pTable != NULL)
+            index = findIndexCore(key, hashValue & pTable->SizeMask);
+
+        if (index >= 0)
+        {            
+            E(index).Value = key;
+        }
+        else
+        {
+            // Entry under key doesn't exist.
+            add(key, hashValue);
+        }
+    }
+
+    template<class CRef>
+    inline void Add(const CRef& key)
+    {
+        size_t hashValue = HashF()(key);
+        add(key, hashValue);
+    }
+
+    // Remove by alternative key.
+    template<class K>
+    void RemoveAlt(const K& key)
+    {   
+        if (pTable == NULL)
+            return;
+
+        size_t   hashValue = AltHashF()(key);
+        intptr_t index     = hashValue & pTable->SizeMask;
+
+        Entry*  e = &E(index);
+
+        // If empty node or occupied by collider, we have nothing to remove.
+        if (e->IsEmpty() || (e->GetCachedHash(pTable->SizeMask) != (size_t)index))
+            return;        
+
+        // Save index
+        intptr_t naturalIndex = index;
+        intptr_t prevIndex    = -1;
+
+        while ((e->GetCachedHash(pTable->SizeMask) != (size_t)naturalIndex) || !(e->Value == key))
+        {
+            // Keep looking through the chain.
+            prevIndex   = index;
+            index       = e->NextInChain;
+            if (index == -1)
+                return; // End of chain, item not found
+            e = &E(index);
+        }
+
+        // Found it - our item is at index
+        if (naturalIndex == index)
+        {
+            // If we have a follower, move it to us
+            if (!e->IsEndOfChain())
+            {               
+                Entry*  enext = &E(e->NextInChain);
+                e->Clear();
+                new (e) Entry(*enext);
+                // Point us to the follower's cell that will be cleared
+                e = enext;
+            }
+        }
+        else
+        {
+            // We are not at natural index, so deal with the prev items next index
+            E(prevIndex).NextInChain = e->NextInChain;
+        }
+
+        // Clear us, of the follower cell that was moved.
+        e->Clear();
+        pTable->EntryCount --;
+        // Should we check the size to condense hash? ...
+    }
+
+    // Remove by main key.
+    template<class CRef>
+    void Remove(const CRef& key)
+    {
+        RemoveAlt(key);
+    }
+
+    // Retrieve the pointer to a value under the given key.
+    //  - If there's no value under the key, then return NULL.    
+    //  - If there is a value, return the pointer.    
+    template<class K>
+    C* Get(const K& key)
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return &E(index).Value;        
+        return 0;
+    }   
+
+    template<class K>
+    const C* Get(const K& key) const
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return &E(index).Value;        
+        return 0;
+    }
+
+    // Alternative key versions of Get. Used by Hash.
+    template<class K>
+    const C* GetAlt(const K& key) const
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return &E(index).Value;
+        return 0;
+    }
+
+    template<class K>
+    C* GetAlt(const K& key)
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return &E(index).Value;
+        return 0;
+    }   
+
+    template<class K>
+    bool GetAlt(const K& key, C* pval) const
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)
+        {
+            if (pval)
+                *pval = E(index).Value;
+            return true;
+        }
+        return false;
+    }
+
+
+    size_t GetSize() const
+    {
+        return pTable == NULL ? 0 : (size_t)pTable->EntryCount;
+    }
+	int GetSizeI() const { return (int)GetSize(); }
+
+
+    // Resize the HashSet table to fit one more Entry.  Often this
+    // doesn't involve any action.
+    void CheckExpand()
+    {
+        if (pTable == NULL)
+        {
+            // Initial creation of table.  Make a minimum-sized table.
+            setRawCapacity(HashMinSize);
+        }
+        else if (pTable->EntryCount * 5 > (pTable->SizeMask + 1) * 4)
+        {
+            // pTable is more than 5/4 ths full.  Expand.
+            setRawCapacity((pTable->SizeMask + 1) * 2);
+        }
+    }
+
+    // Hint the bucket count to >= n.
+    void Resize(size_t n)    
+    {
+        // Not really sure what this means in relation to
+        // STLport's hash_map... they say they "increase the
+        // bucket count to at least n" -- but does that mean
+        // their real capacity after Resize(n) is more like
+        // n*2 (since they do linked-list chaining within
+        // buckets?).
+        SetCapacity(n);
+    }
+
+    // Size the HashSet so that it can comfortably contain the given
+    // number of elements.  If the HashSet already contains more
+    // elements than newSize, then this may be a no-op.
+    void SetCapacity(size_t newSize)
+    {
+        size_t newRawSize = (newSize * 5) / 4;
+        if (newRawSize <= GetSize())
+            return;
+        setRawCapacity(newRawSize);
+    }
+
+    // Disable inappropriate 'operator ->' warning on MSVC6.
+#ifdef OVR_CC_MSVC
+#if (OVR_CC_MSVC < 1300)
+# pragma warning(disable : 4284)
+#endif
+#endif
+
+    // Iterator API, like STL.
+    struct ConstIterator
+    {   
+        const C&    operator * () const
+        {            
+            OVR_ASSERT(Index >= 0 && Index <= (intptr_t)pHash->pTable->SizeMask);
+            return pHash->E(Index).Value;
+        }
+
+        const C*    operator -> () const
+        {
+            OVR_ASSERT(Index >= 0 && Index <= (intptr_t)pHash->pTable->SizeMask);
+            return &pHash->E(Index).Value;
+        }
+
+        void    operator ++ ()
+        {
+            // Find next non-empty Entry.
+            if (Index <= (intptr_t)pHash->pTable->SizeMask)
+            {
+                Index++;
+                while ((size_t)Index <= pHash->pTable->SizeMask &&
+                    pHash->E(Index).IsEmpty())
+                {
+                    Index++;
+                }
+            }
+        }
+
+        bool    operator == (const ConstIterator& it) const
+        {
+            if (IsEnd() && it.IsEnd())
+            {
+                return true;
+            }
+            else
+            {
+                return (pHash == it.pHash) && (Index == it.Index);
+            }
+        }
+
+        bool    operator != (const ConstIterator& it) const
+        {
+            return ! (*this == it);
+        }
+
+
+        bool    IsEnd() const
+        {
+            return (pHash == NULL) || 
+                (pHash->pTable == NULL) || 
+                (Index > (intptr_t)pHash->pTable->SizeMask);
+        }
+
+        ConstIterator()
+            : pHash(NULL), Index(0)
+        { }
+
+    public:
+        // Constructor was intentionally made public to allow create
+        // iterator with arbitrary index.
+        ConstIterator(const SelfType* h, intptr_t index)
+            : pHash(h), Index(index)
+        { }
+
+        const SelfType* GetContainer() const
+        {
+            return pHash;
+        }
+        intptr_t GetIndex() const
+        {
+            return Index;
+        }
+
+    protected:
+        friend class HashSetBase<C, HashF, AltHashF, Allocator, Entry>;
+
+        const SelfType* pHash;
+        intptr_t        Index;
+    };
+
+    friend struct ConstIterator;
+
+
+    // Non-const Iterator; Get most of it from ConstIterator.
+    struct Iterator : public ConstIterator
+    {      
+        // Allow non-const access to entries.
+        C&  operator*() const
+        {            
+            OVR_ASSERT(ConstIterator::Index >= 0 && ConstIterator::Index <= (intptr_t)ConstIterator::pHash->pTable->SizeMask);
+            return const_cast<SelfType*>(ConstIterator::pHash)->E(ConstIterator::Index).Value;
+        }    
+
+        C*  operator->() const 
+        {
+            return &(operator*());
+        }
+
+        Iterator()
+            : ConstIterator(NULL, 0)
+        { }
+
+        // Removes current element from Hash
+        void Remove()
+        {
+            RemoveAlt(operator*());
+        }
+
+        template <class K>
+        void RemoveAlt(const K& key)
+        {
+            SelfType*   phash = const_cast<SelfType*>(ConstIterator::pHash);
+            //Entry*      ee = &phash->E(ConstIterator::Index);
+            //const C&    key = ee->Value;
+
+            size_t      hashValue = AltHashF()(key);
+            intptr_t    index     = hashValue & phash->pTable->SizeMask;
+
+            Entry*      e = &phash->E(index);
+
+            // If empty node or occupied by collider, we have nothing to remove.
+            if (e->IsEmpty() || (e->GetCachedHash(phash->pTable->SizeMask) != (size_t)index))
+                return;        
+
+            // Save index
+            intptr_t   naturalIndex = index;
+            intptr_t   prevIndex    = -1;
+
+            while ((e->GetCachedHash(phash->pTable->SizeMask) != (size_t)naturalIndex) || !(e->Value == key))
+            {
+                // Keep looking through the chain.
+                prevIndex   = index;
+                index       = e->NextInChain;
+                if (index == -1)
+                    return; // End of chain, item not found
+                e = &phash->E(index);
+            }
+
+            if (index == (intptr_t)ConstIterator::Index)
+            {
+                // Found it - our item is at index
+                if (naturalIndex == index)
+                {
+                    // If we have a follower, move it to us
+                    if (!e->IsEndOfChain())
+                    {               
+                        Entry*  enext = &phash->E(e->NextInChain);
+                        e->Clear();
+                        new (e) Entry(*enext);
+                        // Point us to the follower's cell that will be cleared
+                        e = enext;
+                        --ConstIterator::Index;
+                    }
+                }
+                else
+                {
+                    // We are not at natural index, so deal with the prev items next index
+                    phash->E(prevIndex).NextInChain = e->NextInChain;
+                }
+
+                // Clear us, of the follower cell that was moved.
+                e->Clear();
+                phash->pTable->EntryCount --;
+            }
+            else 
+                OVR_ASSERT(0); //?
+        }
+
+    private:
+        friend class HashSetBase<C, HashF, AltHashF, Allocator, Entry>;
+
+        Iterator(SelfType* h, intptr_t i0)
+            : ConstIterator(h, i0)
+        { }
+    };
+
+    friend struct Iterator;
+
+    Iterator    Begin()
+    {
+        if (pTable == 0)
+            return Iterator(NULL, 0);
+
+        // Scan till we hit the First valid Entry.
+        size_t i0 = 0;
+        while (i0 <= pTable->SizeMask && E(i0).IsEmpty())
+        {
+            i0++;
+        }
+        return Iterator(this, i0);
+    }
+    Iterator        End()           { return Iterator(NULL, 0); }
+
+    ConstIterator   Begin() const   { return const_cast<SelfType*>(this)->Begin();     }
+    ConstIterator   End() const     { return const_cast<SelfType*>(this)->End();   }
+
+    template<class K>
+    Iterator Find(const K& key)
+    {
+        intptr_t index = findIndex(key);
+        if (index >= 0)        
+            return Iterator(this, index);        
+        return Iterator(NULL, 0);
+    }
+
+    template<class K>
+    Iterator FindAlt(const K& key)
+    {
+        intptr_t index = findIndexAlt(key);
+        if (index >= 0)        
+            return Iterator(this, index);        
+        return Iterator(NULL, 0);
+    }
+
+    template<class K>
+    ConstIterator Find(const K& key) const       { return const_cast<SelfType*>(this)->Find(key); }
+
+    template<class K>
+    ConstIterator FindAlt(const K& key) const    { return const_cast<SelfType*>(this)->FindAlt(key); }
+
+private:
+    // Find the index of the matching Entry.  If no match, then return -1.
+    template<class K>
+    intptr_t findIndex(const K& key) const
+    {
+        if (pTable == NULL)
+            return -1;
+        size_t hashValue = HashF()(key) & pTable->SizeMask;
+        return findIndexCore(key, hashValue);
+    }
+
+    template<class K>
+    intptr_t findIndexAlt(const K& key) const
+    {
+        if (pTable == NULL)
+            return -1;
+        size_t hashValue = AltHashF()(key) & pTable->SizeMask;
+        return findIndexCore(key, hashValue);
+    }
+
+    // Find the index of the matching Entry.  If no match, then return -1.
+    template<class K>
+    intptr_t findIndexCore(const K& key, size_t hashValue) const
+    {
+        // Table must exist.
+        OVR_ASSERT(pTable != 0);
+        // Hash key must be 'and-ed' by the caller.
+        OVR_ASSERT((hashValue & ~pTable->SizeMask) == 0);
+
+        size_t          index = hashValue;
+        const Entry*    e     = &E(index);
+
+        // If empty or occupied by a collider, not found.
+        if (e->IsEmpty() || (e->GetCachedHash(pTable->SizeMask) != index))
+            return -1;
+
+        while(1)
+        {
+            OVR_ASSERT(e->GetCachedHash(pTable->SizeMask) == hashValue);
+
+            if (e->GetCachedHash(pTable->SizeMask) == hashValue && e->Value == key)
+            {
+                // Found it.
+                return index;
+            }
+            // Values can not be equal at this point.
+            // That would mean that the hash key for the same value differs.
+            OVR_ASSERT(!(e->Value == key));
+
+            // Keep looking through the chain.
+            index = e->NextInChain;
+            if (index == (size_t)-1)
+                break; // end of chain
+
+            e = &E(index);
+            OVR_ASSERT(!e->IsEmpty());
+        }
+        return -1;
+    }
+
+
+    // Add a new value to the HashSet table, under the specified key.
+    template<class CRef>
+    void add(const CRef& key, size_t hashValue)
+    {
+        CheckExpand();
+        hashValue &= pTable->SizeMask;
+
+        pTable->EntryCount++;
+
+        intptr_t   index        = hashValue;
+        Entry*  naturalEntry = &(E(index));
+
+        if (naturalEntry->IsEmpty())
+        {
+            // Put the new Entry in.
+            new (naturalEntry) Entry(key, -1);
+        }
+        else
+        {
+            // Find a blank spot.
+            intptr_t blankIndex = index;
+            do {
+                blankIndex = (blankIndex + 1) & pTable->SizeMask;
+            } while(!E(blankIndex).IsEmpty());
+
+            Entry*  blankEntry = &E(blankIndex);
+
+            if (naturalEntry->GetCachedHash(pTable->SizeMask) == (size_t)index)
+            {
+                // Collision.  Link into this chain.
+
+                // Move existing list head.
+                new (blankEntry) Entry(*naturalEntry);    // placement new, copy ctor
+
+                // Put the new info in the natural Entry.
+                naturalEntry->Value       = key;
+                naturalEntry->NextInChain = blankIndex;
+            }
+            else
+            {
+                // Existing Entry does not naturally
+                // belong in this slot.  Existing
+                // Entry must be moved.
+
+                // Find natural location of collided element (i.e. root of chain)
+                intptr_t collidedIndex = naturalEntry->GetCachedHash(pTable->SizeMask);
+                OVR_ASSERT(collidedIndex >= 0 && collidedIndex <= (intptr_t)pTable->SizeMask);
+                for (;;)
+                {
+                    Entry*  e = &E(collidedIndex);
+                    if (e->NextInChain == index)
+                    {
+                        // Here's where we need to splice.
+                        new (blankEntry) Entry(*naturalEntry);
+                        e->NextInChain = blankIndex;
+                        break;
+                    }
+                    collidedIndex = e->NextInChain;
+                    OVR_ASSERT(collidedIndex >= 0 && collidedIndex <= (intptr_t)pTable->SizeMask);
+                }
+
+                // Put the new data in the natural Entry.
+                naturalEntry->Value       = key;
+                naturalEntry->NextInChain = -1;                
+            }            
+        }
+
+        // Record hash value: has effect only if cached node is used.
+        naturalEntry->SetCachedHash(hashValue);
+    }
+
+    // Index access helpers.
+    Entry& E(size_t index)
+    {
+        // Must have pTable and access needs to be within bounds.
+        OVR_ASSERT(index <= pTable->SizeMask);
+        return *(((Entry*) (pTable + 1)) + index);
+    }
+    const Entry& E(size_t index) const
+    {        
+        OVR_ASSERT(index <= pTable->SizeMask);
+        return *(((Entry*) (pTable + 1)) + index);
+    }
+
+
+    // Resize the HashSet table to the given size (Rehash the
+    // contents of the current table).  The arg is the number of
+    // HashSet table entries, not the number of elements we should
+    // actually contain (which will be less than this).
+    void    setRawCapacity(size_t newSize)    
+    {
+        if (newSize == 0)
+        {
+            // Special case.
+            Clear();
+            return;
+        }
+
+        // Minimum size; don't incur rehashing cost when expanding
+        // very small tables. Not that we perform this check before 
+        // 'log2f' call to avoid fp exception with newSize == 1.
+        if (newSize < HashMinSize)        
+            newSize = HashMinSize;       
+        else
+        {
+            // Force newSize to be a power of two.
+            int bits = Alg::UpperBit(newSize-1) + 1; // Chop( Log2f((float)(newSize-1)) + 1);
+            OVR_ASSERT((size_t(1) << bits) >= newSize);
+            newSize = size_t(1) << bits;
+        }
+
+        SelfType  newHash;
+        newHash.pTable = (TableType*)
+            Allocator::Alloc(                
+                sizeof(TableType) + sizeof(Entry) * newSize);
+        // Need to do something on alloc failure!
+        OVR_ASSERT(newHash.pTable);
+
+        newHash.pTable->EntryCount = 0;
+        newHash.pTable->SizeMask = newSize - 1;
+        size_t i, n;
+
+        // Mark all entries as empty.
+        for (i = 0; i < newSize; i++)
+            newHash.E(i).NextInChain = -2;
+
+        // Copy stuff to newHash
+        if (pTable)
+        {            
+            for (i = 0, n = pTable->SizeMask; i <= n; i++)
+            {
+                Entry*  e = &E(i);
+                if (e->IsEmpty() == false)
+                {
+                    // Insert old Entry into new HashSet.
+                    newHash.Add(e->Value);
+                    // placement delete of old element
+                    e->Clear();
+                }
+            }
+
+            // Delete our old data buffer.
+            Allocator::Free(pTable);
+        }
+
+        // Steal newHash's data.
+        pTable = newHash.pTable;
+        newHash.pTable = NULL;
+    }
+
+    struct TableType
+    {
+        size_t EntryCount;
+        size_t SizeMask;
+        // Entry array follows this structure
+        // in memory.
+    };
+    TableType*  pTable;
+};
+
+
+
+//-----------------------------------------------------------------------------------
+template<class C, class HashF = FixedSizeHash<C>,
+         class AltHashF = HashF, 
+         class Allocator = ContainerAllocator<C>,
+         class Entry = HashsetCachedEntry<C, HashF> >
+class HashSet : public HashSetBase<C, HashF, AltHashF, Allocator, Entry>
+{
+public:
+    typedef HashSetBase<C, HashF, AltHashF, Allocator, Entry> BaseType;
+    typedef HashSet<C, HashF, AltHashF, Allocator, Entry>     SelfType;
+
+    HashSet()                                      {   }
+    HashSet(int sizeHint) : BaseType(sizeHint)     {   }
+    HashSet(const SelfType& src) : BaseType(src)   {   }
+    ~HashSet()                                     {   }
+
+    void operator = (const SelfType& src)   { BaseType::Assign(src); }
+
+    // Set a new or existing value under the key, to the value.
+    // Pass a different class of 'key' so that assignment reference object
+    // can be passed instead of the actual object.
+    template<class CRef>
+    void Set(const CRef& key)
+    {
+        BaseType::Set(key);
+    }
+
+    template<class CRef>
+    inline void Add(const CRef& key)
+    {
+        BaseType::Add(key);
+    }
+
+    // Hint the bucket count to >= n.
+    void Resize(size_t n)    
+    {
+        BaseType::SetCapacity(n);
+    }
+
+    // Size the HashSet so that it can comfortably contain the given
+    // number of elements.  If the HashSet already contains more
+    // elements than newSize, then this may be a no-op.
+    void SetCapacity(size_t newSize)
+    {
+        BaseType::SetCapacity(newSize);
+    }
+
+};
+
+// HashSet with uncached hash code; declared for convenience.
+template<class C, class HashF = FixedSizeHash<C>,
+                  class AltHashF = HashF,
+                  class Allocator = ContainerAllocator<C> >
+class HashSetUncached : public HashSet<C, HashF, AltHashF, Allocator, HashsetEntry<C, HashF> >
+{
+public:
+    
+    typedef HashSetUncached<C, HashF, AltHashF, Allocator>                  SelfType;
+    typedef HashSet<C, HashF, AltHashF, Allocator, HashsetEntry<C, HashF> > BaseType;
+
+    // Delegated constructors.
+    HashSetUncached()                                        { }
+    HashSetUncached(int sizeHint) : BaseType(sizeHint)       { }
+    HashSetUncached(const SelfType& src) : BaseType(src)     { }
+    ~HashSetUncached()                                       { }
+    
+    void    operator = (const SelfType& src)
+    {
+        BaseType::operator = (src);
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Hash hash table implementation
+
+// Node for Hash - necessary so that Hash can delegate its implementation
+// to HashSet.
+template<class C, class U, class HashF>
+struct HashNode
+{
+    typedef HashNode<C, U, HashF>   SelfType;
+    typedef C                       FirstType;
+    typedef U                       SecondType;
+
+    C   First;
+    U   Second;
+
+    // NodeRef is used to allow passing of elements into HashSet
+    // without using a temporary object.
+    struct NodeRef
+    {
+        const C*   pFirst;
+        const U*   pSecond;
+
+        NodeRef(const C& f, const U& s) : pFirst(&f), pSecond(&s) { }
+        NodeRef(const NodeRef& src)     : pFirst(src.pFirst), pSecond(src.pSecond) { }
+
+        // Enable computation of ghash_node_hashf.
+        inline size_t GetHash() const            { return HashF()(*pFirst); } 
+        // Necessary conversion to allow HashNode::operator == to work.
+        operator const C& () const              { return *pFirst; }
+    };
+
+    // Note: No default constructor is necessary.
+     HashNode(const HashNode& src) : First(src.First), Second(src.Second)    { }
+     HashNode(const NodeRef& src) : First(*src.pFirst), Second(*src.pSecond)  { }
+    void operator = (const NodeRef& src)  { First  = *src.pFirst; Second = *src.pSecond; }
+
+    template<class K>
+    bool operator == (const K& src) const   { return (First == src); }
+
+    template<class K>
+    static size_t CalcHash(const K& data)   { return HashF()(data); }
+    inline size_t GetHash() const           { return HashF()(First); }
+
+    // Hash functors used with this node. A separate functor is used for alternative
+    // key lookup so that it does not need to access the '.First' element.    
+    struct NodeHashF
+    {    
+        template<class K>
+        size_t operator()(const K& data) const { return data.GetHash(); } 
+    };    
+    struct NodeAltHashF
+    {
+        template<class K>
+        size_t operator()(const K& data) const { return HashNode<C,U,HashF>::CalcHash(data); }
+    };
+};
+
+
+
+// **** Extra hashset_entry types to allow NodeRef construction.
+
+// The big difference between the below types and the ones used in hash_set is that
+// these allow initializing the node with 'typename C::NodeRef& keyRef', which
+// is critical to avoid temporary node allocation on stack when using placement new.
+
+// Compact hash table Entry type that re-computes hash keys during hash traversal.
+// Good to use if the hash function is cheap or the hash value is already cached in C.
+template<class C, class HashF>
+class HashsetNodeEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t NextInChain;
+    C     Value;
+
+    HashsetNodeEntry()
+        : NextInChain(-2) { }
+    HashsetNodeEntry(const HashsetNodeEntry& e)
+        : NextInChain(e.NextInChain), Value(e.Value) { }
+    HashsetNodeEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }    
+    HashsetNodeEntry(const typename C::NodeRef& keyRef, intptr_t next)
+        : NextInChain(next), Value(keyRef) { }
+
+    bool    IsEmpty() const             { return NextInChain == -2;  }
+    bool    IsEndOfChain() const        { return NextInChain == -1;  }
+    size_t  GetCachedHash(size_t maskValue) const  { return HashF()(Value) & maskValue; }
+    void    SetCachedHash(size_t hashValue)        { OVR_UNUSED(hashValue); }
+
+    void    Clear()
+    {        
+        Value.~C(); // placement delete
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+// Hash table Entry type that caches the Entry hash value for nodes, so that it
+// does not need to be re-computed during access.
+template<class C, class HashF>
+class HashsetCachedNodeEntry
+{
+public:
+    // Internal chaining for collisions.
+    intptr_t NextInChain;
+    size_t HashValue;
+    C     Value;
+
+    HashsetCachedNodeEntry()
+        : NextInChain(-2) { }
+    HashsetCachedNodeEntry(const HashsetCachedNodeEntry& e)
+        : NextInChain(e.NextInChain), HashValue(e.HashValue), Value(e.Value) { }
+    HashsetCachedNodeEntry(const C& key, intptr_t next)
+        : NextInChain(next), Value(key) { }
+    HashsetCachedNodeEntry(const typename C::NodeRef& keyRef, intptr_t next)
+        : NextInChain(next), Value(keyRef) { }
+
+    bool    IsEmpty() const            { return NextInChain == -2;  }
+    bool    IsEndOfChain() const       { return NextInChain == -1;  }
+    size_t  GetCachedHash(size_t maskValue) const  { OVR_UNUSED(maskValue); return HashValue; }
+    void    SetCachedHash(size_t hashValue)        { HashValue = hashValue; }
+
+    void    Clear()
+    {
+        Value.~C();
+        NextInChain = -2;
+    }
+    // Free is only used from dtor of hash; Clear is used during regular operations:
+    // assignment, hash reallocations, value reassignments, so on.
+    void    Free() { Clear(); }
+};
+
+
+//-----------------------------------------------------------------------------------
+template<class C, class U,
+         class HashF = FixedSizeHash<C>,
+         class Allocator = ContainerAllocator<C>,
+         class HashNode = OVR::HashNode<C,U,HashF>,
+         class Entry = HashsetCachedNodeEntry<HashNode, typename HashNode::NodeHashF>,
+         class Container =  HashSet<HashNode, typename HashNode::NodeHashF,
+             typename HashNode::NodeAltHashF, Allocator,
+             Entry> >
+class Hash
+{
+public:
+    OVR_MEMORY_REDEFINE_NEW(Hash)
+
+    // Types used for hash_set.
+    typedef U                                                           ValueType;
+    typedef Hash<C, U, HashF, Allocator, HashNode, Entry, Container>    SelfType;
+
+    // Actual hash table itself, implemented as hash_set.
+    Container   mHash;
+
+public:
+    Hash()     {  }
+    Hash(int sizeHint) : mHash(sizeHint)                        { }
+    Hash(const SelfType& src) : mHash(src.mHash)                { }
+    ~Hash()                                                     { }
+
+    void    operator = (const SelfType& src)    { mHash = src.mHash; }
+
+    // Remove all entries from the Hash table.
+    inline void    Clear() { mHash.Clear(); }
+    // Returns true if the Hash is empty.
+    inline bool    IsEmpty() const { return mHash.IsEmpty(); }
+
+    // Access (set).
+    inline void    Set(const C& key, const U& value)
+    {
+        typename HashNode::NodeRef e(key, value);
+        mHash.Set(e);
+    }
+    inline void    Add(const C& key, const U& value)
+    {
+        typename HashNode::NodeRef e(key, value);
+        mHash.Add(e);
+    }
+
+    // Removes an element by clearing its Entry.
+    inline void     Remove(const C& key)
+    {   
+        mHash.RemoveAlt(key);
+    }
+    template<class K>
+    inline void     RemoveAlt(const K& key)
+    {   
+        mHash.RemoveAlt(key);
+    }
+
+    // Retrieve the value under the given key.    
+    //  - If there's no value under the key, then return false and leave *pvalue alone.
+    //  - If there is a value, return true, and Set *Pvalue to the Entry's value.
+    //  - If value == NULL, return true or false according to the presence of the key.    
+    bool    Get(const C& key, U* pvalue) const   
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        if (p)
+        {
+            if (pvalue)
+                *pvalue = p->Second;
+            return true;
+        }
+        return false;
+    }
+
+    template<class K>
+    bool    GetAlt(const K& key, U* pvalue) const   
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        if (p)
+        {
+            if (pvalue)
+                *pvalue = p->Second;
+            return true;
+        }
+        return false;
+    }
+
+    // Retrieve the pointer to a value under the given key.    
+    //  - If there's no value under the key, then return NULL.    
+    //  - If there is a value, return the pointer.    
+    inline U*  Get(const C& key)
+    {
+        HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+    inline const U* Get(const C& key) const
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+
+    template<class K>
+    inline U*  GetAlt(const K& key)
+    {
+        HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+    template<class K>
+    inline const U* GetAlt(const K& key) const
+    {
+        const HashNode* p = mHash.GetAlt(key);
+        return p ? &p->Second : 0;
+    }
+
+    // Sizing methods - delegate to Hash.
+    inline size_t  GetSize() const              { return mHash.GetSize(); }    
+	inline int     GetSizeI() const             { return (int)GetSize(); }
+	inline void    Resize(size_t n)              { mHash.Resize(n); }
+    inline void    SetCapacity(size_t newSize)   { mHash.SetCapacity(newSize); }
+
+    // Iterator API, like STL.
+    typedef typename Container::ConstIterator   ConstIterator;
+    typedef typename Container::Iterator        Iterator;
+
+    inline Iterator        Begin()              { return mHash.Begin(); }
+    inline Iterator        End()                { return mHash.End(); }
+    inline ConstIterator   Begin() const        { return mHash.Begin(); }
+    inline ConstIterator   End() const          { return mHash.End();   }
+
+    Iterator        Find(const C& key)          { return mHash.FindAlt(key);  }
+    ConstIterator   Find(const C& key) const    { return mHash.FindAlt(key);  }
+
+    template<class K>
+    Iterator        FindAlt(const K& key)       { return mHash.FindAlt(key);  }
+    template<class K>
+    ConstIterator   FindAlt(const K& key) const { return mHash.FindAlt(key);  }
+};
+
+
+
+// Hash with uncached hash code; declared for convenience.
+template<class C, class U, class HashF = FixedSizeHash<C>, class Allocator = ContainerAllocator<C> >
+class HashUncached
+    : public Hash<C, U, HashF, Allocator, HashNode<C,U,HashF>,
+                   HashsetNodeEntry<HashNode<C,U,HashF>, typename HashNode<C,U,HashF>::NodeHashF> >
+{
+public:
+    typedef HashUncached<C, U, HashF, Allocator>                SelfType;
+    typedef Hash<C, U, HashF, Allocator, HashNode<C,U,HashF>,
+                 HashsetNodeEntry<HashNode<C,U,HashF>,
+                 typename HashNode<C,U,HashF>::NodeHashF> >     BaseType;
+
+    // Delegated constructors.
+    HashUncached()                                        { }
+    HashUncached(int sizeHint) : BaseType(sizeHint)       { }
+    HashUncached(const SelfType& src) : BaseType(src)     { }
+    ~HashUncached()                                       { }
+    void operator = (const SelfType& src)                 { BaseType::operator = (src); }
+};
+
+
+
+// And identity hash in which keys serve as hash value. Can be uncached,
+// since hash computation is assumed cheap.
+template<class C, class U, class Allocator = ContainerAllocator<C>, class HashF = IdentityHash<C> >
+class HashIdentity
+    : public HashUncached<C, U, HashF, Allocator>
+{
+public:
+    typedef HashIdentity<C, U, Allocator, HashF> SelfType;
+    typedef HashUncached<C, U, HashF, Allocator> BaseType;
+
+    // Delegated constructors.
+    HashIdentity()                                        { }
+    HashIdentity(int sizeHint) : BaseType(sizeHint)       { }
+    HashIdentity(const SelfType& src) : BaseType(src)     { }
+    ~HashIdentity()                                       { }
+    void operator = (const SelfType& src)                 { BaseType::operator = (src); }
+};
+
+
+} // OVR
+
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_KeyCodes.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_KeyCodes.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,251 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_KeyCodes.h
+Content     :   Common keyboard constants
+Created     :   September 19, 2012
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_KeyCodes_h
+#define OVR_KeyCodes_h
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** KeyCode
+
+// KeyCode enumeration defines platform-independent keyboard key constants.
+// Note that Key_A through Key_Z are mapped to capital ascii constants.
+
+enum KeyCode
+{
+    // Key_None indicates that no key was specified.
+    Key_None            = 0, 
+
+    // A through Z and numbers 0 through 9.
+    Key_A               = 65,
+    Key_B,
+    Key_C,
+    Key_D,
+    Key_E,
+    Key_F,
+    Key_G,
+    Key_H,
+    Key_I,
+    Key_J,
+    Key_K,
+    Key_L,
+    Key_M,
+    Key_N,
+    Key_O,
+    Key_P,
+    Key_Q,
+    Key_R,
+    Key_S,
+    Key_T,
+    Key_U,
+    Key_V,
+    Key_W,
+    Key_X,
+    Key_Y,
+    Key_Z,
+    Key_Num0            = 48,
+    Key_Num1,
+    Key_Num2,
+    Key_Num3,
+    Key_Num4,
+    Key_Num5,
+    Key_Num6,
+    Key_Num7,
+    Key_Num8,
+    Key_Num9,
+
+    // Numeric keypad.
+    Key_KP_0            = 0xa0,
+    Key_KP_1,
+    Key_KP_2,
+    Key_KP_3,
+    Key_KP_4,
+    Key_KP_5,
+    Key_KP_6,
+    Key_KP_7,
+    Key_KP_8,
+    Key_KP_9,
+    Key_KP_Multiply,
+    Key_KP_Add,
+    Key_KP_Enter,
+    Key_KP_Subtract,
+    Key_KP_Decimal,
+    Key_KP_Divide,
+    
+    // Function keys.
+    Key_F1              = 0xb0,
+    Key_F2,
+    Key_F3,
+    Key_F4,
+    Key_F5,
+    Key_F6,
+    Key_F7,
+    Key_F8,
+    Key_F9,
+    Key_F10,
+    Key_F11,
+    Key_F12,
+    Key_F13,
+    Key_F14,
+    Key_F15,
+    
+    // Other keys.
+    Key_Backspace       = 8,
+    Key_Tab,
+    Key_Clear           = 12,
+    Key_Return,
+    Key_Shift           = 16,
+    Key_Control,
+    Key_Alt,
+    Key_Pause,
+    Key_CapsLock        = 20, // Toggle
+    Key_Escape          = 27,
+    Key_Space           = 32,
+    Key_Quote           = 39,
+    Key_PageUp          = 0xc0,
+    Key_PageDown,
+    Key_End,
+    Key_Home,
+    Key_Left,
+    Key_Up,
+    Key_Right,
+    Key_Down,
+    Key_Insert,
+    Key_Delete,
+    Key_Help,
+    
+    Key_Comma           = 44,
+    Key_Minus,
+    Key_Slash           = 47,
+    Key_Period,
+    Key_NumLock         = 144, // Toggle
+    Key_ScrollLock      = 145, // Toggle
+    
+    Key_Semicolon       = 59,
+    Key_Equal           = 61,
+    Key_Backtick        = 96,   // ` and tilda~ when shifted (US keyboard)
+    Key_BracketLeft     = 91,
+    Key_Backslash,
+    Key_BracketRight,
+
+    Key_OEM_AX          = 0xE1,  //  'AX' key on Japanese AX keyboard
+    Key_OEM_102         = 0xE2,  //  "<>" or "\|" on RT 102-key keyboard.
+    Key_ICO_HELP        = 0xE3,  //  Help key on ICO
+    Key_ICO_00          = 0xE4,  //  00 key on ICO
+
+    Key_Meta,
+
+    // Total number of keys.
+    Key_CodeCount
+};
+
+
+//-----------------------------------------------------------------------------------
+
+class KeyModifiers 
+{
+public:
+    enum
+    {
+        Key_ShiftPressed    = 0x01,
+        Key_CtrlPressed     = 0x02,
+        Key_AltPressed      = 0x04,
+        Key_MetaPressed     = 0x08,
+        Key_CapsToggled     = 0x10,
+        Key_NumToggled      = 0x20,
+        Key_ScrollToggled   = 0x40,
+
+        Initialized_Bit     = 0x80,
+        Initialized_Mask    = 0xFF
+    };
+    unsigned char States;
+
+    KeyModifiers() : States(0) { }
+        KeyModifiers(unsigned char st) : States((unsigned char)(st | Initialized_Bit)) { }
+
+    void Reset() { States = 0; }
+
+    bool IsShiftPressed() const { return (States & Key_ShiftPressed) != 0; }
+    bool IsCtrlPressed() const  { return (States & Key_CtrlPressed) != 0; }
+    bool IsAltPressed() const   { return (States & Key_AltPressed) != 0; }
+    bool IsMetaPressed() const  { return (States & Key_MetaPressed) != 0; }
+    bool IsCapsToggled() const  { return (States & Key_CapsToggled) != 0; }
+    bool IsNumToggled() const   { return (States & Key_NumToggled) != 0; }
+    bool IsScrollToggled() const{ return (States & Key_ScrollToggled) != 0; }
+
+    void SetShiftPressed(bool v = true)  { (v) ? States |= Key_ShiftPressed : States &= ~Key_ShiftPressed; }
+    void SetCtrlPressed(bool v = true)   { (v) ? States |= Key_CtrlPressed  : States &= ~Key_CtrlPressed; }
+    void SetAltPressed(bool v = true)    { (v) ? States |= Key_AltPressed   : States &= ~Key_AltPressed; }
+    void SetMetaPressed(bool v = true)   { (v) ? States |= Key_MetaPressed  : States &= ~Key_MetaPressed; }
+    void SetCapsToggled(bool v = true)   { (v) ? States |= Key_CapsToggled  : States &= ~Key_CapsToggled; }
+    void SetNumToggled(bool v = true)    { (v) ? States |= Key_NumToggled   : States &= ~Key_NumToggled; }
+    void SetScrollToggled(bool v = true) { (v) ? States |= Key_ScrollToggled: States &= ~Key_ScrollToggled; }
+
+    bool IsInitialized() const { return (States & Initialized_Mask) != 0; }
+};
+
+
+//-----------------------------------------------------------------------------------
+
+/*
+enum PadKeyCode
+{
+    Pad_None, // Indicates absence of key code.
+    Pad_Back,
+    Pad_Start,
+    Pad_A,
+    Pad_B,
+    Pad_X,
+    Pad_Y,
+    Pad_R1,  // RightShoulder;
+    Pad_L1,  // LeftShoulder;
+    Pad_R2,  // RightTrigger;
+    Pad_L2,  // LeftTrigger;
+    Pad_Up,
+    Pad_Down,
+    Pad_Right,
+    Pad_Left,
+    Pad_Plus,
+    Pad_Minus,
+    Pad_1,
+    Pad_2,
+    Pad_H,
+    Pad_C,
+    Pad_Z,
+    Pad_O,
+    Pad_T,
+    Pad_S,
+    Pad_Select,
+    Pad_Home,
+    Pad_RT,  // RightThumb;
+    Pad_LT   // LeftThumb;
+};
+*/
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_List.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_List.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,336 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_List.h
+Content     :   Template implementation for doubly-connected linked List
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_List_h
+#define OVR_List_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** ListNode
+//
+// Base class for the elements of the intrusive linked list.
+// To store elements in the List do:
+//
+// struct MyData : ListNode<MyData>
+// {
+//     . . .
+// };
+
+template<class T>
+struct ListNode
+{
+    union {
+        T*    pPrev;
+        void* pVoidPrev;
+    };
+    union {
+        T*    pNext;
+        void* pVoidNext;
+    };
+
+    void    RemoveNode()
+    {
+        pPrev->pNext = pNext;
+        pNext->pPrev = pPrev;
+    }
+
+    // Removes us from the list and inserts pnew there instead.
+    void    ReplaceNodeWith(T* pnew)
+    {
+        pPrev->pNext = pnew;
+        pNext->pPrev = pnew;
+        pnew->pPrev = pPrev;
+        pnew->pNext = pNext;
+    }
+       
+    // Inserts the argument linked list node after us in the list.
+    void    InsertNodeAfter(T* p)
+    {
+        p->pPrev          = pNext->pPrev; // this
+        p->pNext          = pNext;
+        pNext->pPrev      = p;
+        pNext             = p;
+    }
+    // Inserts the argument linked list node before us in the list.
+    void    InsertNodeBefore(T* p)
+    {
+        p->pNext          = pNext->pPrev; // this
+        p->pPrev          = pPrev;
+        pPrev->pNext      = p;
+        pPrev             = p;
+    }
+
+    void    Alloc_MoveTo(ListNode<T>* pdest)
+    {
+        pdest->pNext = pNext;
+        pdest->pPrev = pPrev;
+        pPrev->pNext = (T*)pdest;
+        pNext->pPrev = (T*)pdest;
+    }
+};
+
+
+//------------------------------------------------------------------------
+// ***** List
+//
+// Doubly linked intrusive list. 
+// The data type must be derived from ListNode.
+// 
+// Adding:   PushFront(), PushBack().
+// Removing: Remove() - the element must be in the list!
+// Moving:   BringToFront(), SendToBack() - the element must be in the list!
+//
+// Iterating:
+//    MyData* data = MyList.GetFirst();
+//    while (!MyList.IsNull(data))
+//    {
+//        . . .
+//        data = MyList.GetNext(data);
+//    }
+//
+// Removing:
+//    MyData* data = MyList.GetFirst();
+//    while (!MyList.IsNull(data))
+//    {
+//        MyData* next = MyList.GetNext(data);
+//        if (ToBeRemoved(data))
+//             MyList.Remove(data);
+//        data = next;
+//    }
+//
+
+// List<> represents a doubly-linked list of T, where each T must derive
+// from ListNode<B>. B specifies the base class that was directly
+// derived from ListNode, and is only necessary if there is an intermediate
+// inheritance chain.
+
+template<class T, class B = T> class List
+{
+public:
+    typedef T ValueType;
+
+    List()
+    {
+        Root.pNext = Root.pPrev = (ValueType*)&Root;
+    }
+
+    void Clear()
+    {
+        Root.pNext = Root.pPrev = (ValueType*)&Root;
+    }
+
+    const ValueType* GetFirst() const { return (const ValueType*)Root.pNext; }
+    const ValueType* GetLast () const { return (const ValueType*)Root.pPrev; }
+          ValueType* GetFirst()       { return (ValueType*)Root.pNext; }
+          ValueType* GetLast ()       { return (ValueType*)Root.pPrev; }
+
+    // Determine if list is empty (i.e.) points to itself.
+    // Go through void* access to avoid issues with strict-aliasing optimizing out the
+    // access after RemoveNode(), etc.
+    bool IsEmpty()                   const { return Root.pVoidNext == (const T*)(const B*)&Root; }
+    bool IsFirst(const ValueType* p) const { return p == Root.pNext; }
+    bool IsLast (const ValueType* p) const { return p == Root.pPrev; }
+    bool IsNull (const ValueType* p) const { return p == (const T*)(const B*)&Root; }
+
+    inline static const ValueType* GetPrev(const ValueType* p) { return (const ValueType*)p->pPrev; }
+    inline static const ValueType* GetNext(const ValueType* p) { return (const ValueType*)p->pNext; }
+    inline static       ValueType* GetPrev(      ValueType* p) { return (ValueType*)p->pPrev; }
+    inline static       ValueType* GetNext(      ValueType* p) { return (ValueType*)p->pNext; }
+
+    void PushFront(ValueType* p)
+    {
+        p->pNext          =  Root.pNext;
+        p->pPrev          = (ValueType*)&Root;
+        Root.pNext->pPrev =  p;
+        Root.pNext        =  p;
+    }
+
+    void PushBack(ValueType* p)
+    {
+        p->pPrev          =  Root.pPrev;
+        p->pNext          = (ValueType*)&Root;
+        Root.pPrev->pNext =  p;
+        Root.pPrev        =  p;
+    }
+
+    static void Remove(ValueType* p)
+    {
+        p->pPrev->pNext = p->pNext;
+        p->pNext->pPrev = p->pPrev;
+    }
+
+    void BringToFront(ValueType* p)
+    {
+        Remove(p);
+        PushFront(p);
+    }
+
+    void SendToBack(ValueType* p)
+    {
+        Remove(p);
+        PushBack(p);
+    }
+
+    // Appends the contents of the argument list to the front of this list;
+    // items are removed from the argument list.
+    void PushListToFront(List<T>& src)
+    {
+        if (!src.IsEmpty())
+        {
+            ValueType* pfirst = src.GetFirst();
+            ValueType* plast  = src.GetLast();
+            src.Clear();
+            plast->pNext   = Root.pNext;
+            pfirst->pPrev  = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+    void PushListToBack(List<T>& src)
+    {
+        if (!src.IsEmpty())
+        {
+            ValueType* pfirst = src.GetFirst();
+            ValueType* plast  = src.GetLast();
+            src.Clear();
+            plast->pNext   = (ValueType*)&Root;
+            pfirst->pPrev  = Root.pPrev;
+            Root.pPrev->pNext = pfirst;
+            Root.pPrev        = plast;
+        }
+    }
+
+    // Removes all source list items after (and including) the 'pfirst' node from the 
+    // source list and adds them to out list.
+    void    PushFollowingListItemsToFront(List<T>& src, ValueType *pfirst)
+    {
+        if (pfirst != &src.Root)
+        {
+            ValueType *plast = src.Root.pPrev;
+
+            // Remove list remainder from source.
+            pfirst->pPrev->pNext = (ValueType*)&src.Root;
+            src.Root.pPrev      = pfirst->pPrev;
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+    // Removes all source list items up to but NOT including the 'pend' node from the 
+    // source list and adds them to out list.
+    void    PushPrecedingListItemsToFront(List<T>& src, ValueType *ptail)
+    {
+        if (src.GetFirst() != ptail)
+        {
+            ValueType *pfirst = src.Root.pNext;
+            ValueType *plast  = ptail->pPrev;
+
+            // Remove list remainder from source.
+            ptail->pPrev      = (ValueType*)&src.Root;
+            src.Root.pNext    = ptail;            
+
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+
+    // Removes a range of source list items starting at 'pfirst' and up to, but not including 'pend',
+    // and adds them to out list. Note that source items MUST already be in the list.
+    void    PushListItemsToFront(ValueType *pfirst, ValueType *pend)
+    {
+        if (pfirst != pend)
+        {
+            ValueType *plast = pend->pPrev;
+
+            // Remove list remainder from source.
+            pfirst->pPrev->pNext = pend;
+            pend->pPrev          = pfirst->pPrev;
+            // Add the rest of the items to list.
+            plast->pNext      = Root.pNext;
+            pfirst->pPrev     = (ValueType*)&Root;
+            Root.pNext->pPrev = plast;
+            Root.pNext        = pfirst;
+        }
+    }
+
+
+    void    Alloc_MoveTo(List<T>* pdest)
+    {
+        if (IsEmpty())
+            pdest->Clear();
+        else
+        {
+            pdest->Root.pNext = Root.pNext;
+            pdest->Root.pPrev = Root.pPrev;
+
+            Root.pNext->pPrev = (ValueType*)&pdest->Root;
+            Root.pPrev->pNext = (ValueType*)&pdest->Root;
+        }        
+    }
+
+
+private:
+    // Copying is prohibited
+    List(const List<T>&);
+    const List<T>& operator = (const List<T>&);
+
+    ListNode<B> Root;
+};
+
+
+//------------------------------------------------------------------------
+// ***** FreeListElements
+//
+// Remove all elements in the list and free them in the allocator
+
+template<class List, class Allocator>
+void FreeListElements(List& list, Allocator& allocator)
+{
+    typename List::ValueType* self = list.GetFirst();
+    while(!list.IsNull(self))
+    {
+        typename List::ValueType* next = list.GetNext(self);
+        allocator.Free(self);
+        self = next;
+    }
+    list.Clear();
+}
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Lockless.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,117 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Lockless.h
+Content     :   Lock-less classes for producer/consumer communication
+Created     :   November 9, 2013
+Authors     :   John Carmack
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Lockless_h
+#define OVR_Lockless_h
+
+#include "OVR_Atomic.h"
+
+// Define this to compile-in Lockless test logic
+//#define OVR_LOCKLESS_TEST
+
+namespace OVR {
+
+
+// ***** LocklessUpdater
+
+// For single producer cases where you only care about the most recent update, not
+// necessarily getting every one that happens (vsync timing, SensorFusion updates).
+//
+// This is multiple consumer safe, but is currently only used with a single consumer.
+//
+// The SlotType can be the same as T, but should probably be a larger fixed size.
+// This allows for forward compatibility when the updater is shared between processes.
+
+// FIXME: ExchangeAdd_Sync() should be replaced with a portable read-only primitive,
+// so that the lockless pose state can be read-only on remote processes and to reduce
+// false sharing between processes and improve performance.
+
+template<class T, class SlotType>
+class LocklessUpdater
+{
+public:
+	LocklessUpdater() : UpdateBegin( 0 ), UpdateEnd( 0 )
+    {
+        OVR_COMPILER_ASSERT(sizeof(T) <= sizeof(SlotType));
+    }
+
+	T GetState() const
+	{
+		// Copy the state out, then retry with the alternate slot
+		// if we determine that our copy may have been partially
+		// stepped on by a new update.
+		T	state;
+		int	begin, end, final;
+
+		for(;;)
+		{
+			// We are adding 0, only using these as atomic memory barriers, so it
+			// is ok to cast off the const, allowing GetState() to remain const.
+            end   = UpdateEnd.Load_Acquire();
+            state = Slots[ end & 1 ];
+            begin = UpdateBegin.Load_Acquire();
+			if ( begin == end ) {
+				break;
+			}
+
+			// The producer is potentially blocked while only having partially
+			// written the update, so copy out the other slot.
+            state = Slots[ (begin & 1) ^ 1 ];
+            final = UpdateBegin.Load_Acquire();
+			if ( final == begin ) {
+				break;
+			}
+
+			// The producer completed the last update and started a new one before
+			// we got it copied out, so try fetching the current buffer again.
+		}
+		return state;
+	}
+
+	void	SetState( T state )
+	{
+        const int slot = UpdateBegin.ExchangeAdd_Sync(1) & 1;
+        // Write to (slot ^ 1) because ExchangeAdd returns 'previous' value before add.
+        Slots[slot ^ 1] = state;
+        UpdateEnd.ExchangeAdd_Sync(1);
+	}
+
+    AtomicInt<int> UpdateBegin;
+    AtomicInt<int> UpdateEnd;
+    SlotType       Slots[2];
+};
+
+
+#ifdef OVR_LOCKLESS_TEST
+void StartLocklessTest();
+#endif
+
+
+} // namespace OVR
+
+#endif // OVR_Lockless_h
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Log.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,209 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_Log.h
+Content     :   Logging support
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Log_h
+#define OVR_Log_h
+
+#include "OVR_Types.h"
+#include <stdarg.h>
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Logging Constants
+
+// LogMaskConstants defined bit mask constants that describe what log messages
+// should be displayed.
+enum LogMaskConstants
+{
+    LogMask_Regular = 0x100,
+    LogMask_Debug   = 0x200,
+    LogMask_None    = 0,
+    LogMask_All     = LogMask_Regular|LogMask_Debug
+};
+
+
+// LogMessageType describes the type of the log message, controls when it is
+// displayed and what prefix/suffix is given to it. Messages are subdivided into
+// regular and debug logging types. Debug logging is only generated in debug builds.
+//
+// Log_Text         - General output text displayed without prefix or new-line.
+//                    Used in OVR libraries for general log flow messages
+//                    such as "Device Initialized".
+//
+// Log_Error        - Error message output with "Error: %s\n", intended for
+//                    application/sample-level use only, in cases where an expected
+//                    operation failed. OVR libraries should not use this internally,
+//                    reporting status codes instead.
+//
+// Log_DebugText    - Message without prefix or new lines; output in Debug build only.
+//
+// Log_Debug        - Debug-build only message, formatted with "Debug: %s\n".
+//                    Intended to comment on incorrect API usage that doesn't lead
+//                    to crashes but can be avoided with proper use.
+//                    There is no Debug Error on purpose, since real errors should
+//                    be handled by API user.
+//
+// Log_Assert      -  Debug-build only message, formatted with "Assert: %s\n".
+//                    Intended for severe unrecoverable conditions in library
+//                    source code. Generated though OVR_ASSERT_MSG(c, "Text").
+
+enum LogMessageType
+{    
+    // General Logging
+    Log_Text        = LogMask_Regular | 0,    
+    Log_Error       = LogMask_Regular | 1, // "Error: %s\n".
+    
+    // Debug-only messages (not generated in release build)
+    Log_DebugText   = LogMask_Debug | 0,
+    Log_Debug       = LogMask_Debug | 1,   // "Debug: %s\n".
+    Log_Assert      = LogMask_Debug | 2,   // "Assert: %s\n".
+};
+
+
+// LOG_VAARG_ATTRIBUTE macro, enforces printf-style fromatting for message types
+#ifdef __GNUC__
+#  define OVR_LOG_VAARG_ATTRIBUTE(a,b) __attribute__((format (printf, a, b)))
+#else
+#  define OVR_LOG_VAARG_ATTRIBUTE(a,b)
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Log
+
+// Log defines a base class interface that can be implemented to catch both
+// debug and runtime messages.
+// Debug logging can be overridden by calling Log::SetGlobalLog.
+
+class Log
+{
+    friend class System;
+
+#ifdef OVR_OS_WIN32
+    void* hEventSource;
+#endif
+
+public: 
+    Log(unsigned logMask = LogMask_Debug);
+    virtual ~Log();
+
+    // Log formating buffer size used by default LogMessageVarg. Longer strings are truncated.
+    enum { MaxLogBufferMessageSize = 4096 };
+
+    unsigned        GetLoggingMask() const            { return LoggingMask; }
+    void            SetLoggingMask(unsigned logMask)  { LoggingMask = logMask; }
+
+    // This virtual function receives all the messages,
+    // developers should override this function in order to do custom logging
+    virtual void    LogMessageVarg(LogMessageType messageType, const char* fmt, va_list argList);
+
+    // Call the logging function with specific message type, with no type filtering.
+    void            LogMessage(LogMessageType messageType,
+                               const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(3,4);
+
+
+    // Helper used by LogMessageVarg to format the log message, writing the resulting
+    // string into buffer. It formats text based on fmt and appends prefix/new line
+    // based on LogMessageType.
+    static void     FormatLog(char* buffer, unsigned bufferSize, LogMessageType messageType,
+                              const char* fmt, va_list argList);
+
+    // Default log output implementation used by by LogMessageVarg.
+    // Debug flag may be used to re-direct output on some platforms, but doesn't
+    // necessarily disable it in release builds; that is the job of the called.    
+    void            DefaultLogOutput(const char* textBuffer, LogMessageType messageType);
+
+    // Determines if the specified message type is for debugging only.
+    static bool     IsDebugMessage(LogMessageType messageType)
+    {
+        return (messageType & LogMask_Debug) != 0;
+    }
+
+    // *** Global APIs
+
+    // Global Log registration APIs.
+    //  - Global log is used for OVR_DEBUG messages. Set global log to null (0)
+    //    to disable all logging.
+    static void     SetGlobalLog(Log *log);
+    static Log*     GetGlobalLog();
+
+    // Returns default log singleton instance.
+    static Log*     GetDefaultLog();
+
+    // Applies logMask to the default log and returns a pointer to it.
+    // By default, only Debug logging is enabled, so to avoid SDK generating console
+    // messages in user app (those are always disabled in release build,
+    // even if the flag is set). This function is useful in System constructor.
+    static Log*     ConfigureDefaultLog(unsigned logMask = LogMask_Debug)
+    {
+        Log* log = GetDefaultLog();
+        log->SetLoggingMask(logMask);
+        return log;
+    }
+
+private:
+    // Logging mask described by LogMaskConstants.
+    unsigned    LoggingMask;
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Global Logging Functions and Debug Macros
+
+// These functions will output text to global log with semantics described by
+// their LogMessageType.
+void LogText(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+void LogError(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+
+#ifdef OVR_BUILD_DEBUG
+
+    // Debug build only logging.
+    void LogDebugText(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+    void LogDebug(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+    void LogAssert(const char* fmt, ...) OVR_LOG_VAARG_ATTRIBUTE(1,2);
+
+    // Macro to do debug logging, printf-style.
+    // An extra set of set of parenthesis must be used around arguments,
+    // as in: OVR_DEBUG_LOG(("Value %d", 2)).
+    #define OVR_DEBUG_LOG(args)       do { OVR::LogDebug args; } while(0)
+    #define OVR_DEBUG_LOG_TEXT(args)  do { OVR::LogDebugText args; } while(0)
+
+    #define OVR_ASSERT_LOG(c, args)   do { if (!(c)) { OVR::LogAssert args; OVR_DEBUG_BREAK; } } while(0)
+
+#else
+
+    // If not in debug build, macros do nothing.
+    #define OVR_DEBUG_LOG(args)         ((void)0)
+    #define OVR_DEBUG_LOG_TEXT(args)    ((void)0)
+    #define OVR_ASSERT_LOG(c, args)     ((void)0)
+
+#endif
+
+} // OVR 
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Math.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,2766 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Math.h
+Content     :   Implementation of 3D primitives such as vectors, matrices.
+Created     :   September 4, 2012
+Authors     :   Andrew Reisse, Michael Antonov, Steve LaValle, 
+				Anna Yershova, Max Katsev, Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Math_h
+#define OVR_Math_h
+
+#include <assert.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "OVR_Types.h"
+#include "OVR_RefCount.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+
+namespace OVR {
+
+//-------------------------------------------------------------------------------------
+// ***** Constants for 3D world/axis definitions.
+
+// Definitions of axes for coordinate and rotation conversions.
+enum Axis
+{
+    Axis_X = 0, Axis_Y = 1, Axis_Z = 2
+};
+
+// RotateDirection describes the rotation direction around an axis, interpreted as follows:
+//  CW  - Clockwise while looking "down" from positive axis towards the origin.
+//  CCW - Counter-clockwise while looking from the positive axis towards the origin,
+//        which is in the negative axis direction.
+//  CCW is the default for the RHS coordinate system. Oculus standard RHS coordinate
+//  system defines Y up, X right, and Z back (pointing out from the screen). In this
+//  system Rotate_CCW around Z will specifies counter-clockwise rotation in XY plane.
+enum RotateDirection
+{
+    Rotate_CCW = 1,
+    Rotate_CW  = -1 
+};
+
+// Constants for right handed and left handed coordinate systems
+enum HandedSystem
+{
+    Handed_R = 1, Handed_L = -1
+};
+
+// AxisDirection describes which way the coordinate axis points. Used by WorldAxes.
+enum AxisDirection
+{
+    Axis_Up    =  2,
+    Axis_Down  = -2,
+    Axis_Right =  1,
+    Axis_Left  = -1,
+    Axis_In    =  3,
+    Axis_Out   = -3
+};
+
+struct WorldAxes
+{
+    AxisDirection XAxis, YAxis, ZAxis;
+
+    WorldAxes(AxisDirection x, AxisDirection y, AxisDirection z)
+        : XAxis(x), YAxis(y), ZAxis(z) 
+    { OVR_ASSERT(abs(x) != abs(y) && abs(y) != abs(z) && abs(z) != abs(x));}
+};
+
+} // namespace OVR
+
+
+//------------------------------------------------------------------------------------//
+// ***** C Compatibility Types
+
+// These declarations are used to support conversion between C types used in
+// LibOVR C interfaces and their C++ versions. As an example, they allow passing
+// Vector3f into a function that expects ovrVector3f.
+
+typedef struct ovrQuatf_ ovrQuatf;
+typedef struct ovrQuatd_ ovrQuatd;
+typedef struct ovrSizei_ ovrSizei;
+typedef struct ovrSizef_ ovrSizef;
+typedef struct ovrRecti_ ovrRecti;
+typedef struct ovrVector2i_ ovrVector2i;
+typedef struct ovrVector2f_ ovrVector2f;
+typedef struct ovrVector3f_ ovrVector3f;
+typedef struct ovrVector3d_ ovrVector3d;
+typedef struct ovrMatrix3d_ ovrMatrix3d;
+typedef struct ovrMatrix4f_ ovrMatrix4f;
+typedef struct ovrPosef_ ovrPosef;
+typedef struct ovrPosed_ ovrPosed;
+typedef struct ovrPoseStatef_ ovrPoseStatef;
+typedef struct ovrPoseStated_ ovrPoseStated;
+
+namespace OVR {
+
+// Forward-declare our templates.
+template<class T> class Quat;
+template<class T> class Size;
+template<class T> class Rect;
+template<class T> class Vector2;
+template<class T> class Vector3;
+template<class T> class Matrix3;
+template<class T> class Matrix4;
+template<class T> class Pose;
+template<class T> class PoseState;
+
+// CompatibleTypes::Type is used to lookup a compatible C-version of a C++ class.
+template<class C>
+struct CompatibleTypes
+{    
+    // Declaration here seems necessary for MSVC; specializations are
+    // used instead.
+    typedef struct {} Type;
+};
+
+// Specializations providing CompatibleTypes::Type value.
+template<> struct CompatibleTypes<Quat<float> >     { typedef ovrQuatf Type; };
+template<> struct CompatibleTypes<Quat<double> >    { typedef ovrQuatd Type; };
+template<> struct CompatibleTypes<Matrix3<double> > { typedef ovrMatrix3d Type; };
+template<> struct CompatibleTypes<Matrix4<float> >  { typedef ovrMatrix4f Type; };
+template<> struct CompatibleTypes<Size<int> >       { typedef ovrSizei Type; };
+template<> struct CompatibleTypes<Size<float> >     { typedef ovrSizef Type; };
+template<> struct CompatibleTypes<Rect<int> >       { typedef ovrRecti Type; };
+template<> struct CompatibleTypes<Vector2<int> >    { typedef ovrVector2i Type; };
+template<> struct CompatibleTypes<Vector2<float> >  { typedef ovrVector2f Type; };
+template<> struct CompatibleTypes<Vector3<float> >  { typedef ovrVector3f Type; };
+template<> struct CompatibleTypes<Vector3<double> > { typedef ovrVector3d Type; };
+
+template<> struct CompatibleTypes<Pose<float> > { typedef ovrPosef Type; };
+template<> struct CompatibleTypes<Pose<double> > { typedef ovrPosed Type; };
+
+//------------------------------------------------------------------------------------//
+// ***** Math
+//
+// Math class contains constants and functions. This class is a template specialized
+// per type, with Math<float> and Math<double> being distinct.
+template<class Type>
+class Math
+{  
+public:
+    // By default, support explicit conversion to float. This allows Vector2<int> to
+    // compile, for example.
+    typedef float OtherFloatType;
+};
+
+
+#define MATH_FLOAT_PI                (3.1415926f)
+#define MATH_FLOAT_TWOPI             (2.0f *MATH_FLOAT_PI)
+#define MATH_FLOAT_PIOVER2           (0.5f *MATH_FLOAT_PI)
+#define MATH_FLOAT_PIOVER4           (0.25f*MATH_FLOAT_PI)
+#define MATH_FLOAT_E                 (2.7182818f)
+#define MATH_FLOAT_MAXVALUE			 (FLT_MAX) 
+#define MATH_FLOAT MINPOSITIVEVALUE  (FLT_MIN)  
+#define MATH_FLOAT_RADTODEGREEFACTOR (360.0f / MATH_FLOAT_TWOPI)
+#define MATH_FLOAT_DEGREETORADFACTOR (MATH_FLOAT_TWOPI / 360.0f)
+#define MATH_FLOAT_TOLERANCE		 (0.00001f)
+#define MATH_FLOAT_SINGULARITYRADIUS (0.0000001f) // Use for Gimbal lock numerical problems
+
+#define MATH_DOUBLE_PI                (3.14159265358979)
+#define MATH_DOUBLE_TWOPI             (2.0f *MATH_DOUBLE_PI)
+#define MATH_DOUBLE_PIOVER2           (0.5f *MATH_DOUBLE_PI)
+#define MATH_DOUBLE_PIOVER4           (0.25f*MATH_DOUBLE_PI)
+#define MATH_DOUBLE_E                 (2.71828182845905)
+#define MATH_DOUBLE_MAXVALUE		  (DBL_MAX)
+#define MATH_DOUBLE MINPOSITIVEVALUE  (DBL_MIN)
+#define MATH_DOUBLE_RADTODEGREEFACTOR (360.0f / MATH_DOUBLE_TWOPI)
+#define MATH_DOUBLE_DEGREETORADFACTOR (MATH_DOUBLE_TWOPI / 360.0f)
+#define MATH_DOUBLE_TOLERANCE		  (0.00001)
+#define MATH_DOUBLE_SINGULARITYRADIUS (0.000000000001) // Use for Gimbal lock numerical problems
+
+
+
+
+// Single-precision Math constants class.
+template<>
+class Math<float>
+{
+public:
+     typedef double OtherFloatType;
+};
+
+// Double-precision Math constants class.
+template<>
+class Math<double>
+{
+public:
+    typedef float OtherFloatType;
+};
+
+
+typedef Math<float>  Mathf;
+typedef Math<double> Mathd;
+
+// Conversion functions between degrees and radians
+template<class T>
+T RadToDegree(T rads) { return rads * ((T)MATH_DOUBLE_RADTODEGREEFACTOR); }
+template<class T>
+T DegreeToRad(T rads) { return rads * ((T)MATH_DOUBLE_DEGREETORADFACTOR); }
+
+// Numerically stable acos function
+template<class T>
+T Acos(T val) { 
+		if (val > T(1))				return T(0);
+		else if (val < T(-1))		return ((T)MATH_DOUBLE_PI);
+		else						return acos(val); 
+};
+
+// Numerically stable asin function
+template<class T>
+T Asin(T val) { 
+	if (val > T(1))				return ((T)MATH_DOUBLE_PIOVER2);
+	else if (val < T(-1))		return ((T)MATH_DOUBLE_PIOVER2) * T(3);
+	else						return asin(val); 
+};
+
+#ifdef OVR_CC_MSVC
+inline int isnan(double x) { return _isnan(x); };
+#endif
+
+template<class T>
+class Quat;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Vector2<>
+
+// Vector2f (Vector2d) represents a 2-dimensional vector or point in space,
+// consisting of coordinates x and y
+
+template<class T>
+class Vector2
+{
+public:
+    T x, y;
+
+    Vector2() : x(0), y(0) { }
+    Vector2(T x_, T y_) : x(x_), y(y_) { }
+    explicit Vector2(T s) : x(s), y(s) { }
+    explicit Vector2(const Vector2<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y) { }
+
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Vector2<T> >::Type CompatibleType;
+
+    Vector2(const CompatibleType& s) : x(s.x), y(s.y) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector2<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+        
+    bool     operator== (const Vector2& b) const  { return x == b.x && y == b.y; }
+    bool     operator!= (const Vector2& b) const  { return x != b.x || y != b.y; }
+             
+    Vector2  operator+  (const Vector2& b) const  { return Vector2(x + b.x, y + b.y); }
+    Vector2& operator+= (const Vector2& b)        { x += b.x; y += b.y; return *this; }
+    Vector2  operator-  (const Vector2& b) const  { return Vector2(x - b.x, y - b.y); }
+    Vector2& operator-= (const Vector2& b)        { x -= b.x; y -= b.y; return *this; }
+    Vector2  operator- () const                   { return Vector2(-x, -y); }
+
+    // Scalar multiplication/division scales vector.
+    Vector2  operator*  (T s) const               { return Vector2(x*s, y*s); }
+    Vector2& operator*= (T s)                     { x *= s; y *= s; return *this; }
+
+    Vector2  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector2(x*rcp, y*rcp); }
+    Vector2& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp;
+                                                    return *this; }
+
+    static Vector2  Min(const Vector2& a, const Vector2& b) { return Vector2((a.x < b.x) ? a.x : b.x,
+                                                                             (a.y < b.y) ? a.y : b.y); }
+    static Vector2  Max(const Vector2& a, const Vector2& b) { return Vector2((a.x > b.x) ? a.x : b.x,
+                                                                             (a.y > b.y) ? a.y : b.y); }
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool	Compare(const Vector2&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE))  
+    {
+        return (fabs(b.x-x) < tolerance) && (fabs(b.y-y) < tolerance);
+    }
+    
+	// Access element by index
+	T& operator[] (int idx)
+	{
+		OVR_ASSERT(0 <= idx && idx < 2);
+		return *(&x + idx);
+	}
+	const T& operator[] (int idx) const
+	{
+		OVR_ASSERT(0 <= idx && idx < 2);
+		return *(&x + idx);
+	}
+
+    // Entry-wise product of two vectors
+    Vector2	EntrywiseMultiply(const Vector2& b) const	{ return Vector2(x * b.x, y * b.y);}
+
+
+    // Multiply and divide operators do entry-wise math. Used Dot() for dot product.
+    Vector2  operator*  (const Vector2& b) const        { return Vector2(x * b.x,  y * b.y); }
+    Vector2  operator/  (const Vector2& b) const        { return Vector2(x / b.x,  y / b.y); }
+
+	// Dot product
+    // Used to calculate angle q between two vectors among other things,
+    // as (A dot B) = |a||b|cos(q).
+    T		Dot(const Vector2& b) const                 { return x*b.x + y*b.y; }
+
+    // Returns the angle from this vector to b, in radians.
+    T       Angle(const Vector2& b) const        
+	{ 
+		T div = LengthSq()*b.LengthSq();
+		OVR_ASSERT(div != T(0));
+		T result = Acos((this->Dot(b))/sqrt(div));
+		return result;
+	}
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+
+    // Returns squared distance between two points represented by vectors.
+    T       DistanceSq(const Vector2& b) const   { return (*this - b).LengthSq(); }
+
+	// Returns distance between two points represented by vectors.
+    T       Distance(const Vector2& b) const     { return (*this - b).Length(); }
+
+	// Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector2 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Linearly interpolates from this vector to another.
+    // Factor should be between 0.0 and 1.0, with 0 giving full value to this.
+    Vector2 Lerp(const Vector2& b, T f) const    { return *this*(T(1) - f) + b*f; }
+
+    // Projects this vector onto the argument; in other words,
+    // A.Project(B) returns projection of vector A onto B.
+    Vector2 ProjectTo(const Vector2& b) const    
+	{ 
+		T l2 = b.LengthSq();
+		OVR_ASSERT(l2 != T(0));
+		return b * ( Dot(b) / l2 ); 
+	}
+};
+
+
+typedef Vector2<float>  Vector2f;
+typedef Vector2<double> Vector2d;
+typedef Vector2<int>    Vector2i;
+
+typedef Vector2<float>  Point2f;
+typedef Vector2<double> Point2d;
+typedef Vector2<int>    Point2i;
+
+//-------------------------------------------------------------------------------------
+// ***** Vector3<> - 3D vector of {x, y, z}
+
+//
+// Vector3f (Vector3d) represents a 3-dimensional vector or point in space,
+// consisting of coordinates x, y and z.
+
+template<class T>
+class Vector3
+{
+public:
+    T x, y, z;
+
+    // FIXME: default initialization of a vector class can be very expensive in a full-blown
+    // application.  A few hundred thousand vector constructions is not unlikely and can add
+    // up to milliseconds of time on processors like the PS3 PPU.
+    Vector3() : x(0), y(0), z(0) { }
+    Vector3(T x_, T y_, T z_ = 0) : x(x_), y(y_), z(z_) { }
+    explicit Vector3(T s) : x(s), y(s), z(s) { }
+    explicit Vector3(const Vector3<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z) { }
+
+    static const Vector3 ZERO;
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Vector3<T> >::Type CompatibleType;
+
+    Vector3(const CompatibleType& s) : x(s.x), y(s.y), z(s.z) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector3<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    bool     operator== (const Vector3& b) const  { return x == b.x && y == b.y && z == b.z; }
+    bool     operator!= (const Vector3& b) const  { return x != b.x || y != b.y || z != b.z; }
+             
+    Vector3  operator+  (const Vector3& b) const  { return Vector3(x + b.x, y + b.y, z + b.z); }
+    Vector3& operator+= (const Vector3& b)        { x += b.x; y += b.y; z += b.z; return *this; }
+    Vector3  operator-  (const Vector3& b) const  { return Vector3(x - b.x, y - b.y, z - b.z); }
+    Vector3& operator-= (const Vector3& b)        { x -= b.x; y -= b.y; z -= b.z; return *this; }
+    Vector3  operator- () const                   { return Vector3(-x, -y, -z); }
+
+    // Scalar multiplication/division scales vector.
+    Vector3  operator*  (T s) const               { return Vector3(x*s, y*s, z*s); }
+    Vector3& operator*= (T s)                     { x *= s; y *= s; z *= s; return *this; }
+
+    Vector3  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector3(x*rcp, y*rcp, z*rcp); }
+    Vector3& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp; z *= rcp;
+                                                    return *this; }
+
+    static Vector3  Min(const Vector3& a, const Vector3& b)
+    {
+        return Vector3((a.x < b.x) ? a.x : b.x,
+                       (a.y < b.y) ? a.y : b.y,
+                       (a.z < b.z) ? a.z : b.z);
+    }
+    static Vector3  Max(const Vector3& a, const Vector3& b)
+    { 
+        return Vector3((a.x > b.x) ? a.x : b.x,
+                       (a.y > b.y) ? a.y : b.y,
+                       (a.z > b.z) ? a.z : b.z);
+    }        
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool      Compare(const Vector3&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE)) 
+    {
+        return (fabs(b.x-x) < tolerance) && 
+			   (fabs(b.y-y) < tolerance) && 
+			   (fabs(b.z-z) < tolerance);
+    }
+    
+    T& operator[] (int idx)
+    {
+        OVR_ASSERT(0 <= idx && idx < 3);
+        return *(&x + idx);
+    }
+
+    const T& operator[] (int idx) const
+    {
+        OVR_ASSERT(0 <= idx && idx < 3);
+        return *(&x + idx);
+    }
+
+    // Entrywise product of two vectors
+    Vector3	EntrywiseMultiply(const Vector3& b) const	{ return Vector3(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z);}
+
+    // Multiply and divide operators do entry-wise math
+    Vector3  operator*  (const Vector3& b) const        { return Vector3(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z); }
+
+    Vector3  operator/  (const Vector3& b) const        { return Vector3(x / b.x, 
+																		 y / b.y, 
+																		 z / b.z); }
+
+
+	// Dot product
+    // Used to calculate angle q between two vectors among other things,
+    // as (A dot B) = |a||b|cos(q).
+     T      Dot(const Vector3& b) const          { return x*b.x + y*b.y + z*b.z; }
+
+    // Compute cross product, which generates a normal vector.
+    // Direction vector can be determined by right-hand rule: Pointing index finder in
+    // direction a and middle finger in direction b, thumb will point in a.Cross(b).
+    Vector3 Cross(const Vector3& b) const        { return Vector3(y*b.z - z*b.y,
+                                                                  z*b.x - x*b.z,
+                                                                  x*b.y - y*b.x); }
+
+    // Returns the angle from this vector to b, in radians.
+    T       Angle(const Vector3& b) const 
+	{
+		T div = LengthSq()*b.LengthSq();
+		OVR_ASSERT(div != T(0));
+		T result = Acos((this->Dot(b))/sqrt(div));
+		return result;
+	}
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y + z * z); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+
+    // Returns squared distance between two points represented by vectors.
+    T       DistanceSq(Vector3 const& b) const         { return (*this - b).LengthSq(); }
+
+    // Returns distance between two points represented by vectors.
+    T       Distance(Vector3 const& b) const     { return (*this - b).Length(); }
+    
+    // Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector3 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Linearly interpolates from this vector to another.
+    // Factor should be between 0.0 and 1.0, with 0 giving full value to this.
+    Vector3 Lerp(const Vector3& b, T f) const    { return *this*(T(1) - f) + b*f; }
+
+    // Projects this vector onto the argument; in other words,
+    // A.Project(B) returns projection of vector A onto B.
+    Vector3 ProjectTo(const Vector3& b) const    
+	{ 
+		T l2 = b.LengthSq();
+		OVR_ASSERT(l2 != T(0));
+		return b * ( Dot(b) / l2 ); 
+	}
+
+    // Projects this vector onto a plane defined by a normal vector
+    Vector3 ProjectToPlane(const Vector3& normal) const { return *this - this->ProjectTo(normal); }
+};
+
+typedef Vector3<float>  Vector3f;
+typedef Vector3<double> Vector3d;
+typedef Vector3<int32_t>  Vector3i;
+
+typedef Vector3<float>   Point3f;
+typedef Vector3<double>  Point3d;
+typedef Vector3<int32_t>  Point3i;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Vector4<> - 4D vector of {x, y, z, w}
+
+//
+// Vector4f (Vector4d) represents a 3-dimensional vector or point in space,
+// consisting of coordinates x, y, z and w.
+
+template<class T>
+class Vector4
+{
+public:
+    T x, y, z, w;
+
+	// FIXME: default initialization of a vector class can be very expensive in a full-blown
+	// application.  A few hundred thousand vector constructions is not unlikely and can add
+	// up to milliseconds of time on processors like the PS3 PPU.
+    Vector4() : x(0), y(0), z(0), w(0) { }
+    Vector4(T x_, T y_, T z_, T w_) : x(x_), y(y_), z(z_), w(w_) { }
+    explicit Vector4(T s) : x(s), y(s), z(s), w(s) { }
+	explicit Vector4(const Vector3<T>& v, const float w_=1) : x(v.x), y(v.y), z(v.z), w(w_) { }
+    explicit Vector4(const Vector4<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z), w((T)src.w) { }
+
+    static const Vector4 ZERO;
+
+    // C-interop support.
+    typedef  typename CompatibleTypes< Vector4<T> >::Type CompatibleType;
+
+    Vector4(const CompatibleType& s) : x(s.x), y(s.y), z(s.z), w(s.w) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Vector4<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+	Vector4& operator= (const Vector3<T>& other)  { x=other.x; y=other.y; z=other.z; w=1; return *this; }
+    bool     operator== (const Vector4& b) const  { return x == b.x && y == b.y && z == b.z && w == b.w; }
+    bool     operator!= (const Vector4& b) const  { return x != b.x || y != b.y || z != b.z || w != b.w; }
+             
+    Vector4  operator+  (const Vector4& b) const  { return Vector4(x + b.x, y + b.y, z + b.z, w + b.w); }
+    Vector4& operator+= (const Vector4& b)        { x += b.x; y += b.y; z += b.z; w += b.w; return *this; }
+    Vector4  operator-  (const Vector4& b) const  { return Vector4(x - b.x, y - b.y, z - b.z, w - b.w); }
+    Vector4& operator-= (const Vector4& b)        { x -= b.x; y -= b.y; z -= b.z; w -= b.w; return *this; }
+    Vector4  operator- () const                   { return Vector4(-x, -y, -z, -w); }
+
+    // Scalar multiplication/division scales vector.
+    Vector4  operator*  (T s) const               { return Vector4(x*s, y*s, z*s, w*s); }
+    Vector4& operator*= (T s)                     { x *= s; y *= s; z *= s; w *= s;return *this; }
+
+    Vector4  operator/  (T s) const               { T rcp = T(1)/s;
+                                                    return Vector4(x*rcp, y*rcp, z*rcp, w*rcp); }
+    Vector4& operator/= (T s)                     { T rcp = T(1)/s;
+                                                    x *= rcp; y *= rcp; z *= rcp; w *= rcp;
+                                                    return *this; }
+
+    static Vector4  Min(const Vector4& a, const Vector4& b)
+    {
+        return Vector4((a.x < b.x) ? a.x : b.x,
+                       (a.y < b.y) ? a.y : b.y,
+                       (a.z < b.z) ? a.z : b.z,
+					   (a.w < b.w) ? a.w : b.w);
+    }
+    static Vector4  Max(const Vector4& a, const Vector4& b)
+    { 
+        return Vector4((a.x > b.x) ? a.x : b.x,
+                       (a.y > b.y) ? a.y : b.y,
+                       (a.z > b.z) ? a.z : b.z,
+					   (a.w > b.w) ? a.w : b.w);
+    }        
+
+    // Compare two vectors for equality with tolerance. Returns true if vectors match withing tolerance.
+    bool      Compare(const Vector4&b, T tolerance = ((T)MATH_DOUBLE_TOLERANCE))
+    {
+        return (fabs(b.x-x) < tolerance) && 
+			   (fabs(b.y-y) < tolerance) && 
+			   (fabs(b.z-z) < tolerance) &&
+			   (fabs(b.w-w) < tolerance);
+    }
+    
+    T& operator[] (int idx)
+    {
+        OVR_ASSERT(0 <= idx && idx < 4);
+        return *(&x + idx);
+    }
+
+    const T& operator[] (int idx) const
+    {
+        OVR_ASSERT(0 <= idx && idx < 4);
+        return *(&x + idx);
+    }
+
+    // Entry wise product of two vectors
+    Vector4	EntrywiseMultiply(const Vector4& b) const	{ return Vector4(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z);}
+
+    // Multiply and divide operators do entry-wise math
+    Vector4  operator*  (const Vector4& b) const        { return Vector4(x * b.x, 
+																		 y * b.y, 
+																		 z * b.z,
+																		 w * b.w); }
+
+    Vector4  operator/  (const Vector4& b) const        { return Vector4(x / b.x, 
+																		 y / b.y, 
+																		 z / b.z,
+																		 w / b.w); }
+
+
+	// Dot product
+    T       Dot(const Vector4& b) const          { return x*b.x + y*b.y + z*b.z + w*b.w; }
+
+    // Return Length of the vector squared.
+    T       LengthSq() const                     { return (x * x + y * y + z * z + w * w); }
+
+    // Return vector length.
+    T       Length() const                       { return sqrt(LengthSq()); }
+    
+    // Determine if this a unit vector.
+    bool    IsNormalized() const                 { return fabs(LengthSq() - T(1)) < Math<T>::Tolerance; }
+
+    // Normalize, convention vector length to 1.    
+    void    Normalize()                          
+	{
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+    // Returns normalized (unit) version of the vector without modifying itself.
+    Vector4 Normalized() const                   
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+};
+
+typedef Vector4<float>  Vector4f;
+typedef Vector4<double> Vector4d;
+typedef Vector4<int>    Vector4i;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Bounds3
+
+// Bounds class used to describe a 3D axis aligned bounding box.
+
+template<class T>
+class Bounds3
+{
+public:
+	Vector3<T>	b[2];
+
+	Bounds3()
+	{
+	}
+
+	Bounds3( const Vector3<T> & mins, const Vector3<T> & maxs )
+{
+		b[0] = mins;
+		b[1] = maxs;
+	}
+
+	void Clear()
+	{
+		b[0].x = b[0].y = b[0].z = Math<T>::MaxValue;
+		b[1].x = b[1].y = b[1].z = -Math<T>::MaxValue;
+	}
+
+	void AddPoint( const Vector3<T> & v )
+	{
+		b[0].x = Alg::Min( b[0].x, v.x );
+		b[0].y = Alg::Min( b[0].y, v.y );
+		b[0].z = Alg::Min( b[0].z, v.z );
+		b[1].x = Alg::Max( b[1].x, v.x );
+		b[1].y = Alg::Max( b[1].y, v.y );
+		b[1].z = Alg::Max( b[1].z, v.z );
+	}
+
+	const Vector3<T> & GetMins() const { return b[0]; }
+	const Vector3<T> & GetMaxs() const { return b[1]; }
+
+	Vector3<T> & GetMins() { return b[0]; }
+	Vector3<T> & GetMaxs() { return b[1]; }
+};
+
+typedef Bounds3<float>	Bounds3f;
+typedef Bounds3<double>	Bounds3d;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Size
+
+// Size class represents 2D size with Width, Height components.
+// Used to describe distentions of render targets, etc.
+
+template<class T>
+class Size
+{
+public:
+    T   w, h;
+
+    Size()              : w(0), h(0)   { }
+    Size(T w_, T h_)    : w(w_), h(h_) { }
+    explicit Size(T s)  : w(s), h(s)   { }
+    explicit Size(const Size<typename Math<T>::OtherFloatType> &src)
+        : w((T)src.w), h((T)src.h) { }
+
+    // C-interop support.
+    typedef  typename CompatibleTypes<Size<T> >::Type CompatibleType;
+
+    Size(const CompatibleType& s) : w(s.w), h(s.h) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Size<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    bool     operator== (const Size& b) const  { return w == b.w && h == b.h; }
+    bool     operator!= (const Size& b) const  { return w != b.w || h != b.h; }
+             
+    Size  operator+  (const Size& b) const  { return Size(w + b.w, h + b.h); }
+    Size& operator+= (const Size& b)        { w += b.w; h += b.h; return *this; }
+    Size  operator-  (const Size& b) const  { return Size(w - b.w, h - b.h); }
+    Size& operator-= (const Size& b)        { w -= b.w; h -= b.h; return *this; }
+    Size  operator- () const                { return Size(-w, -h); }
+    Size  operator*  (const Size& b) const  { return Size(w * b.w, h * b.h); }
+    Size& operator*= (const Size& b)        { w *= b.w; h *= b.h; return *this; }
+    Size  operator/  (const Size& b) const  { return Size(w / b.w, h / b.h); }
+    Size& operator/= (const Size& b)        { w /= b.w; h /= b.h; return *this; }
+
+    // Scalar multiplication/division scales both components.
+    Size  operator*  (T s) const            { return Size(w*s, h*s); }
+    Size& operator*= (T s)                  { w *= s; h *= s; return *this; }    
+    Size  operator/  (T s) const            { return Size(w/s, h/s); }
+    Size& operator/= (T s)                  { w /= s; h /= s; return *this; }
+
+    static Size Min(const Size& a, const Size& b)  { return Size((a.w  < b.w)  ? a.w  : b.w,
+                                                                 (a.h < b.h) ? a.h : b.h); }
+    static Size Max(const Size& a, const Size& b)  { return Size((a.w  > b.w)  ? a.w  : b.w,
+                                                                 (a.h > b.h) ? a.h : b.h); }
+    
+    T       Area() const                    { return w * h; }
+
+    inline  Vector2<T> ToVector() const     { return Vector2<T>(w, h); }
+};
+
+
+typedef Size<int>       Sizei;
+typedef Size<unsigned>  Sizeu;
+typedef Size<float>     Sizef;
+typedef Size<double>    Sized;
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Rect
+
+// Rect describes a rectangular area for rendering, that includes position and size.
+template<class T>
+class Rect
+{
+public:
+    T x, y;
+    T w, h;
+
+    Rect() { }
+    Rect(T x1, T y1, T w1, T h1)                   : x(x1), y(y1), w(w1), h(h1) { }    
+    Rect(const Vector2<T>& pos, const Size<T>& sz) : x(pos.x), y(pos.y), w(sz.w), h(sz.h) { }
+    Rect(const Size<T>& sz)                        : x(0), y(0), w(sz.w), h(sz.h) { }
+    
+    // C-interop support.
+    typedef  typename CompatibleTypes<Rect<T> >::Type CompatibleType;
+
+    Rect(const CompatibleType& s) : x(s.Pos.x), y(s.Pos.y), w(s.Size.w), h(s.Size.h) {  }
+
+    operator const CompatibleType& () const
+    {
+        OVR_COMPILER_ASSERT(sizeof(Rect<T>) == sizeof(CompatibleType));
+        return reinterpret_cast<const CompatibleType&>(*this);
+    }
+
+    Vector2<T> GetPos() const                { return Vector2<T>(x, y); }
+    Size<T>    GetSize() const               { return Size<T>(w, h); }
+    void       SetPos(const Vector2<T>& pos) { x = pos.x; y = pos.y; }
+    void       SetSize(const Size<T>& sz)    { w = sz.w; h = sz.h; }
+
+    bool operator == (const Rect& vp) const
+    { return (x == vp.x) && (y == vp.y) && (w == vp.w) && (h == vp.h); }
+    bool operator != (const Rect& vp) const
+    { return !operator == (vp); }
+};
+
+typedef Rect<int> Recti;
+
+
+//-------------------------------------------------------------------------------------//
+// ***** Quat
+//
+// Quatf represents a quaternion class used for rotations.
+// 
+// Quaternion multiplications are done in right-to-left order, to match the
+// behavior of matrices.
+
+
+template<class T>
+class Quat
+{
+public:
+    // w + Xi + Yj + Zk
+    T x, y, z, w;    
+
+    Quat() : x(0), y(0), z(0), w(1) { }
+    Quat(T x_, T y_, T z_, T w_) : x(x_), y(y_), z(z_), w(w_) { }
+    explicit Quat(const Quat<typename Math<T>::OtherFloatType> &src)
+        : x((T)src.x), y((T)src.y), z((T)src.z), w((T)src.w) { }
+
+    typedef  typename CompatibleTypes<Quat<T> >::Type CompatibleType;
+
+    // C-interop support.
+    Quat(const CompatibleType& s) : x(s.x), y(s.y), z(s.z), w(s.w) { }
+
+    operator CompatibleType () const
+    {
+        CompatibleType result;
+        result.x = x;
+        result.y = y;
+        result.z = z;
+        result.w = w;
+        return result;
+    }
+
+    // Constructs quaternion for rotation around the axis by an angle.
+    Quat(const Vector3<T>& axis, T angle)
+    {
+        // Make sure we don't divide by zero. 
+        if (axis.LengthSq() == 0)
+        {
+            // Assert if the axis is zero, but the angle isn't
+            OVR_ASSERT(angle == 0);
+            x = 0; y = 0; z = 0; w = 1;
+            return;
+        }
+
+		Vector3<T> unitAxis = axis.Normalized();
+		T          sinHalfAngle = sin(angle * T(0.5));
+
+		w = cos(angle * T(0.5));
+		x = unitAxis.x * sinHalfAngle;
+		y = unitAxis.y * sinHalfAngle;
+		z = unitAxis.z * sinHalfAngle;
+    }
+
+    // Constructs quaternion for rotation around one of the coordinate axis by an angle.
+    Quat(Axis A, T angle, RotateDirection d = Rotate_CCW, HandedSystem s = Handed_R)
+    {
+        T sinHalfAngle = s * d *sin(angle * T(0.5));
+        T v[3];
+        v[0] = v[1] = v[2] = T(0);
+        v[A] = sinHalfAngle;
+
+        w = cos(angle * T(0.5));
+        x = v[0];
+        y = v[1];
+        z = v[2];
+    }
+
+    // Compute axis and angle from quaternion
+    void GetAxisAngle(Vector3<T>* axis, T* angle) const
+    {
+		if ( x*x + y*y + z*z > ((T)MATH_DOUBLE_TOLERANCE) * ((T)MATH_DOUBLE_TOLERANCE) ) {
+			*axis  = Vector3<T>(x, y, z).Normalized();
+			*angle = 2 * Acos(w);
+			if (*angle > ((T)MATH_DOUBLE_PI)) // Reduce the magnitude of the angle, if necessary
+			{
+				*angle = ((T)MATH_DOUBLE_TWOPI) - *angle;
+				*axis = *axis * (-1);
+			}
+		}
+		else 
+		{
+			*axis = Vector3<T>(1, 0, 0);
+			*angle= 0;
+		}
+    }
+
+    // Constructs the quaternion from a rotation matrix
+    explicit Quat(const Matrix4<T>& m)
+    {
+        T trace = m.M[0][0] + m.M[1][1] + m.M[2][2];
+
+        // In almost all cases, the first part is executed.
+        // However, if the trace is not positive, the other
+        // cases arise.
+        if (trace > T(0)) 
+        {
+            T s = sqrt(trace + T(1)) * T(2); // s=4*qw
+            w = T(0.25) * s;
+            x = (m.M[2][1] - m.M[1][2]) / s;
+            y = (m.M[0][2] - m.M[2][0]) / s;
+            z = (m.M[1][0] - m.M[0][1]) / s; 
+        } 
+        else if ((m.M[0][0] > m.M[1][1])&&(m.M[0][0] > m.M[2][2])) 
+        {
+            T s = sqrt(T(1) + m.M[0][0] - m.M[1][1] - m.M[2][2]) * T(2);
+            w = (m.M[2][1] - m.M[1][2]) / s;
+            x = T(0.25) * s;
+            y = (m.M[0][1] + m.M[1][0]) / s;
+            z = (m.M[2][0] + m.M[0][2]) / s;
+        } 
+        else if (m.M[1][1] > m.M[2][2]) 
+        {
+            T s = sqrt(T(1) + m.M[1][1] - m.M[0][0] - m.M[2][2]) * T(2); // S=4*qy
+            w = (m.M[0][2] - m.M[2][0]) / s;
+            x = (m.M[0][1] + m.M[1][0]) / s;
+            y = T(0.25) * s;
+            z = (m.M[1][2] + m.M[2][1]) / s;
+        } 
+        else 
+        {
+            T s = sqrt(T(1) + m.M[2][2] - m.M[0][0] - m.M[1][1]) * T(2); // S=4*qz
+            w = (m.M[1][0] - m.M[0][1]) / s;
+            x = (m.M[0][2] + m.M[2][0]) / s;
+            y = (m.M[1][2] + m.M[2][1]) / s;
+            z = T(0.25) * s;
+        }
+    }
+
+	// Constructs the quaternion from a rotation matrix
+	explicit Quat(const Matrix3<T>& m)
+	{
+		T trace = m.M[0][0] + m.M[1][1] + m.M[2][2];
+
+		// In almost all cases, the first part is executed.
+		// However, if the trace is not positive, the other
+		// cases arise.
+		if (trace > T(0)) 
+		{
+			T s = sqrt(trace + T(1)) * T(2); // s=4*qw
+			w = T(0.25) * s;
+			x = (m.M[2][1] - m.M[1][2]) / s;
+			y = (m.M[0][2] - m.M[2][0]) / s;
+			z = (m.M[1][0] - m.M[0][1]) / s; 
+		} 
+		else if ((m.M[0][0] > m.M[1][1])&&(m.M[0][0] > m.M[2][2])) 
+		{
+			T s = sqrt(T(1) + m.M[0][0] - m.M[1][1] - m.M[2][2]) * T(2);
+			w = (m.M[2][1] - m.M[1][2]) / s;
+			x = T(0.25) * s;
+			y = (m.M[0][1] + m.M[1][0]) / s;
+			z = (m.M[2][0] + m.M[0][2]) / s;
+		} 
+		else if (m.M[1][1] > m.M[2][2]) 
+		{
+			T s = sqrt(T(1) + m.M[1][1] - m.M[0][0] - m.M[2][2]) * T(2); // S=4*qy
+			w = (m.M[0][2] - m.M[2][0]) / s;
+			x = (m.M[0][1] + m.M[1][0]) / s;
+			y = T(0.25) * s;
+			z = (m.M[1][2] + m.M[2][1]) / s;
+		} 
+		else 
+		{
+			T s = sqrt(T(1) + m.M[2][2] - m.M[0][0] - m.M[1][1]) * T(2); // S=4*qz
+			w = (m.M[1][0] - m.M[0][1]) / s;
+			x = (m.M[0][2] + m.M[2][0]) / s;
+			y = (m.M[1][2] + m.M[2][1]) / s;
+			z = T(0.25) * s;
+		}
+	}
+
+    bool operator== (const Quat& b) const   { return x == b.x && y == b.y && z == b.z && w == b.w; }
+    bool operator!= (const Quat& b) const   { return x != b.x || y != b.y || z != b.z || w != b.w; }
+
+    Quat  operator+  (const Quat& b) const  { return Quat(x + b.x, y + b.y, z + b.z, w + b.w); }
+    Quat& operator+= (const Quat& b)        { w += b.w; x += b.x; y += b.y; z += b.z; return *this; }
+    Quat  operator-  (const Quat& b) const  { return Quat(x - b.x, y - b.y, z - b.z, w - b.w); }
+    Quat& operator-= (const Quat& b)        { w -= b.w; x -= b.x; y -= b.y; z -= b.z; return *this; }
+
+    Quat  operator*  (T s) const            { return Quat(x * s, y * s, z * s, w * s); }
+    Quat& operator*= (T s)                  { w *= s; x *= s; y *= s; z *= s; return *this; }
+    Quat  operator/  (T s) const            { T rcp = T(1)/s; return Quat(x * rcp, y * rcp, z * rcp, w *rcp); }
+    Quat& operator/= (T s)                  { T rcp = T(1)/s; w *= rcp; x *= rcp; y *= rcp; z *= rcp; return *this; }
+
+
+    // Get Imaginary part vector
+    Vector3<T> Imag() const                 { return Vector3<T>(x,y,z); }
+
+    // Get quaternion length.
+    T       Length() const                  { return sqrt(LengthSq()); }
+
+    // Get quaternion length squared.
+    T       LengthSq() const                { return (x * x + y * y + z * z + w * w); }
+
+    // Simple Euclidean distance in R^4 (not SLERP distance, but at least respects Haar measure)
+    T       Distance(const Quat& q) const	
+	{ 
+        T d1 = (*this - q).Length();
+        T d2 = (*this + q).Length(); // Antipodal point check
+        return (d1 < d2) ? d1 : d2;
+	}
+
+    T       DistanceSq(const Quat& q) const
+    {
+        T d1 = (*this - q).LengthSq();
+        T d2 = (*this + q).LengthSq(); // Antipodal point check
+        return (d1 < d2) ? d1 : d2;
+    }
+
+    T       Dot(const Quat& q) const
+    {
+        return x * q.x + y * q.y + z * q.z + w * q.w;
+    }
+
+	// Angle between two quaternions in radians
+    T       Angle(const Quat& q) const
+	{
+		return 2 * Acos(Alg::Abs(Dot(q)));
+	}
+
+    // Normalize
+    bool    IsNormalized() const            { return fabs(LengthSq() - T(1)) < ((T)MATH_DOUBLE_TOLERANCE); }
+
+    void    Normalize()                     
+	{
+ 		T l = Length();
+		OVR_ASSERT(l != T(0));
+		*this /= l; 
+	}
+
+	Quat    Normalized() const              
+	{ 
+		T l = Length();
+		OVR_ASSERT(l != T(0));
+		return *this / l; 
+	}
+
+    // Returns conjugate of the quaternion. Produces inverse rotation if quaternion is normalized.
+    Quat    Conj() const                    { return Quat(-x, -y, -z, w); }
+
+    // Quaternion multiplication. Combines quaternion rotations, performing the one on the 
+    // right hand side first.
+    Quat  operator* (const Quat& b) const   { return Quat(w * b.x + x * b.w + y * b.z - z * b.y,
+                                                          w * b.y - x * b.z + y * b.w + z * b.x,
+                                                          w * b.z + x * b.y - y * b.x + z * b.w,
+                                                          w * b.w - x * b.x - y * b.y - z * b.z); }
+
+    // 
+    // this^p normalized; same as rotating by this p times.
+    Quat PowNormalized(T p) const
+    {
+        Vector3<T> v;
+        T          a;
+        GetAxisAngle(&v, &a);
+        return Quat(v, a * p);
+    }
+
+    // Normalized linear interpolation of quaternions
+    Quat Nlerp(const Quat& other, T a)
+    {
+        T sign = (Dot(other) >= 0) ? 1 : -1;
+        return (*this * sign * a + other * (1-a)).Normalized();
+    }
+    
+    // Rotate transforms vector in a manner that matches Matrix rotations (counter-clockwise,
+    // assuming negative direction of the axis). Standard formula: q(t) * V * q(t)^-1. 
+    Vector3<T> Rotate(const Vector3<T>& v) const
+    {
+        return ((*this * Quat<T>(v.x, v.y, v.z, T(0))) * Inverted()).Imag();
+    }
+    
+    // Inversed quaternion rotates in the opposite direction.
+    Quat        Inverted() const
+    {
+        return Quat(-x, -y, -z, w);
+    }
+
+    // Sets this quaternion to the one rotates in the opposite direction.
+    void        Invert()
+    {
+        *this = Quat(-x, -y, -z, w);
+    }
+    
+    // GetEulerAngles extracts Euler angles from the quaternion, in the specified order of
+    // axis rotations and the specified coordinate system. Right-handed coordinate system
+    // is the default, with CCW rotations while looking in the negative axis direction.
+    // Here a,b,c, are the Yaw/Pitch/Roll angles to be returned.
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A3
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+	template <Axis A1, Axis A2, Axis A3, RotateDirection D, HandedSystem S>
+    void GetEulerAngles(T *a, T *b, T *c) const 
+    {
+        OVR_COMPILER_ASSERT((A1 != A2) && (A2 != A3) && (A1 != A3));
+
+        T Q[3] = { x, y, z };  //Quaternion components x,y,z
+
+        T ww  = w*w;
+        T Q11 = Q[A1]*Q[A1];
+        T Q22 = Q[A2]*Q[A2];
+        T Q33 = Q[A3]*Q[A3];
+
+        T psign = T(-1);
+        // Determine whether even permutation
+        if (((A1 + 1) % 3 == A2) && ((A2 + 1) % 3 == A3))
+            psign = T(1);
+        
+        T s2 = psign * T(2) * (psign*w*Q[A2] + Q[A1]*Q[A3]);
+
+        if (s2 < T(-1) + ((T)MATH_DOUBLE_SINGULARITYRADIUS))
+        { // South pole singularity
+            *a = T(0);
+            *b = -S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2(T(2)*(psign*Q[A1]*Q[A2] + w*Q[A3]),
+		                   ww + Q22 - Q11 - Q33 );
+        }
+        else if (s2 > T(1) - ((T)MATH_DOUBLE_SINGULARITYRADIUS))
+        {  // North pole singularity
+            *a = T(0);
+            *b = S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2(T(2)*(psign*Q[A1]*Q[A2] + w*Q[A3]),
+		                   ww + Q22 - Q11 - Q33);
+        }
+        else
+        {
+            *a = -S*D*atan2(T(-2)*(w*Q[A1] - psign*Q[A2]*Q[A3]),
+		                    ww + Q33 - Q11 - Q22);
+            *b = S*D*asin(s2);
+            *c = S*D*atan2(T(2)*(w*Q[A3] - psign*Q[A1]*Q[A2]),
+		                   ww + Q11 - Q22 - Q33);
+        }      
+        return;
+    }
+
+    template <Axis A1, Axis A2, Axis A3, RotateDirection D>
+    void GetEulerAngles(T *a, T *b, T *c) const
+    { GetEulerAngles<A1, A2, A3, D, Handed_R>(a, b, c); }
+
+    template <Axis A1, Axis A2, Axis A3>
+    void GetEulerAngles(T *a, T *b, T *c) const
+    { GetEulerAngles<A1, A2, A3, Rotate_CCW, Handed_R>(a, b, c); }
+
+    // GetEulerAnglesABA extracts Euler angles from the quaternion, in the specified order of
+    // axis rotations and the specified coordinate system. Right-handed coordinate system
+    // is the default, with CCW rotations while looking in the negative axis direction.
+    // Here a,b,c, are the Yaw/Pitch/Roll angles to be returned.
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A1
+    // Rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, RotateDirection D, HandedSystem S>
+    void GetEulerAnglesABA(T *a, T *b, T *c) const
+    {
+        OVR_COMPILER_ASSERT(A1 != A2);
+
+        T Q[3] = {x, y, z}; // Quaternion components
+
+        // Determine the missing axis that was not supplied
+        int m = 3 - A1 - A2;
+
+        T ww = w*w;
+        T Q11 = Q[A1]*Q[A1];
+        T Q22 = Q[A2]*Q[A2];
+        T Qmm = Q[m]*Q[m];
+
+        T psign = T(-1);
+        if ((A1 + 1) % 3 == A2) // Determine whether even permutation
+        {
+            psign = T(1);
+        }
+
+        T c2 = ww + Q11 - Q22 - Qmm;
+        if (c2 < T(-1) + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = T(0);
+            *b = S*D*((T)MATH_DOUBLE_PI);
+            *c = S*D*atan2( T(2)*(w*Q[A1] - psign*Q[A2]*Q[m]),
+		                    ww + Q22 - Q11 - Qmm);
+        }
+        else if (c2 > T(1) - Math<T>::SingularityRadius)
+        {  // North pole singularity
+            *a = T(0);
+            *b = T(0);
+            *c = S*D*atan2( T(2)*(w*Q[A1] - psign*Q[A2]*Q[m]),
+		                   ww + Q22 - Q11 - Qmm);
+        }
+        else
+        {
+            *a = S*D*atan2( psign*w*Q[m] + Q[A1]*Q[A2],
+		                   w*Q[A2] -psign*Q[A1]*Q[m]);
+            *b = S*D*acos(c2);
+            *c = S*D*atan2( -psign*w*Q[m] + Q[A1]*Q[A2],
+		                   w*Q[A2] + psign*Q[A1]*Q[m]);
+        }
+        return;
+    }
+};
+
+typedef Quat<float>  Quatf;
+typedef Quat<double> Quatd;
+
+//-------------------------------------------------------------------------------------
+// ***** Pose
+
+// Position and orientation combined.
+
+template<class T>
+class Pose
+{
+public:
+    typedef typename CompatibleTypes<Pose<T> >::Type CompatibleType;
+
+    Pose() { }
+    Pose(const Quat<T>& orientation, const Vector3<T>& pos)
+        : Rotation(orientation), Translation(pos) {  }
+    Pose(const Pose& s)
+        : Rotation(s.Rotation), Translation(s.Translation) {  }
+    Pose(const CompatibleType& s)
+        : Rotation(s.Orientation), Translation(s.Position) {  }
+    explicit Pose(const Pose<typename Math<T>::OtherFloatType> &s)
+        : Rotation(s.Rotation), Translation(s.Translation) {  }
+
+    operator typename CompatibleTypes<Pose<T> >::Type () const
+    {
+        typename CompatibleTypes<Pose<T> >::Type result;
+        result.Orientation = Rotation;
+        result.Position = Translation;
+        return result;
+    }
+
+    Quat<T>    Rotation;
+    Vector3<T> Translation;
+
+    Vector3<T> Rotate(const Vector3<T>& v) const
+    {
+        return Rotation.Rotate(v);
+    }
+
+    Vector3<T> Translate(const Vector3<T>& v) const
+    {
+        return v + Translation;
+    }
+
+    Vector3<T> Apply(const Vector3<T>& v) const
+    {
+        return Translate(Rotate(v));
+    }
+
+    Pose operator*(const Pose& other) const   
+    {
+        return Pose(Rotation * other.Rotation, Apply(other.Translation));
+    }
+
+    Pose Inverted() const   
+    {
+        Quat<T> inv = Rotation.Inverted();
+        return Pose(inv, inv.Rotate(-Translation));
+    }
+};
+
+typedef Pose<float>  Posef;
+typedef Pose<double> Posed;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Matrix4
+//
+// Matrix4 is a 4x4 matrix used for 3d transformations and projections.
+// Translation stored in the last column.
+// The matrix is stored in row-major order in memory, meaning that values
+// of the first row are stored before the next one.
+//
+// The arrangement of the matrix is chosen to be in Right-Handed 
+// coordinate system and counterclockwise rotations when looking down
+// the axis
+//
+// Transformation Order:
+//   - Transformations are applied from right to left, so the expression
+//     M1 * M2 * M3 * V means that the vector V is transformed by M3 first,
+//     followed by M2 and M1. 
+//
+// Coordinate system: Right Handed
+//
+// Rotations: Counterclockwise when looking down the axis. All angles are in radians.
+//    
+//  | sx   01   02   tx |    // First column  (sx, 10, 20): Axis X basis vector.
+//  | 10   sy   12   ty |    // Second column (01, sy, 21): Axis Y basis vector.
+//  | 20   21   sz   tz |    // Third columnt (02, 12, sz): Axis Z basis vector.
+//  | 30   31   32   33 |
+//
+//  The basis vectors are first three columns.
+
+template<class T>
+class Matrix4
+{
+    static const Matrix4 IdentityValue;
+
+public:
+    T M[4][4];    
+
+    enum NoInitType { NoInit };
+
+    // Construct with no memory initialization.
+    Matrix4(NoInitType) { }
+
+    // By default, we construct identity matrix.
+    Matrix4()
+    {
+        SetIdentity();        
+    }
+
+    Matrix4(T m11, T m12, T m13, T m14,
+            T m21, T m22, T m23, T m24,
+            T m31, T m32, T m33, T m34,
+            T m41, T m42, T m43, T m44)
+    {
+        M[0][0] = m11; M[0][1] = m12; M[0][2] = m13; M[0][3] = m14;
+        M[1][0] = m21; M[1][1] = m22; M[1][2] = m23; M[1][3] = m24;
+        M[2][0] = m31; M[2][1] = m32; M[2][2] = m33; M[2][3] = m34;
+        M[3][0] = m41; M[3][1] = m42; M[3][2] = m43; M[3][3] = m44;
+    }
+
+    Matrix4(T m11, T m12, T m13,
+            T m21, T m22, T m23,
+            T m31, T m32, T m33)
+    {
+        M[0][0] = m11; M[0][1] = m12; M[0][2] = m13; M[0][3] = 0;
+        M[1][0] = m21; M[1][1] = m22; M[1][2] = m23; M[1][3] = 0;
+        M[2][0] = m31; M[2][1] = m32; M[2][2] = m33; M[2][3] = 0;
+        M[3][0] = 0;   M[3][1] = 0;   M[3][2] = 0;   M[3][3] = 1;
+    }
+
+    explicit Matrix4(const Quat<T>& q)
+    {
+        T ww = q.w*q.w;
+        T xx = q.x*q.x;
+        T yy = q.y*q.y;
+        T zz = q.z*q.z;
+
+        M[0][0] = ww + xx - yy - zz;       M[0][1] = 2 * (q.x*q.y - q.w*q.z); M[0][2] = 2 * (q.x*q.z + q.w*q.y); M[0][3] = 0;
+        M[1][0] = 2 * (q.x*q.y + q.w*q.z); M[1][1] = ww - xx + yy - zz;       M[1][2] = 2 * (q.y*q.z - q.w*q.x); M[1][3] = 0;
+        M[2][0] = 2 * (q.x*q.z - q.w*q.y); M[2][1] = 2 * (q.y*q.z + q.w*q.x); M[2][2] = ww - xx - yy + zz;       M[2][3] = 0;
+        M[3][0] = 0;                       M[3][1] = 0;                       M[3][2] = 0;                       M[3][3] = 1;
+    }
+
+    explicit Matrix4(const Pose<T>& p)
+    {
+        Matrix4 result(p.Rotation);
+        result.SetTranslation(p.Translation);
+        *this = result;
+    }
+
+    // C-interop support
+    explicit Matrix4(const Matrix4<typename Math<T>::OtherFloatType> &src)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] = (T)src.M[i][j];
+    }
+
+    // C-interop support.
+    Matrix4(const typename CompatibleTypes<Matrix4<T> >::Type& s) 
+    {
+        OVR_COMPILER_ASSERT(sizeof(s) == sizeof(Matrix4));
+        memcpy(M, s.M, sizeof(M));
+    }
+
+    operator typename CompatibleTypes<Matrix4<T> >::Type () const
+    {
+        typename CompatibleTypes<Matrix4<T> >::Type result;
+        OVR_COMPILER_ASSERT(sizeof(result) == sizeof(Matrix4));
+        memcpy(result.M, M, sizeof(M));
+        return result;
+    }
+
+    void ToString(char* dest, size_t destsize) const
+    {
+        size_t pos = 0;
+        for (int r=0; r<4; r++)
+            for (int c=0; c<4; c++)
+                pos += OVR_sprintf(dest+pos, destsize-pos, "%g ", M[r][c]);
+    }
+
+    static Matrix4 FromString(const char* src)
+    {
+        Matrix4 result;
+		if (src)
+		{
+        for (int r=0; r<4; r++)
+			{
+            for (int c=0; c<4; c++)
+            {
+                result.M[r][c] = (T)atof(src);
+                while (src && *src != ' ')
+					{
+                    src++;
+					}
+                while (src && *src == ' ')
+					{
+                    src++;
+            }
+				}
+			}
+		}
+        return result;
+    }
+
+    static const Matrix4& Identity()  { return IdentityValue; }
+
+    void SetIdentity()
+    {
+        M[0][0] = M[1][1] = M[2][2] = M[3][3] = 1;
+        M[0][1] = M[1][0] = M[2][3] = M[3][1] = 0;
+        M[0][2] = M[1][2] = M[2][0] = M[3][2] = 0;
+        M[0][3] = M[1][3] = M[2][1] = M[3][0] = 0;
+    }
+
+	void SetXBasis(const Vector3f & v)
+	{
+		M[0][0] = v.x;
+		M[1][0] = v.y;
+		M[2][0] = v.z;
+	}
+	Vector3f GetXBasis() const
+	{
+		return Vector3f(M[0][0], M[1][0], M[2][0]);
+	}
+
+	void SetYBasis(const Vector3f & v)
+	{
+		M[0][1] = v.x;
+		M[1][1] = v.y;
+		M[2][1] = v.z;
+	}
+	Vector3f GetYBasis() const
+	{
+		return Vector3f(M[0][1], M[1][1], M[2][1]);
+	}
+
+	void SetZBasis(const Vector3f & v)
+	{
+		M[0][2] = v.x;
+		M[1][2] = v.y;
+		M[2][2] = v.z;
+	}
+	Vector3f GetZBasis() const
+	{
+		return Vector3f(M[0][2], M[1][2], M[2][2]);
+	}
+
+	bool operator== (const Matrix4& b) const
+	{
+		bool isEqual = true;
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                isEqual &= (M[i][j] == b.M[i][j]);
+
+		return isEqual;
+	}
+
+    Matrix4 operator+ (const Matrix4& b) const
+    {
+        Matrix4 result(*this);
+        result += b;
+        return result;
+    }
+
+    Matrix4& operator+= (const Matrix4& b)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] += b.M[i][j];
+        return *this;
+    }
+
+    Matrix4 operator- (const Matrix4& b) const
+    {
+        Matrix4 result(*this);
+        result -= b;
+        return result;
+    }
+
+    Matrix4& operator-= (const Matrix4& b)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] -= b.M[i][j];
+        return *this;
+    }
+
+    // Multiplies two matrices into destination with minimum copying.
+    static Matrix4& Multiply(Matrix4* d, const Matrix4& a, const Matrix4& b)
+    {
+        OVR_ASSERT((d != &a) && (d != &b));
+        int i = 0;
+        do {
+            d->M[i][0] = a.M[i][0] * b.M[0][0] + a.M[i][1] * b.M[1][0] + a.M[i][2] * b.M[2][0] + a.M[i][3] * b.M[3][0];
+            d->M[i][1] = a.M[i][0] * b.M[0][1] + a.M[i][1] * b.M[1][1] + a.M[i][2] * b.M[2][1] + a.M[i][3] * b.M[3][1];
+            d->M[i][2] = a.M[i][0] * b.M[0][2] + a.M[i][1] * b.M[1][2] + a.M[i][2] * b.M[2][2] + a.M[i][3] * b.M[3][2];
+            d->M[i][3] = a.M[i][0] * b.M[0][3] + a.M[i][1] * b.M[1][3] + a.M[i][2] * b.M[2][3] + a.M[i][3] * b.M[3][3];
+        } while((++i) < 4);
+
+        return *d;
+    }
+
+    Matrix4 operator* (const Matrix4& b) const
+    {
+        Matrix4 result(Matrix4::NoInit);
+        Multiply(&result, *this, b);
+        return result;
+    }
+
+    Matrix4& operator*= (const Matrix4& b)
+    {
+        return Multiply(this, Matrix4(*this), b);
+    }
+
+    Matrix4 operator* (T s) const
+    {
+        Matrix4 result(*this);
+        result *= s;
+        return result;
+    }
+
+    Matrix4& operator*= (T s)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] *= s;
+        return *this;
+    }
+
+
+    Matrix4 operator/ (T s) const
+    {
+        Matrix4 result(*this);
+        result /= s;
+        return result;
+    }
+
+    Matrix4& operator/= (T s)
+    {
+        for (int i = 0; i < 4; i++)
+            for (int j = 0; j < 4; j++)
+                M[i][j] /= s;
+        return *this;
+    }
+
+    Vector3<T> Transform(const Vector3<T>& v) const
+    {
+		const T rcpW = 1.0f / (M[3][0] * v.x + M[3][1] * v.y + M[3][2] * v.z + M[3][3]);
+		return Vector3<T>((M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z + M[0][3]) * rcpW,
+						  (M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z + M[1][3]) * rcpW,
+						  (M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z + M[2][3]) * rcpW);
+	}
+
+	Vector4<T> Transform(const Vector4<T>& v) const
+	{
+		return Vector4<T>(M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z + M[0][3] * v.w,
+						  M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z + M[1][3] * v.w,
+						  M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z + M[2][3] * v.w,
+						  M[3][0] * v.x + M[3][1] * v.y + M[3][2] * v.z + M[3][3] * v.w);
+    }
+
+    Matrix4 Transposed() const
+    {
+        return Matrix4(M[0][0], M[1][0], M[2][0], M[3][0],
+                        M[0][1], M[1][1], M[2][1], M[3][1],
+                        M[0][2], M[1][2], M[2][2], M[3][2],
+                        M[0][3], M[1][3], M[2][3], M[3][3]);
+    }
+
+    void     Transpose()
+    {
+        *this = Transposed();
+    }
+
+
+    T SubDet (const size_t* rows, const size_t* cols) const
+    {
+        return M[rows[0]][cols[0]] * (M[rows[1]][cols[1]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[1]])
+             - M[rows[0]][cols[1]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[0]])
+             + M[rows[0]][cols[2]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[1]] - M[rows[1]][cols[1]] * M[rows[2]][cols[0]]);
+    }
+
+    T Cofactor(size_t I, size_t J) const
+    {
+        const size_t indices[4][3] = {{1,2,3},{0,2,3},{0,1,3},{0,1,2}};
+        return ((I+J)&1) ? -SubDet(indices[I],indices[J]) : SubDet(indices[I],indices[J]);
+    }
+
+    T    Determinant() const
+    {
+        return M[0][0] * Cofactor(0,0) + M[0][1] * Cofactor(0,1) + M[0][2] * Cofactor(0,2) + M[0][3] * Cofactor(0,3);
+    }
+
+    Matrix4 Adjugated() const
+    {
+        return Matrix4(Cofactor(0,0), Cofactor(1,0), Cofactor(2,0), Cofactor(3,0), 
+                        Cofactor(0,1), Cofactor(1,1), Cofactor(2,1), Cofactor(3,1), 
+                        Cofactor(0,2), Cofactor(1,2), Cofactor(2,2), Cofactor(3,2),
+                        Cofactor(0,3), Cofactor(1,3), Cofactor(2,3), Cofactor(3,3));
+    }
+
+    Matrix4 Inverted() const
+    {
+        T det = Determinant();
+        assert(det != 0);
+        return Adjugated() * (1.0f/det);
+    }
+
+    void Invert()
+    {
+        *this = Inverted();
+    }
+
+	// This is more efficient than general inverse, but ONLY works
+	// correctly if it is a homogeneous transform matrix (rot + trans)
+	Matrix4 InvertedHomogeneousTransform() const
+	{
+		// Make the inverse rotation matrix
+		Matrix4 rinv = this->Transposed();
+		rinv.M[3][0] = rinv.M[3][1] = rinv.M[3][2] = 0.0f;
+		// Make the inverse translation matrix
+		Vector3<T> tvinv(-M[0][3],-M[1][3],-M[2][3]);
+		Matrix4 tinv = Matrix4::Translation(tvinv);
+		return rinv * tinv;  // "untranslate", then "unrotate"
+	}
+
+	// This is more efficient than general inverse, but ONLY works
+	// correctly if it is a homogeneous transform matrix (rot + trans)
+	void InvertHomogeneousTransform()
+	{
+        *this = InvertedHomogeneousTransform();
+	}
+
+	// Matrix to Euler Angles conversion
+    // a,b,c, are the YawPitchRoll angles to be returned
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A3
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, Axis A3, RotateDirection D, HandedSystem S>
+    void ToEulerAngles(T *a, T *b, T *c) const
+    {
+        OVR_COMPILER_ASSERT((A1 != A2) && (A2 != A3) && (A1 != A3));
+
+        T psign = -1;
+        if (((A1 + 1) % 3 == A2) && ((A2 + 1) % 3 == A3)) // Determine whether even permutation
+        psign = 1;
+        
+        T pm = psign*M[A1][A3];
+        if (pm < -1.0f + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = 0;
+            *b = -S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2( psign*M[A2][A1], M[A2][A2] );
+        }
+        else if (pm > 1.0f - Math<T>::SingularityRadius)
+        { // North pole singularity
+            *a = 0;
+            *b = S*D*((T)MATH_DOUBLE_PIOVER2);
+            *c = S*D*atan2( psign*M[A2][A1], M[A2][A2] );
+        }
+        else
+        { // Normal case (nonsingular)
+            *a = S*D*atan2( -psign*M[A2][A3], M[A3][A3] );
+            *b = S*D*asin(pm);
+            *c = S*D*atan2( -psign*M[A1][A2], M[A1][A1] );
+        }
+
+        return;
+    }
+
+	// Matrix to Euler Angles conversion
+    // a,b,c, are the YawPitchRoll angles to be returned
+    // rotation a around axis A1
+    // is followed by rotation b around axis A2
+    // is followed by rotation c around axis A1
+    // rotations are CCW or CW (D) in LH or RH coordinate system (S)
+    template <Axis A1, Axis A2, RotateDirection D, HandedSystem S>
+    void ToEulerAnglesABA(T *a, T *b, T *c) const
+    {        
+         OVR_COMPILER_ASSERT(A1 != A2);
+  
+        // Determine the axis that was not supplied
+        int m = 3 - A1 - A2;
+
+        T psign = -1;
+        if ((A1 + 1) % 3 == A2) // Determine whether even permutation
+            psign = 1.0f;
+
+        T c2 = M[A1][A1];
+        if (c2 < -1 + Math<T>::SingularityRadius)
+        { // South pole singularity
+            *a = 0;
+            *b = S*D*((T)MATH_DOUBLE_PI);
+            *c = S*D*atan2( -psign*M[A2][m],M[A2][A2]);
+        }
+        else if (c2 > 1.0f - Math<T>::SingularityRadius)
+        { // North pole singularity
+            *a = 0;
+            *b = 0;
+            *c = S*D*atan2( -psign*M[A2][m],M[A2][A2]);
+        }
+        else
+        { // Normal case (nonsingular)
+            *a = S*D*atan2( M[A2][A1],-psign*M[m][A1]);
+            *b = S*D*acos(c2);
+            *c = S*D*atan2( M[A1][A2],psign*M[A1][m]);
+        }
+        return;
+    }
+  
+    // Creates a matrix that converts the vertices from one coordinate system
+    // to another.
+    static Matrix4 AxisConversion(const WorldAxes& to, const WorldAxes& from)
+    {        
+        // Holds axis values from the 'to' structure
+        int toArray[3] = { to.XAxis, to.YAxis, to.ZAxis };
+
+        // The inverse of the toArray
+        int inv[4]; 
+        inv[0] = inv[abs(to.XAxis)] = 0;
+        inv[abs(to.YAxis)] = 1;
+        inv[abs(to.ZAxis)] = 2;
+
+        Matrix4 m(0,  0,  0, 
+                  0,  0,  0,
+                  0,  0,  0);
+
+        // Only three values in the matrix need to be changed to 1 or -1.
+        m.M[inv[abs(from.XAxis)]][0] = T(from.XAxis/toArray[inv[abs(from.XAxis)]]);
+        m.M[inv[abs(from.YAxis)]][1] = T(from.YAxis/toArray[inv[abs(from.YAxis)]]);
+        m.M[inv[abs(from.ZAxis)]][2] = T(from.ZAxis/toArray[inv[abs(from.ZAxis)]]);
+        return m;
+    } 
+
+
+	// Creates a matrix for translation by vector
+    static Matrix4 Translation(const Vector3<T>& v)
+    {
+        Matrix4 t;
+        t.M[0][3] = v.x;
+        t.M[1][3] = v.y;
+        t.M[2][3] = v.z;
+        return t;
+    }
+
+	// Creates a matrix for translation by vector
+    static Matrix4 Translation(T x, T y, T z = 0.0f)
+    {
+        Matrix4 t;
+        t.M[0][3] = x;
+        t.M[1][3] = y;
+        t.M[2][3] = z;
+        return t;
+    }
+
+	// Sets the translation part
+    void SetTranslation(const Vector3<T>& v)
+    {
+        M[0][3] = v.x;
+        M[1][3] = v.y;
+        M[2][3] = v.z;
+    }
+
+    Vector3<T> GetTranslation() const
+    {
+        return Vector3<T>( M[0][3], M[1][3], M[2][3] );
+    }
+
+	// Creates a matrix for scaling by vector
+    static Matrix4 Scaling(const Vector3<T>& v)
+    {
+        Matrix4 t;
+        t.M[0][0] = v.x;
+        t.M[1][1] = v.y;
+        t.M[2][2] = v.z;
+        return t;
+    }
+
+	// Creates a matrix for scaling by vector
+    static Matrix4 Scaling(T x, T y, T z)
+    {
+        Matrix4 t;
+        t.M[0][0] = x;
+        t.M[1][1] = y;
+        t.M[2][2] = z;
+        return t;
+    }
+
+	// Creates a matrix for scaling by constant
+    static Matrix4 Scaling(T s)
+    {
+        Matrix4 t;
+        t.M[0][0] = s;
+        t.M[1][1] = s;
+        t.M[2][2] = s;
+        return t;
+    }
+
+    // Simple L1 distance in R^12
+	T Distance(const Matrix4& m2) const           
+	{ 
+		T d = fabs(M[0][0] - m2.M[0][0]) + fabs(M[0][1] - m2.M[0][1]);
+		d += fabs(M[0][2] - m2.M[0][2]) + fabs(M[0][3] - m2.M[0][3]);
+		d += fabs(M[1][0] - m2.M[1][0]) + fabs(M[1][1] - m2.M[1][1]);
+		d += fabs(M[1][2] - m2.M[1][2]) + fabs(M[1][3] - m2.M[1][3]);
+		d += fabs(M[2][0] - m2.M[2][0]) + fabs(M[2][1] - m2.M[2][1]);
+		d += fabs(M[2][2] - m2.M[2][2]) + fabs(M[2][3] - m2.M[2][3]);
+		d += fabs(M[3][0] - m2.M[3][0]) + fabs(M[3][1] - m2.M[3][1]);
+		d += fabs(M[3][2] - m2.M[3][2]) + fabs(M[3][3] - m2.M[3][3]);
+		return d; 
+	}
+
+    // Creates a rotation matrix rotating around the X axis by 'angle' radians.
+    // Just for quick testing.  Not for final API.  Need to remove case.
+    static Matrix4 RotationAxis(Axis A, T angle, RotateDirection d, HandedSystem s)
+    {
+        T sina = s * d *sin(angle);
+        T cosa = cos(angle);
+        
+        switch(A)
+        {
+        case Axis_X:
+            return Matrix4(1,  0,     0, 
+                           0,  cosa,  -sina,
+                           0,  sina,  cosa);
+        case Axis_Y:
+            return Matrix4(cosa,  0,   sina, 
+                           0,     1,   0,
+                           -sina, 0,   cosa);
+        case Axis_Z:
+            return Matrix4(cosa,  -sina,  0, 
+                           sina,  cosa,   0,
+                           0,     0,      1);
+        }
+    }
+
+
+    // Creates a rotation matrix rotating around the X axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    // RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    // LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationX(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(1,  0,     0, 
+                       0,  cosa,  -sina,
+                       0,  sina,  cosa);
+    }
+
+    // Creates a rotation matrix rotating around the Y axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    //  RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    //  LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationY(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(cosa,  0,   sina, 
+                       0,     1,   0,
+                       -sina, 0,   cosa);
+    }
+
+    // Creates a rotation matrix rotating around the Z axis by 'angle' radians.
+    // Rotation direction is depends on the coordinate system:
+    //  RHS (Oculus default): Positive angle values rotate Counter-clockwise (CCW),
+    //                        while looking in the negative axis direction. This is the
+    //                        same as looking down from positive axis values towards origin.
+    //  LHS: Positive angle values rotate clock-wise (CW), while looking in the
+    //       negative axis direction.
+    static Matrix4 RotationZ(T angle)
+    {
+        T sina = sin(angle);
+        T cosa = cos(angle);
+        return Matrix4(cosa,  -sina,  0, 
+                       sina,  cosa,   0,
+                       0,     0,      1);
+    }
+
+    // LookAtRH creates a View transformation matrix for right-handed coordinate system.
+    // The resulting matrix points camera from 'eye' towards 'at' direction, with 'up'
+    // specifying the up vector. The resulting matrix should be used with PerspectiveRH
+    // projection.
+    static Matrix4 LookAtRH(const Vector3<T>& eye, const Vector3<T>& at, const Vector3<T>& up)
+    {
+        Vector3<T> z = (eye - at).Normalized();  // Forward
+        Vector3<T> x = up.Cross(z).Normalized(); // Right
+        Vector3<T> y = z.Cross(x);
+
+        Matrix4 m(x.x,  x.y,  x.z,  -(x.Dot(eye)),
+                  y.x,  y.y,  y.z,  -(y.Dot(eye)),
+                  z.x,  z.y,  z.z,  -(z.Dot(eye)),
+                  0,    0,    0,    1 );
+        return m;
+    }
+    
+    // LookAtLH creates a View transformation matrix for left-handed coordinate system.
+    // The resulting matrix points camera from 'eye' towards 'at' direction, with 'up'
+    // specifying the up vector. 
+    static Matrix4 LookAtLH(const Vector3<T>& eye, const Vector3<T>& at, const Vector3<T>& up)
+    {
+        Vector3<T> z = (at - eye).Normalized();  // Forward
+        Vector3<T> x = up.Cross(z).Normalized(); // Right
+        Vector3<T> y = z.Cross(x);
+
+        Matrix4 m(x.x,  x.y,  x.z,  -(x.Dot(eye)),
+                  y.x,  y.y,  y.z,  -(y.Dot(eye)),
+                  z.x,  z.y,  z.z,  -(z.Dot(eye)),
+                  0,    0,    0,    1 ); 
+        return m;
+    }
+    
+    // PerspectiveRH creates a right-handed perspective projection matrix that can be
+    // used with the Oculus sample renderer. 
+    //  yfov   - Specifies vertical field of view in radians.
+    //  aspect - Screen aspect ration, which is usually width/height for square pixels.
+    //           Note that xfov = yfov * aspect.
+    //  znear  - Absolute value of near Z clipping clipping range.
+    //  zfar   - Absolute value of far  Z clipping clipping range (larger then near).
+    // Even though RHS usually looks in the direction of negative Z, positive values
+    // are expected for znear and zfar.
+    static Matrix4 PerspectiveRH(T yfov, T aspect, T znear, T zfar)
+    {
+        Matrix4 m;
+        T tanHalfFov = tan(yfov * 0.5f);
+
+        m.M[0][0] = 1. / (aspect * tanHalfFov);
+        m.M[1][1] = 1. / tanHalfFov;
+        m.M[2][2] = zfar / (znear - zfar);
+        m.M[3][2] = -1.;
+        m.M[2][3] = (zfar * znear) / (znear - zfar);
+        m.M[3][3] = 0.;
+
+        // Note: Post-projection matrix result assumes Left-Handed coordinate system,
+        //       with Y up, X right and Z forward. This supports positive z-buffer values.
+		// This is the case even for RHS coordinate input.
+        return m;
+    }
+    
+    // PerspectiveLH creates a left-handed perspective projection matrix that can be
+    // used with the Oculus sample renderer. 
+    //  yfov   - Specifies vertical field of view in radians.
+    //  aspect - Screen aspect ration, which is usually width/height for square pixels.
+    //           Note that xfov = yfov * aspect.
+    //  znear  - Absolute value of near Z clipping clipping range.
+    //  zfar   - Absolute value of far  Z clipping clipping range (larger then near).
+    static Matrix4 PerspectiveLH(T yfov, T aspect, T znear, T zfar)
+    {
+        Matrix4 m;
+        T tanHalfFov = tan(yfov * 0.5f);
+
+        m.M[0][0] = 1. / (aspect * tanHalfFov);
+        m.M[1][1] = 1. / tanHalfFov;
+        //m.M[2][2] = zfar / (znear - zfar);
+         m.M[2][2] = zfar / (zfar - znear);
+        m.M[3][2] = -1.;
+        m.M[2][3] = (zfar * znear) / (znear - zfar);
+        m.M[3][3] = 0.;
+
+        // Note: Post-projection matrix result assumes Left-Handed coordinate system,    
+        //       with Y up, X right and Z forward. This supports positive z-buffer values.
+        // This is the case even for RHS coordinate input. 
+        return m;
+    }
+
+    static Matrix4 Ortho2D(T w, T h)
+    {
+        Matrix4 m;
+        m.M[0][0] = 2.0/w;
+        m.M[1][1] = -2.0/h;
+        m.M[0][3] = -1.0;
+        m.M[1][3] = 1.0;
+        m.M[2][2] = 0;
+        return m;
+    }
+};
+
+typedef Matrix4<float>  Matrix4f;
+typedef Matrix4<double> Matrix4d;
+
+//-------------------------------------------------------------------------------------
+// ***** Matrix3
+//
+// Matrix3 is a 3x3 matrix used for representing a rotation matrix.
+// The matrix is stored in row-major order in memory, meaning that values
+// of the first row are stored before the next one.
+//
+// The arrangement of the matrix is chosen to be in Right-Handed 
+// coordinate system and counterclockwise rotations when looking down
+// the axis
+//
+// Transformation Order:
+//   - Transformations are applied from right to left, so the expression
+//     M1 * M2 * M3 * V means that the vector V is transformed by M3 first,
+//     followed by M2 and M1. 
+//
+// Coordinate system: Right Handed
+//
+// Rotations: Counterclockwise when looking down the axis. All angles are in radians.
+
+template<typename T>
+class SymMat3;
+
+template<class T>
+class Matrix3
+{
+	static const Matrix3 IdentityValue;
+
+public:
+	T M[3][3];    
+
+	enum NoInitType { NoInit };
+
+	// Construct with no memory initialization.
+	Matrix3(NoInitType) { }
+
+	// By default, we construct identity matrix.
+	Matrix3()
+	{
+		SetIdentity();        
+	}
+
+	Matrix3(T m11, T m12, T m13,
+			T m21, T m22, T m23,
+			T m31, T m32, T m33)
+	{
+		M[0][0] = m11; M[0][1] = m12; M[0][2] = m13;
+		M[1][0] = m21; M[1][1] = m22; M[1][2] = m23;
+		M[2][0] = m31; M[2][1] = m32; M[2][2] = m33;
+	}
+	
+	/*
+	explicit Matrix3(const Quat<T>& q)
+	{
+		T ww = q.w*q.w;
+		T xx = q.x*q.x;
+		T yy = q.y*q.y;
+		T zz = q.z*q.z;
+
+		M[0][0] = ww + xx - yy - zz;       M[0][1] = 2 * (q.x*q.y - q.w*q.z); M[0][2] = 2 * (q.x*q.z + q.w*q.y);
+		M[1][0] = 2 * (q.x*q.y + q.w*q.z); M[1][1] = ww - xx + yy - zz;       M[1][2] = 2 * (q.y*q.z - q.w*q.x);
+		M[2][0] = 2 * (q.x*q.z - q.w*q.y); M[2][1] = 2 * (q.y*q.z + q.w*q.x); M[2][2] = ww - xx - yy + zz;      
+	}
+	*/
+	
+	explicit Matrix3(const Quat<T>& q)
+	{
+		const T tx  = q.x+q.x,  ty  = q.y+q.y,  tz  = q.z+q.z;
+		const T twx = q.w*tx,   twy = q.w*ty,   twz = q.w*tz;
+		const T txx = q.x*tx,   txy = q.x*ty,   txz = q.x*tz;
+		const T tyy = q.y*ty,   tyz = q.y*tz,   tzz = q.z*tz;
+		M[0][0] = T(1) - (tyy + tzz);	M[0][1] = txy - twz;			M[0][2] = txz + twy;
+		M[1][0] = txy + twz;			M[1][1] = T(1) - (txx + tzz);	M[1][2] = tyz - twx;
+		M[2][0] = txz - twy;			M[2][1] = tyz + twx;			M[2][2] = T(1) - (txx + tyy);
+	}
+	
+	inline explicit Matrix3(T s)
+    {
+        M[0][0] = M[1][1] = M[2][2] = s;
+        M[0][1] = M[0][2] = M[1][0] = M[1][2] = M[2][0] = M[2][1] = 0;
+    }
+
+	explicit Matrix3(const Pose<T>& p)
+	{
+		Matrix3 result(p.Rotation);
+		result.SetTranslation(p.Translation);
+		*this = result;
+	}
+
+	// C-interop support
+	explicit Matrix3(const Matrix4<typename Math<T>::OtherFloatType> &src)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = (T)src.M[i][j];
+	}
+
+	// C-interop support.
+	Matrix3(const typename CompatibleTypes<Matrix3<T> >::Type& s) 
+	{
+		OVR_COMPILER_ASSERT(sizeof(s) == sizeof(Matrix3));
+		memcpy(M, s.M, sizeof(M));
+	}
+
+	operator const typename CompatibleTypes<Matrix3<T> >::Type () const
+	{
+		typename CompatibleTypes<Matrix3<T> >::Type result;
+		OVR_COMPILER_ASSERT(sizeof(result) == sizeof(Matrix3));
+		memcpy(result.M, M, sizeof(M));
+		return result;
+	}
+
+	void ToString(char* dest, size_t destsize) const
+	{
+		size_t pos = 0;
+		for (int r=0; r<3; r++)
+			for (int c=0; c<3; c++)
+				pos += OVR_sprintf(dest+pos, destsize-pos, "%g ", M[r][c]);
+	}
+
+	static Matrix3 FromString(const char* src)
+	{
+		Matrix3 result;
+		for (int r=0; r<3; r++)
+			for (int c=0; c<3; c++)
+			{
+				result.M[r][c] = (T)atof(src);
+				while (src && *src != ' ')
+					src++;
+				while (src && *src == ' ')
+					src++;
+			}
+			return result;
+	}
+
+	static const Matrix3& Identity()  { return IdentityValue; }
+
+	void SetIdentity()
+	{
+		M[0][0] = M[1][1] = M[2][2] = 1;
+		M[0][1] = M[1][0] = M[2][0] = 0;
+		M[0][2] = M[1][2] = M[2][1] = 0;
+	}
+
+	bool operator== (const Matrix3& b) const
+	{
+		bool isEqual = true;
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				isEqual &= (M[i][j] == b.M[i][j]);
+
+		return isEqual;
+	}
+
+	Matrix3 operator+ (const Matrix3& b) const
+	{
+        Matrix4<T> result(*this);
+		result += b;
+		return result;
+	}
+
+	Matrix3& operator+= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] += b.M[i][j];
+		return *this;
+	}
+
+	void operator= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = b.M[i][j];
+		return;
+	}
+
+	void operator= (const SymMat3<T>& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] = 0;
+
+		M[0][0] = b.v[0];
+		M[0][1] = b.v[1];
+		M[0][2] = b.v[2];
+		M[1][1] = b.v[3];
+		M[1][2] = b.v[4];
+		M[2][2] = b.v[5];
+
+		return;
+	}
+
+	Matrix3 operator- (const Matrix3& b) const
+	{
+		Matrix3 result(*this);
+		result -= b;
+		return result;
+	}
+
+	Matrix3& operator-= (const Matrix3& b)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] -= b.M[i][j];
+		return *this;
+	}
+
+	// Multiplies two matrices into destination with minimum copying.
+	static Matrix3& Multiply(Matrix3* d, const Matrix3& a, const Matrix3& b)
+	{
+		OVR_ASSERT((d != &a) && (d != &b));
+		int i = 0;
+		do {
+			d->M[i][0] = a.M[i][0] * b.M[0][0] + a.M[i][1] * b.M[1][0] + a.M[i][2] * b.M[2][0];
+			d->M[i][1] = a.M[i][0] * b.M[0][1] + a.M[i][1] * b.M[1][1] + a.M[i][2] * b.M[2][1];
+			d->M[i][2] = a.M[i][0] * b.M[0][2] + a.M[i][1] * b.M[1][2] + a.M[i][2] * b.M[2][2];
+		} while((++i) < 3);
+
+		return *d;
+	}
+
+	Matrix3 operator* (const Matrix3& b) const
+	{
+		Matrix3 result(Matrix3::NoInit);
+		Multiply(&result, *this, b);
+		return result;
+	}
+
+	Matrix3& operator*= (const Matrix3& b)
+	{
+		return Multiply(this, Matrix3(*this), b);
+	}
+
+	Matrix3 operator* (T s) const
+	{
+		Matrix3 result(*this);
+		result *= s;
+		return result;
+	}
+
+	Matrix3& operator*= (T s)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] *= s;
+		return *this;
+	}
+
+	Vector3<T> operator* (const Vector3<T> &b) const
+	{
+		Vector3<T> result;
+		result.x = M[0][0]*b.x + M[0][1]*b.y + M[0][2]*b.z;
+		result.y = M[1][0]*b.x + M[1][1]*b.y + M[1][2]*b.z;
+		result.z = M[2][0]*b.x + M[2][1]*b.y + M[2][2]*b.z;
+
+		return result;
+	}
+
+	Matrix3 operator/ (T s) const
+	{
+		Matrix3 result(*this);
+		result /= s;
+		return result;
+	}
+
+	Matrix3& operator/= (T s)
+	{
+		for (int i = 0; i < 3; i++)
+			for (int j = 0; j < 3; j++)
+				M[i][j] /= s;
+		return *this;
+	}
+
+	Vector2<T> Transform(const Vector2<T>& v) const
+	{
+		const float rcpZ = 1.0f / (M[2][0] * v.x + M[2][1] * v.y + M[2][2]);
+		return Vector2<T>((M[0][0] * v.x + M[0][1] * v.y + M[0][2]) * rcpZ,
+						  (M[1][0] * v.x + M[1][1] * v.y + M[1][2]) * rcpZ);
+	}
+
+	Vector3<T> Transform(const Vector3<T>& v) const
+	{
+		return Vector3<T>(M[0][0] * v.x + M[0][1] * v.y + M[0][2] * v.z,
+						  M[1][0] * v.x + M[1][1] * v.y + M[1][2] * v.z,
+						  M[2][0] * v.x + M[2][1] * v.y + M[2][2] * v.z);
+	}
+
+	Matrix3 Transposed() const
+	{
+		return Matrix3(M[0][0], M[1][0], M[2][0],
+					   M[0][1], M[1][1], M[2][1],
+					   M[0][2], M[1][2], M[2][2]);
+	}
+
+	void     Transpose()
+	{
+		*this = Transposed();
+	}
+
+
+	T SubDet (const size_t* rows, const size_t* cols) const
+	{
+		return M[rows[0]][cols[0]] * (M[rows[1]][cols[1]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[1]])
+			 - M[rows[0]][cols[1]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[2]] - M[rows[1]][cols[2]] * M[rows[2]][cols[0]])
+			 + M[rows[0]][cols[2]] * (M[rows[1]][cols[0]] * M[rows[2]][cols[1]] - M[rows[1]][cols[1]] * M[rows[2]][cols[0]]);
+	}
+
+	// M += a*b.t()
+	inline void Rank1Add(const Vector3<T> &a, const Vector3<T> &b)
+	{
+		M[0][0] += a.x*b.x;		M[0][1] += a.x*b.y;		M[0][2] += a.x*b.z;
+		M[1][0] += a.y*b.x;		M[1][1] += a.y*b.y;		M[1][2] += a.y*b.z;
+		M[2][0] += a.z*b.x;		M[2][1] += a.z*b.y;		M[2][2] += a.z*b.z;
+	}
+
+	// M -= a*b.t()
+	inline void Rank1Sub(const Vector3<T> &a, const Vector3<T> &b)
+	{
+		M[0][0] -= a.x*b.x;		M[0][1] -= a.x*b.y;		M[0][2] -= a.x*b.z;
+		M[1][0] -= a.y*b.x;		M[1][1] -= a.y*b.y;		M[1][2] -= a.y*b.z;
+		M[2][0] -= a.z*b.x;		M[2][1] -= a.z*b.y;		M[2][2] -= a.z*b.z;
+	}
+
+	inline Vector3<T> Col(int c) const
+	{
+		return Vector3<T>(M[0][c], M[1][c], M[2][c]);
+	}
+
+	inline Vector3<T> Row(int r) const
+	{
+        return Vector3<T>(M[r][0], M[r][1], M[r][2]);
+	}
+
+	inline T Determinant() const
+	{
+		const Matrix3<T>& m = *this;
+		T d; 
+
+		d  = m.M[0][0] * (m.M[1][1]*m.M[2][2] - m.M[1][2] * m.M[2][1]);
+		d -= m.M[0][1] * (m.M[1][0]*m.M[2][2] - m.M[1][2] * m.M[2][0]);
+		d += m.M[0][2] * (m.M[1][0]*m.M[2][1] - m.M[1][1] * m.M[2][0]);
+
+		return d;
+	}
+	
+	inline Matrix3<T> Inverse() const
+    {
+        Matrix3<T> a;
+        const  Matrix3<T>& m = *this;
+        T d = Determinant();
+
+        assert(d != 0);
+        T s = T(1)/d;
+
+        a.M[0][0] = s * (m.M[1][1] * m.M[2][2] - m.M[1][2] * m.M[2][1]);   
+        a.M[1][0] = s * (m.M[1][2] * m.M[2][0] - m.M[1][0] * m.M[2][2]);   
+        a.M[2][0] = s * (m.M[1][0] * m.M[2][1] - m.M[1][1] * m.M[2][0]);   
+
+		a.M[0][1] = s * (m.M[0][2] * m.M[2][1] - m.M[0][1] * m.M[2][2]);   
+		a.M[1][1] = s * (m.M[0][0] * m.M[2][2] - m.M[0][2] * m.M[2][0]);   
+		a.M[2][1] = s * (m.M[0][1] * m.M[2][0] - m.M[0][0] * m.M[2][1]);   
+        
+		a.M[0][2] = s * (m.M[0][1] * m.M[1][2] - m.M[0][2] * m.M[1][1]);   
+		a.M[1][2] = s * (m.M[0][2] * m.M[1][0] - m.M[0][0] * m.M[1][2]);   
+		a.M[2][2] = s * (m.M[0][0] * m.M[1][1] - m.M[0][1] * m.M[1][0]);   
+        
+        return a;
+    }
+	
+};
+
+typedef Matrix3<float>  Matrix3f;
+typedef Matrix3<double> Matrix3d;
+
+//-------------------------------------------------------------------------------------
+
+template<typename T>
+class SymMat3
+{
+private:
+	typedef SymMat3<T> this_type;
+
+public:
+	typedef T Value_t;
+	// Upper symmetric
+	T v[6]; // _00 _01 _02 _11 _12 _22
+
+	inline SymMat3() {}
+
+	inline explicit SymMat3(T s)
+	{
+		v[0] = v[3] = v[5] = s;
+		v[1] = v[2] = v[4] = 0;
+	}
+
+	inline explicit SymMat3(T a00, T a01, T a02, T a11, T a12, T a22)
+	{
+		v[0] = a00; v[1] = a01; v[2] = a02;
+		v[3] = a11; v[4] = a12;
+		v[5] = a22;
+	}
+
+	static inline int Index(unsigned int i, unsigned int j)
+	{
+		return (i <= j) ? (3*i - i*(i+1)/2 + j) : (3*j - j*(j+1)/2 + i);
+	}
+
+	inline T operator()(int i, int j) const { return v[Index(i,j)]; }
+	
+	inline T &operator()(int i, int j) { return v[Index(i,j)]; }
+
+	template<typename U>
+	inline SymMat3<U> CastTo() const
+	{
+		return SymMat3<U>(static_cast<U>(v[0]), static_cast<U>(v[1]), static_cast<U>(v[2]),
+						  static_cast<U>(v[3]), static_cast<U>(v[4]), static_cast<U>(v[5]));
+	}
+
+	inline this_type& operator+=(const this_type& b)
+	{
+		v[0]+=b.v[0];
+		v[1]+=b.v[1];
+		v[2]+=b.v[2];
+		v[3]+=b.v[3];
+		v[4]+=b.v[4];
+		v[5]+=b.v[5];
+		return *this;
+	}
+
+	inline this_type& operator-=(const this_type& b)
+	{
+		v[0]-=b.v[0];
+		v[1]-=b.v[1];
+		v[2]-=b.v[2];
+		v[3]-=b.v[3];
+		v[4]-=b.v[4];
+		v[5]-=b.v[5];
+
+		return *this;
+	}
+
+	inline this_type& operator*=(T s)
+	{
+		v[0]*=s;
+		v[1]*=s;
+		v[2]*=s;
+		v[3]*=s;
+		v[4]*=s;
+		v[5]*=s;
+
+		return *this;
+	}
+		
+	inline SymMat3 operator*(T s) const
+	{
+		SymMat3 d;
+		d.v[0] = v[0]*s; 
+		d.v[1] = v[1]*s; 
+		d.v[2] = v[2]*s; 
+		d.v[3] = v[3]*s; 
+		d.v[4] = v[4]*s; 
+		d.v[5] = v[5]*s; 
+						
+		return d;
+	}
+
+	// Multiplies two matrices into destination with minimum copying.
+	static SymMat3& Multiply(SymMat3* d, const SymMat3& a, const SymMat3& b)
+	{		
+		// _00 _01 _02 _11 _12 _22
+
+		d->v[0] = a.v[0] * b.v[0];
+		d->v[1] = a.v[0] * b.v[1] + a.v[1] * b.v[3];
+		d->v[2] = a.v[0] * b.v[2] + a.v[1] * b.v[4];
+					
+		d->v[3] = a.v[3] * b.v[3];
+		d->v[4] = a.v[3] * b.v[4] + a.v[4] * b.v[5];
+				
+		d->v[5] = a.v[5] * b.v[5];
+	
+		return *d;
+	}
+	
+	inline T Determinant() const
+	{
+		const this_type& m = *this;
+		T d; 
+
+		d  = m(0,0) * (m(1,1)*m(2,2) - m(1,2) * m(2,1));
+		d -= m(0,1) * (m(1,0)*m(2,2) - m(1,2) * m(2,0));
+		d += m(0,2) * (m(1,0)*m(2,1) - m(1,1) * m(2,0));
+
+		return d;
+	}
+
+	inline this_type Inverse() const
+	{
+		this_type a;
+		const this_type& m = *this;
+		T d = Determinant();
+
+		assert(d != 0);
+		T s = T(1)/d;
+
+		a(0,0) = s * (m(1,1) * m(2,2) - m(1,2) * m(2,1));   
+
+		a(0,1) = s * (m(0,2) * m(2,1) - m(0,1) * m(2,2));   
+		a(1,1) = s * (m(0,0) * m(2,2) - m(0,2) * m(2,0));   
+
+		a(0,2) = s * (m(0,1) * m(1,2) - m(0,2) * m(1,1));   
+		a(1,2) = s * (m(0,2) * m(1,0) - m(0,0) * m(1,2));   
+		a(2,2) = s * (m(0,0) * m(1,1) - m(0,1) * m(1,0));   
+
+		return a;
+	}
+
+	inline T Trace() const { return v[0] + v[3] + v[5]; }
+
+	// M = a*a.t()
+	inline void Rank1(const Vector3<T> &a)
+	{
+		v[0] = a.x*a.x; v[1] = a.x*a.y; v[2] = a.x*a.z;
+		v[3] = a.y*a.y; v[4] = a.y*a.z;
+		v[5] = a.z*a.z;
+	}
+
+	// M += a*a.t()
+	inline void Rank1Add(const Vector3<T> &a)
+	{
+		v[0] += a.x*a.x; v[1] += a.x*a.y; v[2] += a.x*a.z;
+		v[3] += a.y*a.y; v[4] += a.y*a.z;
+		v[5] += a.z*a.z;
+	}
+
+	// M -= a*a.t()
+	inline void Rank1Sub(const Vector3<T> &a)
+	{
+		v[0] -= a.x*a.x; v[1] -= a.x*a.y; v[2] -= a.x*a.z;
+		v[3] -= a.y*a.y; v[4] -= a.y*a.z;
+		v[5] -= a.z*a.z;
+	}
+};
+
+typedef SymMat3<float>  SymMat3f;
+typedef SymMat3<double> SymMat3d;
+
+template<typename T>
+inline Matrix3<T> operator*(const SymMat3<T>& a, const SymMat3<T>& b)
+{
+	#define AJB_ARBC(r,c) (a(r,0)*b(0,c)+a(r,1)*b(1,c)+a(r,2)*b(2,c))
+    return Matrix3<T>(
+		AJB_ARBC(0,0), AJB_ARBC(0,1), AJB_ARBC(0,2),
+		AJB_ARBC(1,0), AJB_ARBC(1,1), AJB_ARBC(1,2),
+		AJB_ARBC(2,0), AJB_ARBC(2,1), AJB_ARBC(2,2));
+	#undef AJB_ARBC
+}
+
+template<typename T>
+inline Matrix3<T> operator*(const Matrix3<T>& a, const SymMat3<T>& b)
+{
+	#define AJB_ARBC(r,c) (a(r,0)*b(0,c)+a(r,1)*b(1,c)+a(r,2)*b(2,c))
+	return Matrix3<T>(
+		AJB_ARBC(0,0), AJB_ARBC(0,1), AJB_ARBC(0,2),
+		AJB_ARBC(1,0), AJB_ARBC(1,1), AJB_ARBC(1,2),
+		AJB_ARBC(2,0), AJB_ARBC(2,1), AJB_ARBC(2,2));
+	#undef AJB_ARBC
+}
+
+//-------------------------------------------------------------------------------------
+// ***** Angle
+
+// Cleanly representing the algebra of 2D rotations.
+// The operations maintain the angle between -Pi and Pi, the same range as atan2.
+
+template<class T>
+class Angle
+{
+public:
+	enum AngularUnits
+	{
+		Radians = 0,
+		Degrees = 1
+	};
+
+    Angle() : a(0) {}
+    
+	// Fix the range to be between -Pi and Pi
+	Angle(T a_, AngularUnits u = Radians) : a((u == Radians) ? a_ : ((T)MATH_DOUBLE_DEGREETORADFACTOR)) { FixRange(); }
+
+	T    Get(AngularUnits u = Radians) const       { return (u == Radians) ? a : a*((T)MATH_DOUBLE_RADTODEGREEFACTOR); }
+	void Set(const T& x, AngularUnits u = Radians) { a = (u == Radians) ? x : x*((T)MATH_DOUBLE_DEGREETORADFACTOR); FixRange(); }
+	int Sign() const                               { if (a == 0) return 0; else return (a > 0) ? 1 : -1; }
+	T   Abs() const                                { return (a > 0) ? a : -a; }
+
+    bool operator== (const Angle& b) const    { return a == b.a; }
+    bool operator!= (const Angle& b) const    { return a != b.a; }
+//	bool operator<  (const Angle& b) const    { return a < a.b; } 
+//	bool operator>  (const Angle& b) const    { return a > a.b; } 
+//	bool operator<= (const Angle& b) const    { return a <= a.b; } 
+//	bool operator>= (const Angle& b) const    { return a >= a.b; } 
+//	bool operator= (const T& x)               { a = x; FixRange(); }
+
+	// These operations assume a is already between -Pi and Pi.
+	Angle& operator+= (const Angle& b)        { a = a + b.a; FastFixRange(); return *this; }
+	Angle& operator+= (const T& x)            { a = a + x; FixRange(); return *this; }
+    Angle  operator+  (const Angle& b) const  { Angle res = *this; res += b; return res; }
+	Angle  operator+  (const T& x) const      { Angle res = *this; res += x; return res; }
+	Angle& operator-= (const Angle& b)        { a = a - b.a; FastFixRange(); return *this; }
+	Angle& operator-= (const T& x)            { a = a - x; FixRange(); return *this; }
+	Angle  operator-  (const Angle& b) const  { Angle res = *this; res -= b; return res; }
+	Angle  operator-  (const T& x) const      { Angle res = *this; res -= x; return res; }
+	
+	T   Distance(const Angle& b)              { T c = fabs(a - b.a); return (c <= ((T)MATH_DOUBLE_PI)) ? c : ((T)MATH_DOUBLE_TWOPI) - c; }
+
+private:
+
+	// The stored angle, which should be maintained between -Pi and Pi
+	T a;
+
+	// Fixes the angle range to [-Pi,Pi], but assumes no more than 2Pi away on either side 
+	inline void FastFixRange()
+	{
+		if (a < -((T)MATH_DOUBLE_PI))
+			a += ((T)MATH_DOUBLE_TWOPI);
+		else if (a > ((T)MATH_DOUBLE_PI))
+			a -= ((T)MATH_DOUBLE_TWOPI);
+	}
+
+	// Fixes the angle range to [-Pi,Pi] for any given range, but slower then the fast method
+	inline void FixRange()
+	{
+        // do nothing if the value is already in the correct range, since fmod call is expensive
+        if (a >= -((T)MATH_DOUBLE_PI) && a <= ((T)MATH_DOUBLE_PI))
+            return;
+		a = fmod(a,((T)MATH_DOUBLE_TWOPI));
+		if (a < -((T)MATH_DOUBLE_PI))
+			a += ((T)MATH_DOUBLE_TWOPI);
+		else if (a > ((T)MATH_DOUBLE_PI))
+			a -= ((T)MATH_DOUBLE_TWOPI);
+	}
+};
+
+
+typedef Angle<float>  Anglef;
+typedef Angle<double> Angled;
+
+
+//-------------------------------------------------------------------------------------
+// ***** Plane
+
+// Consists of a normal vector and distance from the origin where the plane is located.
+
+template<class T>
+class Plane
+{
+public:
+    Vector3<T> N;
+    T          D;
+
+    Plane() : D(0) {}
+
+    // Normals must already be normalized
+    Plane(const Vector3<T>& n, T d) : N(n), D(d) {}
+    Plane(T x, T y, T z, T d) : N(x,y,z), D(d) {}
+
+    // construct from a point on the plane and the normal
+    Plane(const Vector3<T>& p, const Vector3<T>& n) : N(n), D(-(p * n)) {}
+
+    // Find the point to plane distance. The sign indicates what side of the plane the point is on (0 = point on plane).
+    T TestSide(const Vector3<T>& p) const
+    {
+        return (N.Dot(p)) + D;
+    }
+
+    Plane<T> Flipped() const
+    {
+        return Plane(-N, -D);
+    }
+
+    void Flip()
+    {
+        N = -N;
+        D = -D;
+    }
+
+	bool operator==(const Plane<T>& rhs) const
+	{
+		return (this->D == rhs.D && this->N == rhs.N);
+	}
+};
+
+typedef Plane<float> Planef;
+typedef Plane<double> Planed;
+
+
+} // Namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Nullptr.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Nullptr.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,150 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Nullptr.h
+Content     :   Implements C++11 nullptr for the case that the compiler doesn't.
+Created     :   June 19, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Nullptr_h
+#define OVR_Nullptr_h
+
+#pragma once
+
+#include "OVR_Types.h"
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_HAVE_std_nullptr_t
+//
+// Identifies if <cstddef.h> includes std::nullptr_t. 
+//
+#if !defined(OVR_HAVE_std_nullptr_t) && defined(OVR_CPP11_ENABLED)
+    #if defined(OVR_STDLIB_LIBCPP)
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(OVR_STDLIB_LIBSTDCPP)
+        #if (__GLIBCXX__ >= 20110325) && (__GLIBCXX__ != 20110428) && (__GLIBCXX__ != 20120702)
+            #define OVR_HAVE_std_nullptr_t 1
+        #endif
+    #elif defined(_MSC_VER) && (_MSC_VER >= 1600) // VS2010+
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(__clang__)
+        #define OVR_HAVE_std_nullptr_t 1
+    #elif defined(OVR_CPP_GNUC) && (OVR_CPP_VERSION >= 406) // GCC 4.6+
+        #define OVR_HAVE_std_nullptr_t 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** nullptr / std::nullptr_t
+//
+// Declares and defines nullptr and related types.
+//
+#if defined(OVR_CPP_NO_NULLPTR)
+    namespace std
+    {
+        class nullptr_t
+        {
+        public:
+            template <typename T>
+            operator T*() const
+                { return 0; }
+         
+            template <typename C, typename T>
+            operator T C::*() const
+                { return 0; }
+
+            #if OVR_CPP_NO_EXPLICIT_CONVERSION_OPERATORS
+                typedef void* (nullptr_t::*bool_)() const;  // 4.12,p1. We can't portably use operator bool(){ return false; } because bool 
+                operator bool_() const                      // is convertable to int which breaks other required functionality.
+                    { return false; }
+            #else
+                operator bool() const
+                    { return false; }
+            #endif
+
+        private:
+            void operator&() const; // 5.2.10,p9
+        };
+
+        inline nullptr_t nullptr_get()
+        {
+            nullptr_t n = { };
+            return n;
+        }
+
+        #if !defined(nullptr)
+            #define nullptr nullptr_get()
+        #endif
+
+    } // namespace std
+
+
+    // 5.9,p2 p4
+    // 13.6, p13
+    template <typename T>
+    inline bool operator==(T* pT, const std::nullptr_t)
+        { return pT == 0; }
+
+    template <typename T>
+    inline bool operator==(const std::nullptr_t, T* pT)
+        { return pT == 0; }
+
+    template <typename T, typename U>
+    inline bool operator==(const std::nullptr_t, T U::* pU)
+        { return pU == 0; }
+
+    template <typename T, typename U>
+    inline bool operator==(T U::* pTU, const std::nullptr_t)
+        { return pTU == 0; }
+
+    inline bool operator==(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    inline bool operator!=(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator<(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator<=(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    inline bool operator>(const std::nullptr_t, const std::nullptr_t)
+        { return false; }
+
+    inline bool operator>=(const std::nullptr_t, const std::nullptr_t)
+        { return true; }
+
+    using std::nullptr_t;
+    using std::nullptr_get;
+
+// Some compilers natively support C++11 nullptr but the standard library being used 
+// doesn't declare std::nullptr_t, in which case we provide one ourselves.
+#elif !defined(OVR_HAVE_std_nullptr_t) && !defined(OVR_CPP_NO_DECLTYPE)
+    namespace std { typedef decltype(nullptr) nullptr_t; }
+#endif
+
+
+#endif
+
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Observer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Observer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,457 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_Observer.h
+Content     :   Observer pattern
+Created     :   June 20, 2014
+Author      :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Observer_h
+#define OVR_Observer_h
+
+#include "OVR_Types.h"
+#include "OVR_Atomic.h"
+#include "OVR_RefCount.h"
+#include "OVR_Delegates.h"
+#include "OVR_Array.h"
+#include "OVR_String.h"
+#include "OVR_Hash.h"
+
+namespace OVR {
+
+template<class DelegateT> class Observer;
+template<class DelegateT> class ObserverScope;
+template<class DelegateT> class ObserverHash;
+
+
+//-----------------------------------------------------------------------------
+// Observer pattern
+
+// An Observer will observe a Subject.  The Subject can emit callbacks that get
+// serviced by the Observers.
+
+// The trickiest part of this is the shutdown code.
+// To simplify shutdown, the Observer is a reference-counted object divorced
+// from the handler that is called.  To avoid misuse, the ObserverScope object
+// is provided to ensure that the Shutdown() method is called when it goes out
+// of scope.
+
+// The Observer<> class doubles as the subject class.
+// To avoid misuse, assertions are added if a subject tries to observe, or if
+// an observer tries to be watched.
+
+/*
+    Usage example:
+
+    Say we want to invoke a handler with the signature:
+
+        void MyHandler(int i, bool b);
+
+    The corresponding delegate type is:
+
+        typedef Delegate2<void, int, bool> Handler;
+
+    Note: The return value will be ignored for the Observer pattern.
+
+    For this example there are two classes, one that emits events and another
+    that listens for events:
+*/
+
+/*
+    Event emitter example:
+
+    class MyEmitter
+    {
+        ObserverScope<Handler> TheSubject;
+
+    public:
+        void ClearAllListeners()
+        {
+            TheSubject.ReleaseAll();
+        }
+
+        void CallListeners(int x, bool y)
+        {
+            TheSubject->Call(x, y);
+        }
+
+        Observer<Handler>* GetSubject()
+        {
+            return TheSubject;
+        }
+    };
+*/
+
+/*
+    Event listener example:
+
+    class MyListener
+    {
+        ObserverScope<Handler> TheObserver;
+
+        void OnEvent(int x, bool y)
+        {
+            // Handle event here
+        }
+
+    public:
+        MyListener()
+        {
+            TheObserver.SetHandler(
+                Handler::FromMember<MyListener, &MyListener::OnEvent>(this)
+                );
+        }
+
+        void ClearListener()
+        {
+            TheObserver.ReleaseAll();
+        }
+
+        void ListenTo(Observer<Handler>* emitter)
+        {
+            TheObserver->Observe(emitter);
+        }
+    };
+*/
+
+/*
+    Usage example:
+
+    MyListener listener;
+    MyEmitter emitter;
+
+    // To listen to an emitter,
+    listener.ListenTo(emitter.GetSubject());
+
+    // To call the listeners,
+    emitter.CallListeners(22, true);
+*/
+
+template<class DelegateT>
+class Observer : public RefCountBase< Observer<DelegateT> >
+{
+	friend class ObserverScope<DelegateT>;
+	friend class ObserverHash<DelegateT>;
+
+public:
+    typedef Observer<DelegateT> ThisType;
+    typedef DelegateT Handler;
+
+protected:
+	bool                     IsShutdown; // Flag to indicate that the object went out of scope
+	mutable Lock             TheLock;    // Lock to synchronize calls and shutdown
+	Array< Ptr< ThisType > > References; // List of observed or observing objects
+	Handler                  TheHandler; // Observer-only: Handler for callbacks
+
+	Observer() :
+		IsShutdown(false)
+	{
+		TheHandler.Invalidate();
+	}
+	Observer(Handler handler) :
+		IsShutdown(false),
+		TheHandler(handler)
+	{
+	}
+	~Observer()
+	{
+		OVR_ASSERT(References.GetSizeI() == 0);
+	}
+
+public:
+	void SetHandler(Handler handler)
+	{
+		OVR_ASSERT(References.GetSizeI() == 0);
+		TheHandler = handler;
+	}
+
+	// Release references and prevent further actions
+	void Shutdown()
+	{
+		Lock::Locker locker(&TheLock);
+		IsShutdown = true;
+		References.ClearAndRelease();
+	}
+
+	// Get count of references held
+	int GetSizeI() const
+	{
+		Lock::Locker locker(&TheLock);
+		return References.GetSizeI();
+	}
+
+	// Observe a subject
+	bool Observe(ThisType *subject)
+	{
+		OVR_ASSERT(TheHandler.IsValid());
+
+		if (!subject)
+		{
+			return false;
+		}
+
+		Lock::Locker locker(&TheLock);
+
+		if (IsShutdown)
+		{
+			return false;
+		}
+
+		if (!subject->SubjectAddObserver(this))
+		{
+			return false;
+		}
+
+		References.PushBack(subject);
+		return true;
+	}
+
+protected:
+	// Subject function: AddObserver()
+	// Returns true if the observer was added
+	bool SubjectAddObserver(ThisType* observer)
+	{
+		OVR_ASSERT(!TheHandler.IsValid());
+
+		if (!observer)
+		{
+			return true;
+		}
+
+		Lock::Locker locker(&TheLock);
+
+		if (IsShutdown)
+		{
+			return false;
+		}
+
+		const int count = References.GetSizeI();
+		for (int i = 0; i < count; ++i)
+		{
+			if (References[i] == observer)
+			{
+				// Already watched
+				return true;
+			}
+		}
+
+		References.PushBack(observer);
+
+		return true;
+	}
+
+public:
+    // Subject function: Call()
+#define OVR_OBSERVER_CALL_BODY(params) \
+    bool callSuccess = false; \
+	Lock::Locker locker(&TheLock); \
+	int count = References.GetSizeI(); \
+	for (int i = 0; i < count; ++i) \
+	{ \
+		if (!References[i]->IsShutdown) \
+		{ \
+			OVR_ASSERT(References[i]->TheHandler.IsValid()); \
+			References[i]->TheHandler params; \
+            callSuccess = true; \
+		} \
+		if (References[i]->IsShutdown) \
+		{ \
+			References.RemoveAt(i); \
+			--i; --count; \
+		} \
+	} \
+    return callSuccess;
+
+	// Call: Various parameter counts
+    // Returns true if a call was made
+	bool Call()
+	{
+		OVR_OBSERVER_CALL_BODY(());
+	}
+	template<class Param1>
+    bool Call(Param1& p1)
+	{
+		OVR_OBSERVER_CALL_BODY((p1));
+	}
+	template<class Param1>
+    bool Call(Param1* p1)
+	{
+		OVR_OBSERVER_CALL_BODY((p1));
+	}
+	template<class Param1, class Param2>
+    bool Call(Param1& p1, Param2& p2)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2));
+	}
+	template<class Param1, class Param2>
+    bool Call(Param1* p1, Param2* p2)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2));
+	}
+	template<class Param1, class Param2, class Param3>
+    bool Call(Param1& p1, Param2& p2, Param3& p3)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2, p3));
+	}
+	template<class Param1, class Param2, class Param3>
+    bool Call(Param1* p1, Param2* p2, Param3* p3)
+	{
+		OVR_OBSERVER_CALL_BODY((p1, p2, p3));
+	}
+
+#undef OVR_OBSERVER_CALL_BODY
+};
+
+
+//-----------------------------------------------------------------------------
+// ObserverScope
+
+// Scoped shutdown of the Observer object
+template<class DelegateT>
+class ObserverScope : public NewOverrideBase
+{
+	Ptr< Observer<DelegateT> > TheObserver;
+	DelegateT TheHandler;
+
+	void Shutdown()
+	{
+		if (TheObserver)
+		{
+			TheObserver->Shutdown();
+			TheObserver.Clear();
+		}
+	}
+
+public:
+	ObserverScope()
+	{
+		TheObserver = *new Observer<DelegateT>;
+	}
+	~ObserverScope()
+	{
+		Shutdown();
+	}
+
+	// Release all references and recreate it
+	void ReleaseAll()
+	{
+		Shutdown();
+		TheObserver = *new Observer<DelegateT>;
+		if (TheHandler.IsValid())
+		{
+			TheObserver->SetHandler(TheHandler);
+		}
+	}
+
+	void SetHandler(DelegateT handler)
+	{
+		TheHandler = handler;
+		TheObserver->SetHandler(handler);
+	}
+
+	Observer<DelegateT>* GetPtr()
+	{
+		return TheObserver.GetPtr();
+	}
+	Observer<DelegateT>* operator->()
+	{
+		return TheObserver.GetPtr();
+	}
+	const Observer<DelegateT>* operator->() const
+	{
+		return TheObserver.GetPtr();
+	}
+	operator Observer<DelegateT>*()
+	{
+		return TheObserver.GetPtr();
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// ObserverHash
+
+// A hash containing Observers
+template<class DelegateT>
+class ObserverHash : public NewOverrideBase
+{
+public:
+	ObserverHash() {}
+	~ObserverHash() {Clear();}
+	void Clear()
+	{
+		Lock::Locker locker(&TheLock);
+		typename OVR::Hash< String, Ptr<Observer<DelegateT> >, OVR::String::HashFunctor >::Iterator it = _Hash.Begin();
+		for( it = _Hash.Begin(); it != _Hash.End(); ++it )
+		{
+			Ptr<Observer<DelegateT> > o = it->Second;
+			o->Shutdown();
+		}
+	}
+
+	Ptr<Observer<DelegateT> > GetSubject(OVR::String key)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *o = _Hash.Get(key);
+		if (o)
+			return (*o);
+		return NULL;
+	}
+
+	// Add handler to new observer with implicit creation of subject.
+	void AddObserverToSubject(OVR::String key, Observer<DelegateT> *observer)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *subjectPtr = _Hash.Get(key);
+
+		if (subjectPtr==NULL)
+		{
+			Ptr<Observer<DelegateT> > subject = *new Observer<DelegateT>();
+			_Hash.Add(key, subject);
+			observer->Observe(subject);
+		}
+		else
+		{
+			observer->Observe(*subjectPtr);
+		}
+	}
+
+	void RemoveSubject(OVR::String key)
+	{
+		Lock::Locker locker(&TheLock);
+		Ptr<Observer<DelegateT> > *subjectPtr = _Hash.Get(key);
+		if (subjectPtr!=NULL)
+		{
+			(*subjectPtr)->Shutdown();
+			_Hash.Remove(key);
+		}
+	}
+
+protected:
+	OVR::Hash< OVR::String, Ptr<Observer<DelegateT> >, OVR::String::HashFunctor > _Hash;
+	Lock                     TheLock;      // Lock to synchronize calls and shutdown
+};
+
+
+} // namespace OVR
+
+#endif // OVR_Observer_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_RefCount.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,565 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_RefCount.h
+Content     :   Reference counting implementation headers
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_RefCount_h
+#define OVR_RefCount_h
+
+#include "OVR_Types.h"
+#include "OVR_Allocator.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ***** Reference Counting
+
+// There are three types of reference counting base classes:
+//
+//  RefCountBase     - Provides thread-safe reference counting (Default).
+//  RefCountBaseNTS  - Non Thread Safe version of reference counting.
+
+
+// ***** Declared classes
+
+template<class C>
+class   RefCountBase;
+template<class C>
+class   RefCountBaseNTS;
+
+class   RefCountImpl;
+class   RefCountNTSImpl;
+
+
+//-----------------------------------------------------------------------------------
+// ***** Implementation For Reference Counting
+
+// RefCountImplCore holds RefCount value and defines a few utility
+// functions shared by all implementations.
+
+class RefCountImplCore
+{
+protected:
+   volatile int RefCount;
+
+public:
+    // RefCountImpl constructor always initializes RefCount to 1 by default.
+    OVR_FORCE_INLINE RefCountImplCore() : RefCount(1) { }
+
+    // Need virtual destructor
+    // This:    1. Makes sure the right destructor's called.
+    //          2. Makes us have VTable, necessary if we are going to have format needed by InitNewMem()
+    virtual ~RefCountImplCore();
+
+    // Debug method only.
+    int GetRefCount() const { return RefCount;  }
+
+    // This logic is used to detect invalid 'delete' calls of reference counted
+    // objects. Direct delete calls are not allowed on them unless they come in
+    // internally from Release.
+#ifdef OVR_BUILD_DEBUG    
+    static void   OVR_CDECL  reportInvalidDelete(void *pmem);
+    inline static void checkInvalidDelete(RefCountImplCore *pmem)
+    {
+        if (pmem->RefCount != 0)
+            reportInvalidDelete(pmem);
+    }
+#else
+    inline static void checkInvalidDelete(RefCountImplCore *) { }
+#endif
+
+    // Base class ref-count content should not be copied.
+    void operator = (const RefCountImplCore &) { }  
+};
+
+class RefCountNTSImplCore
+{
+protected:
+    mutable int RefCount;
+
+public:
+    // RefCountImpl constructor always initializes RefCount to 1 by default.
+    OVR_FORCE_INLINE RefCountNTSImplCore() : RefCount(1) { }
+
+    // Need virtual destructor
+    // This:    1. Makes sure the right destructor's called.
+    //          2. Makes us have VTable, necessary if we are going to have format needed by InitNewMem()
+    virtual ~RefCountNTSImplCore();
+
+    // Debug method only.
+    int             GetRefCount() const { return RefCount;  }
+
+    // This logic is used to detect invalid 'delete' calls of reference counted
+    // objects. Direct delete calls are not allowed on them unless they come in
+    // internally from Release.
+#ifdef OVR_BUILD_DEBUG    
+    static void   OVR_CDECL  reportInvalidDelete(void *pmem);
+    OVR_FORCE_INLINE static void checkInvalidDelete(RefCountNTSImplCore *pmem)
+    {
+        if (pmem->RefCount != 0)
+            reportInvalidDelete(pmem);
+    }
+#else
+    OVR_FORCE_INLINE static void checkInvalidDelete(RefCountNTSImplCore *) { }
+#endif
+
+    // Base class ref-count content should not be copied.
+    void operator = (const RefCountNTSImplCore &) { }  
+};
+
+
+
+// RefCountImpl provides Thread-Safe implementation of reference counting, so
+// it should be used by default in most places.
+
+class RefCountImpl : public RefCountImplCore
+{
+public:
+    // Thread-Safe Ref-Count Implementation.
+    void    AddRef();
+    void    Release();   
+};
+
+// RefCountVImpl provides Thread-Safe implementation of reference counting, plus,
+// virtual AddRef and Release.
+
+class RefCountVImpl : virtual public RefCountImplCore
+{
+public:
+    // Thread-Safe Ref-Count Implementation.
+    virtual void      AddRef();
+    virtual void      Release();   
+};
+
+
+// RefCountImplNTS provides Non-Thread-Safe implementation of reference counting,
+// which is slightly more efficient since it doesn't use atomics.
+
+class RefCountNTSImpl : public RefCountNTSImplCore
+{
+public:
+    OVR_FORCE_INLINE void    AddRef() const { RefCount++; }
+    void    Release() const;   
+};
+
+
+
+// RefCountBaseStatImpl<> is a common class that adds new/delete override with Stat tracking
+// to the reference counting implementation. Base must be one of the RefCountImpl classes.
+
+template<class Base>
+class RefCountBaseStatImpl : public Base
+{
+public:
+    RefCountBaseStatImpl() { }
+     
+    // *** Override New and Delete
+
+    // DOM-IGNORE-BEGIN
+    // Undef new temporarily if it is being redefined
+#ifdef OVR_DEFINE_NEW
+#undef new
+#endif
+
+#ifdef OVR_BUILD_DEBUG
+    // Custom check used to detect incorrect calls of 'delete' on ref-counted objects.
+    #define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)   \
+        do {if (p) Base::checkInvalidDelete((class_name*)p); } while(0)
+#else
+    #define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)
+#endif
+
+    // Redefine all new & delete operators.
+    OVR_MEMORY_REDEFINE_NEW_IMPL(Base, OVR_REFCOUNTALLOC_CHECK_DELETE)
+
+#undef OVR_REFCOUNTALLOC_CHECK_DELETE
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+        // OVR_BUILD_DEFINE_NEW
+        // DOM-IGNORE-END
+};
+
+
+template<class Base>
+class RefCountBaseStatVImpl : virtual public Base
+{
+public:
+	RefCountBaseStatVImpl() { }
+
+	// *** Override New and Delete
+
+	// DOM-IGNORE-BEGIN
+	// Undef new temporarily if it is being redefined
+#ifdef OVR_DEFINE_NEW
+#undef new
+#endif
+
+#define OVR_REFCOUNTALLOC_CHECK_DELETE(class_name, p)
+
+	// Redefine all new & delete operators.
+	OVR_MEMORY_REDEFINE_NEW_IMPL(Base, OVR_REFCOUNTALLOC_CHECK_DELETE)
+
+#undef OVR_REFCOUNTALLOC_CHECK_DELETE
+
+#ifdef OVR_DEFINE_NEW
+#define new OVR_DEFINE_NEW
+#endif
+		// OVR_BUILD_DEFINE_NEW
+		// DOM-IGNORE-END
+};
+
+
+
+//-----------------------------------------------------------------------------------
+// *** End user RefCountBase<> classes
+
+
+// RefCountBase is a base class for classes that require thread-safe reference
+// counting; it also overrides the new and delete operators to use MemoryHeap.
+//
+// Reference counted objects start out with RefCount value of 1. Further lifetime
+// management is done through the AddRef() and Release() methods, typically
+// hidden by Ptr<>.
+
+template<class C>
+class RefCountBase : public RefCountBaseStatImpl<RefCountImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBase() : RefCountBaseStatImpl<RefCountImpl>() { }    
+};
+
+// RefCountBaseV is the same as RefCountBase but with virtual AddRef/Release
+
+template<class C>
+class RefCountBaseV : virtual public RefCountBaseStatVImpl<RefCountVImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBaseV() : RefCountBaseStatVImpl<RefCountVImpl>() { }    
+};
+
+
+// RefCountBaseNTS is a base class for classes that require Non-Thread-Safe reference
+// counting; it also overrides the new and delete operators to use MemoryHeap.
+// This class should only be used if all pointers to it are known to be assigned,
+// destroyed and manipulated within one thread.
+//
+// Reference counted objects start out with RefCount value of 1. Further lifetime
+// management is done through the AddRef() and Release() methods, typically
+// hidden by Ptr<>.
+
+template<class C>
+class RefCountBaseNTS : public RefCountBaseStatImpl<RefCountNTSImpl>
+{
+public:    
+    // Constructor.
+    OVR_FORCE_INLINE RefCountBaseNTS() : RefCountBaseStatImpl<RefCountNTSImpl>() { }    
+};
+
+//-----------------------------------------------------------------------------------
+// ***** Pickable template pointer
+enum PickType { PickValue };
+
+template <typename T>
+class Pickable
+{
+public:
+    Pickable() : pV(NULL) {}
+    explicit Pickable(T* p) : pV(p) {}
+    Pickable(T* p, PickType) : pV(p) 
+    {
+        OVR_ASSERT(pV);
+        if (pV)
+            pV->AddRef();
+    }
+    template <typename OT>
+    Pickable(const Pickable<OT>& other) : pV(other.GetPtr()) {}
+
+public:
+    Pickable& operator =(const Pickable& other)
+    {
+        OVR_ASSERT(pV == NULL);
+        pV = other.pV;
+        // Extra check.
+        //other.pV = NULL;
+        return *this;
+    }
+
+public:
+    T* GetPtr() const { return pV; }
+    T* operator->() const
+    {
+        return pV;
+    }
+    T& operator*() const
+    {
+        OVR_ASSERT(pV);
+        return *pV;
+    }
+
+private:
+    T* pV;
+};
+
+template <typename T>
+OVR_FORCE_INLINE
+Pickable<T> MakePickable(T* p)
+{
+    return Pickable<T>(p);
+}
+
+//-----------------------------------------------------------------------------------
+// ***** Ref-Counted template pointer
+
+// Automatically AddRefs and Releases interfaces
+
+void* ReturnArg0(void* p);
+
+template<class C>
+class Ptr
+{
+#ifdef OVR_CC_ARM
+    static C* ReturnArg(void* p) { return (C*)ReturnArg0(p); }
+#endif
+
+protected:
+    C   *pObject;
+
+public:
+
+    // Constructors
+    OVR_FORCE_INLINE Ptr() : pObject(0)
+    { }
+#ifdef OVR_CC_ARM
+    OVR_FORCE_INLINE Ptr(C &robj) : pObject(ReturnArg(&robj))
+#else
+    OVR_FORCE_INLINE Ptr(C &robj) : pObject(&robj)
+#endif
+    { }
+    OVR_FORCE_INLINE Ptr(Pickable<C> v) : pObject(v.GetPtr())
+    {
+        // No AddRef() on purpose.
+    }
+    OVR_FORCE_INLINE Ptr(Ptr<C>& other, PickType) : pObject(other.pObject)
+    {
+        other.pObject = NULL;
+        // No AddRef() on purpose.
+    }
+    OVR_FORCE_INLINE Ptr(C *pobj)
+    {
+        if (pobj) pobj->AddRef();   
+        pObject = pobj;
+    }
+    OVR_FORCE_INLINE Ptr(const Ptr<C> &src)
+    {
+        if (src.pObject) src.pObject->AddRef();     
+        pObject = src.pObject;
+    }
+
+    template<class R>
+    OVR_FORCE_INLINE Ptr(Ptr<R> &src)
+    {
+        if (src) src->AddRef();
+        pObject = src;
+    }
+    template<class R>
+    OVR_FORCE_INLINE Ptr(Pickable<R> v) : pObject(v.GetPtr())
+    {
+        // No AddRef() on purpose.
+    }
+
+    // Destructor
+    OVR_FORCE_INLINE ~Ptr()
+    {
+        if (pObject) pObject->Release();        
+    }
+
+    // Compares
+    OVR_FORCE_INLINE bool operator == (const Ptr &other) const       { return pObject == other.pObject; }
+    OVR_FORCE_INLINE bool operator != (const Ptr &other) const       { return pObject != other.pObject; }
+
+    OVR_FORCE_INLINE bool operator == (C *pother) const              { return pObject == pother; }
+    OVR_FORCE_INLINE bool operator != (C *pother) const              { return pObject != pother; }
+
+
+    OVR_FORCE_INLINE bool operator < (const Ptr &other) const       { return pObject < other.pObject; }
+
+    // Assignment
+    template<class R>
+    OVR_FORCE_INLINE const Ptr<C>& operator = (const Ptr<R> &src)
+    {
+        // By design we don't check for src == pObject, as we don't expect that to be the case the large majority of the time.
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = src;
+        return *this;
+    }   
+    // Specialization
+    OVR_FORCE_INLINE const Ptr<C>& operator = (const Ptr<C> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = src;
+        return *this;
+    }   
+    
+    OVR_FORCE_INLINE const Ptr<C>& operator = (C *psrc)
+    {
+        if (psrc) psrc->AddRef();
+        if (pObject) pObject->Release();        
+        pObject = psrc;
+        return *this;
+    }   
+    OVR_FORCE_INLINE const Ptr<C>& operator = (C &src)
+    {       
+        if (pObject) pObject->Release();        
+        pObject = &src;
+        return *this;
+    }
+    OVR_FORCE_INLINE Ptr<C>& operator = (Pickable<C> src)
+    {
+        return Pick(src);
+    }
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& operator = (Pickable<R> src)
+    {
+        return Pick(src);
+    }
+    
+    // Set Assignment
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(const Ptr<R> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();
+        pObject = src;
+        return *this;
+    }
+    // Specialization
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(const Ptr<C> &src)
+    {
+        if (src) src->AddRef();
+        if (pObject) pObject->Release();
+        pObject = src;
+        return *this;
+    }   
+    
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(C *psrc)
+    {
+        if (psrc) psrc->AddRef();
+        if (pObject) pObject->Release();
+        pObject = psrc;
+        return *this;
+    }   
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(C &src)
+    {       
+        if (pObject) pObject->Release();
+        pObject = &src;
+        return *this;
+    }
+    OVR_FORCE_INLINE Ptr<C>& SetPtr(Pickable<C> src)
+    {       
+        return Pick(src);
+    }
+
+    // Nulls ref-counted pointer without decrement
+    OVR_FORCE_INLINE void    NullWithoutRelease()    
+    { 
+        pObject = 0;    
+    }
+
+    // Clears the pointer to the object
+    OVR_FORCE_INLINE void    Clear()
+    {
+        if (pObject) pObject->Release();
+        pObject = 0;
+    }
+
+    // Obtain pointer reference directly, for D3D interfaces
+    OVR_FORCE_INLINE C*& GetRawRef()                 { return pObject; }
+
+    // Access Operators
+    OVR_FORCE_INLINE C* GetPtr() const               { return pObject; }
+    OVR_FORCE_INLINE C& operator * () const          { return *pObject; }
+    OVR_FORCE_INLINE C* operator -> ()  const        { return pObject; }
+    // Conversion                   
+    OVR_FORCE_INLINE operator C* () const            { return pObject; }
+
+    // Pickers.
+
+    // Pick a value.
+    OVR_FORCE_INLINE Ptr<C>& Pick(Ptr<C>& other)
+    {
+        if (&other != this)
+        {
+            if (pObject) pObject->Release();
+            pObject = other.pObject;
+            other.pObject = 0;
+        }
+
+        return *this;
+    }
+
+    OVR_FORCE_INLINE Ptr<C>& Pick(Pickable<C> v)
+    {
+        if (v.GetPtr() != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = v.GetPtr();
+        }
+
+        return *this;
+    }
+
+    template<class R>
+    OVR_FORCE_INLINE Ptr<C>& Pick(Pickable<R> v)
+    {
+        if (v.GetPtr() != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = v.GetPtr();
+        }
+
+        return *this;
+    }
+
+    OVR_FORCE_INLINE Ptr<C>& Pick(C* p)
+    {
+        if (p != pObject)
+        {
+            if (pObject) pObject->Release();
+            pObject = p;
+        }
+
+        return *this;
+    }
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SharedMemory.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,241 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_SharedMemory.h
+Content     :   Inter-process shared memory subsystem
+Created     :   June 1, 2014
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SharedMemory_h
+#define OVR_SharedMemory_h
+
+#include "OVR_Types.h"
+#include "OVR_RefCount.h"
+#include "OVR_Allocator.h"
+#include "OVR_System.h"
+
+#ifdef OVR_SINGLE_PROCESS /* Everything running in one process usually for debugging */
+#define OVR_FAKE_SHAREDMEMORY /* Single-process version to avoid admin privs */
+#endif
+
+namespace OVR {
+
+class SharedMemoryInternal; // Opaque
+
+
+// SharedMemory
+// Note: Safe when used between 32-bit and 64-bit processes
+class SharedMemory : public RefCountBase<SharedMemory>
+{
+	friend class SharedMemoryFactory;
+
+	SharedMemory(SharedMemory&) {}
+	void operator=(SharedMemory&) {}
+
+public:
+	// Only constructed by the SharedMemory Factory
+    SharedMemory(int size, void* data, SharedMemoryInternal* pInternal);
+	// Call close when it goes out of scope
+    ~SharedMemory();
+
+	// Modes for opening a new shared memory region
+	enum OpenMode
+	{
+		// Note: On Windows, Create* requires Administrator priviledges or running as a Service.
+		OpenMode_CreateOnly,		// Must not already exist
+		OpenMode_OpenOnly,			// Must already exist
+		OpenMode_CreateOrOpen		// May exist or not
+	};
+
+	// Local access restrictions
+	enum AccessMode
+	{
+		AccessMode_ReadOnly,		// Acquire read-only access
+		AccessMode_ReadWrite,		// Acquire read or write access
+	};
+
+	// Remote access restrictions
+	enum RemoteMode
+	{
+		RemoteMode_ReadOnly,		// Other processes will need to open in read-only mode
+		RemoteMode_ReadWrite		// Other processes can open in read-write mode
+	};
+
+	// Modes for opening a new shared memory region
+	struct OpenParameters
+	{
+		OpenParameters() :
+			globalName(NULL),
+			minSizeBytes(0),
+			openMode(SharedMemory::OpenMode_CreateOrOpen),
+			remoteMode(SharedMemory::RemoteMode_ReadWrite),
+			accessMode(SharedMemory::AccessMode_ReadWrite)
+		{
+		}
+
+		// Creation parameters
+		const char*					globalName;		// Name of the shared memory region
+		int							minSizeBytes;	// Minimum number of bytes to request
+		SharedMemory::OpenMode		openMode;		// Creating the file or opening the file?
+		SharedMemory::RemoteMode	remoteMode;		// When creating, what access should other processes get?
+		SharedMemory::AccessMode	accessMode;		// When opening/creating, what access should this process get?
+	};
+
+public:
+	// Returns the size of the shared memory region
+	int GetSizeI() const
+	{
+		return Size;
+	}
+
+	// Returns the process-local pointer to the shared memory region
+	// Note: This may be different on different processes
+	void* GetData() const
+	{
+		return Data;
+	}
+
+protected:
+	int Size;		// How many shared bytes are shared at the pointer address?
+	void* Data;		// Pointer to the shared memory region.
+
+	// Hidden implementation class for OS-specific behavior
+	SharedMemoryInternal* Internal;
+
+	// Close and cleanup the shared memory region
+	// Note: This is called on destruction
+	void Close();
+};
+
+
+// SharedMemoryFactory
+class SharedMemoryFactory : public NewOverrideBase, public SystemSingletonBase<SharedMemoryFactory>
+{
+    OVR_DECLARE_SINGLETON(SharedMemoryFactory);
+
+public:
+    // Construct a SharedMemory object.
+	// Note: The new object is reference-counted so it should be stored with Ptr<>.  Initial reference count is 1.
+	Ptr<SharedMemory> Open(const SharedMemory::OpenParameters&);
+};
+
+
+// A shared object
+// Its constructor will be called when creating a writer
+// Its destructor will not be called
+template<class SharedType>
+class ISharedObject : public NewOverrideBase
+{
+public:
+	static const int RegionSize = (int)sizeof(SharedType);
+
+protected:
+	Ptr<SharedMemory> pSharedMemory;
+
+	bool Open(const char* name, bool readOnly)
+	{
+		// Configure open parameters based on read-only mode
+		SharedMemory::OpenParameters params;
+
+        // FIXME: This is a hack.  We currently need to allow clients to open this for read-write even
+        // though they only need read-only access.  This is because in the first 0.4 release the
+        // LocklessUpdater class technically writes to it (increments by 0) to read from the space.
+        // This was quickly corrected in 0.4.1 and we are waiting for the right time to disallow write
+        // access when everyone upgrades to 0.4.1+.
+        //params.remoteMode = SharedMemory::RemoteMode_ReadOnly;
+        params.remoteMode = SharedMemory::RemoteMode_ReadWrite;
+
+        params.globalName = name;
+        params.accessMode = readOnly ? SharedMemory::AccessMode_ReadOnly : SharedMemory::AccessMode_ReadWrite;
+        params.minSizeBytes = RegionSize;
+		params.openMode = readOnly ? SharedMemory::OpenMode_OpenOnly : SharedMemory::OpenMode_CreateOrOpen;
+
+		// Attempt to open the shared memory file
+		pSharedMemory = SharedMemoryFactory::GetInstance()->Open(params);
+
+		// If it was not able to be opened,
+		if (pSharedMemory && pSharedMemory->GetSizeI() >= RegionSize && pSharedMemory->GetData())
+		{
+			// If writing,
+			if (!readOnly)
+			{
+				// Construct the object also
+				Construct<SharedType>(pSharedMemory->GetData());
+			}
+
+			return true;
+		}
+
+		return false;
+	}
+
+	SharedType* Get() const
+	{
+		if (!pSharedMemory)
+		{
+			return NULL;
+		}
+
+		void* data = pSharedMemory->GetData();
+		if (!data)
+		{
+			return NULL;
+		}
+
+		return reinterpret_cast<SharedType*>(data);
+	}
+};
+
+// Writer specialized shared object: Ctor will be called on Open()
+template<class SharedType>
+class SharedObjectWriter : public ISharedObject<SharedType>
+{
+public:
+	OVR_FORCE_INLINE bool Open(const char* name)
+	{
+		return ISharedObject<SharedType>::Open(name, false);
+	}
+	OVR_FORCE_INLINE SharedType* Get()
+	{
+		return ISharedObject<SharedType>::Get();
+	}
+};
+
+// Reader specialized shared object: Ctor will not be called
+template<class SharedType>
+class SharedObjectReader : public ISharedObject<SharedType>
+{
+public:
+	OVR_FORCE_INLINE bool Open(const char* name)
+	{
+		return ISharedObject<SharedType>::Open(name, true);
+	}
+	OVR_FORCE_INLINE const SharedType* Get() const
+	{
+		return ISharedObject<SharedType>::Get();
+	}
+};
+
+
+} // namespace OVR
+
+#endif // OVR_SharedMemory_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Std.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,514 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Std.h
+Content     :   Standard C function interface
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Std_h
+#define OVR_Std_h
+
+#include "OVR_Types.h"
+#include <stdarg.h> // for va_list args
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if !defined(OVR_OS_WINCE) && defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+#define OVR_MSVC_SAFESTRING
+#include <errno.h>
+#endif
+
+// Wide-char funcs
+#include <wchar.h>
+#include <wctype.h>
+
+namespace OVR {
+
+#if defined(OVR_OS_WIN32)
+inline char* OVR_CDECL OVR_itoa(int val, char *dest, size_t destsize, int radix)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    _itoa_s(val, dest, destsize, radix);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return itoa(val, dest, radix);
+#endif
+}
+#else // OVR_OS_WIN32
+inline char* OVR_itoa(int val, char* dest, unsigned int len, int radix)
+{
+    if (val == 0)
+    {
+        if (len > 1)
+        {
+            dest[0] = '0';
+            dest[1] = '\0';  
+        }
+        return dest;
+    }
+
+    int cur = val;
+    unsigned int i    = 0; 
+    unsigned int sign = 0;
+
+    if (val < 0)
+    {
+        val = -val;
+        sign = 1;
+    }
+
+    while ((val != 0) && (i < (len - 1 - sign)))        
+    {
+        cur    = val % radix;
+        val   /= radix;
+
+        if (radix == 16)
+        {
+            switch(cur)
+            {
+            case 10:
+                dest[i] = 'a';
+                break;
+            case 11:
+                dest[i] = 'b';
+                break;
+            case 12:
+                dest[i] = 'c';
+                break;
+            case 13:
+                dest[i] = 'd';
+                break;
+            case 14:
+                dest[i] = 'e';
+                break;
+            case 15:
+                dest[i] = 'f';
+                break;
+            default:
+                dest[i] = (char)('0' + cur);
+                break;
+            }
+        } 
+        else
+        {
+            dest[i] = (char)('0' + cur);
+        }
+        ++i;
+    }
+
+    if (sign)
+    {
+        dest[i++] = '-';
+    }
+
+    for (unsigned int j = 0; j < i / 2; ++j)
+    {
+        char tmp        = dest[j];
+        dest[j]         = dest[i - 1 - j];
+        dest[i - 1 - j] = tmp;
+    }
+    dest[i] = '\0';
+
+    return dest;
+}
+
+#endif
+
+
+// String functions
+
+inline size_t OVR_CDECL OVR_strlen(const char* str)
+{
+    return strlen(str);
+}
+
+inline char* OVR_CDECL OVR_strcpy(char* dest, size_t destsize, const char* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strcpy_s(dest, destsize, src);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strcpy(dest, src);
+#endif
+}
+
+inline char* OVR_CDECL OVR_strncpy(char* dest, size_t destsize, const char* src, size_t count)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strncpy_s(dest, destsize, src, count);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strncpy(dest, src, count);
+#endif
+}
+
+inline char * OVR_CDECL OVR_strcat(char* dest, size_t destsize, const char* src)
+{
+#if defined(OVR_MSVC_SAFESTRING)
+    strcat_s(dest, destsize, src);
+    return dest;
+#else
+    OVR_UNUSED(destsize);
+    return strcat(dest, src);
+#endif
+}
+
+inline int OVR_CDECL OVR_strcmp(const char* dest, const char* src)
+{
+    return strcmp(dest, src);
+}
+
+inline const char* OVR_CDECL OVR_strchr(const char* str, char c)
+{
+    return strchr(str, c);
+}
+
+inline char* OVR_CDECL OVR_strchr(char* str, char c)
+{
+    return strchr(str, c);
+}
+
+inline const char* OVR_strrchr(const char* str, char c)
+{
+    size_t len = OVR_strlen(str);
+    for (size_t i=len; i>0; i--)     
+        if (str[i]==c) 
+            return str+i;
+    return 0;
+}
+
+inline const uint8_t* OVR_CDECL OVR_memrchr(const uint8_t* str, size_t size, uint8_t c)
+{
+    for (intptr_t i = (intptr_t)size - 1; i >= 0; i--)     
+    {
+        if (str[i] == c) 
+            return str + i;
+    }
+    return 0;
+}
+
+inline char* OVR_CDECL OVR_strrchr(char* str, char c)
+{
+    size_t len = OVR_strlen(str);
+    for (size_t i=len; i>0; i--)     
+        if (str[i]==c) 
+            return str+i;
+    return 0;
+}
+
+
+double OVR_CDECL OVR_strtod(const char* string, char** tailptr);
+
+inline long OVR_CDECL OVR_strtol(const char* string, char** tailptr, int radix)
+{
+    return strtol(string, tailptr, radix);
+}
+
+inline long OVR_CDECL OVR_strtoul(const char* string, char** tailptr, int radix)
+{
+    return strtoul(string, tailptr, radix);
+}
+
+inline int OVR_CDECL OVR_strncmp(const char* ws1, const char* ws2, size_t size)
+{
+    return strncmp(ws1, ws2, size);
+}
+
+inline uint64_t OVR_CDECL OVR_strtouq(const char *nptr, char **endptr, int base)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _strtoui64(nptr, endptr, base);
+#else
+    return strtoull(nptr, endptr, base);
+#endif
+}
+
+inline int64_t OVR_CDECL OVR_strtoq(const char *nptr, char **endptr, int base)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _strtoi64(nptr, endptr, base);
+#else
+    return strtoll(nptr, endptr, base);
+#endif
+}
+
+
+inline int64_t OVR_CDECL OVR_atoq(const char* string)
+{
+#if defined(OVR_CC_MSVC) && !defined(OVR_OS_WINCE)
+    return _atoi64(string);
+#else
+    return atoll(string);
+#endif
+}
+
+inline uint64_t OVR_CDECL OVR_atouq(const char* string)
+{
+  return OVR_strtouq(string, NULL, 10);
+}
+
+
+// Implemented in GStd.cpp in platform-specific manner.
+int OVR_CDECL OVR_stricmp(const char* dest, const char* src);
+int OVR_CDECL OVR_strnicmp(const char* dest, const char* src, size_t count);
+
+inline size_t OVR_CDECL OVR_sprintf(char *dest, size_t destsize, const char* format, ...)
+{
+    va_list argList;
+    va_start(argList,format);
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    #if defined(OVR_MSVC_SAFESTRING)
+        ret = _vsnprintf_s(dest, destsize, _TRUNCATE, format, argList);
+        OVR_ASSERT(ret != -1);
+    #else
+        OVR_UNUSED(destsize);
+        ret = _vsnprintf(dest, destsize - 1, format, argList); // -1 for space for the null character
+        OVR_ASSERT(ret != -1);
+        dest[destsize-1] = 0;
+    #endif
+#else
+    OVR_UNUSED(destsize);
+    ret = vsprintf(dest, format, argList);
+    OVR_ASSERT(ret < destsize);
+#endif
+    va_end(argList);
+    return ret;
+}
+
+inline size_t OVR_CDECL OVR_vsprintf(char *dest, size_t destsize, const char * format, va_list argList)
+{
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    #if defined(OVR_MSVC_SAFESTRING)
+        dest[0] = '\0';
+        int rv = vsnprintf_s(dest, destsize, _TRUNCATE, format, argList);
+        if (rv == -1)
+        {
+            dest[destsize - 1] = '\0';
+            ret = destsize - 1;
+        }
+        else
+            ret = (size_t)rv;
+    #else
+        OVR_UNUSED(destsize);
+        int rv = _vsnprintf(dest, destsize - 1, format, argList);
+        OVR_ASSERT(rv != -1);
+        ret = (size_t)rv;
+        dest[destsize-1] = 0;
+    #endif
+#else
+    OVR_UNUSED(destsize);
+    ret = (size_t)vsprintf(dest, format, argList);
+    OVR_ASSERT(ret < destsize);
+#endif
+    return ret;
+}
+
+// Returns the number of characters in the formatted string.
+inline size_t OVR_CDECL OVR_vscprintf(const char * format, va_list argList)
+{
+    size_t ret;
+#if defined(OVR_CC_MSVC)
+    ret = (size_t) _vscprintf(format, argList);
+#else    
+    ret = (size_t) vsnprintf(NULL, 0, format, argList);
+#endif
+    return ret;       
+}
+
+
+wchar_t* OVR_CDECL OVR_wcscpy(wchar_t* dest, size_t destsize, const wchar_t* src);
+wchar_t* OVR_CDECL OVR_wcsncpy(wchar_t* dest, size_t destsize, const wchar_t* src, size_t count);
+wchar_t* OVR_CDECL OVR_wcscat(wchar_t* dest, size_t destsize, const wchar_t* src);
+size_t   OVR_CDECL OVR_wcslen(const wchar_t* str);
+int      OVR_CDECL OVR_wcscmp(const wchar_t* a, const wchar_t* b);
+int      OVR_CDECL OVR_wcsicmp(const wchar_t* a, const wchar_t* b);
+
+inline int OVR_CDECL OVR_wcsicoll(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32)
+#if defined(OVR_CC_MSVC) && (OVR_CC_MSVC >= 1400)
+    return ::_wcsicoll(a, b);
+#else
+    return ::wcsicoll(a, b);
+#endif
+#else
+    // not supported, use regular wcsicmp
+    return OVR_wcsicmp(a, b);
+#endif
+}
+
+inline int OVR_CDECL OVR_wcscoll(const wchar_t* a, const wchar_t* b)
+{
+#if defined(OVR_OS_WIN32) || defined(OVR_OS_LINUX)
+    return wcscoll(a, b);
+#else
+    // not supported, use regular wcscmp
+    return OVR_wcscmp(a, b);
+#endif
+}
+
+#ifndef OVR_NO_WCTYPE
+
+inline int OVR_CDECL UnicodeCharIs(const uint16_t* table, wchar_t charCode)
+{
+    unsigned offset = table[charCode >> 8];
+    if (offset == 0) return 0;
+    if (offset == 1) return 1;
+    return (table[offset + ((charCode >> 4) & 15)] & (1 << (charCode & 15))) != 0;
+}
+
+extern const uint16_t UnicodeAlnumBits[];
+extern const uint16_t UnicodeAlphaBits[];
+extern const uint16_t UnicodeDigitBits[];
+extern const uint16_t UnicodeSpaceBits[];
+extern const uint16_t UnicodeXDigitBits[];
+
+// Uncomment if necessary
+//extern const uint16_t UnicodeCntrlBits[];
+//extern const uint16_t UnicodeGraphBits[];
+//extern const uint16_t UnicodeLowerBits[];
+//extern const uint16_t UnicodePrintBits[];
+//extern const uint16_t UnicodePunctBits[];
+//extern const uint16_t UnicodeUpperBits[];
+
+inline int OVR_CDECL OVR_iswalnum (wchar_t charCode) { return UnicodeCharIs(UnicodeAlnumBits,  charCode); }
+inline int OVR_CDECL OVR_iswalpha (wchar_t charCode) { return UnicodeCharIs(UnicodeAlphaBits,  charCode); }
+inline int OVR_CDECL OVR_iswdigit (wchar_t charCode) { return UnicodeCharIs(UnicodeDigitBits,  charCode); }
+inline int OVR_CDECL OVR_iswspace (wchar_t charCode) { return UnicodeCharIs(UnicodeSpaceBits,  charCode); }
+inline int OVR_CDECL OVR_iswxdigit(wchar_t charCode) { return UnicodeCharIs(UnicodeXDigitBits, charCode); }
+
+// Uncomment if necessary
+//inline int OVR_CDECL OVR_iswcntrl (wchar_t charCode) { return UnicodeCharIs(UnicodeCntrlBits,  charCode); }
+//inline int OVR_CDECL OVR_iswgraph (wchar_t charCode) { return UnicodeCharIs(UnicodeGraphBits,  charCode); }
+//inline int OVR_CDECL OVR_iswlower (wchar_t charCode) { return UnicodeCharIs(UnicodeLowerBits,  charCode); }
+//inline int OVR_CDECL OVR_iswprint (wchar_t charCode) { return UnicodeCharIs(UnicodePrintBits,  charCode); }
+//inline int OVR_CDECL OVR_iswpunct (wchar_t charCode) { return UnicodeCharIs(UnicodePunctBits,  charCode); }
+//inline int OVR_CDECL OVR_iswupper (wchar_t charCode) { return UnicodeCharIs(UnicodeUpperBits,  charCode); }
+
+int OVR_CDECL OVR_towupper(wchar_t charCode);
+int OVR_CDECL OVR_towlower(wchar_t charCode);
+
+#else // OVR_NO_WCTYPE
+
+inline int OVR_CDECL OVR_iswspace(wchar_t c)
+{
+    return iswspace(c);
+}
+
+inline int OVR_CDECL OVR_iswdigit(wchar_t c)
+{
+    return iswdigit(c);
+}
+
+inline int OVR_CDECL OVR_iswxdigit(wchar_t c)
+{
+    return iswxdigit(c);
+}
+
+inline int OVR_CDECL OVR_iswalpha(wchar_t c)
+{
+    return iswalpha(c);
+}
+
+inline int OVR_CDECL OVR_iswalnum(wchar_t c)
+{
+    return iswalnum(c);
+}
+
+inline wchar_t OVR_CDECL OVR_towlower(wchar_t c)
+{
+    return (wchar_t)towlower(c);
+}
+
+inline wchar_t OVR_towupper(wchar_t c)
+{
+    return (wchar_t)towupper(c);
+}
+
+#endif // OVR_NO_WCTYPE
+
+// ASCII versions of tolower and toupper. Don't use "char"
+inline int OVR_CDECL OVR_tolower(int c)
+{
+    return (c >= 'A' && c <= 'Z') ? c - 'A' + 'a' : c;
+}
+
+inline int OVR_CDECL OVR_toupper(int c)
+{
+    return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c;
+}
+
+
+
+inline double OVR_CDECL OVR_wcstod(const wchar_t* string, wchar_t** tailptr)
+{
+#if defined(OVR_OS_OTHER)
+    OVR_UNUSED(tailptr);
+    char buffer[64];
+    char* tp = NULL;
+    size_t max = OVR_wcslen(string);
+    if (max > 63) max = 63;
+    unsigned char c = 0;
+    for (size_t i=0; i < max; i++)
+    {
+        c = (unsigned char)string[i];
+        buffer[i] = ((c) < 128 ? (char)c : '!');
+    }
+    buffer[max] = 0;
+    return OVR_strtod(buffer, &tp);
+#else
+    return wcstod(string, tailptr);
+#endif
+}
+
+inline long OVR_CDECL OVR_wcstol(const wchar_t* string, wchar_t** tailptr, int radix)
+{
+#if defined(OVR_OS_OTHER)
+    OVR_UNUSED(tailptr);
+    char buffer[64];
+    char* tp = NULL;
+    size_t max = OVR_wcslen(string);
+    if (max > 63) max = 63;
+    unsigned char c = 0;
+    for (size_t i=0; i < max; i++)
+    {
+        c = (unsigned char)string[i];
+        buffer[i] = ((c) < 128 ? (char)c : '!');
+    }
+    buffer[max] = 0;
+    return strtol(buffer, &tp, radix);
+#else
+    return wcstol(string, tailptr, radix);
+#endif
+}
+
+} // OVR
+
+#endif // OVR_Std_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_String.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,658 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_String.h
+Content     :   String UTF8 string implementation with copy-on-write semantics
+                (thread-safe for assignment but not modification).
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_String_h
+#define OVR_String_h
+
+#include "OVR_Types.h"
+#include "OVR_Allocator.h"
+#include "OVR_UTF8Util.h"
+#include "OVR_Atomic.h"
+#include "OVR_Std.h"
+#include "OVR_Alg.h"
+
+namespace OVR {
+
+// ***** Classes
+
+class String;
+class StringBuffer;
+
+
+//-----------------------------------------------------------------------------------
+// ***** String Class 
+
+// String is UTF8 based string class with copy-on-write implementation
+// for assignment.
+
+class String
+{
+protected:
+
+    enum FlagConstants
+    {
+        //Flag_GetLength      = 0x7FFFFFFF,
+        // This flag is set if GetLength() == GetSize() for a string.
+        // Avoid extra scanning is Substring and indexing logic.
+        Flag_LengthIsSizeShift   = (sizeof(size_t)*8 - 1)
+    };
+
+
+    // Internal structure to hold string data
+    struct DataDesc
+    {
+        // Number of bytes. Will be the same as the number of chars if the characters
+        // are ascii, may not be equal to number of chars in case string data is UTF8.
+        size_t  Size;       
+        volatile int32_t RefCount;
+        char    Data[1];
+
+        void    AddRef()
+        {
+            AtomicOps<int32_t>::ExchangeAdd_NoSync(&RefCount, 1);
+        }
+        // Decrement ref count. This needs to be thread-safe, since
+        // a different thread could have also decremented the ref count.
+        // For example, if u start off with a ref count = 2. Now if u
+        // decrement the ref count and check against 0 in different
+        // statements, a different thread can also decrement the ref count
+        // in between our decrement and checking against 0 and will find
+        // the ref count = 0 and delete the object. This will lead to a crash
+        // when context switches to our thread and we'll be trying to delete
+        // an already deleted object. Hence decrementing the ref count and
+        // checking against 0 needs to made an atomic operation.
+        void    Release()
+        {
+            if ((AtomicOps<int32_t>::ExchangeAdd_NoSync(&RefCount, -1) - 1) == 0)
+                OVR_FREE(this);
+        }
+
+        static size_t GetLengthFlagBit()     { return size_t(1) << Flag_LengthIsSizeShift; }
+        size_t      GetSize() const         { return Size & ~GetLengthFlagBit() ; }
+        size_t      GetLengthFlag()  const  { return Size & GetLengthFlagBit(); }
+        bool        LengthIsSize() const    { return GetLengthFlag() != 0; }
+    };
+
+    // Heap type of the string is encoded in the lower bits.
+    enum HeapType
+    {
+        HT_Global   = 0,    // Heap is global.
+        HT_Local    = 1,    // SF::String_loc: Heap is determined based on string's address.
+        HT_Dynamic  = 2,    // SF::String_temp: Heap is stored as a part of the class.
+        HT_Mask     = 3
+    };
+
+    union {
+        DataDesc* pData;
+        size_t    HeapTypeBits;
+    };
+    typedef union {
+        DataDesc* pData;
+        size_t    HeapTypeBits;
+    } DataDescUnion;
+
+    inline HeapType    GetHeapType() const { return (HeapType) (HeapTypeBits & HT_Mask); }
+
+    inline DataDesc*   GetData() const
+    {
+        DataDescUnion u;
+        u.pData    = pData;
+        u.HeapTypeBits = (u.HeapTypeBits & ~(size_t)HT_Mask);
+        return u.pData;
+    }
+    
+    inline void        SetData(DataDesc* pdesc)
+    {
+        HeapType ht = GetHeapType();
+        pData = pdesc;
+        OVR_ASSERT((HeapTypeBits & HT_Mask) == 0);
+        HeapTypeBits |= ht;        
+    }
+
+    
+    DataDesc*   AllocData(size_t size, size_t lengthIsSize);
+    DataDesc*   AllocDataCopy1(size_t size, size_t lengthIsSize,
+                               const char* pdata, size_t copySize);
+    DataDesc*   AllocDataCopy2(size_t size, size_t lengthIsSize,
+                               const char* pdata1, size_t copySize1,
+                               const char* pdata2, size_t copySize2);
+
+    // Special constructor to avoid data initalization when used in derived class.
+    struct NoConstructor { };
+    String(const NoConstructor&) { }
+
+public:
+
+    // For initializing string with dynamic buffer
+    struct InitStruct
+    {
+        virtual ~InitStruct() { }
+        virtual void InitString(char* pbuffer, size_t size) const = 0;
+    };
+
+
+    // Constructors / Destructors.
+    String();
+    String(const char* data);
+    String(const char* data1, const char* pdata2, const char* pdata3 = 0);
+    String(const char* data, size_t buflen);
+    String(const String& src);
+    String(const StringBuffer& src);
+    String(const InitStruct& src, size_t size);
+    explicit String(const wchar_t* data);      
+
+    // Destructor (Captain Obvious guarantees!)
+    ~String()
+    {
+        GetData()->Release();
+    }
+
+    // Declaration of NullString
+    static DataDesc NullData;
+
+
+    // *** General Functions
+
+    void        Clear();
+
+    // For casting to a pointer to char.
+    operator const char*() const        { return GetData()->Data; }
+    // Pointer to raw buffer.
+    const char* ToCStr() const          { return GetData()->Data; }
+
+    // Returns number of bytes
+    size_t      GetSize() const         { return GetData()->GetSize() ; }
+    // Tells whether or not the string is empty
+    bool        IsEmpty() const         { return GetSize() == 0; }
+
+    // Returns  number of characters
+    size_t      GetLength() const;
+    int         GetLengthI() const      { return (int)GetLength(); }
+
+    // Returns  character at the specified index
+    uint32_t    GetCharAt(size_t index) const;
+    uint32_t    GetFirstCharAt(size_t index, const char** offset) const;
+    uint32_t    GetNextChar(const char** offset) const;
+
+    // Appends a character
+    void        AppendChar(uint32_t ch);
+
+    // Append a string
+    void        AppendString(const wchar_t* pstr, intptr_t len = -1);
+    void        AppendString(const char* putf8str, intptr_t utf8StrSz = -1);
+
+    // Assigned a string with dynamic data (copied through initializer).
+    void        AssignString(const InitStruct& src, size_t size);
+    // Assigns string with known size.
+    void        AssignString(const char* putf8str, size_t size);
+
+    //  Resize the string to the new size
+//  void        Resize(size_t _size);
+
+    // Removes the character at posAt
+    void        Remove(size_t posAt, intptr_t len = 1);
+
+    // Returns a String that's a substring of this.
+    //  -start is the index of the first UTF8 character you want to include.
+    //  -end is the index one past the last UTF8 character you want to include.
+    String   Substring(size_t start, size_t end) const;
+
+    // Case-conversion
+    String   ToUpper() const;
+    String   ToLower() const;
+
+    // Inserts substr at posAt
+    String&    Insert (const char* substr, size_t posAt, intptr_t len = -1);
+
+    // Inserts character at posAt
+    size_t      InsertCharAt(uint32_t c, size_t posAt);
+
+    // Inserts substr at posAt, which is an index of a character (not byte).
+    // Of size is specified, it is in bytes.
+//  String&    Insert(const uint32_t* substr, size_t posAt, intptr_t size = -1);
+
+    // Get Byte index of the character at position = index
+    size_t      GetByteIndex(size_t index) const { return (size_t)UTF8Util::GetByteIndex(index, GetData()->Data); }
+
+    // Utility: case-insensitive string compare.  stricmp() & strnicmp() are not
+    // ANSI or POSIX, do not seem to appear in Linux.
+    static int OVR_STDCALL   CompareNoCase(const char* a, const char* b);
+    static int OVR_STDCALL   CompareNoCase(const char* a, const char* b, intptr_t len);
+
+    // Hash function, case-insensitive
+    static size_t OVR_STDCALL BernsteinHashFunctionCIS(const void* pdataIn, size_t size, size_t seed = 5381);
+
+    // Hash function, case-sensitive
+    static size_t OVR_STDCALL BernsteinHashFunction(const void* pdataIn, size_t size, size_t seed = 5381);
+
+
+    // ***** File path parsing helper functions.
+    // Implemented in OVR_String_FilePath.cpp.
+
+    // Absolute paths can star with:
+    //  - protocols:        'file://', 'http://'
+    //  - windows drive:    'c:\'
+    //  - UNC share name:   '\\share'
+    //  - unix root         '/'
+    static bool HasAbsolutePath(const char* path);
+    static bool HasExtension(const char* path);
+    static bool HasProtocol(const char* path);
+
+    bool    HasAbsolutePath() const { return HasAbsolutePath(ToCStr()); }
+    bool    HasExtension() const    { return HasExtension(ToCStr()); }
+    bool    HasProtocol() const     { return HasProtocol(ToCStr()); }
+
+    String  GetProtocol() const;    // Returns protocol, if any, with trailing '://'.
+    String  GetPath() const;        // Returns path with trailing '/'.
+    String  GetFilename() const;    // Returns filename, including extension.
+    String  GetExtension() const;   // Returns extension with a dot.
+
+    void    StripProtocol();        // Strips front protocol, if any, from the string.
+    void    StripExtension();       // Strips off trailing extension.
+    
+
+    // Operators
+    // Assignment
+    void        operator =  (const char* str);
+    void        operator =  (const wchar_t* str);
+    void        operator =  (const String& src);
+    void        operator =  (const StringBuffer& src);
+
+    // Addition
+    void        operator += (const String& src);
+    void        operator += (const char* psrc)       { AppendString(psrc); }
+    void        operator += (const wchar_t* psrc)    { AppendString(psrc); }
+    void        operator += (char  ch)               { AppendChar(ch); }
+    String      operator +  (const char* str) const;
+    String      operator +  (const String& src)  const;
+
+    // Comparison
+    bool        operator == (const String& str) const
+    {
+        return (OVR_strcmp(GetData()->Data, str.GetData()->Data)== 0);
+    }
+
+    bool        operator != (const String& str) const
+    {
+        return !operator == (str);
+    }
+
+    bool        operator == (const char* str) const
+    {
+        return OVR_strcmp(GetData()->Data, str) == 0;
+    }
+
+    bool        operator != (const char* str) const
+    {
+        return !operator == (str);
+    }
+
+    bool        operator <  (const char* pstr) const
+    {
+        return OVR_strcmp(GetData()->Data, pstr) < 0;
+    }
+
+    bool        operator <  (const String& str) const
+    {
+        return *this < str.GetData()->Data;
+    }
+
+    bool        operator >  (const char* pstr) const
+    {
+        return OVR_strcmp(GetData()->Data, pstr) > 0;
+    }
+
+    bool        operator >  (const String& str) const
+    {
+        return *this > str.GetData()->Data;
+    }
+
+    int CompareNoCase(const char* pstr) const
+    {
+        return CompareNoCase(GetData()->Data, pstr);
+    }
+    int CompareNoCase(const String& str) const
+    {
+        return CompareNoCase(GetData()->Data, str.ToCStr());
+    }
+
+    // Accesses raw bytes
+    const char&     operator [] (int index) const
+    {
+        OVR_ASSERT(index >= 0 && (size_t)index < GetSize());
+        return GetData()->Data[index];
+    }
+    const char&     operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < GetSize());
+        return GetData()->Data[index];
+    }
+
+
+    // Case insensitive keys are used to look up insensitive string in hash tables
+    // for SWF files with version before SWF 7.
+    struct NoCaseKey
+    {   
+        const String* pStr;
+        NoCaseKey(const String &str) : pStr(&str){};
+    };
+
+    bool    operator == (const NoCaseKey& strKey) const
+    {
+        return (CompareNoCase(ToCStr(), strKey.pStr->ToCStr()) == 0);
+    }
+    bool    operator != (const NoCaseKey& strKey) const
+    {
+        return !(CompareNoCase(ToCStr(), strKey.pStr->ToCStr()) == 0);
+    }
+
+    // Hash functor used for strings.
+    struct HashFunctor
+    {    
+        size_t operator()(const String& data) const
+        {
+            size_t size = data.GetSize();
+            return String::BernsteinHashFunction((const char*)data, size);
+        }        
+    };
+    // Case-insensitive hash functor used for strings. Supports additional
+    // lookup based on NoCaseKey.
+    struct NoCaseHashFunctor
+    {    
+        size_t operator()(const String& data) const
+        {
+            size_t size = data.GetSize();
+            return String::BernsteinHashFunctionCIS((const char*)data, size);
+        }
+        size_t operator()(const NoCaseKey& data) const
+        {       
+            size_t size = data.pStr->GetSize();
+            return String::BernsteinHashFunctionCIS((const char*)data.pStr->ToCStr(), size);
+        }
+    };
+
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** String Buffer used for Building Strings
+
+class StringBuffer
+{
+    char*           pData;
+    size_t          Size;
+    size_t          BufferSize;
+    size_t          GrowSize;    
+    mutable bool    LengthIsSize;    
+
+public:
+
+    // Constructors / Destructor.    
+    StringBuffer();
+    explicit StringBuffer(size_t growSize);
+    StringBuffer(const char* data);
+    StringBuffer(const char* data, size_t buflen);
+    StringBuffer(const String& src);
+    StringBuffer(const StringBuffer& src);
+    explicit StringBuffer(const wchar_t* data);
+    ~StringBuffer();
+    
+
+    // Modify grow size used for growing/shrinking the buffer.
+    size_t      GetGrowSize() const         { return GrowSize; }
+    void        SetGrowSize(size_t growSize);
+    
+
+    // *** General Functions
+    // Does not release memory, just sets Size to 0
+    void        Clear();
+
+    // For casting to a pointer to char.
+    operator const char*() const        { return (pData) ? pData : ""; }
+    // Pointer to raw buffer.
+    const char* ToCStr() const          { return (pData) ? pData : ""; }
+
+    // Returns number of bytes.
+    size_t      GetSize() const         { return Size ; }
+    // Tells whether or not the string is empty.
+    bool        IsEmpty() const         { return GetSize() == 0; }
+
+    // Returns  number of characters
+    size_t      GetLength() const;
+
+    // Returns  character at the specified index
+    uint32_t    GetCharAt(size_t index) const;
+    uint32_t    GetFirstCharAt(size_t index, const char** offset) const;
+    uint32_t    GetNextChar(const char** offset) const;
+
+
+    //  Resize the string to the new size
+    void        Resize(size_t _size);
+    void        Reserve(size_t _size);
+
+    // Appends a character
+    void        AppendChar(uint32_t ch);
+
+    // Append a string
+    void        AppendString(const wchar_t* pstr, intptr_t len = -1);
+    void        AppendString(const char* putf8str, intptr_t utf8StrSz = -1);
+    void        AppendFormat(const char* format, ...);
+
+    // Assigned a string with dynamic data (copied through initializer).
+    //void        AssignString(const InitStruct& src, size_t size);
+
+    // Inserts substr at posAt
+    void        Insert (const char* substr, size_t posAt, intptr_t len = -1);
+    // Inserts character at posAt
+    size_t      InsertCharAt(uint32_t c, size_t posAt);
+
+    // Assignment
+    void        operator =  (const char* str);
+    void        operator =  (const wchar_t* str);
+    void        operator =  (const String& src);
+    void        operator =  (const StringBuffer& src);
+
+    // Addition
+    void        operator += (const String& src)      { AppendString(src.ToCStr(),src.GetSize()); }
+    void        operator += (const char* psrc)       { AppendString(psrc); }
+    void        operator += (const wchar_t* psrc)    { AppendString(psrc); }
+    void        operator += (char  ch)               { AppendChar(ch); }
+    //String   operator +  (const char* str) const ;
+    //String   operator +  (const String& src)  const ;
+
+    // Accesses raw bytes
+    char&       operator [] (int index)
+    {
+        OVR_ASSERT(((size_t)index) < GetSize());
+        return pData[index];
+    }
+    char&       operator [] (size_t index)
+    {
+        OVR_ASSERT(index < GetSize());
+        return pData[index];
+    }
+
+    const char&     operator [] (int index) const 
+    {
+        OVR_ASSERT(((size_t)index) < GetSize());
+        return pData[index];
+    }
+    const char&     operator [] (size_t index) const
+    {
+        OVR_ASSERT(index < GetSize());
+        return pData[index];
+    }
+};
+
+
+//
+// Wrapper for string data. The data must have a guaranteed 
+// lifespan throughout the usage of the wrapper. Not intended for 
+// cached usage. Not thread safe.
+//
+class StringDataPtr
+{
+public:
+    StringDataPtr() : pStr(NULL), Size(0) {}
+    StringDataPtr(const StringDataPtr& p)
+        : pStr(p.pStr), Size(p.Size) {}
+    StringDataPtr(const char* pstr, size_t sz)
+        : pStr(pstr), Size(sz) {}
+    StringDataPtr(const char* pstr)
+        : pStr(pstr), Size((pstr != NULL) ? OVR_strlen(pstr) : 0) {}
+    explicit StringDataPtr(const String& str)
+        : pStr(str.ToCStr()), Size(str.GetSize()) {}
+    template <typename T, int N> 
+    StringDataPtr(const T (&v)[N])
+        : pStr(v), Size(N) {}
+
+public:
+    const char* ToCStr() const { return pStr; }
+    size_t      GetSize() const { return Size; }
+    bool        IsEmpty() const { return GetSize() == 0; }
+
+    // value is a prefix of this string
+    // Character's values are not compared.
+    bool        IsPrefix(const StringDataPtr& value) const
+    {
+        return ToCStr() == value.ToCStr() && GetSize() >= value.GetSize();
+    }
+    // value is a suffix of this string
+    // Character's values are not compared.
+    bool        IsSuffix(const StringDataPtr& value) const
+    {
+        return ToCStr() <= value.ToCStr() && (End()) == (value.End());
+    }
+
+    // Find first character.
+    // init_ind - initial index.
+    intptr_t    FindChar(char c, size_t init_ind = 0) const 
+    {
+        for (size_t i = init_ind; i < GetSize(); ++i)
+            if (pStr[i] == c)
+                return static_cast<intptr_t>(i);
+
+        return -1; 
+    }
+
+    // Find last character.
+    // init_ind - initial index.
+    intptr_t    FindLastChar(char c, size_t init_ind = ~0) const 
+    {
+        if (init_ind == (size_t)~0 || init_ind > GetSize())
+            init_ind = GetSize();
+        else
+            ++init_ind;
+
+        for (size_t i = init_ind; i > 0; --i)
+            if (pStr[i - 1] == c)
+                return static_cast<intptr_t>(i - 1);
+
+        return -1; 
+    }
+
+    // Create new object and trim size bytes from the left.
+    StringDataPtr  GetTrimLeft(size_t size) const
+    {
+        // Limit trim size to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+
+        return StringDataPtr(ToCStr() + size, GetSize() - size);
+    }
+    // Create new object and trim size bytes from the right.
+    StringDataPtr  GetTrimRight(size_t size) const
+    {
+        // Limit trim to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+
+        return StringDataPtr(ToCStr(), GetSize() - size);
+    }
+
+    // Create new object, which contains next token.
+    // Useful for parsing.
+    StringDataPtr GetNextToken(char separator = ':') const
+    {
+        size_t cur_pos = 0;
+        const char* cur_str = ToCStr();
+
+        for (; cur_pos < GetSize() && cur_str[cur_pos]; ++cur_pos)
+        {
+            if (cur_str[cur_pos] == separator)
+            {
+                break;
+            }
+        }
+
+        return StringDataPtr(ToCStr(), cur_pos);
+    }
+
+    // Trim size bytes from the left.
+    StringDataPtr& TrimLeft(size_t size)
+    {
+        // Limit trim size to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+        pStr += size;
+        Size -= size;
+
+        return *this;
+    }
+    // Trim size bytes from the right.
+    StringDataPtr& TrimRight(size_t size)
+    {
+        // Limit trim to the size of the string.
+        size = Alg::PMin(GetSize(), size);
+        Size -= size;
+
+        return *this;
+    }
+
+    const char* Begin() const { return ToCStr(); }
+    const char* End() const { return ToCStr() + GetSize(); }
+
+    // Hash functor used string data pointers
+    struct HashFunctor
+    {    
+        size_t operator()(const StringDataPtr& data) const
+        {
+            return String::BernsteinHashFunction(data.ToCStr(), data.GetSize());
+        }        
+    };
+
+    bool operator== (const StringDataPtr& data) const 
+    {
+        return (OVR_strncmp(pStr, data.pStr, data.Size) == 0);
+    }
+
+protected:
+    const char* pStr;
+    size_t      Size;
+};
+
+} // OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_StringHash.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_StringHash.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,100 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_StringHash.h
+Content     :   String hash table used when optional case-insensitive
+                lookup is required.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_StringHash_h
+#define OVR_StringHash_h
+
+#include "OVR_String.h"
+#include "OVR_Hash.h"
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// *** StringHash
+
+// This is a custom string hash table that supports case-insensitive
+// searches through special functions such as GetCaseInsensitive, etc.
+// This class is used for Flash labels, exports and other case-insensitive tables.
+
+template<class U, class Allocator = ContainerAllocator<U> >
+class StringHash : public Hash<String, U, String::NoCaseHashFunctor, Allocator>
+{
+public:
+    typedef U                                                        ValueType;
+    typedef StringHash<U, Allocator>                                 SelfType;
+    typedef Hash<String, U, String::NoCaseHashFunctor, Allocator>    BaseType;
+
+public:    
+
+    void    operator = (const SelfType& src) { BaseType::operator = (src); }
+
+    bool    GetCaseInsensitive(const String& key, U* pvalue) const
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey, pvalue);
+    }
+    // Pointer-returning get variety.
+    const U* GetCaseInsensitive(const String& key) const   
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey);
+    }
+    U*  GetCaseInsensitive(const String& key)
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::GetAlt(ikey);
+    }
+
+    
+    typedef typename BaseType::Iterator base_iterator;
+
+    base_iterator    FindCaseInsensitive(const String& key)
+    {
+        String::NoCaseKey ikey(key);
+        return BaseType::FindAlt(ikey);
+    }
+
+    // Set just uses a find and assigns value if found. The key is not modified;
+    // this behavior is identical to Flash string variable assignment.    
+    void    SetCaseInsensitive(const String& key, const U& value)
+    {
+        base_iterator it = FindCaseInsensitive(key);
+        if (it != BaseType::End())
+        {
+            it->Second = value;
+        }
+        else
+        {
+            BaseType::Add(key, value);
+        }
+    } 
+};
+
+} // OVR 
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_SysFile.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,104 @@
+/************************************************************************************
+
+PublicHeader:   Kernel
+Filename    :   OVR_SysFile.h
+Content     :   Header for all internal file management - functions and structures
+                to be inherited by OS specific subclasses.
+Created     :   September 19, 2012
+Notes       : 
+
+Notes       :   errno may not be preserved across use of GBaseFile member functions
+            :   Directories cannot be deleted while files opened from them are in use
+                (For the GetFullName function)
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SysFile_h
+#define OVR_SysFile_h
+
+#include "OVR_File.h"
+
+namespace OVR {
+
+// ***** Declared classes
+class   SysFile;
+
+//-----------------------------------------------------------------------------------
+// *** File Statistics
+
+// This class contents are similar to _stat, providing
+// creation, modify and other information about the file.
+struct FileStat
+{
+    // No change or create time because they are not available on most systems
+    int64_t ModifyTime;
+    int64_t AccessTime;
+    int64_t FileSize;
+
+    bool operator== (const FileStat& stat) const
+    {
+        return ( (ModifyTime == stat.ModifyTime) &&
+                 (AccessTime == stat.AccessTime) &&
+                 (FileSize == stat.FileSize) );
+    }
+};
+
+//-----------------------------------------------------------------------------------
+// *** System File
+
+// System file is created to access objects on file system directly
+// This file can refer directly to path.
+// System file can be open & closed several times; however, such use is not recommended
+// This class is realy a wrapper around an implementation of File interface for a 
+// particular platform.
+
+class SysFile : public DelegatedFile
+{
+protected:
+  SysFile(const SysFile &source) : DelegatedFile () { OVR_UNUSED(source); }
+public:
+
+    // ** Constructor
+    SysFile();
+    // Opens a file
+    SysFile(const String& path, int flags = Open_Read|Open_Buffered, int mode = Mode_ReadWrite); 
+
+    // ** Open & management 
+    bool  Open(const String& path, int flags = Open_Read|Open_Buffered, int mode = Mode_ReadWrite);
+        
+    OVR_FORCE_INLINE bool  Create(const String& path, int mode = Mode_ReadWrite)
+    { return Open(path, Open_ReadWrite|Open_Create, mode); }
+
+    // Helper function: obtain file statistics information. In OVR, this is used to detect file changes.
+    // Return 0 if function failed, most likely because the file doesn't exist.
+    static bool OVR_CDECL GetFileStat(FileStat* pfileStats, const String& path);
+    
+    // ** Overrides
+    // Overridden to provide re-open support
+    virtual int   GetErrorCode();
+
+    virtual bool  IsValid();
+
+    virtual bool  Close();    
+};
+
+} // Namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_System.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,172 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_System.h
+Content     :   General kernel initialization/cleanup, including that
+                of the memory allocator.
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_System_h
+#define OVR_System_h
+
+#include "OVR_Allocator.h"
+#include "OVR_Log.h"
+#include "OVR_Atomic.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// SystemSingleton
+
+// Subsystems are implemented using the Singleton pattern.
+// To avoid code duplication in all the places where Singletons are defined,
+// The pattern is defined once here and used everywhere.
+
+class SystemSingletonInternal
+{
+    friend class System;
+
+    SystemSingletonInternal* NextSingleton;
+
+    // No copying allowed
+    SystemSingletonInternal(const SystemSingletonInternal&) {}
+    void operator=(const SystemSingletonInternal&) {}
+
+protected:
+    SystemSingletonInternal() :
+        NextSingleton(0)
+    {
+    }
+
+    // Call this to register the destroy events
+    // Destroy callbacks will be called in the reverse order they were registered
+    // Note: As a rule of thumb, call this at the end of the singleton class constructor.
+    void PushDestroyCallbacks();
+
+    // Required: Invoked when the System object is shutting down
+    // Called after threads are stopped
+    // Called before Log, Allocator, and Timer subsystems are stopped
+    // Listeners are called in the opposite order they were registered
+    virtual void OnSystemDestroy() = 0;
+
+    // Called just before waiting for threads to die
+    // Listeners are called in the opposite order they were registered
+    // Useful to start terminating threads at the right time
+    // Note: The singleton must not delete itself here.
+    virtual void OnThreadDestroy() {}
+};
+
+// Singletons derive from this class
+template<class T>
+class SystemSingletonBase : public SystemSingletonInternal
+{
+    static AtomicPtr<T> SingletonInstance;
+    static T* SlowGetInstance();
+
+protected:
+    ~SystemSingletonBase()
+    {
+        // Make sure the instance gets set to zero on dtor
+        if (SingletonInstance == this)
+            SingletonInstance = 0;
+    }
+
+public:
+    static OVR_FORCE_INLINE T* GetInstance()
+    {
+        // Fast version
+        // Note: The singleton instance is stored in an AtomicPtr<> to allow it to be accessed
+        // atomically from multiple threads without locks.
+        T* instance = SingletonInstance;
+        return instance ? instance : SlowGetInstance();
+    }
+};
+
+// For reference, see N3337 14.5.1.3 (Static data members of class templates):
+template<class T> OVR::AtomicPtr<T> OVR::SystemSingletonBase<T>::SingletonInstance;
+
+// Place this in the singleton class in the header file
+#define OVR_DECLARE_SINGLETON(T) \
+    friend class OVR::SystemSingletonBase<T>; \
+private: \
+    T(); \
+    virtual ~T(); \
+    virtual void OnSystemDestroy();
+
+// Place this in the singleton class source file
+#define OVR_DEFINE_SINGLETON(T) \
+    namespace OVR { \
+    template<> T* SystemSingletonBase<T>::SlowGetInstance() \
+    { \
+        static OVR::Lock lock; \
+        OVR::Lock::Locker locker(&lock); \
+        if (!SingletonInstance) SingletonInstance = new T; \
+        return SingletonInstance; \
+    } \
+    }
+
+
+// ***** System Core Initialization class
+
+// System initialization must take place before any other OVR_Kernel objects are used;
+// this is done my calling System::Init(). Among other things, this is necessary to
+// initialize the memory allocator. Similarly, System::Destroy must be
+// called before program exist for proper cleanup. Both of these tasks can be achieved by
+// simply creating System object first, allowing its constructor/destructor do the work.
+
+// TBD: Require additional System class for Oculus Rift API?
+
+class System
+{
+public:
+    // System constructor expects allocator to be specified, if it is being substituted.
+    System(Log* log = Log::ConfigureDefaultLog(LogMask_Debug),
+           Allocator* palloc = DefaultAllocator::InitSystemSingleton())
+    {
+        Init(log, palloc);
+    }
+    ~System()
+    {
+        Destroy();
+    }
+
+	static void OVR_CDECL DirectDisplayInitialize();
+
+    // Returns 'true' if system was properly initialized.
+    static bool OVR_CDECL IsInitialized();
+
+    // Initializes System core.  Users can override memory implementation by passing
+    // a different Allocator here.
+    static void OVR_CDECL Init(Log* log = Log::ConfigureDefaultLog(LogMask_Debug),
+                               Allocator *palloc = DefaultAllocator::InitSystemSingleton());
+
+	// De-initializes System more, finalizing the threading system and destroying
+    // the global memory allocator.
+    static void OVR_CDECL Destroy();
+};
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_ThreadCommandQueue.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,318 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_ThreadCommandQueue.h
+Content     :   Command queue for operations executed on a thread
+Created     :   October 29, 2012
+Author      :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_ThreadCommandQueue_h
+#define OVR_ThreadCommandQueue_h
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_List.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_Threads.h"
+
+namespace OVR {
+
+class ThreadCommand;
+class ThreadCommandQueue;
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadCommand
+
+// ThreadCommand is a base class implementation for commands stored in ThreadCommandQueue.
+class ThreadCommand
+{
+public:    
+    // NotifyEvent is used by ThreadCommandQueue::PushCallAndWait to notify the
+    // calling (producer)  thread when command is completed or queue slot is available.
+    class NotifyEvent : public ListNode<NotifyEvent>, public NewOverrideBase
+    {
+        Event E;
+    public:   
+        NotifyEvent() { }
+
+        void Wait()        { E.Wait(); }
+        void PulseEvent()  { E.PulseEvent(); }
+    };
+
+    // ThreadCommand::PopBuffer is temporary storage for a command popped off
+    // by ThreadCommandQueue::PopCommand. 
+    class PopBuffer
+    {
+        enum { MaxSize = 256 };
+
+        size_t Size;
+        union {            
+            uint8_t Buffer[MaxSize];
+            size_t Align;
+        };
+
+        ThreadCommand* toCommand() const { return (ThreadCommand*)Buffer; }
+
+    public:
+        PopBuffer() : Size(0) { }
+        ~PopBuffer();
+
+        void        InitFromBuffer(void* data);
+
+        bool        HasCommand() const  { return Size != 0; }
+        size_t      GetSize() const     { return Size; }
+        bool        NeedsWait() const   { return toCommand()->NeedsWait(); }
+        NotifyEvent* GetEvent() const   { return toCommand()->pEvent; }
+
+        // Execute the command and also notifies caller to finish waiting,
+        // if necessary.
+        void        Execute();
+    };
+    
+    uint16_t     Size;
+    bool         WaitFlag; 
+    bool         ExitFlag; // Marks the last exit command. 
+    NotifyEvent* pEvent;
+
+    ThreadCommand(size_t size, bool waitFlag, bool exitFlag = false)
+        : Size((uint16_t)size), WaitFlag(waitFlag), ExitFlag(exitFlag), pEvent(0) { }
+    virtual ~ThreadCommand() { }
+
+    bool          NeedsWait() const { return WaitFlag; }
+    size_t        GetSize() const   { return Size; }
+
+    virtual void            Execute() const = 0;
+    // Copy constructor used for serializing this to memory buffer.
+    virtual ThreadCommand*  CopyConstruct(void* p) const = 0;
+};
+
+
+//-------------------------------------------------------------------------------------
+
+// CleanType is a template that strips 'const' and '&' modifiers from the argument type;
+// for example, typename CleanType<A&>::Type is equivalent to A.
+template<class T> struct CleanType           { typedef T Type; };
+template<class T> struct CleanType<T&>       { typedef T Type; };
+template<class T> struct CleanType<const T>  { typedef T Type; };
+template<class T> struct CleanType<const T&> { typedef T Type; };
+
+// SelfType is a template that yields the argument type. This helps avoid conflicts with
+// automatic template argument deduction for function calls when identical argument
+// is already defined.
+template<class T> struct SelfType { typedef T Type; };
+
+
+
+//-------------------------------------------------------------------------------------
+// ThreadCommand specializations for member functions with different number of
+// arguments and argument types.
+
+// Used to return nothing from a ThreadCommand, to avoid problems with 'void'.
+struct Void
+{
+    Void() {}
+    Void(int) {}
+};
+
+// ThreadCommand for member function with 0 arguments.
+template<class C, class R>
+class ThreadCommandMF0 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)();
+    C*      pClass;
+    FnPtr   pFn;
+    R*      pRet;
+
+    void executeImpl() const
+    {
+        pRet ? (void)(*pRet = (pClass->*pFn)()) :
+	           (void)(pClass->*pFn)();
+    }
+
+public:    
+    ThreadCommandMF0(C* pclass, FnPtr fn, R* ret, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF0), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret) { }
+
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const
+    { return Construct<ThreadCommandMF0>(p, *this); }
+};
+
+
+// ThreadCommand for member function with 1 argument.
+template<class C, class R, class A0>
+class ThreadCommandMF1 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)(A0);
+    C*                           pClass;
+    FnPtr                        pFn;
+    R*                           pRet;
+    typename CleanType<A0>::Type AVal0;
+
+    void executeImpl() const
+    {
+      pRet ? (void)(*pRet = (pClass->*pFn)(AVal0)) :
+	         (void)(pClass->*pFn)(AVal0);
+    }
+
+public:    
+    ThreadCommandMF1(C* pclass, FnPtr fn, R* ret, A0 a0, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF1), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret), AVal0(a0) { }
+
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const
+    { return Construct<ThreadCommandMF1>(p, *this); }
+};
+
+// ThreadCommand for member function with 2 arguments.
+template<class C, class R, class A0, class A1>
+class ThreadCommandMF2 : public ThreadCommand
+{   
+    typedef R (C::*FnPtr)(A0, A1);
+    C*                            pClass;
+    FnPtr                         pFn;
+    R*                            pRet;
+    typename CleanType<A0>::Type  AVal0;
+    typename CleanType<A1>::Type  AVal1;
+
+    void executeImpl() const
+    {
+        pRet ? (void)(*pRet = (pClass->*pFn)(AVal0, AVal1)) :
+	           (void)(pClass->*pFn)(AVal0, AVal1);
+    }
+
+public:    
+    ThreadCommandMF2(C* pclass, FnPtr fn, R* ret, A0 a0, A1 a1, bool needsWait)
+        : ThreadCommand(sizeof(ThreadCommandMF2), needsWait),
+          pClass(pclass), pFn(fn), pRet(ret), AVal0(a0), AVal1(a1) { }
+    
+    virtual void           Execute() const { executeImpl(); }
+    virtual ThreadCommand* CopyConstruct(void* p) const 
+    { return Construct<ThreadCommandMF2>(p, *this); }
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** ThreadCommandQueue
+
+// ThreadCommandQueue is a queue of executable function-call commands intended to be
+// serviced by a single consumer thread. Commands are added to the queue with PushCall
+// and removed with PopCall; they are processed in FIFO order. Multiple producer threads
+// are supported and will be blocked if internal data buffer is full.
+
+class ThreadCommandQueue
+{
+public:
+
+    ThreadCommandQueue();
+    virtual ~ThreadCommandQueue();
+
+
+    // Pops the next command from the thread queue, if any is available.
+    // The command should be executed by calling popBuffer->Execute().
+    // Returns 'false' if no command is available at the time of the call.
+    bool PopCommand(ThreadCommand::PopBuffer* popBuffer);
+
+    // Generic implementaion of PushCommand; enqueues a command for execution.
+    // Returns 'false' if push failed, usually indicating thread shutdown.
+    bool PushCommand(const ThreadCommand& command);
+
+    // 
+    void PushExitCommand(bool wait);
+
+    // Returns 'true' once ExitCommand has been processed, so the thread can shut down.
+    bool IsExiting() const;
+
+
+    // These two virtual functions serve as notifications for derived
+    // thread waiting.    
+    virtual void OnPushNonEmpty_Locked() { }
+    virtual void OnPopEmpty_Locked()     { }
+
+
+    // *** PushCall with no result
+    
+    // Enqueue a member function of 'this' class to be called on consumer thread.
+    // By default the function returns immediately; set 'wait' argument to 'true' to
+    // wait for completion.
+    template<class C, class R>
+    bool PushCall(R (C::*fn)(), bool wait = false)
+    { return PushCommand(ThreadCommandMF0<C,R>(static_cast<C*>(this), fn, 0, wait)); }       
+    template<class C, class R, class A0>
+    bool PushCall(R (C::*fn)(A0), typename SelfType<A0>::Type a0, bool wait = false)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(static_cast<C*>(this), fn, 0, a0, wait)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCall(R (C::*fn)(A0, A1),
+                  typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1, bool wait = false)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(static_cast<C*>(this), fn, 0, a0, a1, wait)); }
+    // Enqueue a specified member function call of class C.
+    // By default the function returns immediately; set 'wait' argument to 'true' to
+    // wait for completion.
+    template<class C, class R>
+    bool PushCall(C* p, R (C::*fn)(), bool wait = false)
+    { return PushCommand(ThreadCommandMF0<C,R>(p, fn, 0, wait)); }
+    template<class C, class R, class A0>
+    bool PushCall(C* p, R (C::*fn)(A0), typename SelfType<A0>::Type a0, bool wait = false)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(p, fn, 0, a0, wait)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCall(C* p, R (C::*fn)(A0, A1),
+                  typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1, bool wait = false)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(p, fn, 0, a0, a1, wait)); }
+    
+    
+    // *** PushCall with Result
+
+    // Enqueue a member function of 'this' class call and wait for call to complete
+    // on consumer thread before returning.
+    template<class C, class R>
+    bool PushCallAndWaitResult(R (C::*fn)(), R* ret)
+    { return PushCommand(ThreadCommandMF0<C,R>(static_cast<C*>(this), fn, ret, true)); }       
+    template<class C, class R, class A0>
+    bool PushCallAndWaitResult(R (C::*fn)(A0), R* ret, typename SelfType<A0>::Type a0)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(static_cast<C*>(this), fn, ret, a0, true)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCallAndWaitResult(R (C::*fn)(A0, A1), R* ret,
+                               typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(static_cast<C*>(this), fn, ret, a0, a1, true)); }
+    // Enqueue a member function call for class C and wait for the call to complete
+    // on consumer thread before returning.
+    template<class C, class R>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(), R* ret)
+    { return PushCommand(ThreadCommandMF0<C,R>(p, fn, ret, true)); }
+    template<class C, class R, class A0>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(A0), R* ret, typename SelfType<A0>::Type a0)
+    { return PushCommand(ThreadCommandMF1<C,R,A0>(p, fn, ret, a0, true)); }
+    template<class C, class R, class A0, class A1>
+    bool PushCallAndWaitResult(C* p, R (C::*fn)(A0, A1), R* ret,
+                               typename SelfType<A0>::Type a0, typename SelfType<A1>::Type a1)
+    { return PushCommand(ThreadCommandMF2<C,R,A0,A1>(p, fn, ret, a0, a1, true)); }
+
+private:
+    class ThreadCommandQueueImpl* pImpl;
+};
+
+
+} // namespace OVR
+
+#endif // OVR_ThreadCommandQueue_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Threads.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Threads.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,406 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_Threads.h
+Content     :   Contains thread-related (safe) functionality
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_Threads_h
+#define OVR_Threads_h
+
+#include "OVR_Types.h"
+#include "OVR_Atomic.h"
+#include "OVR_RefCount.h"
+#include "OVR_Array.h"
+
+// Defines the infinite wait delay timeout
+#define OVR_WAIT_INFINITE 0xFFFFFFFF
+
+// To be defined in the project configuration options
+#ifdef OVR_ENABLE_THREADS
+
+
+namespace OVR {
+
+//-----------------------------------------------------------------------------------
+// ****** Declared classes
+
+// Declared with thread support only
+class   Mutex;
+class   WaitCondition;
+class   Event;
+// Implementation forward declarations
+class MutexImpl;
+class WaitConditionImpl;
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Mutex
+
+// Mutex class represents a system Mutex synchronization object that provides access 
+// serialization between different threads, allowing one thread mutually exclusive access 
+// to a resource. Mutex is more heavy-weight then Lock, but supports WaitCondition.
+
+class Mutex
+{
+    friend class WaitConditionImpl;    
+    friend class MutexImpl;
+
+    MutexImpl  *pImpl; 
+
+public:
+    // Constructor/destructor
+    Mutex(bool recursive = 1);
+    ~Mutex();
+
+    // Locking functions
+    void  DoLock();
+    bool  TryLock();
+    void  Unlock();
+
+    // Returns 1 if the mutes is currently locked by another thread
+    // Returns 0 if the mutex is not locked by another thread, and can therefore be acquired. 
+    bool  IsLockedByAnotherThread();
+    
+    // Locker class; Used for automatic locking of a mutex withing scope    
+    class Locker
+    {
+    public:
+        Mutex *pMutex;
+        Locker(Mutex *pmutex)
+            { pMutex = pmutex; pMutex->DoLock(); }
+        ~Locker()
+            { pMutex->Unlock(); }
+    };
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** WaitCondition
+
+/*
+    WaitCondition is a synchronization primitive that can be used to implement what is known as a monitor.
+    Dependent threads wait on a wait condition by calling Wait(), and get woken up by other threads that
+    call Notify() or NotifyAll().
+
+    The unique feature of this class is that it provides an atomic way of first releasing a Mutex, and then 
+    starting a wait on a wait condition. If both the mutex and the wait condition are associated with the same
+    resource, this ensures that any condition checked for while the mutex was locked does not change before
+    the wait on the condition is actually initiated.
+*/
+
+class WaitCondition
+{
+    friend class WaitConditionImpl;
+    // Internal implementation structure
+    WaitConditionImpl *pImpl;
+
+public:
+    // Constructor/destructor
+    WaitCondition();
+    ~WaitCondition();
+
+    // Release mutex and wait for condition. The mutex is re-aquired after the wait.
+    // Delay is specified in milliseconds (1/1000 of a second).
+    bool    Wait(Mutex *pmutex, unsigned delay = OVR_WAIT_INFINITE);
+
+    // Notify a condition, releasing at one object waiting
+    void    Notify();
+    // Notify a condition, releasing all objects waiting
+    void    NotifyAll();
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Event
+
+// Event is a wait-able synchronization object similar to Windows event.
+// Event can be waited on until it's signaled by another thread calling
+// either SetEvent or PulseEvent.
+
+class Event
+{
+    // Event state, its mutex and the wait condition
+    volatile bool   State;
+    volatile bool   Temporary;  
+    mutable Mutex   StateMutex;
+    WaitCondition   StateWaitCondition;
+
+    void updateState(bool newState, bool newTemp, bool mustNotify);
+
+public:    
+    Event(bool setInitially = 0) : State(setInitially), Temporary(false) { }
+    ~Event() { }
+
+    // Wait on an event condition until it is set
+    // Delay is specified in milliseconds (1/1000 of a second).
+    bool  Wait(unsigned delay = OVR_WAIT_INFINITE);
+    
+    // Set an event, releasing objects waiting on it
+    void  SetEvent()
+    { updateState(true, false, true); }
+
+    // Reset an event, un-signaling it
+    void  ResetEvent()
+    { updateState(false, false, false); }
+
+    // Set and then reset an event once a waiter is released.
+    // If threads are already waiting, they will be notified and released
+    // If threads are not waiting, the event is set until the first thread comes in
+    void  PulseEvent()
+    { updateState(true, true, true); }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Thread class
+
+// ThreadId uniquely identifies a thread; returned by GetCurrentThreadId() and
+// Thread::GetThreadId.
+typedef void* ThreadId;
+
+
+// *** Thread flags
+
+// Indicates that the thread is has been started, i.e. Start method has been called, and threads
+// OnExit() method has not yet been called/returned.
+#define OVR_THREAD_STARTED               0x01
+// This flag is set once the thread has ran, and finished.
+#define OVR_THREAD_FINISHED              0x02
+// This flag is set temporarily if this thread was started suspended. It is used internally.
+#define OVR_THREAD_START_SUSPENDED       0x08
+// This flag is used to ask a thread to exit. Message driven threads will usually check this flag
+// and finish once it is set.
+#define OVR_THREAD_EXIT                  0x10
+
+
+class Thread : public RefCountBase<Thread>
+{ // NOTE: Waitable must be the first base since it implements RefCountImpl.    
+public:
+    // *** Callback functions, can be used instead of overriding Run
+
+    // Run function prototypes.    
+    // Thread function and user handle passed to it, executed by the default
+    // Thread::Run implementation if not null.
+    typedef int (*ThreadFn)(Thread *pthread, void* h);
+    
+    // Thread ThreadFunction1 is executed if not 0, otherwise ThreadFunction2 is tried
+    ThreadFn    ThreadFunction;    
+    // User handle passes to a thread
+    void*       UserHandle;
+
+    // Thread state to start a thread with
+    enum ThreadState
+    {
+        NotRunning  = 0,
+        Running     = 1,
+        Suspended   = 2
+    };
+
+    // Thread priority
+    enum ThreadPriority
+    {
+        CriticalPriority,
+        HighestPriority,
+        AboveNormalPriority,
+        NormalPriority,
+        BelowNormalPriority,
+        LowestPriority,
+        IdlePriority,
+    };
+
+    // Thread constructor parameters
+    struct CreateParams
+    {
+        CreateParams(ThreadFn func = 0, void* hand = 0, size_t ssize = 128 * 1024, 
+                     int proc = -1, ThreadState state = NotRunning, ThreadPriority prior = NormalPriority)
+                     : threadFunction(func), userHandle(hand), stackSize(ssize), 
+                       processor(proc), initialState(state), priority(prior) {}
+        ThreadFn       threadFunction;   // Thread function
+        void*          userHandle;       // User handle passes to a thread
+        size_t         stackSize;        // Thread stack size
+        int            processor;        // Thread hardware processor
+        ThreadState    initialState;     // 
+        ThreadPriority priority;         // Thread priority
+    };
+
+
+    // *** Constructors
+
+    // A default constructor always creates a thread in NotRunning state, because
+    // the derived class has not yet been initialized. The derived class can call Start explicitly.
+    // "processor" parameter specifies which hardware processor this thread will be run on. 
+    // -1 means OS decides this. Implemented only on Win32
+    Thread(size_t stackSize = 128 * 1024, int processor = -1);
+    // Constructors that initialize the thread with a pointer to function.
+    // An option to start a thread is available, but it should not be used if classes are derived from Thread.
+    // "processor" parameter specifies which hardware processor this thread will be run on. 
+    // -1 means OS decides this. Implemented only on Win32
+    Thread(ThreadFn threadFunction, void*  userHandle = 0, size_t stackSize = 128 * 1024,
+           int processor = -1, ThreadState initialState = NotRunning);
+    // Constructors that initialize the thread with a create parameters structure.
+    explicit Thread(const CreateParams& params);
+
+    // Destructor.
+    virtual ~Thread();
+
+    // Waits for all Threads to finish; should be called only from the root
+    // application thread. Once this function returns, we know that all other
+    // thread's references to Thread object have been released.
+    static  void OVR_CDECL FinishAllThreads();
+
+
+    // *** Overridable Run function for thread processing
+
+    // - returning from this method will end the execution of the thread
+    // - return value is usually 0 for success 
+    virtual int   Run();
+    // Called after return/exit function
+    virtual void  OnExit();
+
+
+    // *** Thread management
+
+    // Starts the thread if its not already running
+    // - internally sets up the threading and calls Run()
+    // - initial state can either be Running or Suspended, NotRunning will just fail and do nothing
+    // - returns the exit code
+    virtual bool  Start(ThreadState initialState = Running);
+
+    // Quits with an exit code
+    virtual void  Exit(int exitCode=0);
+
+    // Suspend the thread until resumed
+    // Returns 1 for success, 0 for failure.
+    bool  Suspend();
+    // Resumes currently suspended thread
+    // Returns 1 for success, 0 for failure.
+    bool  Resume();
+
+    // Static function to return a pointer to the current thread
+    //static Thread* GetThread();
+
+
+    // *** Thread status query functions
+
+    bool          GetExitFlag() const;
+    void          SetExitFlag(bool exitFlag);
+
+    // Determines whether the thread was running and is now finished
+    bool          IsFinished() const;
+    // Determines if the thread is currently suspended
+    bool          IsSuspended() const;
+    // Returns current thread state
+    ThreadState   GetThreadState() const;
+
+    // Wait for thread to finish for a maxmimum number of milliseconds
+    // For maxWaitMs = 0 it simply polls and then returns if the thread is not finished
+    // For maxWaitMs < 0 it will wait forever
+    bool          Join(int maxWaitMs = -1) const;
+
+    // Returns the number of available CPUs on the system 
+    static int    GetCPUCount();
+
+    // Returns the thread exit code. Exit code is initialized to 0,
+    // and set to the return value if Run function after the thread is finished.
+    inline int    GetExitCode() const { return ExitCode; }
+    // Returns an OS handle 
+#if defined(OVR_OS_WIN32)
+    void*          GetOSHandle() const { return ThreadHandle; }
+#else
+    pthread_t      GetOSHandle() const { return ThreadHandle; }
+#endif
+
+#if defined(OVR_OS_WIN32)
+    ThreadId       GetThreadId() const { return IdValue; }
+#else
+    ThreadId       GetThreadId() const { return (ThreadId)GetOSHandle(); }
+#endif
+
+    static int      GetOSPriority(ThreadPriority);
+    // *** Sleep
+
+    // Sleep secs seconds
+    static bool    Sleep(unsigned secs);
+    // Sleep msecs milliseconds
+    static bool    MSleep(unsigned msecs);
+
+
+    // *** Debugging functionality
+    virtual void    SetThreadName( const char* name );
+
+private:
+#if defined(OVR_OS_WIN32)
+    friend unsigned WINAPI Thread_Win32StartFn(void *phandle);
+#else
+    friend void *Thread_PthreadStartFn(void * phandle);
+
+    static int            InitAttr;
+    static pthread_attr_t Attr;
+#endif
+
+protected:    
+    // Thread state flags
+    AtomicInt<uint32_t>   ThreadFlags;
+    AtomicInt<int32_t>   SuspendCount;
+    size_t              StackSize;
+
+    // Hardware processor which this thread is running on.
+    int            Processor;
+    ThreadPriority Priority;
+
+#if defined(OVR_OS_WIN32)
+    void*               ThreadHandle;
+    volatile ThreadId   IdValue;
+
+    // System-specific cleanup function called from destructor
+    void                CleanupSystemThread();
+
+#else
+    pthread_t           ThreadHandle;
+#endif
+
+    // Exit code of the thread, as returned by Run.
+    int                 ExitCode;
+
+    // Internal run function.
+    int                 PRun();    
+    // Finishes the thread and releases internal reference to it.
+    void                FinishAndRelease();
+
+    void                Init(const CreateParams& params);
+
+    // Protected copy constructor
+    Thread(const Thread &source) : RefCountBase<Thread>() { OVR_UNUSED(source); }
+
+};
+
+// Returns the unique Id of a thread it is called on, intended for
+// comparison purposes.
+ThreadId GetCurrentThreadId();
+
+
+} // OVR
+
+#endif // OVR_ENABLE_THREADS
+#endif // OVR_Threads_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Timer.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,88 @@
+/************************************************************************************
+
+PublicHeader:   OVR
+Filename    :   OVR_Timer.h
+Content     :   Provides static functions for precise timing
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Timer_h
+#define OVR_Timer_h
+
+#include "OVR_Types.h"
+
+namespace OVR {
+    
+//-----------------------------------------------------------------------------------
+// ***** Timer
+
+// Timer class defines a family of static functions used for application
+// timing and profiling.
+
+class Timer
+{
+public:
+    enum {
+        MsPerSecond     = 1000, // Milliseconds in one second.
+        NanosPerSecond  = MsPerSecond * 1000 * 1000,
+        MksPerSecond    = MsPerSecond * 1000
+    };
+
+    // ***** Timing APIs for Application    
+
+    // These APIs should be used to guide animation and other program functions
+    // that require precision.
+
+    // Returns global high-resolution application timer in seconds.
+    static double  OVR_STDCALL GetSeconds();    
+
+    // Returns time in Nanoseconds, using highest possible system resolution.
+    static uint64_t  OVR_STDCALL GetTicksNanos();
+
+    // Kept for compatibility.
+    // Returns ticks in milliseconds, as a 32-bit number. May wrap around every 49.2 days.
+    // Use either time difference of two values of GetTicks to avoid wrap-around.
+    static uint32_t  OVR_STDCALL GetTicksMs()
+    { return  uint32_t(GetTicksNanos() / 1000000); }
+
+    // for recorded data playback
+    static void SetFakeSeconds(double fakeSeconds) 
+    { 
+        FakeSeconds = fakeSeconds; 
+        useFakeSeconds = true; 
+    }
+
+private:
+    friend class System;
+    // System called during program startup/shutdown.
+    static void initializeTimerSystem();
+    static void shutdownTimerSystem();
+
+    // for recorded data playback
+    static double FakeSeconds;
+    static bool   useFakeSeconds; 
+};
+
+
+} // OVR::Timer
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Types.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_Types.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,772 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_Types.h
+Content     :   Standard library defines and simple types
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Types_H
+#define OVR_Types_H
+
+#include "OVR_Compiler.h"
+
+
+// Unsupported compiler configurations
+#if _MSC_VER == 0x1600
+#  if _MSC_FULL_VER < 160040219
+#     error "Oculus does not support VS2010 without SP1 installed: It will crash in Release mode"
+#  endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ****** Operating System
+//
+// Type definitions exist for the following operating systems: (OVR_OS_x)
+//
+//    WIN32    - Win32 (Windows 95/98/ME and Windows NT/2000/XP)
+//    DARWIN   - Darwin OS (Mac OS X)
+//    LINUX    - Linux
+//    ANDROID  - Android
+//    IPHONE   - iPhone
+
+#if (defined(__APPLE__) && (defined(__GNUC__) ||\
+     defined(__xlC__) || defined(__xlc__))) || defined(__MACOS__)
+#  if (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) || defined(__IPHONE_OS_VERSION_MIN_REQUIRED))
+#    define OVR_OS_IPHONE
+#  else
+#    define OVR_OS_DARWIN
+#    define OVR_OS_MAC
+#  endif
+#elif (defined(WIN64) || defined(_WIN64) || defined(__WIN64__))
+#  define OVR_OS_WIN32
+#elif (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))
+#  define OVR_OS_WIN32
+#elif defined(__linux__) || defined(__linux)
+#  define OVR_OS_LINUX
+#else
+#  define OVR_OS_OTHER
+#endif
+
+#if defined(ANDROID)
+#  define OVR_OS_ANDROID
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** CPU Architecture
+//
+// The following CPUs are defined: (OVR_CPU_x)
+//
+//    X86        - x86 (IA-32)
+//    X86_64     - x86_64 (amd64)
+//    PPC        - PowerPC
+//    PPC64      - PowerPC64
+//    MIPS       - MIPS
+//    OTHER      - CPU for which no special support is present or needed
+
+
+#if defined(__x86_64__) || defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
+#  define OVR_CPU_X86_64
+#  define OVR_64BIT_POINTERS
+#elif defined(__i386__) || defined(OVR_OS_WIN32)
+#  define OVR_CPU_X86
+#elif defined(__powerpc64__)
+#  define OVR_CPU_PPC64
+#elif defined(__ppc__)
+#  define OVR_CPU_PPC
+#elif defined(__mips__) || defined(__MIPSEL__)
+#  define OVR_CPU_MIPS
+#elif defined(__arm__)
+#  define OVR_CPU_ARM
+#else
+#  define OVR_CPU_OTHER
+#endif
+
+//-----------------------------------------------------------------------------------
+// ***** Co-Processor Architecture
+//
+// The following co-processors are defined: (OVR_CPU_x)
+//
+//    SSE        - Available on all modern x86 processors.
+//    Altivec    - Available on all modern ppc processors.
+//    Neon       - Available on some armv7+ processors.
+
+#if defined(__SSE__) || defined(OVR_OS_WIN32)
+#  define  OVR_CPU_SSE
+#endif // __SSE__
+
+#if defined( __ALTIVEC__ )
+#  define OVR_CPU_ALTIVEC
+#endif // __ALTIVEC__
+
+#if defined(__ARM_NEON__)
+#  define OVR_CPU_ARM_NEON
+#endif // __ARM_NEON__
+
+
+//-----------------------------------------------------------------------------------
+// ***** Compiler Warnings
+
+// Disable MSVC warnings
+#if defined(OVR_CC_MSVC)
+#  pragma warning(disable : 4127)    // Inconsistent dll linkage
+#  pragma warning(disable : 4530)    // Exception handling
+#  if (OVR_CC_MSVC<1300)
+#    pragma warning(disable : 4514)  // Unreferenced inline function has been removed
+#    pragma warning(disable : 4710)  // Function not inlined
+#    pragma warning(disable : 4714)  // _force_inline not inlined
+#    pragma warning(disable : 4786)  // Debug variable name longer than 255 chars
+#  endif // (OVR_CC_MSVC<1300)
+#endif // (OVR_CC_MSVC)
+
+
+
+// *** Linux Unicode - must come before Standard Includes
+
+#ifdef OVR_OS_LINUX
+// Use glibc unicode functions on linux.
+#  ifndef  _GNU_SOURCE
+#    define _GNU_SOURCE
+#  endif
+#endif
+
+//-----------------------------------------------------------------------------------
+// ***** Standard Includes
+//
+#include    <stddef.h>
+#include    <limits.h>
+#include    <float.h>
+
+
+// MSVC Based Memory Leak checking - for now
+#if defined(OVR_CC_MSVC) && defined(OVR_BUILD_DEBUG)
+#  define _CRTDBG_MAP_ALLOC
+#  include <stdlib.h>
+#  include <crtdbg.h>
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** int8_t, int16_t, etc.
+
+#if defined(OVR_CC_MSVC) && (OVR_CC_VER <= 1500) // VS2008 and earlier
+    typedef signed char        int8_t; 
+    typedef unsigned char     uint8_t;
+    typedef signed short      int16_t;
+    typedef unsigned short   uint16_t;
+    typedef signed int        int32_t;
+    typedef unsigned int     uint32_t;
+    typedef signed __int64    int64_t;
+    typedef unsigned __int64 uint64_t;
+#else
+    #include <stdint.h>
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Type definitions for Common Systems
+
+namespace OVR {
+
+typedef char            Char;
+
+// Pointer-sized integer
+typedef size_t          UPInt;
+typedef ptrdiff_t       SPInt;
+
+
+#if defined(OVR_OS_WIN32)
+
+typedef char            SByte;  // 8 bit Integer (Byte)
+typedef unsigned char   UByte;
+typedef short           SInt16; // 16 bit Integer (Word)
+typedef unsigned short  UInt16;
+typedef long            SInt32; // 32 bit Integer
+typedef unsigned long   UInt32;
+typedef __int64         SInt64; // 64 bit Integer (QWord)
+typedef unsigned __int64 UInt64;
+
+ 
+#elif defined(OVR_OS_MAC) || defined(OVR_OS_IPHONE) || defined(OVR_CC_GNU)
+
+typedef int             SByte  __attribute__((__mode__ (__QI__)));
+typedef unsigned int    UByte  __attribute__((__mode__ (__QI__)));
+typedef int             SInt16 __attribute__((__mode__ (__HI__)));
+typedef unsigned int    UInt16 __attribute__((__mode__ (__HI__)));
+typedef int             SInt32 __attribute__((__mode__ (__SI__)));
+typedef unsigned int    UInt32 __attribute__((__mode__ (__SI__)));
+typedef int             SInt64 __attribute__((__mode__ (__DI__)));
+typedef unsigned int    UInt64 __attribute__((__mode__ (__DI__)));
+
+#else
+
+#include <sys/types.h>
+typedef int8_t          SByte;
+typedef uint8_t         UByte;
+typedef int16_t         SInt16;
+typedef uint16_t        UInt16;
+typedef int32_t         SInt32;
+typedef uint32_t        UInt32;
+typedef int64_t         SInt64;
+typedef uint64_t        UInt64;
+
+#endif
+    
+    
+//osx PID is a signed int32 (already defined to pid_t in OSX framework)
+//linux PID is a signed int32 (already defined)
+//win32 PID is an unsigned int64
+#ifdef OVR_OS_WIN32
+//process ID representation
+typedef unsigned long pid_t;
+#endif
+
+struct OVR_GUID
+{
+	uint32_t Data1;
+	uint16_t Data2;
+	uint16_t Data3;
+	uint8_t  Data4[8];
+};
+
+
+
+} // OVR
+
+
+
+//-----------------------------------------------------------------------------------
+// ****** Standard C/C++ Library
+//
+// Identifies which standard library is currently being used. 
+//
+//    LIBSTDCPP   - GNU libstdc++, used by GCC.
+//    LIBCPP      - LLVM libc++, typically used by clang and GCC.
+//    DINKUMWARE  - Used by Microsoft and various non-Microsoft compilers (e.g. Sony clang).
+
+#if !defined(OVR_STDLIB_LIBSTDCPP)
+    #if defined(__GLIBCXX__)
+        #define OVR_STDLIB_LIBSTDCPP 1
+    #endif
+#endif
+
+#if !defined(OVR_STDLIB_LIBCPP)
+    #if defined(__clang__)
+        #if defined(__cplusplus) && __has_include(<__config>)
+            #define OVR_STDLIB_LIBCPP 1
+        #endif
+    #endif 
+#endif
+
+#if !defined(OVR_STDLIB_DINKUMWARE)
+    #if defined(_YVALS) // Dinkumware globally #defines _YVALS from the #includes above.
+        #define OVR_STDLIB_DINKUMWARE 1
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** Macro Definitions
+//
+// We define the following:
+//
+//  OVR_BYTE_ORDER      - Defined to either OVR_LITTLE_ENDIAN or OVR_BIG_ENDIAN
+//  OVR_FORCE_INLINE    - Forces inline expansion of function
+//  OVR_ASM             - Assembly language prefix
+//  OVR_STR             - Prefixes string with L"" if building unicode
+// 
+//  OVR_STDCALL         - Use stdcall calling convention (Pascal arg order)
+//  OVR_CDECL           - Use cdecl calling convention (C argument order)
+//  OVR_FASTCALL        - Use fastcall calling convention (registers)
+//
+
+// Byte order constants, OVR_BYTE_ORDER is defined to be one of these.
+#define OVR_LITTLE_ENDIAN       1
+#define OVR_BIG_ENDIAN          2
+
+
+#if defined(OVR_OS_WIN32)
+    
+    // ***** Win32
+
+    // Byte order
+    #define OVR_BYTE_ORDER    OVR_LITTLE_ENDIAN
+
+    // Calling convention - goes after function return type but before function name
+    #ifdef __cplusplus_cli
+    #  define OVR_FASTCALL      __stdcall
+    #else
+    #  define OVR_FASTCALL      __fastcall
+    #endif
+
+    #define OVR_STDCALL         __stdcall
+    #define OVR_CDECL           __cdecl
+
+
+    // Assembly macros
+    #if defined(OVR_CC_MSVC)
+    #  define OVR_ASM           _asm
+    #else
+    #  define OVR_ASM           asm
+    #endif // (OVR_CC_MSVC)
+
+    #ifdef UNICODE
+    #  define OVR_STR(str)      L##str
+    #else
+    #  define OVR_STR(str)      str
+    #endif // UNICODE
+
+#else
+
+    // **** Standard systems
+
+    #if (defined(BYTE_ORDER) && (BYTE_ORDER == BIG_ENDIAN))|| \
+        (defined(_BYTE_ORDER) && (_BYTE_ORDER == _BIG_ENDIAN))
+    #  define OVR_BYTE_ORDER    OVR_BIG_ENDIAN
+    #elif (defined(__ARMEB__) || defined(OVR_CPU_PPC) || defined(OVR_CPU_PPC64))
+    #  define OVR_BYTE_ORDER    OVR_BIG_ENDIAN
+    #else
+    #  define OVR_BYTE_ORDER    OVR_LITTLE_ENDIAN
+    #endif
+    
+    // Assembly macros
+    #define OVR_ASM                  __asm__
+    #define OVR_ASM_PROC(procname)   OVR_ASM
+    #define OVR_ASM_END              OVR_ASM
+    
+    // Calling convention - goes after function return type but before function name
+    #define OVR_FASTCALL
+    #define OVR_STDCALL
+    #define OVR_CDECL
+
+#endif // defined(OVR_OS_WIN32)
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_PTR_SIZE
+// 
+// Specifies the byte size of pointers (same as sizeof void*).
+
+#if !defined(OVR_PTR_SIZE)
+    #if defined(__WORDSIZE)
+        #define OVR_PTR_SIZE ((__WORDSIZE) / 8)
+    #elif defined(_WIN64) || defined(__LP64__) || defined(_LP64) || defined(_M_IA64) || defined(__ia64__) || defined(__arch64__) || defined(__64BIT__) || defined(__Ptr_Is_64)
+        #define OVR_PTR_SIZE 8
+    #elif defined(__CC_ARM) && (__sizeof_ptr == 8)
+        #define OVR_PTR_SIZE 8
+    #else
+        #define OVR_PTR_SIZE 4
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_WORD_SIZE
+// 
+// Specifies the byte size of a machine word/register. Not necessarily the same as
+// the size of pointers, but usually >= the size of pointers.
+
+#if !defined(OVR_WORD_SIZE)
+   #define OVR_WORD_SIZE OVR_PTR_SIZE // For our currently supported platforms these are equal.
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_FORCE_INLINE
+//
+// Force inline substitute - goes before function declaration
+// Example usage:
+//     OVR_FORCE_INLINE void Test();
+
+#if !defined(OVR_FORCE_INLINE)
+    #if defined(OVR_CC_MSVC)
+        #define OVR_FORCE_INLINE  __forceinline
+    #elif defined(OVR_CC_GNU)
+        #define OVR_FORCE_INLINE  __attribute__((always_inline)) inline
+    #else
+        #define OVR_FORCE_INLINE  inline
+    #endif  // OVR_CC_MSVC
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_NO_INLINE
+//
+// Cannot be used with inline or OVR_FORCE_INLINE.
+// Example usage:
+//     OVR_NO_INLINE void Test();
+
+#if !defined(OVR_NO_INLINE)
+    #if defined(OVR_CC_MSVC) && (_MSC_VER >= 1500) // VS2008+
+        #define OVR_NO_INLINE __declspec(noinline)
+    #elif !defined(OVR_CC_MSVC)
+        #define OVR_NO_INLINE __attribute__((noinline))
+    #endif
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_STRINGIZE
+//
+// Converts a preprocessor symbol to a string.
+//
+// Example usage:
+//     printf("Line: %s", OVR_STRINGIZE(__LINE__));
+//
+#if !defined(OVR_STRINGIFY)
+    #define OVR_STRINGIZEIMPL(x) #x
+    #define OVR_STRINGIZE(x)     OVR_STRINGIZEIMPL(x)
+#endif
+
+
+// -----------------------------------------------------------------------------------
+// ***** OVR_JOIN
+//
+// Joins two preprocessing symbols together. Supports the case when either or the
+// the symbols are macros themselves.
+//
+// Example usage:
+//    char OVR_JOIN(unique_, __LINE__);  // Results in (e.g.) char unique_123;
+//
+#if !defined(OVR_JOIN)
+    #define OVR_JOIN(a, b)  OVR_JOIN1(a, b)
+    #define OVR_JOIN1(a, b) OVR_JOIN2(a, b)
+    #define OVR_JOIN2(a, b) a##b
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_OFFSETOF
+// 
+// Portable implementation of offsetof for structs and classes. offsetof and GCC's 
+// __builtin_offsetof work only with POD types (standard-layout types under C++11), 
+// despite that it can safely work with a number of types that aren't POD. This 
+// version works with more types without generating compiler warnings or errors.
+// Returns the offset as a size_t, as per offsetof.
+//
+// Example usage:
+//     struct Test{ int i; float f; };
+//     size_t fPos = OVR_OFFSETOF(Test, f);
+
+#if defined(OVR_CC_GNU)
+    #define OVR_OFFSETOF(class_, member_) ((size_t)(((uintptr_t)&reinterpret_cast<const volatile char&>((((class_*)65536)->member_))) - 65536))
+#else
+    #define OVR_OFFSETOF(class_, member_) offsetof(class_, member_)
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_SIZEOF_MEMBER
+//
+// Implements a portable way to determine the size of struct or class data member. 
+// C++11 allows this directly via sizeof (see OVR_CPP_NO_EXTENDED_SIZEOF), and this 
+// macro exists to handle pre-C++11 compilers.
+// Returns the offset as a size_t, as per sizeof.
+//
+// Example usage:
+//     struct Test{ int i; float f; };
+//     size_t fSize = OVR_SIZEOF_MEMBER(Test, f);
+//
+#if defined(OVR_CPP_NO_EXTENDED_SIZEOF)
+    #define OVR_SIZEOF_MEMBER(class_, member_) (sizeof(((class_*)0)->member_))
+#else
+    #define OVR_SIZEOF_MEMBER(class_, member_) (sizeof(class_::member_))
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_DEBUG_BREAK, OVR_ASSERT
+//
+// If not in debug build, macros do nothing
+#ifndef OVR_BUILD_DEBUG
+
+#  define OVR_DEBUG_CODE(c)
+#  define OVR_DEBUG_BREAK  ((void)0)
+#  define OVR_ASSERT(p)    ((void)0)
+
+#else 
+
+// Microsoft Win32 specific debugging support
+#if defined(OVR_OS_WIN32)
+#  ifdef OVR_CPU_X86
+#    if defined(__cplusplus_cli)
+#      define OVR_DEBUG_BREAK   do { __debugbreak(); } while(0)
+#    elif defined(OVR_CC_GNU)
+#      define OVR_DEBUG_BREAK   do { OVR_ASM("int $3\n\t"); } while(0)
+#    else
+#      define OVR_DEBUG_BREAK   do { OVR_ASM int 3 } while (0)
+#    endif
+#  else
+#    define OVR_DEBUG_BREAK     do { __debugbreak(); } while(0)
+#  endif
+// Unix specific debugging support
+#elif defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64)
+#  define OVR_DEBUG_BREAK       do { OVR_ASM("int $3\n\t"); } while(0)
+#else
+#  define OVR_DEBUG_BREAK       do { *((int *) 0) = 1; } while(0)
+#endif
+
+#define OVR_DEBUG_CODE(c) c
+
+// This will cause compiler breakpoint
+#define OVR_ASSERT(p)           do { if (!(p))  { OVR_DEBUG_BREAK; } } while(0)
+
+#endif // OVR_BUILD_DEBUG
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_COMPILER_ASSERT
+//
+// Compile-time assert; produces compiler error if condition is false.
+// The expression must be a compile-time constant expression.
+// 
+// Example usage:
+//     OVR_COMPILER_ASSERT(sizeof(int32_t == 4));
+
+#if OVR_CPP_NO_STATIC_ASSERT
+    #define OVR_COMPILER_ASSERT(x)  { int zero = 0; switch(zero) {case 0: case x:;} }
+#else
+    #define OVR_COMPILER_ASSERT(x)  static_assert((x), #x)
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** static_assert
+//
+// Portable support for C++11 static_assert.
+// Acts as if the following were declared:
+//     void static_assert(bool const_expression, const char* msg);
+//
+// Example usage:
+//     static_assert(sizeof(int32_t) == 4, "int32_t expected to be 4 bytes.");
+
+#if defined(OVR_CPP_NO_STATIC_ASSERT)
+    #if defined(OVR_CC_GNU) || defined(OVR_CC_CLANG)
+        #define OVR_SA_UNUSED __attribute__((unused))
+    #else
+        #define OVR_SA_UNUSED
+    #endif
+    #define OVR_SA_PASTE(a,b) a##b
+    #define OVR_SA_HELP(a,b)  OVR_SA_PASTE(a,b)
+
+    #if defined(__COUNTER__)
+        #define static_assert(expression, msg) typedef char OVR_SA_HELP(compileTimeAssert, __COUNTER__) [((expression) != 0) ? 1 : -1] OVR_SA_UNUSED
+    #else
+        #define static_assert(expression, msg) typedef char OVR_SA_HELP(compileTimeAssert, __LINE__) [((expression) != 0) ? 1 : -1] OVR_SA_UNUSED
+    #endif
+#endif
+
+
+// ***** OVR_PROCESSOR_PAUSE
+//
+// Yields the processor for other hyperthreads, usually for the purpose of implementing spins and spin locks. 
+//
+// Example usage:
+//     while(!finished())
+//         OVR_PROCESSOR_PAUSE();
+
+#if defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64)
+    #if defined(OVR_CC_GNU) || defined(OVR_CC_CLANG)
+        #define OVR_PROCESSOR_PAUSE() asm volatile("pause" ::: "memory") // Consumes 38-40 clocks on current Intel x86 and x64 hardware.
+    #elif defined(OVR_CC_MSVC)
+        #include <emmintrin.h>
+        #pragma intrinsic(_mm_pause) // Maps to asm pause.
+        #define OVR_PROCESSOR_PAUSE _mm_pause
+    #else
+        #define OVR_PROCESSOR_PAUSE()
+    #endif
+#else
+    #define OVR_PROCESSOR_PAUSE()
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_ARRAY_COUNT
+//
+// Returns the element count of a C array. 
+//
+// Example usage:
+//     float itemArray[16];
+//     for(size_t i = 0; i < OVR_ARRAY_COUNT(itemArray); i++) { ... }
+
+#if defined(OVR_CPP_NO_CONSTEXPR)
+    #ifndef OVR_ARRAY_COUNT
+        #define OVR_ARRAY_COUNT(x) (sizeof(x) / sizeof(x[0]))
+    #endif
+#else
+    // Smarter C++11 version which knows the difference between arrays and pointers. 
+    template <typename T, size_t N>
+    char (&OVRArrayCountHelper(T (&x)[N]))[N];
+    #define OVR_ARRAY_COUNT(x) (sizeof(OVRArrayCountHelper(x)))
+#endif
+
+
+// ------------------------------------------------------------------------
+// ***** OVR_CURRENT_FUNCTION
+//
+// Portable wrapper for __PRETTY_FUNCTION__, C99 __func__, __FUNCTION__.
+// This represents the most expressive version available.
+// Acts as if the following were declared:
+//     static const char OVR_CURRENT_FUNCTION[] = "function-name";
+//
+// Example usage:
+//     void Test() { printf("%s", OVR_CURRENT_FUNCTION); }
+
+#if defined(OVR_CC_GNU) || defined(OVR_CC_CLANG) || (defined(__ICC) && (__ICC >= 600)) // GCC, clang, Intel
+    #define OVR_CURRENT_FUNCTION __PRETTY_FUNCTION__
+#elif defined(__FUNCSIG__) // VC++
+    #define OVR_CURRENT_FUNCTION __FUNCSIG__
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901) // C99 compilers
+    #define OVR_CURRENT_FUNCTION __func__
+#else
+    #define OVR_CURRENT_FUNCTION __FUNCTION__
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_DEPRECATED / OVR_DEPRECATED_MSG
+// 
+// Portably annotates a function or struct as deprecated.
+// Note that clang supports __deprecated_enum_msg, which may be useful to support.
+//
+// Example usage:
+//    OVR_DEPRECATED void Test();       // Use on the function declaration, as opposed to definition.
+//
+//    struct OVR_DEPRECATED Test{ ... };
+//
+//    OVR_DEPRECATED_MSG("Test is deprecated")
+//    void Test();
+
+#if !defined(OVR_DEPRECATED)
+    #if defined(OVR_CC_MSVC) && (OVR_CC_VERSION > 1400) // VS2005+
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __declspec(deprecated(msg))
+    #elif defined(OVR_CC_CLANG) && OVR_CC_HAS_FEATURE(attribute_deprecated_with_message)
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
+    #elif defined(OVR_CC_GNU) && (OVR_CC_VERSION >= 405)
+        #define OVR_DEPRECATED          __declspec(deprecated)
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
+    #elif !defined(OVR_CC_MSVC)
+        #define OVR_DEPRECATED          __attribute__((deprecated))
+        #define OVR_DEPRECATED_MSG(msg) __attribute__((deprecated))
+    #else
+        #define OVR_DEPRECATED
+        #define OVR_DEPRECATED_MSG(msg)
+    #endif
+#endif
+
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_UNUSED - Unused Argument handling
+// Macro to quiet compiler warnings about unused parameters/variables.
+//
+// Example usage:
+//     void Test() {
+//         int x = SomeFunction();
+//         OVR_UNUSED(x);
+//     }
+//
+
+#if defined(OVR_CC_GNU)
+#  define   OVR_UNUSED(a)   do {__typeof__ (&a) __attribute__ ((unused)) __tmp = &a; } while(0)
+#else
+#  define   OVR_UNUSED(a)   (a)
+#endif
+
+#define     OVR_UNUSED1(a1) OVR_UNUSED(a1)
+#define     OVR_UNUSED2(a1,a2) OVR_UNUSED(a1); OVR_UNUSED(a2)
+#define     OVR_UNUSED3(a1,a2,a3) OVR_UNUSED2(a1,a2); OVR_UNUSED(a3)
+#define     OVR_UNUSED4(a1,a2,a3,a4) OVR_UNUSED3(a1,a2,a3); OVR_UNUSED(a4)
+#define     OVR_UNUSED5(a1,a2,a3,a4,a5) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED(a5)
+#define     OVR_UNUSED6(a1,a2,a3,a4,a5,a6) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED2(a5,a6)
+#define     OVR_UNUSED7(a1,a2,a3,a4,a5,a6,a7) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED3(a5,a6,a7)
+#define     OVR_UNUSED8(a1,a2,a3,a4,a5,a6,a7,a8) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED4(a5,a6,a7,a8)
+#define     OVR_UNUSED9(a1,a2,a3,a4,a5,a6,a7,a8,a9) OVR_UNUSED4(a1,a2,a3,a4); OVR_UNUSED5(a5,a6,a7,a8,a9)
+
+
+//-----------------------------------------------------------------------------------
+// ***** Configuration Macros
+//
+// Expands to the current build type as a const char string literal.
+// Acts as the following declaration: const char OVR_BUILD_STRING[];
+
+#ifdef OVR_BUILD_DEBUG
+#  define OVR_BUILD_STRING  "Debug"
+#else
+#  define OVR_BUILD_STRING  "Release"
+#endif
+
+
+//// Enables SF Debugging information
+//# define OVR_BUILD_DEBUG
+
+// OVR_DEBUG_STATEMENT injects a statement only in debug builds.
+// OVR_DEBUG_SELECT injects first argument in debug builds, second argument otherwise.
+#ifdef OVR_BUILD_DEBUG
+#define OVR_DEBUG_STATEMENT(s)   s
+#define OVR_DEBUG_SELECT(d, nd)  d
+#else
+#define OVR_DEBUG_STATEMENT(s)
+#define OVR_DEBUG_SELECT(d, nd)  nd
+#endif
+
+
+#define OVR_ENABLE_THREADS
+//
+// Prevents OVR from defining new within
+// type macros, so developers can override
+// new using the #define new new(...) trick
+// - used with OVR_DEFINE_NEW macro
+//# define OVR_BUILD_DEFINE_NEW
+//
+
+
+//-----------------------------------------------------------------------------------
+// ***** Find normal allocations
+//
+// Our allocations are all supposed to go through the OVR System Allocator, so that
+// they can be run through a game's own preferred allocator.  Occasionally we will
+// accidentally introduce new code that doesn't adhere to this contract.  And it
+// then becomes difficult to track down these normal allocations.  This piece of
+// code makes it easy to check for normal allocations by asserting whenever they
+// happen in our code.
+
+//#define OVR_FIND_NORMAL_ALLOCATIONS
+#ifdef OVR_FIND_NORMAL_ALLOCATIONS
+
+inline void* operator new (size_t size, const char* filename, int line)
+{
+    void* ptr = new char[size];
+    OVR_ASSERT(false);
+    return ptr;
+}
+
+#define new new(__FILE__, __LINE__)
+
+#endif // OVR_FIND_NORMAL_ALLOCATIONS
+
+
+
+#endif  // OVR_Types_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Kernel/OVR_UTF8Util.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,99 @@
+/************************************************************************************
+
+PublicHeader:   OVR_Kernel.h
+Filename    :   OVR_UTF8Util.h
+Content     :   UTF8 Unicode character encoding/decoding support
+Created     :   September 19, 2012
+Notes       : 
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_UTF8Util_h
+#define OVR_UTF8Util_h
+
+#include "OVR_Types.h"
+
+namespace OVR { namespace UTF8Util {
+
+//-----------------------------------------------------------------------------------
+
+// *** UTF8 string length and indexing.
+
+// Determines the length of UTF8 string in characters.
+// If source length is specified (in bytes), null 0 character is counted properly.
+intptr_t OVR_STDCALL GetLength(const char* putf8str, intptr_t length = -1);
+
+// Gets a decoded UTF8 character at index; you can access up to the index returned
+// by GetLength. 0 will be returned for out of bounds access.
+uint32_t OVR_STDCALL GetCharAt(intptr_t index, const char* putf8str, intptr_t length = -1);
+
+// Converts UTF8 character index into byte offset.
+// -1 is returned if index was out of bounds.
+intptr_t OVR_STDCALL GetByteIndex(intptr_t index, const char* putf8str, intptr_t length = -1);
+
+
+// *** 16-bit Unicode string Encoding/Decoding routines.
+
+// Determines the number of bytes necessary to encode a string.
+// Does not count the terminating 0 (null) character.
+intptr_t OVR_STDCALL GetEncodeStringSize(const wchar_t* pchar, intptr_t length = -1);
+
+// Encodes a unicode (UCS-2 only) string into a buffer. The size of buffer must be at
+// least GetEncodeStringSize() + 1.
+void     OVR_STDCALL EncodeString(char *pbuff, const wchar_t* pchar, intptr_t length = -1);
+
+// Decode UTF8 into a wchar_t buffer. Must have GetLength()+1 characters available.
+// Characters over 0xFFFF are replaced with 0xFFFD.
+// Returns the length of resulting string (number of characters)
+size_t   OVR_STDCALL DecodeString(wchar_t *pbuff, const char* putf8str, intptr_t bytesLen = -1);
+
+
+// *** Individual character Encoding/Decoding.
+
+// Determined the number of bytes necessary to encode a UCS character.
+int      OVR_STDCALL GetEncodeCharSize(uint32_t ucsCharacter);
+
+// Encodes the given UCS character into the given UTF-8 buffer.
+// Writes the data starting at buffer[offset], and 
+// increments offset by the number of bytes written.
+// May write up to 6 bytes, so make sure there's room in the buffer
+void     OVR_STDCALL EncodeChar(char* pbuffer, intptr_t* poffset, uint32_t ucsCharacter);
+
+// Return the next Unicode character in the UTF-8 encoded buffer.
+// Invalid UTF-8 sequences produce a U+FFFD character as output.
+// Advances *utf8_buffer past the character returned. Pointer advance
+// occurs even if the terminating 0 character is hit, since that allows
+// strings with middle '\0' characters to be supported.
+uint32_t OVR_STDCALL DecodeNextChar_Advance0(const char** putf8Buffer);
+
+// Safer version of DecodeNextChar, which doesn't advance pointer if
+// null character is hit.
+inline uint32_t DecodeNextChar(const char** putf8Buffer)
+{
+    uint32_t ch = DecodeNextChar_Advance0(putf8Buffer);
+    if (ch == 0)
+        (*putf8Buffer)--;
+    return ch;
+}
+
+
+}} // OVR::UTF8Util
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_BitStream.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,1746 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_BitStream.h
+Content     :   A generic serialization toolkit for packing data to a binary stream.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Bitstream_h
+#define OVR_Bitstream_h
+
+#include <math.h>
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Std.h"
+#include "../Kernel/OVR_String.h"
+
+namespace OVR { namespace Net {
+
+typedef uint32_t BitSize_t;
+#define BITSTREAM_STACK_ALLOCATION_SIZE 256
+#define BITS_TO_BYTES(x) (((x)+7)>>3)
+#define BYTES_TO_BITS(x) ((x)<<3)
+
+
+//-----------------------------------------------------------------------------
+// BitStream
+
+// Generic serialization class to binary stream
+class BitStream : public NewOverrideBase
+{
+public:
+	/// Default Constructor
+	BitStream();
+
+	/// \brief Create the bitstream, with some number of bytes to immediately allocate.
+	/// \details There is no benefit to calling this, unless you know exactly how many bytes you need and it is greater than BITSTREAM_STACK_ALLOCATION_SIZE.
+	/// In that case all it does is save you one or more realloc calls.
+	/// \param[in] initialBytesToAllocate the number of bytes to pre-allocate.
+	BitStream( const unsigned int initialBytesToAllocate );
+
+	/// \brief Initialize the BitStream, immediately setting the data it contains to a predefined pointer.
+	/// \details Set \a _copyData to true if you want to make an internal copy of the data you are passing. Set it to false to just save a pointer to the data.
+	/// You shouldn't call Write functions with \a _copyData as false, as this will write to unallocated memory
+	/// 99% of the time you will use this function to cast Packet::data to a bitstream for reading, in which case you should write something as follows:
+	/// \code
+	/// RakNet::BitStream bs(packet->data, packet->length, false);
+	/// \endcode
+	/// \param[in] _data An array of bytes.
+	/// \param[in] lengthInBytes Size of the \a _data.
+	/// \param[in] _copyData true or false to make a copy of \a _data or not.
+	BitStream( char* _data, const unsigned int lengthInBytes, bool _copyData );
+
+	// Destructor
+	~BitStream();
+
+public:
+	/// Resets the bitstream for reuse.
+	void Reset( void );
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutTemplateVar The value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool Serialize(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream. 
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \param[in] lastValue The last value to compare against.  Only used if \a writeToBitstream is true.
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue);
+
+	/// \brief Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutTemplateVar The value to write
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeCompressed(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize any integral type to/from a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutCurrentValue The current value to write
+	/// \param[in] lastValue The last value to compare against.  Only used if \a writeToBitstream is true.
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType>
+	bool SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue);
+
+	/// \brief Save as SerializeCompressedDelta(templateType &currentValue, const templateType &lastValue) when we have an unknown second parameter
+	/// \return true on data read. False on insufficient data in bitstream
+	template <class templateType>
+	bool SerializeCompressedDelta(bool writeToBitstream, templateType &inOutTemplateVar);
+
+	/// \brief Bidirectional serialize/deserialize an array or casted stream or raw data.  This does NOT do endian swapping.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutByteArray a byte buffer
+	/// \param[in] numberOfBytes the size of \a input in bytes
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	bool Serialize(bool writeToBitstream,  char* inOutByteArray, const unsigned int numberOfBytes );
+
+	/// \brief Serialize a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutFloat The float to write
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	bool SerializeFloat16(bool writeToBitstream, float &inOutFloat, float floatMin, float floatMax);
+
+	/// Serialize one type casted to another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num=53; SerializeCasted<uint8_t>(true, num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes)
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] value The value to serialize
+	template <class serializationType, class sourceType >
+	bool SerializeCasted( bool writeToBitstream, sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then serialize only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] value Integer value to write, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates
+	template <class templateType>
+	bool SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	bool SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeNormVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z );
+
+	/// \brief Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z );
+
+	/// \brief Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeNormQuat(bool writeToBitstream,  templateType &w, templateType &x, templateType &y, templateType &z);
+
+	/// \brief Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool SerializeOrthMatrix(
+		bool writeToBitstream,
+		templateType &m00, templateType &m01, templateType &m02,
+		templateType &m10, templateType &m11, templateType &m12,
+		templateType &m20, templateType &m21, templateType &m22 );
+
+	/// \brief Bidirectional serialize/deserialize numberToSerialize bits to/from the input. 
+	/// \details Right aligned data means in the case of a partial byte, the bits are aligned
+	/// from the right (bit 0) rather than the left (as in the normal
+	/// internal representation) You would set this to true when
+	/// writing user data, and false when copying bitstream data, such
+	/// as writing one bitstream to another
+	/// \param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data
+	/// \param[in] inOutByteArray The data
+	/// \param[in] numberOfBitsToSerialize The number of bits to write
+	/// \param[in] rightAlignedBits if true data will be right aligned
+	/// \return true if \a writeToBitstream is true.  true if \a writeToBitstream is false and the read was successful.  false if \a writeToBitstream is false and the read was not successful.
+	bool SerializeBits(bool writeToBitstream, unsigned char* inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits = true );
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void Write(const templateType &inTemplateVar);
+
+	/// \brief Write the dereferenced pointer to any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void WritePtr(templateType *inTemplateVar);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <class templateType>
+	void WriteDelta(const templateType &currentValue, const templateType &lastValue);
+
+	/// \brief WriteDelta when you don't know what the last value is, or there is no last value.
+	/// \param[in] currentValue The current value to write
+	template <class templateType>
+	void WriteDelta(const templateType &currentValue);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// \param[in] inTemplateVar The value to write
+	template <class templateType>
+	void WriteCompressed(const templateType &inTemplateVar);
+
+	/// \brief Write any integral type to a bitstream.  
+	/// \details If the current value is different from the last value
+	/// the current value will be written.  Otherwise, a single bit will be written
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <class templateType>
+	void WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue);
+
+	/// \brief Save as WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue) when we have an unknown second parameter
+	template <class templateType>
+	void WriteCompressedDelta(const templateType &currentValue);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details Define __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool Read(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details If the written value differed from the value compared against in the write function,
+	/// var will be updated.  Otherwise it will retain the current value.
+	/// ReadDelta is only valid from a previous call to WriteDelta
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadDelta(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadCompressed(templateType &outTemplateVar);
+
+	/// \brief Read any integral type from a bitstream.  
+	/// \details If the written value differed from the value compared against in the write function,
+	/// var will be updated.  Otherwise it will retain the current value.
+	/// the current value will be updated.
+	/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+	/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+	/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+	/// ReadCompressedDelta is only valid from a previous call to WriteDelta
+	/// \param[in] outTemplateVar The value to read
+	/// \return true on success, false on failure.
+	template <class templateType>
+	bool ReadCompressedDelta(templateType &outTemplateVar);
+
+	/// \brief Read one bitstream to another.
+	/// \param[in] numberOfBits bits to read
+	/// \param bitStream the bitstream to read into from
+	/// \return true on success, false on failure.
+	bool Read( BitStream *bitStream, BitSize_t numberOfBits );
+	bool Read( BitStream *bitStream );
+	bool Read( BitStream &bitStream, BitSize_t numberOfBits );
+	bool Read( BitStream &bitStream );
+
+	/// \brief Write an array or casted stream or raw data.  This does NOT do endian swapping.
+	/// \param[in] inputByteArray a byte buffer
+	/// \param[in] numberOfBytes the size of \a input in bytes
+	void Write( const char* inputByteArray, const unsigned int numberOfBytes );
+
+	/// \brief Write one bitstream to another.
+	/// \param[in] numberOfBits bits to write
+	/// \param bitStream the bitstream to copy from
+	void Write( BitStream *bitStream, BitSize_t numberOfBits );
+	void Write( BitStream *bitStream );
+	void Write( BitStream &bitStream, BitSize_t numberOfBits );
+	void Write( BitStream &bitStream );\
+
+	/// \brief Write a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] x The float to write
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	void WriteFloat16( float x, float floatMin, float floatMax );
+
+	/// Write one type serialized as another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num=53; WriteCasted<uint8_t>(num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes)
+	/// \param[in] value The value to write
+	template <class serializationType, class sourceType >
+	void WriteCasted( const sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then write only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] value Integer value to write, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates. This should match the corresponding value passed to Read().
+	template <class templateType>
+	void WriteBitsFromIntegerRange( const templateType value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	void WriteBitsFromIntegerRange( const templateType value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteNormVector( templateType x, templateType y, templateType z );
+
+	/// \brief Write a vector, using 10 bytes instead of 12.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, 
+	/// so only use if accuracy is not important.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteVector( templateType x, templateType y, templateType z );
+
+	/// \brief Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.  Slightly lossy.
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteNormQuat( templateType w, templateType x, templateType y, templateType z);
+
+	/// \brief Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	template <class templateType> // templateType for this function must be a float or double
+	void WriteOrthMatrix(
+		templateType m00, templateType m01, templateType m02,
+		templateType m10, templateType m11, templateType m12,
+		templateType m20, templateType m21, templateType m22 );
+
+	/// \brief Read an array or casted stream of byte.
+	/// \details The array is raw data. There is no automatic endian conversion with this function
+	/// \param[in] output The result byte array. It should be larger than @em numberOfBytes.
+	/// \param[in] numberOfBytes The number of byte to read
+	/// \return true on success false if there is some missing bytes.
+	bool Read( char* output, const unsigned int numberOfBytes );
+
+	/// \brief Read a float into 2 bytes, spanning the range between \a floatMin and \a floatMax
+	/// \param[in] outFloat The float to read
+	/// \param[in] floatMin Predetermined minimum value of f
+	/// \param[in] floatMax Predetermined maximum value of f
+	bool ReadFloat16( float &outFloat, float floatMin, float floatMax );
+
+	/// Read one type serialized to another (smaller) type, to save bandwidth
+	/// serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t
+	/// Example: int num; ReadCasted<uint8_t>(num); would read 1 bytefrom the stream, and put the value in an integer
+	/// \param[in] value The value to write
+	template <class serializationType, class sourceType >
+	bool ReadCasted( sourceType &value );
+
+	/// Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range
+	/// Then read only those bits
+	/// \note A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that \a minimum and \maximum are fixed values for a given line of code for the life of the program
+	/// \param[in] value Integer value to read, which should be between \a minimum and \a maximum
+	/// \param[in] minimum Minimum value of \a value
+	/// \param[in] maximum Maximum value of \a value
+	/// \param[in] allowOutsideRange If true, all sends will take an extra bit, however value can deviate from outside \a minimum and \a maximum. If false, will assert if the value deviates. This should match the corresponding value passed to Write().
+	template <class templateType>
+	bool ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false );
+	/// \param[in] requiredBits Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum
+	template <class templateType>
+	bool ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false );
+
+	/// \brief Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  
+	/// \details Will further compress y or z axis aligned vectors.
+	/// Accurate to 1/32767.5.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadNormVector( templateType &x, templateType &y, templateType &z );
+
+	/// \brief Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector.
+	/// \details Loses accuracy to about 3/10ths and only saves 2 bytes, 
+	/// so only use if accuracy is not important.
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadVector( templateType &x, templateType &y, templateType &z );
+
+	/// \brief Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.
+	/// \param[in] w w
+	/// \param[in] x x
+	/// \param[in] y y
+	/// \param[in] z z
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadNormQuat( templateType &w, templateType &x, templateType &y, templateType &z);
+
+	/// \brief Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th.
+	/// \details Use 6 bytes instead of 36
+	/// Lossy, although the result is renormalized
+	/// \return true on success, false on failure.
+	template <class templateType> // templateType for this function must be a float or double
+	bool ReadOrthMatrix(
+		templateType &m00, templateType &m01, templateType &m02,
+		templateType &m10, templateType &m11, templateType &m12,
+		templateType &m20, templateType &m21, templateType &m22 );
+
+	/// \brief Sets the read pointer back to the beginning of your data.
+	void ResetReadPointer( void );
+
+	/// \brief Sets the write pointer back to the beginning of your data.
+	void ResetWritePointer( void );
+
+	/// \brief This is good to call when you are done with the stream to make
+	/// sure you didn't leave any data left over void
+	void AssertStreamEmpty( void );
+
+	/// \brief RAKNET_DEBUG_PRINTF the bits in the stream.  Great for debugging.
+	void PrintBits( char *out ) const;
+	void PrintBits( void ) const;
+	void PrintHex( char *out ) const;
+	void PrintHex( void ) const;
+
+	/// \brief Ignore data we don't intend to read
+	/// \param[in] numberOfBits The number of bits to ignore
+	void IgnoreBits( const BitSize_t numberOfBits );
+
+	/// \brief Ignore data we don't intend to read
+	/// \param[in] numberOfBits The number of bytes to ignore
+	void IgnoreBytes( const unsigned int numberOfBytes );
+
+	/// \brief Move the write pointer to a position on the array.
+	/// \param[in] offset the offset from the start of the array.
+	/// \attention
+	/// \details Dangerous if you don't know what you are doing!
+	/// For efficiency reasons you can only write mid-stream if your data is byte aligned.
+	void SetWriteOffset( const BitSize_t offset );
+
+	/// \brief Returns the length in bits of the stream
+	inline BitSize_t GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}
+	inline BitSize_t GetWriteOffset( void ) const {return numberOfBitsUsed;}
+
+	/// \brief Returns the length in bytes of the stream
+	inline BitSize_t GetNumberOfBytesUsed( void ) const {return BITS_TO_BYTES( numberOfBitsUsed );}
+
+	/// \brief Returns the number of bits into the stream that we have read
+	inline BitSize_t GetReadOffset( void ) const {return readOffset;}
+
+	/// \brief Sets the read bit index
+	void SetReadOffset( const BitSize_t newReadOffset ) {readOffset=newReadOffset;}
+
+	/// \brief Returns the number of bits left in the stream that haven't been read
+	inline BitSize_t GetNumberOfUnreadBits( void ) const {return numberOfBitsUsed - readOffset;}
+
+	/// \brief Makes a copy of the internal data for you \a _data will point to
+	/// the stream. Partial bytes are left aligned.
+	/// \param[out] _data The allocated copy of GetData()
+	/// \return The length in bits of the stream.
+	BitSize_t CopyData( unsigned char** _data ) const;
+
+	/// \internal
+	/// Set the stream to some initial data.
+	void SetData( unsigned char *inByteArray );
+
+	/// Gets the data that BitStream is writing to / reading from.
+	/// Partial bytes are left aligned.
+	/// \return A pointer to the internal state
+	inline char* GetData( void ) const {return (char*) data;}
+
+	/// \brief Write numberToWrite bits from the input source.
+	/// \details Right aligned data means in the case of a partial byte, the bits are aligned
+	/// from the right (bit 0) rather than the left (as in the normal
+	/// internal representation) You would set this to true when
+	/// writing user data, and false when copying bitstream data, such
+	/// as writing one bitstream to another.
+	/// \param[in] inByteArray The data
+	/// \param[in] numberOfBitsToWrite The number of bits to write
+	/// \param[in] rightAlignedBits if true data will be right aligned
+	void WriteBits( const unsigned char* inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits = true );
+
+	/// \brief Align the bitstream to the byte boundary and then write the
+	/// specified number of bits.  
+	/// \details This is faster than WriteBits but
+	/// wastes the bits to do the alignment and requires you to call
+	/// ReadAlignedBits at the corresponding read position.
+	/// \param[in] inByteArray The data
+	/// \param[in] numberOfBytesToWrite The size of input.
+	void WriteAlignedBytes( const unsigned char *inByteArray, const unsigned int numberOfBytesToWrite );
+
+	// Endian swap bytes already in the bitstream
+	void EndianSwapBytes( int byteOffset, int length );
+
+	/// \brief Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite
+	/// \param[in] inByteArray The data
+	/// \param[in] inputLength The size of input.
+	/// \param[in] maxBytesToWrite Max bytes to write
+	void WriteAlignedBytesSafe( const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite );
+
+	/// \brief Read bits, starting at the next aligned bits. 
+	/// \details Note that the modulus 8 starting offset of the sequence must be the same as
+	/// was used with WriteBits. This will be a problem with packet
+	/// coalescence unless you byte align the coalesced packets.
+	/// \param[in] inOutByteArray The byte array larger than @em numberOfBytesToRead
+	/// \param[in] numberOfBytesToRead The number of byte to read from the internal state
+	/// \return true if there is enough byte.
+	bool ReadAlignedBytes( unsigned char *inOutByteArray, const unsigned int numberOfBytesToRead );
+
+	/// \brief Reads what was written by WriteAlignedBytesSafe.
+	/// \param[in] inOutByteArray The data
+	/// \param[in] maxBytesToRead Maximum number of bytes to read
+	/// \return true on success, false on failure.
+	bool ReadAlignedBytesSafe( char *inOutByteArray, int &inputLength, const int maxBytesToRead );
+	bool ReadAlignedBytesSafe( char *inOutByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead );
+
+	/// \brief Same as ReadAlignedBytesSafe() but allocates the memory for you using new, rather than assuming it is safe to write to
+	/// \param[in] outByteArray outByteArray will be deleted if it is not a pointer to 0
+	/// \return true on success, false on failure.
+	bool ReadAlignedBytesSafeAlloc( char **outByteArray, int &inputLength, const unsigned int maxBytesToRead );
+	bool ReadAlignedBytesSafeAlloc( char **outByteArray, unsigned int &inputLength, const unsigned int maxBytesToRead );
+
+	/// \brief Align the next write and/or read to a byte boundary.  
+	/// \details This can be used to 'waste' bits to byte align for efficiency reasons It
+	/// can also be used to force coalesced bitstreams to start on byte
+	/// boundaries so so WriteAlignedBits and ReadAlignedBits both
+	/// calculate the same offset when aligning.
+	inline void AlignWriteToByteBoundary( void ) {numberOfBitsUsed += 8 - ( (( numberOfBitsUsed - 1 ) & 7) + 1 );}
+
+	/// \brief Align the next write and/or read to a byte boundary.  
+	/// \details This can be used to 'waste' bits to byte align for efficiency reasons It
+	/// can also be used to force coalesced bitstreams to start on byte
+	/// boundaries so so WriteAlignedBits and ReadAlignedBits both
+	/// calculate the same offset when aligning.
+	inline void AlignReadToByteBoundary( void ) {readOffset += 8 - ( (( readOffset - 1 ) & 7 ) + 1 );}
+
+	/// \brief Read \a numberOfBitsToRead bits to the output source.
+	/// \details alignBitsToRight should be set to true to convert internal
+	/// bitstream data to userdata. It should be false if you used
+	/// WriteBits with rightAlignedBits false
+	/// \param[in] inOutByteArray The resulting bits array
+	/// \param[in] numberOfBitsToRead The number of bits to read
+	/// \param[in] alignBitsToRight if true bits will be right aligned.
+	/// \return true if there is enough bits to read
+	bool ReadBits( unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight = true );
+
+	/// \brief Write a 0
+	void Write0( void );
+
+	/// \brief Write a 1
+	void Write1( void );
+
+	/// \brief Reads 1 bit and returns true if that bit is 1 and false if it is 0.
+	bool ReadBit( void );
+
+	/// \brief If we used the constructor version with copy data off, this
+	/// *makes sure it is set to on and the data pointed to is copied.
+	void AssertCopyData( void );
+
+	/// \brief Use this if you pass a pointer copy to the constructor
+	/// *(_copyData==false) and want to overallocate to prevent
+	/// reallocation.
+	void SetNumberOfBitsAllocated( const BitSize_t lengthInBits );
+
+	/// \brief Reallocates (if necessary) in preparation of writing numberOfBitsToWrite
+	void AddBitsAndReallocate( const BitSize_t numberOfBitsToWrite );
+
+	/// \internal
+	/// \return How many bits have been allocated internally
+	BitSize_t GetNumberOfBitsAllocated(void) const;
+
+	/// Write zeros until the bitstream is filled up to \a bytes
+	void PadWithZeroToByteLength( unsigned int bytes );
+
+	/// Get the number of leading zeros for a number
+	/// \param[in] x Number to test
+	static int NumberOfLeadingZeroes( uint8_t x );
+	static int NumberOfLeadingZeroes( uint16_t x );
+	static int NumberOfLeadingZeroes( uint32_t x );
+	static int NumberOfLeadingZeroes( uint64_t x );
+	static int NumberOfLeadingZeroes( int8_t x );
+	static int NumberOfLeadingZeroes( int16_t x );
+	static int NumberOfLeadingZeroes( int32_t x );
+	static int NumberOfLeadingZeroes( int64_t x );
+
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar8(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar8(char *inOutByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar16(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar16(char *inOutByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	void WriteAlignedVar32(const char *inByteArray);
+	/// \internal Unrolled inner loop, for when performance is critical
+	bool ReadAlignedVar32(char *inOutByteArray);
+
+	inline void Write(const char * const inStringVar)
+	{
+		uint16_t l = (uint16_t) OVR_strlen(inStringVar);
+		Write(l);
+		WriteAlignedBytes((const unsigned char*) inStringVar, (const unsigned int) l);
+	}
+	inline void Write(const unsigned char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+	inline void Write(char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+	inline void Write(unsigned char * const inTemplateVar)
+	{
+		Write((const char*)inTemplateVar);
+	}
+
+	/// ---- Member function template specialization declarations ----
+	// Used for VC7
+#if defined(OVR_CC_MSVC) && _MSC_VER == 1300
+	/// Write a bool to a bitstream.
+	/// \param[in] var The value to write
+	template <>
+	void Write(const bool &var);
+
+	/// Write a RakNetGUID to a bitsteam
+	/// \param[in] var The value to write
+	template <>
+	void Write(const RakNetGuid &var);
+
+	/// Write a string to a bitstream
+	/// \param[in] var The value to write
+	template <>
+	void Write(const char* const &var);
+	template <>
+	void Write(const unsigned char* const &var);
+	template <>
+	void Write(char* const &var);
+	template <>
+	void Write(unsigned char* const &var);
+	template <>
+	void Write(const OVR::String &var);
+
+	/// \brief Write a bool delta.  
+	/// \details Same thing as just calling Write
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <>
+	void WriteDelta(const bool &currentValue, const bool &lastValue);
+
+	template <>
+	void WriteCompressed(const bool &var);
+
+	/// For values between -1 and 1
+	template <>
+	void WriteCompressed(const float &var);
+
+	/// For values between -1 and 1
+	template <>
+	void WriteCompressed(const double &var);
+	
+	/// \brief Write a bool delta.  
+	/// \details Same thing as just calling Write
+	/// \param[in] currentValue The current value to write
+	/// \param[in] lastValue The last value to compare against
+	template <>
+	void WriteCompressedDelta(const bool &currentValue, const bool &lastValue);
+
+	/// \brief Save as WriteCompressedDelta(bool currentValue, const templateType &lastValue) 
+	/// when we have an unknown second bool
+	template <>
+	void WriteCompressedDelta(const bool &currentValue);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool Read(bool &var);
+
+	/// \brief Read a String from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool Read(char *&var);
+	template <>
+	bool Read(wchar_t *&var);
+	template <>
+	bool Read(unsigned char *&var);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadDelta(bool &var);
+
+	template <>
+	bool ReadCompressed(bool &var);
+
+	template <>
+	bool ReadCompressed(float &var);
+
+	/// For values between -1 and 1
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadCompressed(double &var);
+
+	template <>
+	bool ReadCompressed(char* &var);
+	template <>
+	bool ReadCompressed(wchar_t* &var);
+	template <>
+	bool ReadCompressed(unsigned char *&var);
+	template <>
+	bool ReadCompressed(OVR::String &var);
+
+	/// \brief Read a bool from a bitstream.
+	/// \param[in] var The value to read
+	/// \return true on success, false on failure.
+	template <>
+	bool ReadCompressedDelta(bool &var);
+#endif
+
+	inline static bool DoEndianSwap(void) {
+#ifndef __BITSTREAM_NATIVE_END
+		return IsNetworkOrder()==false;
+#else
+		return false;
+#endif
+	}
+	inline static bool IsBigEndian(void)
+	{
+		return IsNetworkOrder();
+	}
+	inline static bool IsNetworkOrder(void) {bool r = IsNetworkOrderInternal(); return r;}
+	// Not inline, won't compile on PC due to winsock include errors
+	static bool IsNetworkOrderInternal(void);
+	static void ReverseBytes(unsigned char *inByteArray, unsigned char *inOutByteArray, const unsigned int length);
+	static void ReverseBytesInPlace(unsigned char *inOutData,const unsigned int length);
+
+private:
+
+	BitStream( const BitStream &invalid) {
+		(void) invalid;
+		OVR_ASSERT(0);
+	}
+
+	BitStream& operator = ( const BitStream& invalid ) {
+		(void) invalid;
+		OVR_ASSERT(0);
+		static BitStream i;
+		return i;
+	}
+
+	/// \brief Assume the input source points to a native type, compress and write it.
+	void WriteCompressed( const unsigned char* inByteArray, const unsigned int size, const bool unsignedData );
+
+	/// \brief Assume the input source points to a compressed native type. Decompress and read it.
+	bool ReadCompressed( unsigned char* inOutByteArray,	const unsigned int size, const bool unsignedData );
+
+
+	BitSize_t numberOfBitsUsed;
+
+	BitSize_t numberOfBitsAllocated;
+
+	BitSize_t readOffset;
+
+	unsigned char *data;
+
+	/// true if the internal buffer is copy of the data passed to the constructor
+	bool copyData;
+
+	/// BitStreams that use less than BITSTREAM_STACK_ALLOCATION_SIZE use the stack, rather than the heap to store data.  It switches over if BITSTREAM_STACK_ALLOCATION_SIZE is exceeded
+	unsigned char stackData[BITSTREAM_STACK_ALLOCATION_SIZE];
+};
+
+template <class templateType>
+inline bool BitStream::Serialize(bool writeToBitstream, templateType &inOutTemplateVar)
+{
+	if (writeToBitstream)
+		Write(inOutTemplateVar);
+	else
+		return Read(inOutTemplateVar);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue)
+{
+	if (writeToBitstream)
+		WriteDelta(inOutCurrentValue, lastValue);
+	else
+		return ReadDelta(inOutCurrentValue);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeDelta(bool writeToBitstream, templateType &inOutCurrentValue)
+{
+	if (writeToBitstream)
+		WriteDelta(inOutCurrentValue);
+	else
+		return ReadDelta(inOutCurrentValue);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeCompressed(bool writeToBitstream, templateType &inOutTemplateVar)
+{
+	if (writeToBitstream)
+		WriteCompressed(inOutTemplateVar);
+	else
+		return ReadCompressed(inOutTemplateVar);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue, const templateType &lastValue)
+{
+	if (writeToBitstream)
+		WriteCompressedDelta(inOutCurrentValue,lastValue);
+	else
+		return ReadCompressedDelta(inOutCurrentValue);
+	return true;
+}
+//Stoppedhere
+template <class templateType>
+inline bool BitStream::SerializeCompressedDelta(bool writeToBitstream, templateType &inOutCurrentValue)
+{
+	if (writeToBitstream)
+		WriteCompressedDelta(inOutCurrentValue);
+	else
+		return ReadCompressedDelta(inOutCurrentValue);
+	return true;
+}
+
+inline bool BitStream::Serialize(bool writeToBitstream, char* inOutByteArray, const unsigned int numberOfBytes )
+{
+	if (writeToBitstream)
+		Write(inOutByteArray, numberOfBytes);
+	else
+		return Read(inOutByteArray, numberOfBytes);
+	return true;
+}
+
+template <class serializationType, class sourceType >
+bool BitStream::SerializeCasted( bool writeToBitstream, sourceType &value )
+{
+	if (writeToBitstream) WriteCasted<serializationType>(value);
+	else return ReadCasted<serializationType>(value);
+	return true;
+}
+
+template <class templateType>
+bool BitStream::SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	return SerializeBitsFromIntegerRange(writeToBitstream,value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+bool BitStream::SerializeBitsFromIntegerRange( bool writeToBitstream, templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	if (writeToBitstream) WriteBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+	else return ReadBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeNormVector(bool writeToBitstream, templateType &x, templateType &y, templateType &z )
+{
+	if (writeToBitstream)
+		WriteNormVector(x,y,z);
+	else
+		return ReadNormVector(x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeVector(bool writeToBitstream,  templateType &x, templateType &y, templateType &z )
+{
+	if (writeToBitstream)
+		WriteVector(x,y,z);
+	else
+		return ReadVector(x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeNormQuat(bool writeToBitstream,  templateType &w, templateType &x, templateType &y, templateType &z)
+{
+	if (writeToBitstream)
+		WriteNormQuat(w,x,y,z);
+	else
+		return ReadNormQuat(w,x,y,z);
+	return true;
+}
+
+template <class templateType>
+inline bool BitStream::SerializeOrthMatrix(
+	bool writeToBitstream,
+	templateType &m00, templateType &m01, templateType &m02,
+	templateType &m10, templateType &m11, templateType &m12,
+	templateType &m20, templateType &m21, templateType &m22 )
+{
+	if (writeToBitstream)
+		WriteOrthMatrix(m00,m01,m02,m10,m11,m12,m20,m21,m22);
+	else
+		return ReadOrthMatrix(m00,m01,m02,m10,m11,m12,m20,m21,m22);
+	return true;
+}
+
+inline bool BitStream::SerializeBits(bool writeToBitstream, unsigned char* inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits )
+{
+	if (writeToBitstream)
+		WriteBits(inOutByteArray,numberOfBitsToSerialize,rightAlignedBits);
+	else
+		return ReadBits(inOutByteArray,numberOfBitsToSerialize,rightAlignedBits);
+	return true;
+}
+
+template <class templateType>
+inline void BitStream::Write(const templateType &inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(inTemplateVar)==1)
+		WriteBits( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));
+			WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteBits( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <class templateType>
+inline void BitStream::WritePtr(templateType *inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(templateType)==1)
+		WriteBits( ( unsigned char* ) inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*) inTemplateVar, output, sizeof(templateType));
+			WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteBits( ( unsigned char* ) inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+/// \brief Write a bool to a bitstream.
+/// \param[in] inTemplateVar The value to write
+template <>
+inline void BitStream::Write(const bool &inTemplateVar)
+{
+	if ( inTemplateVar )
+		Write1();
+	else
+		Write0();
+}
+
+
+/// \brief Write a string to a bitstream.
+/// \param[in] var The value to write
+template <>
+inline void BitStream::Write(const OVR::String &inTemplateVar)
+{
+	uint16_t l = (uint16_t) inTemplateVar.GetLength();
+	Write(l);
+	WriteAlignedBytes((const unsigned char*) inTemplateVar.ToCStr(), (const unsigned int) l);
+}
+template <>
+inline void BitStream::Write(const char * const &inStringVar)
+{
+	uint16_t l = (uint16_t) strlen(inStringVar);
+	Write(l);
+	WriteAlignedBytes((const unsigned char*) inStringVar, (const unsigned int) l);
+}
+template <>
+inline void BitStream::Write(const unsigned char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+template <>
+inline void BitStream::Write(char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+template <>
+inline void BitStream::Write(unsigned char * const &inTemplateVar)
+{
+	Write((const char*)inTemplateVar);
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details If the current value is different from the last value
+/// the current value will be written.  Otherwise, a single bit will be written
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <class templateType>
+inline void BitStream::WriteDelta(const templateType &currentValue, const templateType &lastValue)
+{
+	if (currentValue==lastValue)
+	{
+		Write(false);
+	}
+	else
+	{
+		Write(true);
+		Write(currentValue);
+	}
+}
+
+/// \brief Write a bool delta. Same thing as just calling Write
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <>
+inline void BitStream::WriteDelta(const bool &currentValue, const bool &lastValue)
+{
+	(void) lastValue;
+
+	Write(currentValue);
+}
+
+/// \brief WriteDelta when you don't know what the last value is, or there is no last value.
+/// \param[in] currentValue The current value to write
+template <class templateType>
+inline void BitStream::WriteDelta(const templateType &currentValue)
+{
+	Write(true);
+	Write(currentValue);
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] inTemplateVar The value to write
+template <class templateType>
+inline void BitStream::WriteCompressed(const templateType &inTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(inTemplateVar)==1)
+		WriteCompressed( ( unsigned char* ) & inTemplateVar, sizeof( templateType ) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'uint16_t', possible loss of data
+#endif
+
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			ReverseBytes((unsigned char*)&inTemplateVar, output, sizeof(templateType));
+			WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
+		}
+		else
+#endif
+			WriteCompressed( ( unsigned char* ) & inTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <>
+inline void BitStream::WriteCompressed(const bool &inTemplateVar)
+{
+	Write(inTemplateVar);
+}
+
+/// For values between -1 and 1
+template <>
+inline void BitStream::WriteCompressed(const float &inTemplateVar)
+{
+	OVR_ASSERT(inTemplateVar > -1.01f && inTemplateVar < 1.01f);
+	float varCopy=inTemplateVar;
+	if (varCopy < -1.0f)
+		varCopy=-1.0f;
+	if (varCopy > 1.0f)
+		varCopy=1.0f;
+	Write((uint16_t)((varCopy+1.0f)*32767.5f));
+}
+
+/// For values between -1 and 1
+template <>
+inline void BitStream::WriteCompressed(const double &inTemplateVar)
+{
+	OVR_ASSERT(inTemplateVar > -1.01 && inTemplateVar < 1.01);
+	double varCopy=inTemplateVar;
+	if (varCopy < -1.0f)
+		varCopy=-1.0f;
+	if (varCopy > 1.0f)
+		varCopy=1.0f;
+	Write((uint32_t)((varCopy+1.0)*2147483648.0));
+}
+
+/// \brief Write any integral type to a bitstream.  
+/// \details If the current value is different from the last value
+/// the current value will be written.  Otherwise, a single bit will be written
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <class templateType>
+inline void BitStream::WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue)
+{
+	if (currentValue==lastValue)
+	{
+		Write(false);
+	}
+	else
+	{
+		Write(true);
+		WriteCompressed(currentValue);
+	}
+}
+
+/// \brief Write a bool delta.  Same thing as just calling Write
+/// \param[in] currentValue The current value to write
+/// \param[in] lastValue The last value to compare against
+template <>
+inline void BitStream::WriteCompressedDelta(const bool &currentValue, const bool &lastValue)
+{
+	(void) lastValue;
+
+	Write(currentValue);
+}
+
+/// \brief Save as WriteCompressedDelta(const templateType &currentValue, const templateType &lastValue) 
+/// when we have an unknown second parameter
+template <class templateType>
+inline void BitStream::WriteCompressedDelta(const templateType &currentValue)
+{
+	Write(true);
+	WriteCompressed(currentValue);
+}
+
+/// \brief Save as WriteCompressedDelta(bool currentValue, const templateType &lastValue) 
+/// when we have an unknown second bool
+template <>
+inline void BitStream::WriteCompressedDelta(const bool &currentValue)
+{
+	Write(currentValue);
+}
+
+/// \brief Read any integral type from a bitstream.  Define __BITSTREAM_NATIVE_END if you need endian swapping.
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::Read(templateType &outTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(outTemplateVar)==1)
+		return ReadBits( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'uint16_t', possible loss of data
+#endif
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
+			{
+				ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));
+				return true;
+			}
+			return false;
+		}
+		else
+#endif
+			return ReadBits( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::Read(bool &outTemplateVar)
+{
+	if ( readOffset + 1 > numberOfBitsUsed )
+		return false;
+
+	if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset & 7 ) ) )   // Is it faster to just write it out here?
+		outTemplateVar = true;
+	else
+		outTemplateVar = false;
+
+	// Has to be on a different line for Mac
+	readOffset++;
+
+	return true;
+}
+
+template <>
+inline bool BitStream::Read(OVR::String &outTemplateVar)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		AlignReadToByteBoundary();
+		outTemplateVar.AssignString((const char*) (data + ( readOffset >> 3 )), (size_t) l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+template <>
+inline bool BitStream::Read(char *&varString)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		memcpy(varString, data + ( readOffset >> 3 ), l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+template <>
+inline bool BitStream::Read(unsigned char *&varString)
+{
+	bool b;
+	uint16_t l;
+	b=Read(l);
+	if (b && l>0)
+	{
+		memcpy(varString, data + ( readOffset >> 3 ), l);
+		IgnoreBytes(l);
+	}
+	else
+	{
+		AlignReadToByteBoundary();
+	}
+	return b;
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details If the written value differed from the value compared against in the write function,
+/// var will be updated.  Otherwise it will retain the current value.
+/// ReadDelta is only valid from a previous call to WriteDelta
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadDelta(templateType &outTemplateVar)
+{
+	bool dataWritten;
+	bool success;
+	success=Read(dataWritten);
+	if (dataWritten)
+		success=Read(outTemplateVar);
+	return success;
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::ReadDelta(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details Undefine __BITSTREAM_NATIVE_END if you need endian swapping.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadCompressed(templateType &outTemplateVar)
+{
+#ifdef OVR_CC_MSVC
+#pragma warning(disable:4127)   // conditional expression is constant
+#endif
+	if (sizeof(outTemplateVar)==1)
+		return ReadCompressed( ( unsigned char* ) &outTemplateVar, sizeof(templateType) * 8, true );
+	else
+	{
+#ifndef __BITSTREAM_NATIVE_END
+		if (DoEndianSwap())
+		{
+			unsigned char output[sizeof(templateType)];
+			if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
+			{
+				ReverseBytes(output, (unsigned char*)&outTemplateVar, sizeof(templateType));
+				return true;
+			}
+			return false;
+		}
+		else
+#endif
+			return ReadCompressed( ( unsigned char* ) & outTemplateVar, sizeof(templateType) * 8, true );
+	}
+}
+
+template <>
+inline bool BitStream::ReadCompressed(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+/// For values between -1 and 1
+template <>
+inline bool BitStream::ReadCompressed(float &outTemplateVar)
+{
+	uint16_t compressedFloat;
+	if (Read(compressedFloat))
+	{
+		outTemplateVar = ((float)compressedFloat / 32767.5f - 1.0f);
+		return true;
+	}
+	return false;
+}
+
+/// For values between -1 and 1
+template <>
+inline bool BitStream::ReadCompressed(double &outTemplateVar)
+{
+	uint32_t compressedFloat;
+	if (Read(compressedFloat))
+	{
+		outTemplateVar = ((double)compressedFloat / 2147483648.0 - 1.0);
+		return true;
+	}
+	return false;
+}
+
+/// \brief Read any integral type from a bitstream.  
+/// \details If the written value differed from the value compared against in the write function,
+/// var will be updated.  Otherwise it will retain the current value.
+/// the current value will be updated.
+/// For floating point, this is lossy, using 2 bytes for a float and 4 for a double.  The range must be between -1 and +1.
+/// For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type
+/// If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte
+/// ReadCompressedDelta is only valid from a previous call to WriteDelta
+/// \param[in] outTemplateVar The value to read
+template <class templateType>
+inline bool BitStream::ReadCompressedDelta(templateType &outTemplateVar)
+{
+	bool dataWritten;
+	bool success;
+	success=Read(dataWritten);
+	if (dataWritten)
+		success=ReadCompressed(outTemplateVar);
+	return success;
+}
+
+/// \brief Read a bool from a bitstream.
+/// \param[in] outTemplateVar The value to read
+template <>
+inline bool BitStream::ReadCompressedDelta(bool &outTemplateVar)
+{
+	return Read(outTemplateVar);
+}
+
+template <class destinationType, class sourceType >
+void BitStream::WriteCasted( const sourceType &value )
+{
+	destinationType val = (destinationType) value;
+	Write(val);
+}
+
+template <class templateType>
+void BitStream::WriteBitsFromIntegerRange( const templateType value, const templateType minimum,const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	WriteBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+void BitStream::WriteBitsFromIntegerRange( const templateType value, const templateType minimum,const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	OVR_ASSERT(maximum>=minimum);
+	OVR_ASSERT(allowOutsideRange==true || (value>=minimum && value<=maximum));
+	if (allowOutsideRange)
+	{
+		if (value<minimum || value>maximum)
+		{
+			Write(true);
+			Write(value);
+			return;
+		}
+		Write(false);
+	}
+	templateType valueOffMin=value-minimum;
+	if (IsBigEndian()==true)
+	{
+		unsigned char output[sizeof(templateType)];
+		ReverseBytes((unsigned char*)&valueOffMin, output, sizeof(templateType));
+		WriteBits(output,requiredBits);
+	}
+	else
+	{
+		WriteBits((unsigned char*) &valueOffMin,requiredBits);
+	}
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteNormVector( templateType x, templateType y, templateType z )
+{
+#ifdef _DEBUG
+	OVR_ASSERT(x <= 1.01 && y <= 1.01 && z <= 1.01 && x >= -1.01 && y >= -1.01 && z >= -1.01);
+#endif
+
+	WriteFloat16((float)x,-1.0f,1.0f);
+	WriteFloat16((float)y,-1.0f,1.0f);
+	WriteFloat16((float)z,-1.0f,1.0f);
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteVector( templateType x, templateType y, templateType z )
+{
+	templateType magnitude = sqrt(x * x + y * y + z * z);
+	Write((float)magnitude);
+	if (magnitude > 0.00001f)
+	{
+		WriteCompressed((float)(x/magnitude));
+		WriteCompressed((float)(y/magnitude));
+		WriteCompressed((float)(z/magnitude));
+		//	Write((uint16_t)((x/magnitude+1.0f)*32767.5f));
+		//	Write((uint16_t)((y/magnitude+1.0f)*32767.5f));
+		//	Write((uint16_t)((z/magnitude+1.0f)*32767.5f));
+	}
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteNormQuat( templateType w, templateType x, templateType y, templateType z)
+{
+	Write((bool)(w<0.0));
+	Write((bool)(x<0.0));
+	Write((bool)(y<0.0));
+	Write((bool)(z<0.0));
+	Write((uint16_t)(fabs(x)*65535.0));
+	Write((uint16_t)(fabs(y)*65535.0));
+	Write((uint16_t)(fabs(z)*65535.0));
+	// Leave out w and calculate it on the target
+}
+
+template <class templateType> // templateType for this function must be a float or double
+void BitStream::WriteOrthMatrix(
+	templateType m00, templateType m01, templateType m02,
+	templateType m10, templateType m11, templateType m12,
+	templateType m20, templateType m21, templateType m22 )
+{
+
+	double qw;
+	double qx;
+	double qy;
+	double qz;
+
+	// Convert matrix to quat
+	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
+	float sum;
+	sum = 1 + m00 + m11 + m22;
+	if (sum < 0.0f) sum=0.0f;
+	qw = sqrt( sum  ) / 2;
+	sum = 1 + m00 - m11 - m22;
+	if (sum < 0.0f) sum=0.0f;
+	qx = sqrt( sum  ) / 2;
+	sum = 1 - m00 + m11 - m22;
+	if (sum < 0.0f) sum=0.0f;
+	qy = sqrt( sum  ) / 2;
+	sum = 1 - m00 - m11 + m22;
+	if (sum < 0.0f) sum=0.0f;
+	qz = sqrt( sum  ) / 2;
+	if (qw < 0.0) qw=0.0;
+	if (qx < 0.0) qx=0.0;
+	if (qy < 0.0) qy=0.0;
+	if (qz < 0.0) qz=0.0;
+#ifdef OVR_OS_WIN32
+	qx = _copysign( (double) qx, (double) (m21 - m12) );
+	qy = _copysign( (double) qy, (double) (m02 - m20) );
+	qz = _copysign( (double) qz, (double) (m10 - m01) );
+#else
+	qx = copysign( (double) qx, (double) (m21 - m12) );
+	qy = copysign( (double) qy, (double) (m02 - m20) );
+	qz = copysign( (double) qz, (double) (m10 - m01) );
+#endif
+
+	WriteNormQuat(qw,qx,qy,qz);
+}
+
+template <class serializationType, class sourceType >
+bool BitStream::ReadCasted( sourceType &value )
+{
+	serializationType val;
+	bool success = Read(val);
+	value=(sourceType) val;
+	return success;
+}
+
+template <class templateType>
+bool BitStream::ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, bool allowOutsideRange )
+{
+	int requiredBits=BYTES_TO_BITS(sizeof(templateType))-NumberOfLeadingZeroes(templateType(maximum-minimum));
+	return ReadBitsFromIntegerRange(value,minimum,maximum,requiredBits,allowOutsideRange);
+}
+template <class templateType>
+bool BitStream::ReadBitsFromIntegerRange( templateType &value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange )
+{
+	OVR_ASSERT(maximum>=minimum);
+	if (allowOutsideRange)
+	{
+		bool isOutsideRange;
+		Read(isOutsideRange);
+		if (isOutsideRange)
+			return Read(value);
+	}
+	unsigned char output[sizeof(templateType)];
+	memset(output,0,sizeof(output));
+	bool success = ReadBits(output,requiredBits);
+	if (success)
+	{
+		if (IsBigEndian()==true)
+			ReverseBytesInPlace(output,sizeof(output));
+		memcpy(&value,output,sizeof(output));
+
+		value+=minimum;
+	}
+
+	return success;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadNormVector( templateType &x, templateType &y, templateType &z )
+{
+	float xIn,yIn,zIn;
+	ReadFloat16(xIn,-1.0f,1.0f);
+	ReadFloat16(yIn,-1.0f,1.0f);
+	ReadFloat16(zIn,-1.0f,1.0f);
+	x=xIn;
+	y=yIn;
+	z=zIn;
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadVector( templateType &x, templateType &y, templateType &z )
+{
+	float magnitude;
+	//uint16_t sx,sy,sz;
+	if (!Read(magnitude))
+		return false;
+	if (magnitude>0.00001f)
+	{
+		//	Read(sx);
+		//	Read(sy);
+		//	if (!Read(sz))
+		//		return false;
+		//	x=((float)sx / 32767.5f - 1.0f) * magnitude;
+		//	y=((float)sy / 32767.5f - 1.0f) * magnitude;
+		//	z=((float)sz / 32767.5f - 1.0f) * magnitude;
+		float cx=0.0f,cy=0.0f,cz=0.0f;
+		ReadCompressed(cx);
+		ReadCompressed(cy);
+		if (!ReadCompressed(cz))
+			return false;
+		x=cx;
+		y=cy;
+		z=cz;
+		x*=magnitude;
+		y*=magnitude;
+		z*=magnitude;
+	}
+	else
+	{
+		x=0.0;
+		y=0.0;
+		z=0.0;
+	}
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadNormQuat( templateType &w, templateType &x, templateType &y, templateType &z)
+{
+	bool cwNeg=false, cxNeg=false, cyNeg=false, czNeg=false;
+	uint16_t cx,cy,cz;
+	Read(cwNeg);
+	Read(cxNeg);
+	Read(cyNeg);
+	Read(czNeg);
+	Read(cx);
+	Read(cy);
+	if (!Read(cz))
+		return false;
+
+	// Calculate w from x,y,z
+	x=(templateType)(cx/65535.0);
+	y=(templateType)(cy/65535.0);
+	z=(templateType)(cz/65535.0);
+	if (cxNeg) x=-x;
+	if (cyNeg) y=-y;
+	if (czNeg) z=-z;
+	float difference = 1.0f - x*x - y*y - z*z;
+	if (difference < 0.0f)
+		difference=0.0f;
+	w = (templateType)(sqrt(difference));
+	if (cwNeg)
+		w=-w;
+
+	return true;
+}
+
+template <class templateType> // templateType for this function must be a float or double
+bool BitStream::ReadOrthMatrix(
+	templateType &m00, templateType &m01, templateType &m02,
+	templateType &m10, templateType &m11, templateType &m12,
+	templateType &m20, templateType &m21, templateType &m22 )
+{
+	float qw,qx,qy,qz;
+	if (!ReadNormQuat(qw,qx,qy,qz))
+		return false;
+
+	// Quat to orthogonal rotation matrix
+	// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm
+	double sqw = (double)qw*(double)qw;
+	double sqx = (double)qx*(double)qx;
+	double sqy = (double)qy*(double)qy;
+	double sqz = (double)qz*(double)qz;
+	m00 =  (templateType)(sqx - sqy - sqz + sqw); // since sqw + sqx + sqy + sqz =1
+	m11 = (templateType)(-sqx + sqy - sqz + sqw);
+	m22 = (templateType)(-sqx - sqy + sqz + sqw);
+
+	double tmp1 = (double)qx*(double)qy;
+	double tmp2 = (double)qz*(double)qw;
+	m10 = (templateType)(2.0 * (tmp1 + tmp2));
+	m01 = (templateType)(2.0 * (tmp1 - tmp2));
+
+	tmp1 = (double)qx*(double)qz;
+	tmp2 = (double)qy*(double)qw;
+	m20 =(templateType)(2.0 * (tmp1 - tmp2));
+	m02 = (templateType)(2.0 * (tmp1 + tmp2));
+	tmp1 = (double)qy*(double)qz;
+	tmp2 = (double)qx*(double)qw;
+	m21 = (templateType)(2.0 * (tmp1 + tmp2));
+	m12 = (templateType)(2.0 * (tmp1 - tmp2));
+
+	return true;
+}
+
+template <class templateType>
+BitStream& operator<<(BitStream& out, templateType& c)
+{
+	out.Write(c);
+	return out;
+}
+template <class templateType>
+BitStream& operator>>(BitStream& in, templateType& c)
+{
+	bool success = in.Read(c);
+	(void)success;
+
+	OVR_ASSERT(success);
+	return in;
+}
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_MessageIDTypes.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_MessageIDTypes.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,39 @@
+/************************************************************************************
+
+Filename    :   OVR_MessageIDTypes.h
+Content     :   Enumeration list indicating what type of message is being sent
+Created     :   July 3, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+namespace OVR { namespace Net {
+
+/// First byte of a network message
+typedef unsigned char MessageID;
+
+enum DefaultMessageIDTypes
+{
+    OVRID_RPC1,
+    OVRID_END = 128,
+    OVRID_LATENCY_TESTER_1,
+};
+
+}} // namespace OVR::Net
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkPlugin.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,60 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_NetworkPlugin.h
+Content     :   Base class for an extension to the network objects.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_NetworkPlugin_h
+#define OVR_NetworkPlugin_h
+
+#include "OVR_Session.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+
+//-----------------------------------------------------------------------------
+// NetworkPlugin
+
+// NetworkPlugins use Session and SessionListener to provide network functionality
+// independent of the transport medium.
+// Uses the chain of command design pattern such that plugins can invoke or intercept
+// network events via the Session.
+class NetworkPlugin : public SessionListener
+{
+public:
+	NetworkPlugin();
+	virtual ~NetworkPlugin();
+
+protected:
+	virtual void OnAddedToSession(Session* _pSession);
+	virtual void OnRemovedFromSession(Session* _pSession);
+
+	Session *pSession;
+	//uint8_t PluginId;
+};
+
+
+}}} // OVR::Net::Plugins
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkTypes.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_NetworkTypes.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,42 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_NetworkTypes.h
+Content     :   Shared header for network types
+Created     :   June 12, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_NetworkTypes_h
+#define OVR_NetworkTypes_h
+
+#include "../Kernel/OVR_Types.h"
+
+namespace OVR {	namespace Net {
+
+
+typedef uint64_t NetworkID;
+const NetworkID InvalidNetworkID = ~((NetworkID)0);
+
+
+} } // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_PacketizedTCPSocket.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,87 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_PacketizedTCPSocket.cpp
+Content     :   TCP with automated message framing.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_PacketizedTCPSocket_h
+#define OVR_PacketizedTCPSocket_h
+
+#include "OVR_Socket.h"
+#include "../Kernel/OVR_Allocator.h"
+#include "../Kernel/OVR_Atomic.h"
+
+#ifdef OVR_OS_WIN32
+#include "OVR_Win32_Socket.h"
+#else
+#include "OVR_Unix_Socket.h"
+#endif
+
+namespace OVR { namespace Net {
+
+
+//-----------------------------------------------------------------------------
+// NetworkPlugin
+
+// Packetized TCP base socket
+class PacketizedTCPSocketBase : public TCPSocket
+{
+public:
+	PacketizedTCPSocketBase() {}
+	PacketizedTCPSocketBase(SocketHandle _sock, bool isListenSocket) : TCPSocket(_sock, isListenSocket) {}
+};
+
+
+//-----------------------------------------------------------------------------
+// PacketizedTCPSocket
+
+// Uses TCP but is message aligned rather than stream aligned
+// Alternative to reliable UDP
+class PacketizedTCPSocket : public PacketizedTCPSocketBase
+{
+public:
+	PacketizedTCPSocket();
+	PacketizedTCPSocket(SocketHandle _sock, bool isListenSocket);
+	virtual ~PacketizedTCPSocket();
+
+public:
+	virtual int Send(const void* pData, int bytes);
+	virtual int SendAndConcatenate(const void** pDataArray, int *dataLengthArray, int arrayCount);
+
+protected:
+	virtual void OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData, int bytesRead);
+
+	int BytesFromStream(uint8_t* pData, int bytesRead);
+
+    Lock   sendLock;
+    Lock   recvBuffLock;
+
+	uint8_t* pRecvBuff;     // Queued receive buffered data
+	int    pRecvBuffSize; // Size of receive queue in bytes
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_RPC1.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,105 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_RPC1.h
+Content     :   A network plugin that provides remote procedure call functionality.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Net_RPC_h
+#define OVR_Net_RPC_h
+
+#include "OVR_NetworkPlugin.h"
+#include "../Kernel/OVR_Hash.h"
+#include "../Kernel/OVR_String.h"
+#include "OVR_BitStream.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Delegates.h"
+#include "../Kernel//OVR_Observer.h"
+
+namespace OVR { namespace Net { namespace Plugins {
+
+
+typedef Delegate3<void, BitStream*, BitStream*, ReceivePayload*> RPCDelegate;
+typedef Delegate2<void, BitStream*, ReceivePayload*> RPCSlot;
+// typedef void ( *Slot ) ( OVR::Net::BitStream *userData, OVR::Net::ReceivePayload *pPayload );
+
+/// NetworkPlugin that maps strings to function pointers. Can invoke the functions using blocking calls with return values, or signal/slots. Networked parameters serialized with BitStream
+class RPC1 : public NetworkPlugin, public NewOverrideBase
+{
+public:
+	RPC1();
+	virtual ~RPC1();
+
+	/// Register a slot, which is a function pointer to one or more implementations that supports this function signature
+	/// When a signal occurs, all slots with the same identifier are called.
+	/// \param[in] sharedIdentifier A string to identify the slot. Recommended to be the same as the name of the function.
+	/// \param[in] functionPtr Pointer to the function.
+	/// \param[in] callPriority Slots are called by order of the highest callPriority first. For slots with the same priority, they are called in the order they are registered
+	void RegisterSlot(OVR::String sharedIdentifier,  OVR::Observer<RPCSlot> *rpcSlotObserver);
+
+	/// \brief Same as \a RegisterFunction, but is called with CallBlocking() instead of Call() and returns a value to the caller
+	bool RegisterBlockingFunction(OVR::String uniqueID, RPCDelegate blockingFunction);
+
+	/// \brief Same as UnregisterFunction, except for a blocking function
+	void UnregisterBlockingFunction(OVR::String uniqueID);
+
+	// \brief Same as call, but don't return until the remote system replies.
+	/// Broadcasting parameter does not exist, this can only call one remote system
+	/// \note This function does not return until the remote system responds, disconnects, or was never connected to begin with
+	/// \param[in] Identifier originally passed to RegisterBlockingFunction() on the remote system(s)
+	/// \param[in] bitStream bitStream encoded data to send to the function callback
+	/// \param[in] pConnection connection to send on
+	/// \param[out] returnData Written to by the function registered with RegisterBlockingFunction.
+	/// \return true if successfully called. False on disconnect, function not registered, or not connected to begin with
+	bool CallBlocking( OVR::String uniqueID, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection, OVR::Net::BitStream *returnData = NULL );
+
+	/// Calls zero or more functions identified by sharedIdentifier registered with RegisterSlot()
+	/// \param[in] sharedIdentifier parameter of the same name passed to RegisterSlot() on the remote system
+	/// \param[in] bitStream bitStream encoded data to send to the function callback
+	/// \param[in] pConnection connection to send on
+	bool Signal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream, Ptr<Connection> pConnection);
+    void BroadcastSignal(OVR::String sharedIdentifier, OVR::Net::BitStream * bitStream);
+
+
+protected:
+	virtual void OnReceive(ReceivePayload *pPayload, ListenerReceiveResult *lrrOut);
+
+    virtual void OnDisconnected(Connection* conn);
+    virtual void OnConnected(Connection* conn);
+
+	Hash< String, RPCDelegate, String::HashFunctor > registeredBlockingFunctions;
+	ObserverHash< RPCSlot > slotHash;
+
+    // Synchronization for RPC caller
+    Lock            singleRPCLock;
+    Mutex           callBlockingMutex;
+    WaitCondition   callBlockingWait;
+
+    Net::BitStream* blockingReturnValue;
+	Ptr<Connection> blockingOnThisConnection;
+};
+
+
+}}} // OVR::Net::Plugins
+
+#endif // OVR_Net_RPC_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Session.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,502 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Session.h
+Content     :   One network session that provides connection/disconnection events.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Session_h
+#define OVR_Session_h
+
+#include "OVR_Socket.h"
+#include "OVR_PacketizedTCPSocket.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Atomic.h"
+#include "../Kernel/OVR_RefCount.h"
+
+namespace OVR { namespace Net {
+
+class Session;
+
+
+//-----------------------------------------------------------------------------
+// Based on Semantic Versioning ( http://semver.org/ )
+//
+// Please update changelog below:
+// 1.0.0 - [SDK 0.4.0] Initial version (July 21, 2014)
+// 1.1.0 - Add Get/SetDriverMode_1, HMDCountUpdate_1
+//         Version mismatch results (July 28, 2014)
+//-----------------------------------------------------------------------------
+
+static const uint16_t RPCVersion_Major = 1; // MAJOR version when you make incompatible API changes,
+static const uint16_t RPCVersion_Minor = 1; // MINOR version when you add functionality in a backwards-compatible manner, and
+static const uint16_t RPCVersion_Patch = 0; // PATCH version when you make backwards-compatible bug fixes.
+
+// Client starts communication by sending its version number.
+struct RPC_C2S_Hello
+{
+    RPC_C2S_Hello() :
+        MajorVersion(0),
+        MinorVersion(0),
+        PatchVersion(0)
+    {
+    }
+
+    String HelloString;
+
+    // Client version info
+    uint16_t MajorVersion, MinorVersion, PatchVersion;
+
+    void Serialize(Net::BitStream* bs)
+    {
+        bs->Write(HelloString);
+        bs->Write(MajorVersion);
+        bs->Write(MinorVersion);
+        bs->Write(PatchVersion);
+    }
+
+    bool Deserialize(Net::BitStream* bs)
+    {
+        bs->Read(HelloString);
+        bs->Read(MajorVersion);
+        bs->Read(MinorVersion);
+        return bs->Read(PatchVersion);
+    }
+
+    static void Generate(Net::BitStream* bs);
+
+    bool Validate();
+};
+
+// Server responds with an authorization accepted message, including the server's version number
+struct RPC_S2C_Authorization
+{
+    RPC_S2C_Authorization() :
+        MajorVersion(0),
+        MinorVersion(0),
+        PatchVersion(0)
+    {
+    }
+
+    String AuthString;
+
+    // Server version info
+    uint16_t MajorVersion, MinorVersion, PatchVersion;
+
+    void Serialize(Net::BitStream* bs)
+    {
+        bs->Write(AuthString);
+        bs->Write(MajorVersion);
+        bs->Write(MinorVersion);
+        bs->Write(PatchVersion);
+    }
+
+    bool Deserialize(Net::BitStream* bs)
+    {
+        bs->Read(AuthString);
+        bs->Read(MajorVersion);
+        bs->Read(MinorVersion);
+        return bs->Read(PatchVersion);
+    }
+
+    static void Generate(Net::BitStream* bs, String errorString = "");
+
+    bool Validate();
+};
+
+
+//-----------------------------------------------------------------------------
+// Result of a session function
+enum SessionResult
+{
+	SessionResult_OK,
+	SessionResult_BindFailure,
+	SessionResult_ListenFailure,
+	SessionResult_ConnectFailure,
+    SessionResult_ConnectInProgress,
+    SessionResult_AlreadyConnected,
+};
+
+
+//-----------------------------------------------------------------------------
+// Connection state
+enum EConnectionState
+{
+    State_Zombie,          // Disconnected
+
+    // Client-only:
+    Client_Connecting,     // Waiting for TCP connection
+    Client_ConnectedWait,  // Connected! Waiting for server to authorize
+
+    // Server-only:
+    Server_ConnectedWait,  // Connected! Waiting for client handshake
+
+    State_Connected        // Connected
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic connection over any transport
+class Connection : public RefCountBase<Connection>
+{
+public:
+    Connection() :
+        Transport(TransportType_None),
+        State(State_Zombie),
+        RemoteMajorVersion(0),
+        RemoteMinorVersion(0),
+        RemotePatchVersion(0)
+    {
+    }
+	virtual ~Connection() // Allow delete from base
+    {
+    }
+
+public:
+    virtual void SetState(EConnectionState s) {State = s;}
+
+    TransportType    Transport;
+    EConnectionState State;
+
+    // Version number read from remote host just before connection completes
+    int              RemoteMajorVersion;
+    int              RemoteMinorVersion;
+    int              RemotePatchVersion;
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic network connection over any network transport
+class NetworkConnection : public Connection
+{
+protected:
+    NetworkConnection()
+	{
+	}
+    virtual ~NetworkConnection()
+    {
+    }
+
+public:
+    virtual void SetState(EConnectionState s)
+    {
+        if (s != State)
+        {
+            Mutex::Locker locker(&StateMutex);
+
+            if (s != State)
+            {
+                State = s;
+
+                if (State != Client_Connecting)
+                {
+                    ConnectingWait.NotifyAll();
+                }
+            }
+        }
+    }
+
+    void WaitOnConnecting()
+    {
+        Mutex::Locker locker(&StateMutex);
+
+        while (State == Client_Connecting)
+        {
+            ConnectingWait.Wait(&StateMutex);
+        }
+    }
+
+	SockAddr      Address;
+    Mutex         StateMutex;
+    WaitCondition ConnectingWait;
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Connection
+class TCPConnection : public NetworkConnection
+{
+public:
+    TCPConnection()
+    {
+    }
+    virtual ~TCPConnection()
+    {
+    }
+
+public:
+	Ptr<TCPSocket> pSocket;
+};
+
+
+//-----------------------------------------------------------------------------
+// Packetized TCP Connection
+class PacketizedTCPConnection : public TCPConnection
+{
+public:
+	PacketizedTCPConnection()
+    {
+        Transport = TransportType_PacketizedTCP;
+    }
+    virtual ~PacketizedTCPConnection()
+    {
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// Generic socket listener description
+class ListenerDescription
+{
+public:
+    ListenerDescription() :
+        Transport(TransportType_None)
+    {
+    }
+
+    TransportType Transport;
+};
+
+
+//-----------------------------------------------------------------------------
+// Description for a Berkley socket listener
+class BerkleyListenerDescription : public ListenerDescription
+{
+public:
+	static const int DefaultMaxIncomingConnections =  64;
+	static const int DefaultMaxConnections         = 128;
+
+	BerkleyListenerDescription() :
+		MaxIncomingConnections(DefaultMaxIncomingConnections),
+		MaxConnections(DefaultMaxConnections)
+	{
+	}
+
+	Ptr<BerkleySocket> BoundSocketToListenWith;
+    int                MaxIncomingConnections;
+    int                MaxConnections;
+};
+
+
+//-----------------------------------------------------------------------------
+// Receive payload
+struct ReceivePayload
+{
+	Connection* pConnection; // Source connection
+	uint8_t*      pData;       // Pointer to data received
+	int         Bytes;       // Number of bytes of data received
+};
+
+//-----------------------------------------------------------------------------
+// Broadcast parameters
+class BroadcastParameters
+{
+public:
+    BroadcastParameters() :
+        pData(NULL),
+        Bytes(0)
+    {
+    }
+
+    BroadcastParameters(const void* _pData, int _bytes) :
+        pData(_pData),
+        Bytes(_bytes)
+    {
+    }
+
+public:
+    const void*     pData;       // Pointer to data to send
+    int             Bytes;       // Number of bytes of data received
+};
+
+//-----------------------------------------------------------------------------
+// Send parameters
+class SendParameters
+{
+public:
+	SendParameters() :
+		pData(NULL),
+		Bytes(0)
+	{
+	}
+	SendParameters(Ptr<Connection> _pConnection, const void* _pData, int _bytes) :
+		pConnection(_pConnection),
+		pData(_pData),
+		Bytes(_bytes)
+	{
+	}
+
+public:
+	Ptr<Connection> pConnection; // Connection to use
+	const void*     pData;       // Pointer to data to send
+	int             Bytes;       // Number of bytes of data received
+};
+
+
+//-----------------------------------------------------------------------------
+// Parameters to connect
+struct ConnectParameters
+{
+public:
+	ConnectParameters() :
+		Transport(TransportType_None)
+	{
+	}
+
+	TransportType Transport;
+};
+
+struct ConnectParametersBerkleySocket : public ConnectParameters
+{
+	SockAddr           RemoteAddress;
+	Ptr<BerkleySocket> BoundSocketToConnectWith;
+    bool                Blocking;
+
+	ConnectParametersBerkleySocket()
+    {
+    }
+
+	ConnectParametersBerkleySocket(Socket* s, SockAddr* addr) :
+        RemoteAddress(*addr)
+    {
+        BoundSocketToConnectWith = (BerkleySocket*)s;
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// Listener receive result
+enum ListenerReceiveResult
+{
+	/// The SessionListener used this message and it shouldn't be given to the user.
+	LRR_RETURN = 0,
+
+	/// The SessionListener is going to hold on to this message.  Do not deallocate it but do not pass it to other plugins either.
+	LRR_BREAK,
+
+    /// This message will be processed by other SessionListeners, and at last by the user.
+    LRR_CONTINUE,
+};
+
+
+//-----------------------------------------------------------------------------
+// SessionListener
+
+// Callback interface for network events such as connecting, disconnecting, getting data, independent of the transport medium
+class SessionListener
+{
+public:
+	// Data events
+    virtual void OnReceive(ReceivePayload* pPayload, ListenerReceiveResult* lrrOut) { OVR_UNUSED2(pPayload, lrrOut);  }
+
+	// Connection was closed
+    virtual void OnDisconnected(Connection* conn) = 0;
+
+	// Connection was created (some data was exchanged to verify protocol compatibility too)
+    virtual void OnConnected(Connection* conn) = 0;
+
+    // Server accepted client
+    virtual void OnNewIncomingConnection(Connection* conn)     { OnConnected(conn); }
+    // Client was accepted
+    virtual void OnConnectionRequestAccepted(Connection* conn) { OnConnected(conn); }
+
+    // Connection attempt failed for some reason
+    virtual void OnConnectionAttemptFailed(Connection* conn)   { OnDisconnected(conn); }
+
+    // Incompatible protocol
+    virtual void OnIncompatibleProtocol(Connection* conn)      { OnConnectionAttemptFailed(conn); }
+    // Disconnected during initial handshake
+    virtual void OnHandshakeAttemptFailed(Connection* conn)    { OnConnectionAttemptFailed(conn); }
+
+	// Other
+    virtual void OnAddedToSession(Session* session)            { OVR_UNUSED(session); }
+    virtual void OnRemovedFromSession(Session* session)        { OVR_UNUSED(session); }
+};
+
+
+//-----------------------------------------------------------------------------
+// Session
+
+//  Interface for network events such as listening on a socket, sending data, connecting, and disconnecting. Works independently of the transport medium and also implements loopback
+class Session : public SocketEvent_TCP, public NewOverrideBase
+{
+public:
+    Session() :
+        HasLoopbackListener(false)
+    {
+    }
+    virtual ~Session()
+    {
+    }
+
+	virtual SessionResult Listen(ListenerDescription* pListenerDescription);
+	virtual SessionResult Connect(ConnectParameters* cp);
+	virtual int           Send(SendParameters* payload);
+    virtual void          Broadcast(BroadcastParameters* payload);
+    virtual void          Poll(bool listeners = true);
+	virtual void          AddSessionListener(SessionListener* se);
+	virtual void          RemoveSessionListener(SessionListener* se);
+    virtual SInt32        GetActiveSocketsCount();
+
+    // Packetized TCP convenience functions
+    virtual SessionResult ListenPTCP(BerkleyBindParameters* bbp);
+    virtual SessionResult ConnectPTCP(BerkleyBindParameters* bbp, SockAddr* RemoteAddress, bool blocking);
+
+    // Closes all the sockets; useful for interrupting the socket polling during shutdown
+    void            Shutdown();
+
+    // Get count of successful connections (past handshake point)
+    int             GetConnectionCount() const
+    {
+        return FullConnections.GetSizeI();
+    }
+    Ptr<Connection> GetConnectionAtIndex(int index);
+
+protected:
+	virtual Ptr<Connection> AllocConnection(TransportType transportType);
+
+    Lock SocketListenersLock, ConnectionsLock, SessionListenersLock;
+    bool                      HasLoopbackListener; // Has loopback listener installed?
+	Array< Ptr<TCPSocket> >   SocketListeners;     // List of active sockets
+    Array< Ptr<Connection> >  AllConnections;      // List of active connections stuck at the versioning handshake
+    Array< Ptr<Connection> >  FullConnections;     // List of active connections past the versioning handshake
+    Array< SessionListener* > SessionListeners;    // List of session listeners
+
+    // Tools
+    Ptr<PacketizedTCPConnection> findConnectionBySocket(Array< Ptr<Connection> >& connectionArray, Socket* s, int *connectionIndex = NULL); // Call with ConnectionsLock held
+    Ptr<PacketizedTCPConnection> findConnectionBySockAddr(SockAddr* address); // Call with ConnectionsLock held
+    int                   invokeSessionListeners(ReceivePayload*);
+    void                  invokeSessionEvent(void(SessionListener::*f)(Connection*), Connection* pConnection);
+
+	// TCP
+	virtual void          TCP_OnRecv(Socket* pSocket, uint8_t* pData, int bytesRead);
+	virtual void          TCP_OnClosed(TCPSocket* pSocket);
+	virtual void          TCP_OnAccept(TCPSocket* pListener, SockAddr* pSockAddr, SocketHandle newSock);
+	virtual void          TCP_OnConnected(TCPSocket* pSocket);
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Socket.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,238 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Socket.h
+Content     :   Socket common data shared between all platforms.
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Socket_h
+#define OVR_Socket_h
+
+#include "../Kernel/OVR_Types.h"
+#include "../Kernel/OVR_Timer.h"
+#include "../Kernel/OVR_Allocator.h"
+#include "../Kernel/OVR_RefCount.h"
+#include "../Kernel/OVR_String.h"
+
+// OS-specific socket headers
+#if defined(OVR_OS_WIN32)
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#else
+# include <unistd.h>
+# include <sys/types.h>
+# include <netinet/in.h>
+#ifdef OVR_OS_ANDROID
+#include <sys/socket.h>
+#endif
+#endif
+
+namespace OVR { namespace Net {
+
+class SockAddr;
+class UDPSocket;
+class TCPSocket;
+
+
+//-----------------------------------------------------------------------------
+// Portable numeric Socket handle
+#if defined(OVR_OS_WIN32)
+typedef SOCKET SocketHandle;
+#else
+typedef int SocketHandle;
+static const SocketHandle INVALID_SOCKET = -1;
+static const int SOCKET_ERROR = -1;
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Types of network transport
+enum TransportType
+{
+	TransportType_None,          // No transport (useful placeholder for invalid states)
+	TransportType_Loopback,      // Loopback transport: Class talks to itself
+	TransportType_TCP,           // TCP/IPv4/v6
+	TransportType_UDP,           // UDP/IPv4/v6
+	TransportType_PacketizedTCP  // Packetized TCP: Message framing is automatic
+};
+
+
+//-----------------------------------------------------------------------------
+// Abstraction for a network socket. Inheritance hierarchy
+// modeled after RakNet so that future support can be added
+// for Linux, Windows RT, consoles, etc.
+class Socket : public RefCountBase<Socket>
+{
+public:
+	Socket();
+	virtual void Close() = 0;
+
+public:
+	TransportType Transport; // Type of transport
+};
+
+
+//-----------------------------------------------------------------------------
+// Bind parameters for Berkley sockets
+struct BerkleyBindParameters
+{
+public:
+	BerkleyBindParameters();
+
+public:
+	uint16_t Port;     // Port
+	String Address;
+    uint32_t blockingTimeout;
+};
+
+
+//-----------------------------------------------------------------------------
+// Berkley socket
+class BerkleySocket : public Socket
+{
+public:
+	BerkleySocket();
+	virtual ~BerkleySocket();
+
+	virtual void   Close();
+	virtual int32_t GetSockname(SockAddr* pSockAddrOut);
+	virtual void   SetBlockingTimeout(int timeoutMs) // milliseconds
+	{
+        TimeoutSec = timeoutMs / 1000;
+        TimeoutUsec = (timeoutMs % 1000) * 1000;
+	}
+    int            GetBlockingTimeoutUsec() const
+    {
+        return TimeoutUsec;
+    }
+    int            GetBlockingTimeoutSec() const
+    {
+        return TimeoutSec;
+    }
+    SocketHandle   GetSocketHandle() const
+    {
+        return TheSocket;
+    }
+
+protected:
+	SocketHandle TheSocket;           // Socket handle
+    int TimeoutUsec, TimeoutSec;
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP socket events
+class SocketEvent_UDP
+{
+public:
+	virtual void UDP_OnRecv(Socket* pSocket, uint8_t* pData,
+							uint32_t bytesRead, SockAddr* pSockAddr)
+	{
+		OVR_UNUSED4(pSocket, pData, bytesRead, pSockAddr);
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP socket events
+class SocketEvent_TCP
+{
+public:
+	virtual void TCP_OnRecv     (Socket* pSocket,
+                                 uint8_t* pData,
+                                 int bytesRead)
+	{
+		OVR_UNUSED3(pSocket, pData, bytesRead);
+	}
+	virtual void TCP_OnClosed   (TCPSocket* pSocket)
+	{
+		OVR_UNUSED(pSocket);
+	}
+	virtual void TCP_OnAccept   (TCPSocket* pListener,
+                                 SockAddr* pSockAddr,
+								 SocketHandle newSock)
+	{
+		OVR_UNUSED3(pListener, pSockAddr, newSock);
+	}
+	virtual void TCP_OnConnected(TCPSocket* pSocket)
+	{
+		OVR_UNUSED(pSocket);
+	}
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP Berkley socket
+
+// Base class for UDP sockets, code shared between platforms
+class UDPSocketBase : public BerkleySocket
+{
+public:
+	UDPSocketBase();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters) = 0;
+	virtual int          Send(const void* pData,
+                              int bytes,
+                              SockAddr* pSockAddr) = 0;
+	virtual void         Poll(SocketEvent_UDP* eventHandler) = 0;
+
+protected:
+	virtual void         OnRecv(SocketEvent_UDP* eventHandler,
+                                uint8_t* pData,
+								int bytesRead,
+                                SockAddr* address) = 0;
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Berkley socket
+
+// Base class for TCP sockets, code shared between platforms
+class TCPSocketBase : public BerkleySocket
+{
+public:
+	TCPSocketBase();
+	TCPSocketBase(SocketHandle handle);
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters) = 0;
+	virtual int          Listen() = 0;
+	virtual int          Connect(SockAddr* pSockAddr) = 0;
+	virtual int          Send(const void* pData,
+                              int bytes) = 0;
+protected:
+	virtual void         OnRecv(SocketEvent_TCP* eventHandler,
+                                uint8_t* pData,
+                                int bytesRead) = 0;
+
+protected:
+	bool IsListenSocket; // Is the socket listening (acting as a server)?
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Net/OVR_Win32_Socket.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,151 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_Win32_Socket.h
+Content     :   Windows-specific socket-based networking implementation
+Created     :   June 10, 2014
+Authors     :   Kevin Jenkins
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Win32_Socket_h
+#define OVR_Win32_Socket_h
+
+#include "OVR_Socket.h"
+#include "OVR_BitStream.h"
+
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <io.h>
+
+namespace OVR { namespace Net { 
+
+
+//-----------------------------------------------------------------------------
+// SockAddr
+
+// Abstraction for IPV6 socket address, with various convenience functions
+class SockAddr
+{
+public:
+	SockAddr();
+	SockAddr(SockAddr* sa);
+	SockAddr(sockaddr_storage* sa);
+	SockAddr(sockaddr_in6* sa);
+	SockAddr(const char* hostAddress, uint16_t port, int sockType);
+
+public:
+	void   Set(const sockaddr_storage* sa);
+	void   Set(const sockaddr_in6* sa);
+	void   Set(const char* hostAddress, uint16_t port, int sockType); // SOCK_DGRAM or SOCK_STREAM
+
+	uint16_t GetPort();
+
+	String ToString(bool writePort, char portDelineator) const;
+    bool IsLocalhost() const;
+
+	void   Serialize(BitStream* bs);
+	bool   Deserialize(BitStream);
+
+	bool   operator==( const SockAddr& right ) const;
+	bool   operator!=( const SockAddr& right ) const;
+	bool   operator >( const SockAddr& right ) const;
+	bool   operator <( const SockAddr& right ) const;
+
+public:
+	sockaddr_in6 Addr6;
+};
+
+
+//-----------------------------------------------------------------------------
+// UDP Socket
+
+// Windows version of TCP socket
+class UDPSocket : public UDPSocketBase
+{
+public:
+	UDPSocket();
+	virtual ~UDPSocket();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters);
+	virtual int          Send(const void* pData, int bytes, SockAddr* address);
+	virtual void         Poll(SocketEvent_UDP* eventHandler);
+
+protected:
+	static const int RecvBufSize = 1048576;
+	uint8_t* RecvBuf;
+
+	virtual void         OnRecv(SocketEvent_UDP* eventHandler, uint8_t* pData,
+								int bytesRead, SockAddr* address);
+};
+
+
+//-----------------------------------------------------------------------------
+// TCP Socket
+
+// Windows version of TCP socket
+class TCPSocket : public TCPSocketBase
+{
+    friend class TCPSocketPollState;
+
+public:
+	TCPSocket();
+	TCPSocket(SocketHandle boundHandle, bool isListenSocket);
+	virtual ~TCPSocket();
+
+public:
+	virtual SocketHandle Bind(BerkleyBindParameters* pBindParameters);
+	virtual int          Listen();
+	virtual int          Connect(SockAddr* address);
+	virtual int          Send(const void* pData, int bytes);
+
+protected:
+	virtual void         OnRecv(SocketEvent_TCP* eventHandler, uint8_t* pData,
+								int bytesRead);
+
+public:
+	bool IsConnecting; // Is in the process of connecting?
+};
+
+
+//-----------------------------------------------------------------------------
+// TCPSocketPollState
+
+// Polls multiple blocking TCP sockets at once
+class TCPSocketPollState
+{
+    fd_set readFD, exceptionFD, writeFD;
+    SocketHandle largestDescriptor;
+
+public:
+    TCPSocketPollState();
+    bool IsValid() const;
+    void Add(TCPSocket* tcpSocket);
+    bool Poll(long usec = 30000, long seconds = 0);
+    void HandleEvent(TCPSocket* tcpSocket, SocketEvent_TCP* eventHandler);
+};
+
+
+}} // OVR::Net
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,932 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI.h
+Content     :   C Interface to Oculus tracking and rendering.
+Created     :   November 23, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+/// @file OVR_CAPI.h
+/// Exposes all general Rift functionality.
+/// 
+/// @mainpage Overview
+/// Welcome to the Oculus SDK Reference Manual. All SDK functionality is exposed through a simple and portable C API, found in OVR_CAPI.h.
+///
+/// Please see the Oculus Developer Guide for detailed information about using the SDK in your native applications.
+
+#ifndef OVR_CAPI_h
+#define OVR_CAPI_h
+
+#include <stdint.h>
+
+typedef char ovrBool;
+
+//-----------------------------------------------------------------------------------
+// ***** OVR_EXPORT definition
+
+#if !defined(OVR_EXPORT)
+    #ifdef OVR_OS_WIN32
+        #define OVR_EXPORT __declspec(dllexport)        
+    #else
+        #define OVR_EXPORT
+    #endif
+#endif
+
+//#define ENABLE_LATENCY_TESTER
+
+//-----------------------------------------------------------------------------------
+// ***** Simple Math Structures
+
+/// A 2D vector with integer components.
+typedef struct ovrVector2i_
+{
+    int x, y;
+} ovrVector2i;
+/// A 2D size with integer components.
+typedef struct ovrSizei_
+{
+    int w, h;
+} ovrSizei;
+/// A 2D rectangle with a position and size.
+/// All components are integers.
+typedef struct ovrRecti_
+{
+    ovrVector2i Pos;
+    ovrSizei    Size;
+} ovrRecti;
+
+/// A quaternion rotation.
+typedef struct ovrQuatf_
+{
+    float x, y, z, w;  
+} ovrQuatf;
+/// A 2D vector with float components.
+typedef struct ovrVector2f_
+{
+    float x, y;
+} ovrVector2f;
+/// A 3D vector with float components.
+typedef struct ovrVector3f_
+{
+    float x, y, z;
+} ovrVector3f;
+/// A 4x4 matrix with float elements.
+typedef struct ovrMatrix4f_
+{
+    float M[4][4];
+} ovrMatrix4f;
+/// Position and orientation together.
+typedef struct ovrPosef_
+{
+    ovrQuatf     Orientation;
+    ovrVector3f  Position;    
+} ovrPosef;
+
+/// A full pose (rigid body) configuration with first and second derivatives.
+typedef struct ovrPoseStatef_
+{
+    ovrPosef     ThePose;
+    ovrVector3f  AngularVelocity;
+    ovrVector3f  LinearVelocity;
+    ovrVector3f  AngularAcceleration;
+    ovrVector3f  LinearAcceleration;
+    double       TimeInSeconds;         // Absolute time of this state sample.
+} ovrPoseStatef;
+
+/// Field Of View (FOV) in tangent of the angle units.
+/// As an example, for a standard 90 degree vertical FOV, we would 
+/// have: { UpTan = tan(90 degrees / 2), DownTan = tan(90 degrees / 2) }.
+typedef struct ovrFovPort_
+{
+    /// The tangent of the angle between the viewing vector and the top edge of the field of view.
+    float UpTan;
+    /// The tangent of the angle between the viewing vector and the bottom edge of the field of view.
+    float DownTan;
+    /// The tangent of the angle between the viewing vector and the left edge of the field of view.
+    float LeftTan;
+    /// The tangent of the angle between the viewing vector and the right edge of the field of view.
+    float RightTan;
+} ovrFovPort;
+
+
+//-----------------------------------------------------------------------------------
+// ***** HMD Types
+
+/// Enumerates all HMD types that we support.
+typedef enum
+{
+    ovrHmd_None             = 0,    
+    ovrHmd_DK1              = 3,
+    ovrHmd_DKHD             = 4,    
+    ovrHmd_DK2              = 6,
+    ovrHmd_Other             // Some HMD other then the one in the enumeration.
+} ovrHmdType;
+
+/// HMD capability bits reported by device.
+typedef enum
+{
+    // Read-only flags.
+    ovrHmdCap_Present           = 0x0001,   ///  The HMD is plugged in and detected by the system.
+    ovrHmdCap_Available         = 0x0002,   ///  The HMD and its sensor is available for ownership use.
+											///  i.e. it is not already owned by another application.
+    ovrHmdCap_Captured          = 0x0004,   ///  Set to 'true' if we captured ownership of this HMD.
+
+    // These flags are intended for use with the new driver display mode.
+    ovrHmdCap_ExtendDesktop     = 0x0008,   /// (read only) Means the display driver is in compatibility mode.
+
+    // Modifiable flags (through ovrHmd_SetEnabledCaps).
+    ovrHmdCap_NoMirrorToWindow  = 0x2000,   /// Disables mirroring of HMD output to the window. This may improve 
+											/// rendering performance slightly (only if 'ExtendDesktop' is off).
+    ovrHmdCap_DisplayOff        = 0x0040,   /// Turns off HMD screen and output (only if 'ExtendDesktop' is off).
+
+    ovrHmdCap_LowPersistence    = 0x0080,   ///  HMD supports low persistence mode.
+    ovrHmdCap_DynamicPrediction = 0x0200,   ///  Adjust prediction dynamically based on internally measured latency.
+    /// Support rendering without VSync for debugging.
+    ovrHmdCap_NoVSync           = 0x1000,
+
+    // These bits can be modified by ovrHmd_SetEnabledCaps.
+    ovrHmdCap_Writable_Mask     = 0x33F0,
+    /// These flags are currently passed into the service. May change without notice.
+    ovrHmdCap_Service_Mask      = 0x23F0
+} ovrHmdCaps;
+
+
+/// Tracking capability bits reported by the device.
+/// Used with ovrHmd_ConfigureTracking.
+typedef enum
+{
+    ovrTrackingCap_Orientation      = 0x0010,   ///  Supports orientation tracking (IMU).
+    ovrTrackingCap_MagYawCorrection = 0x0020,   ///  Supports yaw drift correction via a magnetometer or other means.
+    ovrTrackingCap_Position         = 0x0040,   ///  Supports positional tracking.
+    ///  Overrides the other flags. Indicates that the application
+    ///  doesn't care about tracking settings. This is the internal
+    ///  default before ovrHmd_ConfigureTracking is called.
+    ovrTrackingCap_Idle             = 0x0100,
+} ovrTrackingCaps;
+
+/// Distortion capability bits reported by device.
+/// Used with ovrHmd_ConfigureRendering and ovrHmd_CreateDistortionMesh.
+typedef enum
+{        
+    ovrDistortionCap_Chromatic	    = 0x01,		///	Supports chromatic aberration correction.
+    ovrDistortionCap_TimeWarp	    = 0x02,		///	Supports timewarp.
+    ovrDistortionCap_Vignette	    = 0x08,		///	Supports vignetting around the edges of the view.
+    ovrDistortionCap_NoRestore      = 0x10,		///  Do not save and restore the graphics state when rendering distortion.
+    ovrDistortionCap_FlipInput      = 0x20,		///  Flip the vertical texture coordinate of input images.
+    ovrDistortionCap_SRGB           = 0x40,		///  Assume input images are in sRGB gamma-corrected color space.
+    ovrDistortionCap_Overdrive      = 0x80,		///  Overdrive brightness transitions to reduce artifacts on DK2+ displays
+    ovrDistortionCap_HqDistortion   = 0x100,	/// High-quality sampling of distortion buffer for anti-aliasing
+
+    ovrDistortionCap_ProfileNoTimewarpSpinWaits = 0x10000,  /// Use when profiling with timewarp to remove false positives
+} ovrDistortionCaps;
+
+
+/// Specifies which eye is being used for rendering.
+/// This type explicitly does not include a third "NoStereo" option, as such is
+/// not required for an HMD-centered API.
+typedef enum
+{
+    ovrEye_Left  = 0,
+    ovrEye_Right = 1,
+    ovrEye_Count = 2
+} ovrEyeType;
+
+
+
+/// This is a complete descriptor of the HMD.
+typedef struct ovrHmdDesc_
+{
+    /// Internal handle of this HMD.
+    struct ovrHmdStruct* Handle;
+
+    /// This HMD's type.
+    ovrHmdType  Type;
+    
+    /// Name string describing the product: "Oculus Rift DK1", etc.
+    const char* ProductName;    
+    const char* Manufacturer;
+    
+    /// HID Vendor and ProductId of the device.
+    short       VendorId;
+    short       ProductId;
+    /// Sensor (and display) serial number.
+    char        SerialNumber[24];
+    /// Sensor firmware version.
+    short       FirmwareMajor;
+    short       FirmwareMinor;
+    /// External tracking camera frustum dimensions (if present).
+    float       CameraFrustumHFovInRadians;
+    float       CameraFrustumVFovInRadians;
+    float       CameraFrustumNearZInMeters;
+    float       CameraFrustumFarZInMeters;
+
+    /// Capability bits described by ovrHmdCaps.
+    unsigned int HmdCaps;
+	/// Capability bits described by ovrTrackingCaps.
+    unsigned int TrackingCaps;
+    /// Capability bits described by ovrDistortionCaps.
+    unsigned int DistortionCaps;
+
+    /// These define the recommended and maximum optical FOVs for the HMD.    
+    ovrFovPort  DefaultEyeFov[ovrEye_Count];
+    ovrFovPort  MaxEyeFov[ovrEye_Count];
+
+    /// Preferred eye rendering order for best performance.
+    /// Can help reduce latency on sideways-scanned screens.
+    ovrEyeType  EyeRenderOrder[ovrEye_Count];
+
+    /// Resolution of the full HMD screen (both eyes) in pixels.
+    ovrSizei    Resolution;
+    /// Location of the application window on the desktop (or 0,0).
+    ovrVector2i WindowsPos;     
+
+    /// Display that the HMD should present on.
+    /// TBD: It may be good to remove this information relying on WindowPos instead.
+    /// Ultimately, we may need to come up with a more convenient alternative,
+    /// such as API-specific functions that return adapter, or something that will
+    /// work with our monitor driver.
+    /// Windows: (e.g. "\\\\.\\DISPLAY3", can be used in EnumDisplaySettings/CreateDC).
+    const char* DisplayDeviceName;
+    /// MacOS:
+    int         DisplayId;
+  
+} ovrHmdDesc;
+
+
+/// Simple type ovrHmd is used in ovrHmd_* calls.
+typedef const ovrHmdDesc * ovrHmd;
+
+
+
+/// Bit flags describing the current status of sensor tracking.
+typedef enum
+{
+    ovrStatus_OrientationTracked    = 0x0001,   /// Orientation is currently tracked (connected and in use).
+    ovrStatus_PositionTracked       = 0x0002,   /// Position is currently tracked (false if out of range).
+    ovrStatus_CameraPoseTracked     = 0x0004,   /// Camera pose is currently tracked.
+    ovrStatus_PositionConnected     = 0x0020,   /// Position tracking hardware is connected.
+    ovrStatus_HmdConnected          = 0x0080    /// HMD Display is available and connected.
+} ovrStatusBits;
+
+/// Specifies a reading we can query from the sensor.
+typedef struct ovrSensorData_
+{
+    ovrVector3f    Accelerometer;    /// Acceleration reading in m/s^2.
+    ovrVector3f    Gyro;             /// Rotation rate in rad/s.
+    ovrVector3f    Magnetometer;     /// Magnetic field in Gauss.
+    float          Temperature;      /// Temperature of the sensor in degrees Celsius.
+    float          TimeInSeconds;    /// Time when the reported IMU reading took place, in seconds.
+} ovrSensorData;
+
+
+/// Tracking state at a given absolute time (describes predicted HMD pose etc).
+/// Returned by ovrHmd_GetTrackingState.
+typedef struct ovrTrackingState_
+{
+    /// Predicted head pose (and derivatives) at the requested absolute time.
+    /// The look-ahead interval is equal to (HeadPose.TimeInSeconds - RawSensorData.TimeInSeconds).
+    ovrPoseStatef  HeadPose;
+
+    /// Current pose of the external camera (if present).
+    /// This pose includes camera tilt (roll and pitch). For a leveled coordinate
+    /// system use LeveledCameraPose.
+    ovrPosef       CameraPose;
+
+    /// Camera frame aligned with gravity.
+    /// This value includes position and yaw of the camera, but not roll and pitch.
+    /// It can be used as a reference point to render real-world objects in the correct location.
+    ovrPosef       LeveledCameraPose;
+
+    /// The most recent sensor data received from the HMD.
+    ovrSensorData  RawSensorData;
+
+    /// Tracking status described by ovrStatusBits.
+    unsigned int   StatusFlags;
+
+    //// 0.4.1
+
+    /// Time spent processing the last vision frame
+    double         LastVisionProcessingTime;
+} ovrTrackingState;
+
+
+/// Frame timing data reported by ovrHmd_BeginFrameTiming() or ovrHmd_BeginFrame().
+typedef struct ovrFrameTiming_
+{
+    /// The amount of time that has passed since the previous frame's
+	/// ThisFrameSeconds value (usable for movement scaling).
+    /// This will be clamped to no more than 0.1 seconds to prevent
+    /// excessive movement after pauses due to loading or initialization.
+    float			DeltaSeconds;
+
+    /// It is generally expected that the following holds:
+    /// ThisFrameSeconds < TimewarpPointSeconds < NextFrameSeconds < 
+    /// EyeScanoutSeconds[EyeOrder[0]] <= ScanoutMidpointSeconds <= EyeScanoutSeconds[EyeOrder[1]].
+
+    /// Absolute time value when rendering of this frame began or is expected to
+    /// begin. Generally equal to NextFrameSeconds of the previous frame. Can be used
+    /// for animation timing.
+    double			ThisFrameSeconds;
+    /// Absolute point when IMU expects to be sampled for this frame.
+    double			TimewarpPointSeconds;
+    /// Absolute time when frame Present followed by GPU Flush will finish and the next frame begins.
+    double			NextFrameSeconds;
+
+    /// Time when when half of the screen will be scanned out. Can be passed as an absolute time
+	/// to ovrHmd_GetTrackingState() to get the predicted general orientation.
+    double		    ScanoutMidpointSeconds;
+    /// Timing points when each eye will be scanned out to display. Used when rendering each eye.
+    double			EyeScanoutSeconds[2];    
+} ovrFrameTiming;
+
+
+
+/// Rendering information for each eye. Computed by either ovrHmd_ConfigureRendering()
+/// or ovrHmd_GetRenderDesc() based on the specified FOV. Note that the rendering viewport 
+/// is not included here as it can be specified separately and modified per frame through:
+///    (a) ovrHmd_GetRenderScaleAndOffset in the case of client rendered distortion,
+/// or (b) passing different values via ovrTexture in the case of SDK rendered distortion.
+typedef struct ovrEyeRenderDesc_
+{    
+    ovrEyeType  Eye;
+    ovrFovPort  Fov;
+	ovrRecti	DistortedViewport; 	        /// Distortion viewport.
+    ovrVector2f PixelsPerTanAngleAtCenter;  /// How many display pixels will fit in tan(angle) = 1.
+    ovrVector3f ViewAdjust;  		        /// Translation to be applied to view matrix.
+} ovrEyeRenderDesc;
+
+
+//-----------------------------------------------------------------------------------
+// ***** Platform-independent Rendering Configuration
+
+/// These types are used to hide platform-specific details when passing
+/// render device, OS, and texture data to the API.
+///
+/// The benefit of having these wrappers versus platform-specific API functions is
+/// that they allow game glue code to be portable. A typical example is an
+/// engine that has multiple back ends, say GL and D3D. Portable code that calls
+/// these back ends may also use LibOVR. To do this, back ends can be modified
+/// to return portable types such as ovrTexture and ovrRenderAPIConfig.
+typedef enum
+{
+    ovrRenderAPI_None,
+    ovrRenderAPI_OpenGL,
+    ovrRenderAPI_Android_GLES,  // May include extra native window pointers, etc.
+    ovrRenderAPI_D3D9,
+    ovrRenderAPI_D3D10,
+    ovrRenderAPI_D3D11,
+    ovrRenderAPI_Count
+} ovrRenderAPIType;
+
+/// Platform-independent part of rendering API-configuration data.
+/// It is a part of ovrRenderAPIConfig, passed to ovrHmd_Configure.
+typedef struct ovrRenderAPIConfigHeader_
+{
+    ovrRenderAPIType API;
+    ovrSizei         RTSize;
+    int              Multisample;
+} ovrRenderAPIConfigHeader;
+
+/// Contains platform-specific information for rendering.
+typedef struct ovrRenderAPIConfig_
+{
+    ovrRenderAPIConfigHeader Header;
+    uintptr_t                PlatformData[8];
+} ovrRenderAPIConfig;
+
+/// Platform-independent part of the eye texture descriptor.
+/// It is a part of ovrTexture, passed to ovrHmd_EndFrame.
+/// If RenderViewport is all zeros then the full texture will be used.
+typedef struct ovrTextureHeader_
+{
+    ovrRenderAPIType API;
+    ovrSizei         TextureSize;
+    ovrRecti         RenderViewport;  // Pixel viewport in texture that holds eye image.
+} ovrTextureHeader;
+
+/// Contains platform-specific information about a texture.
+typedef struct ovrTexture_
+{
+    ovrTextureHeader Header;
+    uintptr_t        PlatformData[8];
+} ovrTexture;
+
+
+// -----------------------------------------------------------------------------------
+// ***** API Interfaces
+
+// Basic steps to use the API:
+//
+// Setup:
+//  1. ovrInitialize()
+//  2. ovrHMD hmd = ovrHmd_Create(0)
+//  3. Use hmd members and ovrHmd_GetFovTextureSize() to determine graphics configuration.
+//  4. Call ovrHmd_ConfigureTracking() to configure and initialize tracking.
+//  5. Call ovrHmd_ConfigureRendering() to setup graphics for SDK rendering,
+//     which is the preferred approach.
+//     Please refer to "Client Distorton Rendering" below if you prefer to do that instead.
+//  6. If the ovrHmdCap_ExtendDesktop flag is not set, then use ovrHmd_AttachToWindow to 
+//     associate the relevant application window with the hmd.
+//  5. Allocate render target textures as needed.
+//
+// Game Loop:
+//  6. Call ovrHmd_BeginFrame() to get the current frame timing information.
+//  7. Render each eye using ovrHmd_GetEyePose to get the predicted head pose.
+//  8. Call ovrHmd_EndFrame() to render the distorted textures to the back buffer
+//     and present them on the hmd.
+//
+// Shutdown:
+//  9. ovrHmd_Destroy(hmd)
+//  10. ovr_Shutdown()
+//
+
+#ifdef __cplusplus 
+extern "C" {
+#endif
+
+// ovr_InitializeRenderingShim initializes the rendering shim appart from everything
+// else in LibOVR. This may be helpful if the application prefers to avoid
+// creating any OVR resources (allocations, service connections, etc) at this point.
+// ovr_InitializeRenderingShim does not bring up anything within LibOVR except the
+// necessary hooks to enable the Direct-to-Rift functionality.
+//
+// Either ovr_InitializeRenderingShim() or ovr_Initialize() must be called before any
+// Direct3D or OpenGL initilization is done by applictaion (creation of devices, etc).
+// ovr_Initialize() must still be called after to use the rest of LibOVR APIs.
+OVR_EXPORT void     ovr_InitializeRenderingShim();
+
+// Library init/shutdown, must be called around all other OVR code.
+// No other functions calls besides ovr_InitializeRenderingShim are allowed
+// before ovr_Initialize succeeds or after ovr_Shutdown.
+/// Initializes all Oculus functionality.
+OVR_EXPORT ovrBool  ovr_Initialize();
+/// Shuts down all Oculus functionality.
+OVR_EXPORT void     ovr_Shutdown();
+
+/// Returns version string representing libOVR version. Static, so
+/// string remains valid for app lifespan
+OVR_EXPORT const char* ovr_GetVersionString();
+
+
+
+/// Detects or re-detects HMDs and reports the total number detected.
+/// Users can get information about each HMD by calling ovrHmd_Create with an index.
+OVR_EXPORT int      ovrHmd_Detect();
+
+
+/// Creates a handle to an HMD which doubles as a description structure.
+/// Index can [0 .. ovrHmd_Detect()-1]. Index mappings can cange after each ovrHmd_Detect call.
+/// If not null, then the returned handle must be freed with ovrHmd_Destroy.
+OVR_EXPORT ovrHmd   ovrHmd_Create(int index);
+OVR_EXPORT void     ovrHmd_Destroy(ovrHmd hmd);
+
+/// Creates a 'fake' HMD used for debugging only. This is not tied to specific hardware,
+/// but may be used to debug some of the related rendering.
+OVR_EXPORT ovrHmd   ovrHmd_CreateDebug(ovrHmdType type);
+
+
+/// Returns last error for HMD state. Returns null for no error.
+/// String is valid until next call or GetLastError or HMD is destroyed.
+/// Pass null hmd to get global errors (during create etc).
+OVR_EXPORT const char* ovrHmd_GetLastError(ovrHmd hmd);
+
+/// Platform specific function to specify the application window whose output will be 
+/// displayed on the HMD. Only used if the ovrHmdCap_ExtendDesktop flag is false.
+///   Windows: SwapChain associated with this window will be displayed on the HMD.
+///            Specify 'destMirrorRect' in window coordinates to indicate an area
+///            of the render target output that will be mirrored from 'sourceRenderTargetRect'.
+///            Null pointers mean "full size".
+/// @note Source and dest mirror rects are not yet implemented.
+OVR_EXPORT ovrBool ovrHmd_AttachToWindow(ovrHmd hmd, void* window,
+										 const ovrRecti* destMirrorRect,
+										 const ovrRecti* sourceRenderTargetRect);
+
+//-------------------------------------------------------------------------------------
+
+/// Returns capability bits that are enabled at this time as described by ovrHmdCaps.
+/// Note that this value is different font ovrHmdDesc::HmdCaps, which describes what
+/// capabilities are available for that HMD.
+OVR_EXPORT unsigned int ovrHmd_GetEnabledCaps(ovrHmd hmd);
+
+/// Modifies capability bits described by ovrHmdCaps that can be modified,
+/// such as ovrHmd_LowPersistance.
+OVR_EXPORT void         ovrHmd_SetEnabledCaps(ovrHmd hmd, unsigned int hmdCaps);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Tracking Interface
+
+/// All tracking interface functions are thread-safe, allowing tracking state to be sampled
+/// from different threads.
+/// ConfigureTracking starts sensor sampling, enabling specified capabilities,
+///    described by ovrTrackingCaps.
+///  - supportedTrackingCaps specifies support that is requested. The function will succeed 
+///	  even if these caps are not available (i.e. sensor or camera is unplugged). Support
+///    will automatically be enabled if such device is plugged in later. Software should
+///    check ovrTrackingState.StatusFlags for real-time status.
+///  - requiredTrackingCaps specify sensor capabilities required at the time of the call.
+///    If they are not available, the function will fail. Pass 0 if only specifying
+///    supportedTrackingCaps.
+///  - Pass 0 for both supportedTrackingCaps and requiredTrackingCaps to disable tracking.
+OVR_EXPORT ovrBool  ovrHmd_ConfigureTracking(ovrHmd hmd, unsigned int supportedTrackingCaps,
+													     unsigned int requiredTrackingCaps);
+
+/// Re-centers the sensor orientation.
+/// Normally this will recenter the (x,y,z) translational components and the yaw 
+/// component of orientation.
+OVR_EXPORT void     ovrHmd_RecenterPose(ovrHmd hmd);
+
+/// Returns tracking state reading based on the specified absolute system time.
+/// Pass an absTime value of 0.0 to request the most recent sensor reading. In this case
+/// both PredictedPose and SamplePose will have the same value.
+/// ovrHmd_GetEyePose relies on this internally.
+/// This may also be used for more refined timing of FrontBuffer rendering logic, etc.
+OVR_EXPORT ovrTrackingState ovrHmd_GetTrackingState(ovrHmd hmd, double absTime);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Graphics Setup
+
+
+/// Calculates the recommended texture size for rendering a given eye within the HMD
+/// with a given FOV cone. Higher FOV will generally require larger textures to 
+/// maintain quality.
+///  - pixelsPerDisplayPixel specifies the ratio of the number of render target pixels 
+///    to display pixels at the center of distortion. 1.0 is the default value. Lower
+///    values can improve performance.
+OVR_EXPORT ovrSizei ovrHmd_GetFovTextureSize(ovrHmd hmd, ovrEyeType eye, ovrFovPort fov,
+                                             float pixelsPerDisplayPixel);
+
+
+
+//-------------------------------------------------------------------------------------
+// *****  Rendering API Thread Safety
+
+//  All of rendering functions including the configure and frame functions
+// are *NOT thread safe*. It is ok to use ConfigureRendering on one thread and handle
+//  frames on another thread, but explicit synchronization must be done since
+//  functions that depend on configured state are not reentrant.
+//
+//  As an extra requirement, any of the following calls must be done on
+//  the render thread, which is the same thread that calls ovrHmd_BeginFrame
+//  or ovrHmd_BeginFrameTiming.
+//    - ovrHmd_EndFrame
+//    - ovrHmd_GetEyePose
+//    - ovrHmd_GetEyeTimewarpMatrices
+
+
+//-------------------------------------------------------------------------------------
+// *****  SDK Distortion Rendering Functions
+
+// These functions support rendering of distortion by the SDK through direct
+// access to the underlying rendering API, such as D3D or GL.
+// This is the recommended approach since it allows better support for future
+// Oculus hardware, and enables a range of low-level optimizations.
+
+
+/// Configures rendering and fills in computed render parameters.
+/// This function can be called multiple times to change rendering settings.
+/// eyeRenderDescOut is a pointer to an array of two ovrEyeRenderDesc structs
+/// that are used to return complete rendering information for each eye.
+///
+///  - apiConfig provides D3D/OpenGL specific parameters. Pass null
+///    to shutdown rendering and release all resources.
+///  - distortionCaps describe desired distortion settings.
+///
+OVR_EXPORT ovrBool ovrHmd_ConfigureRendering( ovrHmd hmd,
+                                              const ovrRenderAPIConfig* apiConfig,
+                                              unsigned int distortionCaps,
+                                              const ovrFovPort eyeFovIn[2],
+                                              ovrEyeRenderDesc eyeRenderDescOut[2] );
+
+
+/// Begins a frame, returning timing information.
+/// This should be called at the beginning of the game rendering loop (on the render thread).
+/// Pass 0 for the frame index if not using ovrHmd_GetFrameTiming.
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrame(ovrHmd hmd, unsigned int frameIndex);
+
+/// Ends a frame, submitting the rendered textures to the frame buffer.
+/// - RenderViewport within each eyeTexture can change per frame if necessary.
+/// - 'renderPose' will typically be the value returned from ovrHmd_GetEyePose, 
+///   but can be different if a different head pose was used for rendering.
+/// - This may perform distortion and scaling internally, assuming is it not 
+///   delegated to another thread. 
+/// - Must be called on the same thread as BeginFrame.
+/// - *** This Function will call Present/SwapBuffers and potentially wait for GPU Sync ***.
+OVR_EXPORT void     ovrHmd_EndFrame(ovrHmd hmd,
+                                    const ovrPosef renderPose[2],
+                                    const ovrTexture eyeTexture[2]);
+
+
+/// Returns the predicted head pose to use when rendering the specified eye.
+/// - Must be called between ovrHmd_BeginFrameTiming and ovrHmd_EndFrameTiming.
+/// - If the pose is used for rendering the eye, it should be passed to ovrHmd_EndFrame.
+OVR_EXPORT ovrPosef ovrHmd_GetEyePose(ovrHmd hmd, ovrEyeType eye);
+
+
+
+//-------------------------------------------------------------------------------------
+// *****  Client Distortion Rendering Functions
+
+// These functions provide the distortion data and render timing support necessary to allow
+// client rendering of distortion. Client-side rendering involves the following steps:
+//
+//  1. Setup ovrEyeDesc based on the desired texture size and FOV.
+//     Call ovrHmd_GetRenderDesc to get the necessary rendering parameters for each eye.
+// 
+//  2. Use ovrHmd_CreateDistortionMesh to generate the distortion mesh.
+//
+//  3. Use ovrHmd_BeginFrameTiming, ovrHmd_GetEyePose, and ovrHmd_BeginFrameTiming
+//     in the rendering loop to obtain timing and predicted head orientation when
+//     rendering each eye.
+//      - When using timewarp, use ovr_WaitTillTime after the rendering and gpu flush, followed
+//        by ovrHmd_GetEyeTimewarpMatrices to obtain the timewarp matrices used 
+//        by the distortion pixel shader. This will minimize latency.
+//
+
+/// Computes the distortion viewport, view adjust, and other rendering parameters for 
+/// the specified eye. This can be used instead of ovrHmd_ConfigureRendering to do 
+/// setup for client rendered distortion.
+OVR_EXPORT ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmd hmd,
+                                                 ovrEyeType eyeType, ovrFovPort fov);
+
+
+/// Describes a vertex used by the distortion mesh. This is intended to be converted into
+/// the engine-specific format. Some fields may be unused based on the ovrDistortionCaps 
+/// flags selected. TexG and TexB, for example, are not used if chromatic correction is 
+/// not requested.
+typedef struct ovrDistortionVertex_
+{
+    ovrVector2f ScreenPosNDC;    // [-1,+1],[-1,+1] over the entire framebuffer.
+    float       TimeWarpFactor;  // Lerp factor between time-warp matrices. Can be encoded in Pos.z.
+    float       VignetteFactor;  // Vignette fade factor. Can be encoded in Pos.w.
+    ovrVector2f TanEyeAnglesR;
+    ovrVector2f TanEyeAnglesG;
+    ovrVector2f TanEyeAnglesB;    
+} ovrDistortionVertex;
+
+/// Describes a full set of distortion mesh data, filled in by ovrHmd_CreateDistortionMesh.
+/// Contents of this data structure, if not null, should be freed by ovrHmd_DestroyDistortionMesh.
+typedef struct ovrDistortionMesh_
+{
+    ovrDistortionVertex* pVertexData;
+    unsigned short*      pIndexData;
+    unsigned int         VertexCount;
+    unsigned int         IndexCount;
+} ovrDistortionMesh;
+
+/// Generate distortion mesh per eye.
+/// Distortion capabilities will depend on 'distortionCaps' flags. Users should 
+/// render using the appropriate shaders based on their settings.
+/// Distortion mesh data will be allocated and written into the ovrDistortionMesh data structure,
+/// which should be explicitly freed with ovrHmd_DestroyDistortionMesh.
+/// Users should call ovrHmd_GetRenderScaleAndOffset to get uvScale and Offset values for rendering.
+/// The function shouldn't fail unless theres is a configuration or memory error, in which case
+/// ovrDistortionMesh values will be set to null.
+/// This is the only function in the SDK reliant on eye relief, currently imported from profiles, 
+/// or overriden here.
+OVR_EXPORT ovrBool  ovrHmd_CreateDistortionMesh( ovrHmd hmd,
+                                                 ovrEyeType eyeType, ovrFovPort fov,
+                                                 unsigned int distortionCaps,
+                                                 ovrDistortionMesh *meshData);
+
+/// Used to free the distortion mesh allocated by ovrHmd_GenerateDistortionMesh. meshData elements
+/// are set to null and zeroes after the call.
+OVR_EXPORT void     ovrHmd_DestroyDistortionMesh( ovrDistortionMesh* meshData );
+
+/// Computes updated 'uvScaleOffsetOut' to be used with a distortion if render target size or
+/// viewport changes after the fact. This can be used to adjust render size every frame if desired.
+OVR_EXPORT void     ovrHmd_GetRenderScaleAndOffset( ovrFovPort fov,
+                                                    ovrSizei textureSize, ovrRecti renderViewport,
+                                                    ovrVector2f uvScaleOffsetOut[2] );
+
+
+/// Thread-safe timing function for the main thread. Caller should increment frameIndex
+/// with every frame and pass the index where applicable to functions called on the 
+/// rendering thread.
+OVR_EXPORT ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+/// Called at the beginning of the frame on the rendering thread.
+/// Pass frameIndex == 0 if ovrHmd_GetFrameTiming isn't being used. Otherwise,
+/// pass the same frame index as was used for GetFrameTiming on the main thread.
+OVR_EXPORT ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+/// Marks the end of client distortion rendered frame, tracking the necessary timing information.
+/// This function must be called immediately after Present/SwapBuffers + GPU sync. GPU sync is
+/// important before this call to reduce latency and ensure proper timing.
+OVR_EXPORT void     ovrHmd_EndFrameTiming(ovrHmd hmd);
+
+/// Initializes and resets frame time tracking. This is typically not necessary, but
+/// is helpful if game changes vsync state or video mode. vsync is assumed to be on if this
+/// isn't called. Resets internal frame index to the specified number.
+OVR_EXPORT void     ovrHmd_ResetFrameTiming(ovrHmd hmd, unsigned int frameIndex);
+
+
+/// Computes timewarp matrices used by distortion mesh shader, these are used to adjust
+/// for head orientation change since the last call to ovrHmd_GetEyePose when rendering
+/// this eye. The ovrDistortionVertex::TimeWarpFactor is used to blend between the
+/// matrices, usually representing two different sides of the screen.
+/// Must be called on the same thread as ovrHmd_BeginFrameTiming.
+OVR_EXPORT void     ovrHmd_GetEyeTimewarpMatrices(ovrHmd hmd, ovrEyeType eye,
+                                                  ovrPosef renderPose, ovrMatrix4f twmOut[2]);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Stateless math setup functions
+
+/// Used to generate projection from ovrEyeDesc::Fov.
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_Projection( ovrFovPort fov,
+                                               float znear, float zfar, ovrBool rightHanded );
+
+/// Used for 2D rendering, Y is down
+/// orthoScale = 1.0f / pixelsPerTanAngleAtCenter
+/// orthoDistance = distance from camera, such as 0.8m
+OVR_EXPORT ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale,
+                                                      float orthoDistance, float eyeViewAdjustX);
+
+/// Returns global, absolute high-resolution time in seconds. This is the same
+/// value as used in sensor messages.
+OVR_EXPORT double   ovr_GetTimeInSeconds();
+
+/// Waits until the specified absolute time.
+OVR_EXPORT double   ovr_WaitTillTime(double absTime);
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** Latency Test interface
+
+/// Does latency test processing and returns 'TRUE' if specified rgb color should
+/// be used to clear the screen.
+OVR_EXPORT ovrBool      ovrHmd_ProcessLatencyTest(ovrHmd hmd, unsigned char rgbColorOut[3]);
+
+/// Returns non-null string once with latency test result, when it is available.
+/// Buffer is valid until next call.
+OVR_EXPORT const char*  ovrHmd_GetLatencyTestResult(ovrHmd hmd);
+
+/// Returns the latency testing color in rgbColorOut to render when using a DK2
+/// Returns false if this feature is disabled or not-applicable (e.g. using a DK1)
+OVR_EXPORT ovrBool      ovrHmd_GetLatencyTest2DrawColor(ovrHmd hmddesc, unsigned char rgbColorOut[3]);
+
+
+//-------------------------------------------------------------------------------------
+// ***** Health and Safety Warning Display interface
+//
+
+/// Used by ovrhmd_GetHSWDisplayState to report the current display state.
+typedef struct ovrHSWDisplayState_
+{
+    /// If true then the warning should be currently visible
+    /// and the following variables have meaning. Else there is no
+    /// warning being displayed for this application on the given HMD.
+    ovrBool Displayed;
+    double  StartTime;       /// Absolute time when the warning was first displayed. See ovr_GetTimeInSeconds().
+    double  DismissibleTime; /// Earliest absolute time when the warning can be dismissed. May be a time in the past.
+} ovrHSWDisplayState;
+
+/// Returns the current state of the HSW display. If the application is doing the rendering of
+/// the HSW display then this function serves to indicate that the the warning should be 
+/// currently displayed. If the application is using SDK-based eye rendering then the SDK by 
+/// default automatically handles the drawing of the HSW display. An application that uses 
+/// application-based eye rendering should use this function to know when to start drawing the
+/// HSW display itself and can optionally use it in conjunction with ovrhmd_DismissHSWDisplay
+/// as described below.
+///
+/// Example usage for application-based rendering:
+///    bool HSWDisplayCurrentlyDisplayed = false; // global or class member variable
+///    ovrHSWDisplayState hswDisplayState;
+///    ovrhmd_GetHSWDisplayState(Hmd, &hswDisplayState);
+///
+///    if (hswDisplayState.Displayed && !HSWDisplayCurrentlyDisplayed) {
+///        <insert model into the scene that stays in front of the user>
+///        HSWDisplayCurrentlyDisplayed = true;
+///    }
+OVR_EXPORT void ovrHmd_GetHSWDisplayState(ovrHmd hmd, ovrHSWDisplayState *hasWarningState);
+
+/// Dismisses the HSW display if the warning is dismissible and the earliest dismissal time 
+/// has occurred. Returns true if the display is valid and could be dismissed. The application 
+/// should recognize that the HSW display is being displayed (via ovrhmd_GetHSWDisplayState)
+/// and if so then call this function when the appropriate user input to dismiss the warning
+/// occurs.
+///
+/// Example usage :
+///    void ProcessEvent(int key) {
+///        if(key == escape) {
+///            ovrHSWDisplayState hswDisplayState;
+///            ovrhmd_GetHSWDisplayState(hmd, &hswDisplayState);
+///
+///            if(hswDisplayState.Displayed && ovrhmd_DismissHSWDisplay(hmd)) {
+///                <remove model from the scene>
+///                HSWDisplayCurrentlyDisplayed = false;
+///            }
+///        }
+///    }
+OVR_EXPORT ovrBool ovrHmd_DismissHSWDisplay(ovrHmd hmd);
+
+
+
+
+
+// -----------------------------------------------------------------------------------
+// ***** Property Access
+
+// NOTICE: This is experimental part of API that is likely to go away or change.
+
+// These allow accessing different properties of the HMD and profile.
+// Some of the properties may go away with profile/HMD versions, so software should
+// use defaults and/or proper fallbacks.
+// 
+
+// For now, access profile entries; this will change.
+#if !defined(OVR_KEY_USER)
+
+#define OVR_KEY_USER                        "User"
+#define OVR_KEY_NAME                        "Name"
+#define OVR_KEY_GENDER                      "Gender"
+#define OVR_KEY_PLAYER_HEIGHT               "PlayerHeight"
+#define OVR_KEY_EYE_HEIGHT                  "EyeHeight"
+#define OVR_KEY_IPD                         "IPD"
+#define OVR_KEY_NECK_TO_EYE_DISTANCE        "NeckEyeDistance"
+#define OVR_KEY_CAMERA_POSITION				"CenteredFromWorld"
+
+// TODO: remove this duplication with OVR_Profile.h
+// Default measurements empirically determined at Oculus to make us happy
+// The neck model numbers were derived as an average of the male and female averages from ANSUR-88
+// NECK_TO_EYE_HORIZONTAL = H22 - H43 = INFRAORBITALE_BACK_OF_HEAD - TRAGION_BACK_OF_HEAD
+// NECK_TO_EYE_VERTICAL = H21 - H15 = GONION_TOP_OF_HEAD - ECTOORBITALE_TOP_OF_HEAD
+// These were determined to be the best in a small user study, clearly beating out the previous default values
+#define OVR_DEFAULT_GENDER                  "Unknown"
+#define OVR_DEFAULT_PLAYER_HEIGHT           1.778f
+#define OVR_DEFAULT_EYE_HEIGHT              1.675f
+#define OVR_DEFAULT_IPD                     0.064f
+#define OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL  0.0805f
+#define OVR_DEFAULT_NECK_TO_EYE_VERTICAL    0.075f
+#define OVR_DEFAULT_EYE_RELIEF_DIAL         3
+#define OVR_DEFAULT_CAMERA_POSITION			{0,0,0,1,0,0,0}
+
+#endif
+
+/// Get boolean property. Returns first element if property is a boolean array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT ovrBool      ovrHmd_GetBool(ovrHmd hmd, const char* propertyName, ovrBool defaultVal);
+
+/// Modify bool property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetBool(ovrHmd hmd, const char* propertyName, ovrBool value);
+
+/// Get integer property. Returns first element if property is an integer array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT int          ovrHmd_GetInt(ovrHmd hmd, const char* propertyName, int defaultVal);
+
+/// Modify integer property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetInt(ovrHmd hmd, const char* propertyName, int value);
+
+/// Get float property. Returns first element if property is a float array.
+/// Returns defaultValue if property doesn't exist.
+OVR_EXPORT float        ovrHmd_GetFloat(ovrHmd hmd, const char* propertyName, float defaultVal);
+
+/// Modify float property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetFloat(ovrHmd hmd, const char* propertyName, float value);
+
+/// Get float[] property. Returns the number of elements filled in, 0 if property doesn't exist.
+/// Maximum of arraySize elements will be written.
+OVR_EXPORT unsigned int ovrHmd_GetFloatArray(ovrHmd hmd, const char* propertyName,
+                                            float values[], unsigned int arraySize);
+
+/// Modify float[] property; false if property doesn't exist or is readonly.
+OVR_EXPORT ovrBool      ovrHmd_SetFloatArray(ovrHmd hmd, const char* propertyName,
+                                             float values[], unsigned int arraySize);
+
+/// Get string property. Returns first element if property is a string array.
+/// Returns defaultValue if property doesn't exist.
+/// String memory is guaranteed to exist until next call to GetString or GetStringArray, or HMD is destroyed.
+OVR_EXPORT const char*  ovrHmd_GetString(ovrHmd hmd, const char* propertyName,
+                                        const char* defaultVal);
+
+/// Set string property
+OVR_EXPORT ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char* propertyName,
+                                    const char* value);
+
+#ifdef __cplusplus 
+} // extern "C"
+#endif
+
+
+#endif	// OVR_CAPI_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_D3D.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_D3D.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,171 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI_D3D.h
+Content     :   D3D specific structures used by the CAPI interface.
+Created     :   November 7, 2013
+Authors     :   Michael Antonov
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+#ifndef OVR_CAPI_D3D_h
+#define OVR_CAPI_D3D_h
+
+/// @file OVR_CAPI_D3D.h
+/// D3D rendering support.
+
+#include "OVR_CAPI.h"
+
+#ifndef OVR_D3D_VERSION
+#error Please define OVR_D3D_VERSION to 9 or 10 or 11 before including OVR_CAPI_D3D.h
+#endif
+
+
+#if defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 11)
+
+//-----------------------------------------------------------------------------------
+// ***** D3D11 Specific
+
+#include <d3d11.h>
+
+/// Used to configure slave D3D rendering (i.e. for devices created externally).
+struct ovrD3D11ConfigData
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+    /// The D3D device to use for rendering.
+	ID3D11Device*            pDevice;
+    /// The D3D device context to use for rendering.
+    ID3D11DeviceContext*     pDeviceContext;
+    /// A render target view for the backbuffer.
+    ID3D11RenderTargetView*  pBackBufferRT;
+    /// The swapchain that will present rendered frames.
+    IDXGISwapChain*          pSwapChain;
+};
+
+/// Contains D3D11-specific rendering information.
+union ovrD3D11Config
+{
+    /// General device settings.
+    ovrRenderAPIConfig Config;
+    /// D3D11-specific settings.
+    ovrD3D11ConfigData D3D11;
+};
+
+/// Used to pass D3D11 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D11TextureData
+{
+    /// General device settings.
+    ovrTextureHeader          Header;
+    /// The D3D11 texture containing the undistorted eye image.
+    ID3D11Texture2D*          pTexture;
+    /// The D3D11 shader resource view for this texture.
+    ID3D11ShaderResourceView* pSRView;
+};
+
+/// Contains OpenGL-specific texture information.
+union ovrD3D11Texture
+{
+    /// General device settings.
+    ovrTexture          Texture;
+    /// D3D11-specific settings.
+    ovrD3D11TextureData D3D11;
+};
+
+
+
+#elif defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 10)
+
+#include <d3d10_1.h>
+#include <d3d10.h>
+
+//-----------------------------------------------------------------------------------
+// ***** D3D10 Specific
+
+/// Used to configure slave D3D rendering (i.e. for devices created externally).
+struct ovrD3D10ConfigData
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+    ID3D10Device*            pDevice;
+    void*                    Unused;
+    ID3D10RenderTargetView*  pBackBufferRT;
+    IDXGISwapChain*          pSwapChain;
+};
+
+union ovrD3D10Config
+{
+    ovrRenderAPIConfig Config;
+    ovrD3D10ConfigData D3D10;
+};
+
+/// Used to pass D3D10 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D10TextureData
+{
+    /// General device settings.
+    ovrTextureHeader          Header;
+    ID3D10Texture2D*          pTexture;
+    ID3D10ShaderResourceView* pSRView;
+};
+
+union ovrD3D10Texture
+{
+    ovrTexture          Texture;
+    ovrD3D10TextureData D3D10;
+};
+
+#elif defined(OVR_D3D_VERSION) && (OVR_D3D_VERSION == 9)
+
+#include <d3d9.h>
+
+//-----------------------------------------------------------------------------------
+// ***** D3D9 Specific
+
+// Used to configure D3D9 rendering 
+struct ovrD3D9ConfigData
+{
+    // General device settings.
+    ovrRenderAPIConfigHeader Header;
+    
+	IDirect3DDevice9*           pDevice;
+    IDirect3DSwapChain9*        pSwapChain;
+};
+
+union ovrD3D9Config
+{
+    ovrRenderAPIConfig Config;
+    ovrD3D9ConfigData D3D9;
+};
+
+// Used to pass D3D9 eye texture data to ovrHmd_EndFrame.
+struct ovrD3D9TextureData
+{
+    // General device settings.
+    ovrTextureHeader            Header;
+    IDirect3DTexture9*          pTexture;  
+};
+
+union ovrD3D9Texture
+{
+    ovrTexture         Texture;
+    ovrD3D9TextureData D3D9;
+};
+
+#endif
+
+#endif	// OVR_CAPI_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_GL.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_CAPI_GL.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,87 @@
+/************************************************************************************
+
+Filename    :   OVR_CAPI_GL.h
+Content     :   GL specific structures used by the CAPI interface.
+Created     :   November 7, 2013
+Authors     :   Lee Cooper
+
+Copyright   :   Copyright 2013 Oculus VR, Inc. All Rights reserved.
+
+Use of this software is subject to the terms of the Oculus Inc license
+agreement provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+************************************************************************************/
+#ifndef OVR_CAPI_GL_h
+#define OVR_CAPI_GL_h
+
+/// @file OVR_CAPI_GL.h
+/// OpenGL rendering support.
+
+#include "OVR_CAPI.h"
+
+//-----------------------------------------------------------------------------------
+// ***** GL Specific
+
+#if defined(OVR_OS_WIN32)
+    #ifndef WIN32_LEAN_AND_MEAN
+    #define WIN32_LEAN_AND_MEAN
+    #endif
+    #include <Windows.h>
+    #include <GL/gl.h>
+#elif defined(OVR_OS_MAC)
+    #include <OpenGL/gl3.h>
+    #include <OpenGL/OpenGL.h>
+#else
+    #include <GL/gl.h>
+    #include <GL/glx.h>
+#endif
+
+
+/// Used to configure slave GL rendering (i.e. for devices created externally).
+typedef struct ovrGLConfigData_s
+{
+    /// General device settings.
+    ovrRenderAPIConfigHeader Header;
+
+#if defined(OVR_OS_WIN32)
+    /// The optional window handle. If unset, rendering will use the current window.
+    HWND Window;
+    /// The optional device context. If unset, rendering will use a new context.
+    HDC  DC;
+#elif defined(OVR_OS_LINUX)
+    /// The optional display. If unset, rendering will use the current display.
+    _XDisplay* Disp;
+    /// The optional window. If unset, rendering will use the current window.
+    Window     Win;
+#endif
+} ovrGLConfigData;
+
+/// Contains OpenGL-specific rendering information.
+union ovrGLConfig
+{
+    /// General device settings.
+    ovrRenderAPIConfig Config;
+    /// OpenGL-specific settings.
+    ovrGLConfigData    OGL;
+};
+
+/// Used to pass GL eye texture data to ovrHmd_EndFrame.
+typedef struct ovrGLTextureData_s
+{
+    /// General device settings.
+    ovrTextureHeader Header;
+    /// The OpenGL name for this texture.
+    GLuint           TexId;       
+} ovrGLTextureData;
+
+/// Contains OpenGL-specific texture information.
+typedef union ovrGLTexture_s
+{
+    /// General device settings.
+    ovrTexture       Texture;
+    /// OpenGL-specific settings.
+    ovrGLTextureData OGL;
+} ovrGLTexture;
+
+#endif	// OVR_CAPI_GL_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_JSON.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,165 @@
+/************************************************************************************
+
+PublicHeader:   None
+Filename    :   OVR_JSON.h
+Content     :   JSON format reader and writer
+Created     :   April 9, 2013
+Author      :   Brant Lewis
+Notes       :
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_JSON_H
+#define OVR_JSON_H
+
+#include "Kernel/OVR_RefCount.h"
+#include "Kernel/OVR_String.h"
+#include "Kernel/OVR_List.h"
+
+namespace OVR {  
+
+// JSONItemType describes the type of JSON item, specifying the type of
+// data that can be obtained from it.
+enum JSONItemType
+{
+    JSON_None      = 0,
+    JSON_Null      = 1,
+    JSON_Bool      = 2,
+    JSON_Number    = 3,
+    JSON_String    = 4,
+    JSON_Array     = 5,
+    JSON_Object    = 6
+};
+
+//-----------------------------------------------------------------------------
+// ***** JSON
+
+// JSON object represents a JSON node that can be either a root of the JSON tree
+// or a child item. Every node has a type that describes what is is.
+// New JSON trees are typically loaded JSON::Load or created with JSON::Parse.
+
+class JSON : public RefCountBase<JSON>, public ListNode<JSON>
+{
+protected:
+    List<JSON>      Children;
+
+public:
+    JSONItemType    Type;       // Type of this JSON node.
+    String          Name;       // Name part of the {Name, Value} pair in a parent object.
+    String          Value;
+    double          dValue;
+
+public:
+    ~JSON();
+
+    // *** Creation of NEW JSON objects
+
+    static JSON*    CreateObject() { return new JSON(JSON_Object);}
+    static JSON*    CreateNull()   { return new JSON(JSON_Null); }
+    static JSON*    CreateArray()  { return new JSON(JSON_Array); }
+    static JSON*    CreateBool(bool b);
+    static JSON*    CreateNumber(double num);
+    static JSON*    CreateInt(int num);
+    static JSON*    CreateString(const char *s);
+
+    // Creates a new JSON object from parsing string.
+    // Returns null pointer and fills in *perror in case of parse error.
+    static JSON*    Parse(const char* buff, const char** perror = 0);
+
+	// This version works for buffers that are not null terminated strings.
+	static JSON*	ParseBuffer(const char *buff, int len, const char** perror = 0);
+
+    // Loads and parses a JSON object from a file.
+    // Returns 0 and assigns perror with error message on fail.
+    static JSON*    Load(const char* path, const char** perror = 0);
+
+    // Saves a JSON object to a file.
+    bool            Save(const char* path);
+
+    // *** Object Member Access
+
+    // These provide access to child items of the list.
+    bool            HasItems() const         { return Children.IsEmpty(); }
+    // Returns first/last child item, or null if child list is empty
+    JSON*           GetFirstItem()           { return (!Children.IsEmpty()) ? Children.GetFirst() : 0; }
+    JSON*           GetLastItem()            { return (!Children.IsEmpty()) ? Children.GetLast() : 0; }
+
+    // Counts the number of items in the object; these methods are inefficient.
+    unsigned        GetItemCount() const;
+    JSON*           GetItemByIndex(unsigned i);
+    JSON*           GetItemByName(const char* name);
+
+	// Accessors by name
+	double			GetNumberByName(const char *name, double defValue = 0.0);
+	int				GetIntByName(const char *name, int defValue = 0);
+	bool			GetBoolByName(const char *name, bool defValue = false);
+	String			GetStringByName(const char *name, const String &defValue = "");
+
+    // Returns next item in a list of children; 0 if no more items exist.
+    JSON*           GetNextItem(JSON* item)  { return Children.IsNull(item->pNext) ? 0 : item->pNext; }
+    JSON*           GetPrevItem(JSON* item)  { return Children.IsNull(item->pPrev) ? 0 : item->pPrev; }
+
+
+    // Child item access functions
+    void            AddItem(const char *string, JSON* item);
+    void            AddNullItem(const char* name)                    { AddItem(name, CreateNull()); }
+    void            AddBoolItem(const char* name, bool b)            { AddItem(name, CreateBool(b)); }
+    void            AddIntItem(const char* name, int n)              { AddItem(name, CreateInt(n)); }
+    void            AddNumberItem(const char* name, double n)        { AddItem(name, CreateNumber(n)); }
+    void            AddStringItem(const char* name, const char* s)   { AddItem(name, CreateString(s)); }
+//    void            ReplaceItem(unsigned index, JSON* new_item);
+//    void            DeleteItem(unsigned index);
+    void            RemoveLast();
+
+    // *** Array Element Access
+
+    // Add new elements to the end of array.
+    void            AddArrayElement(JSON *item);
+    void            InsertArrayElement(int index, JSON* item);
+    void            AddArrayNumber(double n)        { AddArrayElement(CreateNumber(n)); }
+    void            AddArrayInt(int n)              { AddArrayElement(CreateInt(n)); }
+    void            AddArrayString(const char* s)   { AddArrayElement(CreateString(s)); }
+
+    // Accessed array elements; currently inefficient.
+    int             GetArraySize();
+    double          GetArrayNumber(int index);
+    const char*     GetArrayString(int index);
+
+    JSON*           Copy();  // Create a copy of this object
+
+protected:
+    JSON(JSONItemType itemType = JSON_Object);
+
+    // JSON Parsing helper functions.
+    const char*     parseValue(const char *buff, const char** perror);
+    const char*     parseNumber(const char *num);
+    const char*     parseArray(const char* value, const char** perror);
+    const char*     parseObject(const char* value, const char** perror);
+    const char*     parseString(const char* str, const char** perror);
+
+    char*           PrintValue(int depth, bool fmt);
+    char*           PrintObject(int depth, bool fmt);
+    char*           PrintArray(int depth, bool fmt);
+};
+
+
+}
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Profile.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,255 @@
+/************************************************************************************
+
+Filename    :   OVR_Profile.h
+Content     :   Structs and functions for loading and storing device profile settings
+Created     :   February 14, 2013
+Notes       :
+   Profiles are used to store per-user settings that can be transferred and used
+   across multiple applications.  For example, player IPD can be configured once 
+   and reused for a unified experience across games.  Configuration and saving of profiles
+   can be accomplished in game via the Profile API or by the official Oculus Configuration
+   Utility.
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Profile_h
+#define OVR_Profile_h
+
+#include "Sensors/OVR_DeviceConstants.h"
+#include "Kernel/OVR_String.h"
+#include "Kernel/OVR_RefCount.h"
+#include "Kernel/OVR_Array.h"
+#include "Kernel/OVR_StringHash.h"
+#include "Kernel/OVR_System.h"
+
+namespace OVR {
+
+class HMDInfo; // Opaque forward declaration
+class Profile;
+class JSON;
+
+
+// Device key for looking up profiles
+struct ProfileDeviceKey
+{
+    ProfileDeviceKey(const HMDInfo* info);
+
+	// Initialized properly?
+	bool Valid;
+
+    // The HMD type
+    HmdTypeEnum HmdType;
+
+	// This is the 12 character serial number printed on the HMD
+	String PrintedSerial;
+
+	// This is the product name string of the USB sensor device
+	// Note: It has been modified from the original to remove spaces and strip off "Oculus"
+	String ProductName;
+
+	// This is the product id from the HID info of the USB sensor device
+	unsigned ProductId;
+
+    static String SanitizeProductName(String productName);
+};
+
+
+// -----------------------------------------------------------------------------
+// ***** ProfileManager
+
+// Profiles are interfaced through a ProfileManager object.  Applications should
+// create a ProfileManager each time they intend to read or write user profile data.
+// The scope of the ProfileManager object defines when disk I/O is performed.  Disk
+// reads are performed on the first profile access and disk writes are performed when
+// the ProfileManager goes out of scope.  All profile interactions between these times
+// are performed in local memory and are fast.  A typical profile interaction might
+// look like this:
+//
+// {
+//     Ptr<ProfileManager> pm      = *ProfileManager::Create();
+//     Ptr<Profile>        profile = pm->LoadProfile(Profile_RiftDK1,
+//                                                   pm->GetDefaultProfileName(Profile_RiftDK1));
+//     if (profile)
+//     {   // Retrieve the current profile settings
+//     }
+// }   // Profile will be destroyed and any disk I/O completed when going out of scope
+class ProfileManager : public NewOverrideBase, public SystemSingletonBase<ProfileManager>
+{
+    friend class OVR::SystemSingletonBase<ProfileManager>;
+
+protected:
+    ProfileManager(bool sys_register);
+    virtual ~ProfileManager();
+    virtual void OnSystemDestroy();
+
+protected:
+    // Synchronize ProfileManager access since it may be accessed from multiple threads,
+    // as it's shared through DeviceManager.
+    Lock                ProfileLock;
+    Ptr<JSON>           ProfileCache;
+    bool                Changed;
+    String              TempBuff;
+    String              BasePath;
+    
+public:
+    // In the service process it is important to set the base path because this cannot be detected automatically
+    void                SetBasePath(String basePath);
+
+    int                 GetUserCount();
+    const char*         GetUser(unsigned int index);
+    bool                CreateUser(const char* user, const char* name);
+    bool                RemoveUser(const char* user);
+    const char*         GetDefaultUser(const ProfileDeviceKey& deviceKey);
+    bool                SetDefaultUser(const ProfileDeviceKey& deviceKey, const char* user);
+
+    virtual Profile*    CreateProfile();
+    Profile*            GetProfile(const ProfileDeviceKey& deviceKey, const char* user);
+    Profile*            GetDefaultUserProfile(const ProfileDeviceKey& deviceKey);
+    Profile*            GetDefaultProfile(HmdTypeEnum device);
+    Profile*            GetTaggedProfile(const char** key_names, const char** keys, int num_keys);
+    bool                SetTaggedProfile(const char** key_names, const char** keys, int num_keys, Profile* profile);
+    
+    // Force re-reading the settings
+    void                Read();
+
+protected:
+    // Force writing the settings
+    void                ClearProfileData();
+    void                Save();
+
+    String              GetProfilePath();
+    void                LoadCache(bool create);
+    void                LoadV1Profiles(JSON* v1);
+    const char*         GetDefaultUser(const char* product, const char* serial);
+};
+
+
+//-------------------------------------------------------------------
+// ***** Profile
+
+// The base profile for all users.  This object is not created directly.
+// Instead derived device objects provide add specific device members to 
+// the base profile
+class Profile : public RefCountBase<Profile>
+{
+protected:
+    OVR::Hash<String, JSON*, String::HashFunctor>   ValMap;
+    OVR::Array<JSON*>   Values;  
+    OVR::String         TempVal;
+    String              BasePath;
+    bool                IsDefault;
+
+public:
+    ~Profile();
+
+    int                 GetNumValues(const char* key) const;
+    const char*         GetValue(const char* key);
+    char*               GetValue(const char* key, char* val, int val_length) const;
+    bool                GetBoolValue(const char* key, bool default_val) const;
+    int                 GetIntValue(const char* key, int default_val) const;
+    float               GetFloatValue(const char* key, float default_val) const;
+    int                 GetFloatValues(const char* key, float* values, int num_vals) const;
+    double              GetDoubleValue(const char* key, double default_val) const;
+    int                 GetDoubleValues(const char* key, double* values, int num_vals) const;
+
+    void                SetValue(const char* key, const char* val);
+    void                SetBoolValue(const char* key, bool val);
+    void                SetIntValue(const char* key, int val);
+    void                SetFloatValue(const char* key, float val);
+    void                SetFloatValues(const char* key, const float* vals, int num_vals);
+    void                SetDoubleValue(const char* key, double val);
+    void                SetDoubleValues(const char* key, const double* vals, int num_vals);
+
+    bool                IsDefaultProfile();
+    
+    bool Close();
+
+protected:
+	Profile(String basePath) :
+		BasePath(basePath)
+	{
+	}
+    
+    void                SetValue(JSON* val);
+
+	static bool         LoadProfile(const ProfileDeviceKey& deviceKey,
+                                    const char* user,
+                                    Profile** profile);
+    void                CopyItems(JSON* root, String prefix);
+    
+    bool                LoadDeviceFile(unsigned int device_id, const char* serial);
+	bool                LoadDeviceProfile(const ProfileDeviceKey& deviceKey);
+
+    bool                LoadProfile(JSON* root,
+                                    const char* user,
+                                    const char* device_model,
+                                    const char* device_serial);
+
+    bool                LoadUser(JSON* root,
+                                 const char* user,
+                                 const char* device_name,
+                                 const char* device_serial);
+
+    friend class ProfileManager;
+    friend class WProfileManager;
+};
+
+// # defined() check for CAPI compatibility near term that re-defines these
+//   for now. To be unified.
+#if !defined(OVR_KEY_USER)
+
+#define OVR_KEY_USER                        "User"
+#define OVR_KEY_NAME                        "Name"
+#define OVR_KEY_GENDER                      "Gender"
+#define OVR_KEY_PLAYER_HEIGHT               "PlayerHeight"
+#define OVR_KEY_EYE_HEIGHT                  "EyeHeight"
+#define OVR_KEY_IPD                         "IPD"
+#define OVR_KEY_NECK_TO_EYE_DISTANCE        "NeckEyeDistance"
+#define OVR_KEY_EYE_RELIEF_DIAL             "EyeReliefDial"
+#define OVR_KEY_EYE_TO_NOSE_DISTANCE        "EyeToNoseDist"
+#define OVR_KEY_MAX_EYE_TO_PLATE_DISTANCE   "MaxEyeToPlateDist"
+#define OVR_KEY_EYE_CUP                     "EyeCup"
+#define OVR_KEY_CUSTOM_EYE_RENDER           "CustomEyeRender"
+#define OVR_KEY_CAMERA_POSITION				"CenteredFromWorld"
+
+// Default measurements empirically determined at Oculus to make us happy
+// The neck model numbers were derived as an average of the male and female averages from ANSUR-88
+// NECK_TO_EYE_HORIZONTAL = H22 - H43 = INFRAORBITALE_BACK_OF_HEAD - TRAGION_BACK_OF_HEAD
+// NECK_TO_EYE_VERTICAL = H21 - H15 = GONION_TOP_OF_HEAD - ECTOORBITALE_TOP_OF_HEAD
+// These were determined to be the best in a small user study, clearly beating out the previous default values
+#define OVR_DEFAULT_GENDER                  "Unknown"
+#define OVR_DEFAULT_PLAYER_HEIGHT           1.778f
+#define OVR_DEFAULT_EYE_HEIGHT              1.675f
+#define OVR_DEFAULT_IPD                     0.064f
+#define OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL  0.0805f
+#define OVR_DEFAULT_NECK_TO_EYE_VERTICAL    0.075f
+#define OVR_DEFAULT_EYE_RELIEF_DIAL         3
+#define OVR_DEFAULT_CAMERA_POSITION			{0,0,0,1,0,0,0}
+
+#endif // OVR_KEY_USER
+
+
+// This path should be passed into the ProfileManager
+String GetBaseOVRPath(bool create_dir);
+
+
+} // namespace OVR
+
+#endif // OVR_Profile_h
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_SerialFormat.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,144 @@
+/************************************************************************************
+
+PublicHeader:   n/a
+Filename    :   OVR_SerialFormat.h
+Content     :   Serial Number format tools
+Created     :   June 12, 2014
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_SerialFormat_h
+#define OVR_SerialFormat_h
+
+#include "Kernel/OVR_Types.h"
+#include "Kernel/OVR_String.h"
+
+namespace OVR {
+
+
+//-----------------------------------------------------------------------------
+// SerialFormatType enumeration
+
+enum SerialFormatType
+{
+	SerialFormatType_Invalid = -1, // Invalid format
+	SerialFormatType_DK2 = 0,	   // Format used for DK2
+};
+
+// Returns the expected serial format based on the first byte of the buffer
+SerialFormatType DetectBufferFormat(uint8_t firstByte, int sizeInBytes);
+
+
+//-----------------------------------------------------------------------------
+// DK2 Serial Format
+
+enum DK2ProductId
+{
+	DK2ProductId_DK1    = 1, // DK1
+	DK2ProductId_DK2    = 2, // Product Id used for initial DK2 launch
+	DK2ProductId_Refurb = 3, // Refurbished DK2
+};
+
+enum DK2PartId
+{
+	DK2PartId_HMD    = 0, // HMD
+	DK2PartId_PTC    = 1, // PTC(camera)
+	DK2PartId_Carton = 2, // Carton: An HMD + PTC combo (should not be stamped on a component) AKA Overpack
+};
+
+typedef DK2PartId DK2LabelType; // Printed Serial Number version
+
+
+// DK2 tool for reading/writing the binary serial format
+class DK2BinarySerialFormat
+{
+public:
+	static const SerialFormatType FormatType = SerialFormatType_DK2; // first byte
+
+	DK2ProductId ProductId;         // [4 bits] 2 = DK2
+	DK2PartId    PartId;            // [4 bits] 0 means HMD, 1 means PTC(camera)
+	int          MinutesSinceEpoch; // [3 bytes] Number of minutes that have elapsed since the epoch: May 1st, 2014
+	// [0] = high byte, [1] = middle byte, [2] = low byte
+	int          UnitNumber;        // [2 bytes] Value that increments each time a new serial number is created.  Resets to zero each day
+	// [0] = high byte, [1] = low byte
+	uint8_t      MacHash[5];        // [5 bytes] 5 most significant bytes of MD5 hash from first ethernet adapter mac address
+
+	bool operator==(const DK2BinarySerialFormat& rhs);
+
+public:
+	// Returns false if the input is invalid in some way
+	bool FromBuffer(const uint8_t buffer[12], bool allowUnknownTypes = false);
+
+	// Fills the provided buffer with 12 bytes
+	void ToBuffer(uint8_t buffer[12]);
+};
+
+
+// DK2 tool for reading/writing the printed serial format
+class DK2PrintedSerialFormat
+{
+public:
+	DK2ProductId ProductId;         // [1 char] 2 = DK2, 3 = Reconditioned bundle
+	DK2LabelType LabelType;         // [1 char] 0 means HMD, 1 means PTC(camera), 2 means Overpack(bundle)
+	int          MinutesSinceEpoch; // [4 char] Number of minutes that have elapsed since the epoch: May 1st, 2014
+	int          UnitNumber;        // [3 char] Value that increments each time a new serial number is created.  Resets to zero each day
+	uint8_t      MacHashLow[3];     // [3 char] 3 least significant bytes of mac hash
+
+	bool operator==(const DK2PrintedSerialFormat& rhs);
+	bool operator==(const DK2BinarySerialFormat& rhs);
+
+public:
+	// Convert from binary to printed
+	void FromBinary(const DK2BinarySerialFormat& bin);
+
+	// Returns false if the input is invalid in some way
+	// Convert from a 12 character printed serial number
+	bool FromBase32(const char* str, bool allowUnknownTypes = false);
+
+	// Returns a long human-readable base32 string (20 characters), NOT a printed serial number
+	String ToBase32();
+};
+
+
+// Generates a Human-readable labels with built-in checksums
+// Returns false on error
+bool GenerateHumanString(int dataBits,               // Number of bits to store
+                         int checkBits,              // Number of extra bits of checksum data
+                         const unsigned char* input, // Bytes stored LSB-first
+                         int dataBytes,              // Size of data buffer in bytes
+                         String& resultStr);         // Output string
+
+// Returns number of bytes written to result, or zero on failure
+int ProcessHumanString(int dataBits,               // Number of bits to expect
+                       int checkBits,              // Number of extra bits of checksum data
+                       String humanStr,            // Human readable input string
+                       unsigned char* result,      // Output data buffer stored LSB-first
+                       int resultBytes);           // Size of result buffer in bytes
+
+
+//#define SERIAL_FORMAT_UNIT_TEST
+#ifdef SERIAL_FORMAT_UNIT_TEST
+void TestSerialFormatStuff();
+#endif
+
+
+} // OVR
+
+#endif // OVR_SerialFormat_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/OVR_Stereo.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,647 @@
+/************************************************************************************
+
+Filename    :   OVR_Stereo.h
+Content     :   Stereo rendering functions
+Created     :   November 30, 2013
+Authors     :   Tom Fosyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Stereo_h
+#define OVR_Stereo_h
+
+#include "Sensors/OVR_DeviceConstants.h"
+#include "Displays/OVR_Display.h"
+#include "OVR_Profile.h"
+
+// CAPI Forward declaration.
+typedef struct ovrFovPort_ ovrFovPort;
+typedef struct ovrRecti_ ovrRecti;
+
+namespace OVR {
+
+class SensorDevice; // Opaque forward declaration
+
+
+//-----------------------------------------------------------------------------------
+// ***** Stereo Enumerations
+
+// StereoEye specifies which eye we are rendering for; it is used to
+// retrieve StereoEyeParams.
+enum StereoEye
+{
+    StereoEye_Center,
+    StereoEye_Left,
+    StereoEye_Right    
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** FovPort
+
+// FovPort describes Field Of View (FOV) of a viewport.
+// This class has values for up, down, left and right, stored in 
+// tangent of the angle units to simplify calculations.
+//
+// As an example, for a standard 90 degree vertical FOV, we would 
+// have: { UpTan = tan(90 degrees / 2), DownTan = tan(90 degrees / 2) }.
+//
+// CreateFromRadians/Degrees helper functions can be used to
+// access FOV in different units.
+
+struct FovPort
+{
+    float UpTan;
+    float DownTan;
+    float LeftTan;
+    float RightTan;
+
+    FovPort ( float sideTan = 0.0f ) :
+        UpTan(sideTan), DownTan(sideTan), LeftTan(sideTan), RightTan(sideTan) { }
+    FovPort ( float u, float d, float l, float r ) :
+        UpTan(u), DownTan(d), LeftTan(l), RightTan(r) { }
+
+    // C-interop support: FovPort <-> ovrFovPort (implementation in OVR_CAPI.cpp).
+    FovPort(const ovrFovPort& src);
+    operator ovrFovPort () const;
+
+    static FovPort CreateFromRadians(float horizontalFov, float verticalFov)
+    {
+        FovPort result;
+        result.UpTan    = tanf (   verticalFov * 0.5f );
+        result.DownTan  = tanf (   verticalFov * 0.5f );
+        result.LeftTan  = tanf ( horizontalFov * 0.5f );
+        result.RightTan = tanf ( horizontalFov * 0.5f );
+        return result;
+    }
+
+    static FovPort CreateFromDegrees(float horizontalFovDegrees,
+                                     float verticalFovDegrees)
+    {
+        return CreateFromRadians(DegreeToRad(horizontalFovDegrees),
+                                 DegreeToRad(verticalFovDegrees));
+    }
+
+    //  Get Horizontal/Vertical components of Fov in radians.
+    float GetVerticalFovRadians() const     { return atanf(UpTan)    + atanf(DownTan); }
+    float GetHorizontalFovRadians() const   { return atanf(LeftTan)  + atanf(RightTan); }
+    //  Get Horizontal/Vertical components of Fov in degrees.
+    float GetVerticalFovDegrees() const     { return RadToDegree(GetVerticalFovRadians()); }
+    float GetHorizontalFovDegrees() const   { return RadToDegree(GetHorizontalFovRadians()); }
+
+    // Compute maximum tangent value among all four sides.
+    float GetMaxSideTan() const
+    {
+        return Alg::Max(Alg::Max(UpTan, DownTan), Alg::Max(LeftTan, RightTan));
+    }
+
+    // Converts Fov Tan angle units to [-1,1] render target NDC space
+    Vector2f TanAngleToRendertargetNDC(Vector2f const &tanEyeAngle);
+
+
+    // Compute per-channel minimum and maximum of Fov.
+    static FovPort Min(const FovPort& a, const FovPort& b)
+    {   
+        FovPort fov( Alg::Min( a.UpTan   , b.UpTan    ),   
+                     Alg::Min( a.DownTan , b.DownTan  ),
+                     Alg::Min( a.LeftTan , b.LeftTan  ),
+                     Alg::Min( a.RightTan, b.RightTan ) );
+        return fov;
+    }
+
+    static FovPort Max(const FovPort& a, const FovPort& b)
+    {   
+        FovPort fov( Alg::Max( a.UpTan   , b.UpTan    ),   
+                     Alg::Max( a.DownTan , b.DownTan  ),
+                     Alg::Max( a.LeftTan , b.LeftTan  ),
+                     Alg::Max( a.RightTan, b.RightTan ) );
+        return fov;
+    }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** ScaleAndOffset
+
+struct ScaleAndOffset2D
+{
+    Vector2f Scale;
+    Vector2f Offset;
+
+    ScaleAndOffset2D(float sx = 0.0f, float sy = 0.0f, float ox = 0.0f, float oy = 0.0f)
+      : Scale(sx, sy), Offset(ox, oy)        
+    { }
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** Misc. utility functions.
+
+// Inputs are 4 points (pFitX[0],pFitY[0]) through (pFitX[3],pFitY[3])
+// Result is four coefficients in pResults[0] through pResults[3] such that
+//      y = pResult[0] + x * ( pResult[1] + x * ( pResult[2] + x * ( pResult[3] ) ) );
+// passes through all four input points.
+// Return is true if it succeeded, false if it failed (because two control points
+// have the same pFitX value).
+bool FitCubicPolynomial ( float *pResult, const float *pFitX, const float *pFitY );
+
+//-----------------------------------------------------------------------------------
+// ***** LensConfig
+
+// LensConfig describes the configuration of a single lens in an HMD.
+// - Eqn and K[] describe a distortion function.
+// - MetersPerTanAngleAtCenter is the relationship between distance on a
+//   screen (at the center of the lens), and the angle variance of the light after it
+//   has passed through the lens.
+// - ChromaticAberration is an array of parameters for controlling
+//   additional Red and Blue scaling in order to reduce chromatic aberration
+//   caused by the Rift lenses.
+struct LensConfig
+{
+    // The result is a scaling applied to the distance from the center of the lens.
+    float    DistortionFnScaleRadiusSquared (float rsq) const;
+    // x,y,z components map to r,g,b scales.
+    Vector3f DistortionFnScaleRadiusSquaredChroma (float rsq) const;
+
+    // DistortionFn applies distortion to the argument.
+    // Input: the distance in TanAngle/NIC space from the optical center to the input pixel.
+    // Output: the resulting distance after distortion.
+    float DistortionFn(float r) const
+    {
+        return r * DistortionFnScaleRadiusSquared ( r * r );
+    }
+
+    // DistortionFnInverse computes the inverse of the distortion function on an argument.
+    float DistortionFnInverse(float r) const;
+
+    // Also computes the inverse, but using a polynomial approximation. Warning - it's just an approximation!
+    float DistortionFnInverseApprox(float r) const;
+    // Sets up InvK[].
+    void SetUpInverseApprox();
+
+    // Sets a bunch of sensible defaults.
+    void SetToIdentity();
+
+
+
+    enum { NumCoefficients = 11 };
+
+    DistortionEqnType   Eqn;
+    float               K[NumCoefficients];
+    float               MaxR;       // The highest R you're going to query for - the curve is unpredictable beyond it.
+
+    float               MetersPerTanAngleAtCenter;
+
+    // Additional per-channel scaling is applied after distortion:
+    //  Index [0] - Red channel constant coefficient.
+    //  Index [1] - Red channel r^2 coefficient.
+    //  Index [2] - Blue channel constant coefficient.
+    //  Index [3] - Blue channel r^2 coefficient.
+    float               ChromaticAberration[4];
+
+    float               InvK[NumCoefficients];
+    float               MaxInvR;
+};
+
+
+// For internal use - storing and loading lens config data
+
+// Returns true on success.
+bool LoadLensConfig ( LensConfig *presult, uint8_t const *pbuffer, int bufferSizeInBytes );
+
+// Returns number of bytes needed.
+int SaveLensConfigSizeInBytes ( LensConfig const &config );
+// Returns true on success.
+bool SaveLensConfig ( uint8_t *pbuffer, int bufferSizeInBytes, LensConfig const &config );
+
+
+//-----------------------------------------------------------------------------------
+// ***** DistortionRenderDesc
+
+// This describes distortion for a single eye in an HMD with a display, not just the lens by itself.
+struct DistortionRenderDesc
+{
+    // The raw lens values.
+    LensConfig          Lens;
+
+    // These map from [-1,1] across the eye being rendered into TanEyeAngle space (but still distorted)
+    Vector2f            LensCenter;
+    Vector2f            TanEyeAngleScale;
+    // Computed from device characteristics, IPD and eye-relief.
+    // (not directly used for rendering, but very useful)
+    Vector2f            PixelsPerTanAngleAtCenter;
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** HMDInfo 
+
+// This structure describes various aspects of the HMD allowing us to configure rendering.
+//
+//  Currently included data:
+//   - Physical screen dimensions, resolution, and eye distances.
+//     (some of these will be configurable with a tool in the future).
+//     These arguments allow us to properly setup projection across HMDs.
+//   - DisplayDeviceName for identifying HMD screen; system-specific interpretation.
+//
+// TBD:
+//  - Power on/ off?
+//  - Sensor rates and capabilities
+//  - Distortion radius/variables    
+//  - Screen update frequency
+//  - Distortion needed flag
+//  - Update modes:
+//      Set update mode: Stereo (both sides together), mono (same in both eyes),
+//                       Alternating, Alternating scan-lines.
+
+// Win32 Oculus VR Display Driver Shim Information
+struct Win32ShimInfo
+{
+	int DeviceNumber;
+	int NativeWidth;
+	int NativeHeight;
+	int Rotation;
+	int UseMirroring;
+
+	Win32ShimInfo() :
+		DeviceNumber(-1),
+		NativeWidth(-1),
+		NativeHeight(-1),
+		Rotation(-1),
+		UseMirroring(1)
+	{
+	}
+};
+
+class HMDInfo
+{
+public:
+	// Name string describing the product: "Oculus Rift DK1", etc.
+	String      ProductName;
+	String      Manufacturer;
+
+	unsigned    Version;
+
+	// Characteristics of the HMD screen and enclosure
+	HmdTypeEnum HmdType;
+	Size<int>   ResolutionInPixels;
+	Size<float> ScreenSizeInMeters;
+	float       ScreenGapSizeInMeters;
+	float       CenterFromTopInMeters;
+	float       LensSeparationInMeters;
+
+	// Timing & shutter data. All values in seconds.
+	struct ShutterInfo
+	{
+		HmdShutterTypeEnum  Type;
+		float   VsyncToNextVsync;                // 1/framerate
+		float   VsyncToFirstScanline;            // for global shutter, vsync->shutter open.
+		float   FirstScanlineToLastScanline;     // for global shutter, will be zero.
+		float   PixelSettleTime;                 // estimated.
+		float   PixelPersistence;                // Full persistence = 1/framerate.
+	}           Shutter;
+
+	// Desktop coordinate position of the screen (can be negative; may not be present on all platforms)
+	int         DesktopX;
+	int         DesktopY;
+
+	// Windows:
+	// "\\\\.\\DISPLAY3", etc. Can be used in EnumDisplaySettings/CreateDC.
+	String      DisplayDeviceName;
+	Win32ShimInfo ShimInfo;
+
+	// MacOS:
+	int         DisplayId;
+
+	bool	    InCompatibilityMode;
+
+	// Printed serial number for the HMD; should match external sticker
+    String      PrintedSerial;
+
+    // Tracker descriptor information:
+    int         VendorId;
+    int         ProductId;
+    int         FirmwareMajor;
+    int         FirmwareMinor;
+
+    float   CameraFrustumHFovInRadians;
+    float   CameraFrustumVFovInRadians;
+    float   CameraFrustumNearZInMeters;
+    float   CameraFrustumFarZInMeters;
+
+	// Constructor initializes all values to 0s.
+	// To create a "virtualized" HMDInfo, use CreateDebugHMDInfo instead.
+	HMDInfo() :
+		Version(0),
+		HmdType(HmdType_None),
+		ResolutionInPixels(0),
+		ScreenSizeInMeters(0.0f),
+		ScreenGapSizeInMeters(0.0f),
+		CenterFromTopInMeters(0),
+		LensSeparationInMeters(0),
+		DisplayId(-1),
+		InCompatibilityMode(false)
+	{
+		DesktopX = 0;
+		DesktopY = 0;
+		Shutter.Type = HmdShutter_LAST;
+		Shutter.VsyncToNextVsync = 0.0f;
+		Shutter.VsyncToFirstScanline = 0.0f;
+		Shutter.FirstScanlineToLastScanline = 0.0f;
+		Shutter.PixelSettleTime = 0.0f;
+		Shutter.PixelPersistence = 0.0f;
+
+        CameraFrustumHFovInRadians = 0;
+        CameraFrustumVFovInRadians = 0;
+        CameraFrustumNearZInMeters = 0;
+        CameraFrustumFarZInMeters = 0;
+    }
+
+	// Operator = copies local fields only (base class must be correct already)
+	void operator=(const HMDInfo& src)
+	{
+		ProductName = src.ProductName;
+		Manufacturer = src.Manufacturer;
+		Version = src.Version;
+		HmdType = src.HmdType;
+		ResolutionInPixels = src.ResolutionInPixels;
+		ScreenSizeInMeters = src.ScreenSizeInMeters;
+		ScreenGapSizeInMeters = src.ScreenGapSizeInMeters;
+		CenterFromTopInMeters = src.CenterFromTopInMeters;
+		LensSeparationInMeters = src.LensSeparationInMeters;
+		DesktopX = src.DesktopX;
+		DesktopY = src.DesktopY;
+		Shutter = src.Shutter;
+		DisplayDeviceName = src.DisplayDeviceName;
+		ShimInfo = src.ShimInfo;
+		DisplayId = src.DisplayId;
+		InCompatibilityMode = src.InCompatibilityMode;
+        VendorId = src.VendorId;
+        ProductId = src.ProductId;
+        FirmwareMajor = src.FirmwareMajor;
+        FirmwareMinor = src.FirmwareMinor;
+        PrintedSerial = src.PrintedSerial;
+        CameraFrustumHFovInRadians = src.CameraFrustumHFovInRadians;
+        CameraFrustumVFovInRadians = src.CameraFrustumVFovInRadians;
+        CameraFrustumNearZInMeters = src.CameraFrustumNearZInMeters;
+        CameraFrustumFarZInMeters = src.CameraFrustumFarZInMeters;
+    }
+
+	void SetScreenParameters(int hres, int vres,
+							 float hsize, float vsize,
+							 float vCenterFromTopInMeters, float lensSeparationInMeters,
+							 bool compatibilityMode)
+	{
+		ResolutionInPixels = Sizei(hres, vres);
+		ScreenSizeInMeters = Sizef(hsize, vsize);
+		CenterFromTopInMeters = vCenterFromTopInMeters;
+		LensSeparationInMeters = lensSeparationInMeters;
+		InCompatibilityMode = compatibilityMode;
+	}
+
+	bool IsSameDisplay(const HMDInfo& o) const
+	{
+		return DisplayId == o.DisplayId &&
+			DisplayDeviceName.CompareNoCase(o.DisplayDeviceName) == 0;
+	}
+
+	static bool CreateFromSensorAndDisplay(SensorDevice* sensor, Display* display, HMDInfo* hmdi);
+};
+
+
+//-----------------------------------------------------------------------------------
+// ***** HmdRenderInfo
+
+// All the parts of the HMD info that are needed to set up the rendering system.
+
+struct HmdRenderInfo
+{
+    // The start of this structure is intentionally very similar to HMDInfo in OVER_Device.h
+    // However to reduce interdependencies, one does not simply #include the other.
+
+    HmdTypeEnum HmdType;
+
+    // Size of the entire screen
+    Size<int>   ResolutionInPixels;
+    Size<float> ScreenSizeInMeters;
+    float       ScreenGapSizeInMeters;
+
+    // Characteristics of the lenses.
+    float       CenterFromTopInMeters;
+    float       LensSeparationInMeters;
+    float       LensDiameterInMeters;
+    float       LensSurfaceToMidplateInMeters;
+    EyeCupType  EyeCups;
+
+    // Timing & shutter data. All values in seconds.
+    struct ShutterInfo
+    {
+        HmdShutterTypeEnum  Type;
+        float               VsyncToNextVsync;                // 1/framerate
+        float               VsyncToFirstScanline;            // for global shutter, vsync->shutter open.
+        float               FirstScanlineToLastScanline;     // for global shutter, will be zero.
+        float               PixelSettleTime;                 // estimated.
+        float               PixelPersistence;                // Full persistence = 1/framerate.
+    }           Shutter;
+
+
+    // These are all set from the user's profile.
+    struct EyeConfig
+    {
+        // Distance from center of eyeball to front plane of lens.
+        float               ReliefInMeters;
+        // Distance from nose (technically, center of Rift) to the middle of the eye.
+        float               NoseToPupilInMeters;
+
+        LensConfig          Distortion;
+    } EyeLeft, EyeRight;
+
+
+    HmdRenderInfo()
+    {
+        HmdType = HmdType_None;
+        ResolutionInPixels.w = 0;
+        ResolutionInPixels.h = 0;
+        ScreenSizeInMeters.w = 0.0f;
+        ScreenSizeInMeters.h = 0.0f;
+        ScreenGapSizeInMeters = 0.0f;
+        CenterFromTopInMeters = 0.0f;
+        LensSeparationInMeters = 0.0f;
+        LensDiameterInMeters = 0.0f;
+        LensSurfaceToMidplateInMeters = 0.0f;
+        Shutter.Type = HmdShutter_LAST;
+        Shutter.VsyncToNextVsync = 0.0f;
+        Shutter.VsyncToFirstScanline = 0.0f;
+        Shutter.FirstScanlineToLastScanline = 0.0f;
+        Shutter.PixelSettleTime = 0.0f;
+        Shutter.PixelPersistence = 0.0f;
+        EyeCups = EyeCup_DK1A;
+        EyeLeft.ReliefInMeters = 0.0f;
+        EyeLeft.NoseToPupilInMeters = 0.0f;
+        EyeLeft.Distortion.SetToIdentity();
+        EyeRight = EyeLeft;
+    }
+
+    // The "center eye" is the position the HMD tracking returns,
+    // and games will also usually use it for audio, aiming reticles, some line-of-sight tests, etc.
+    EyeConfig GetEyeCenter() const
+    {
+        EyeConfig result;
+        result.ReliefInMeters = 0.5f * ( EyeLeft.ReliefInMeters + EyeRight.ReliefInMeters );
+        result.NoseToPupilInMeters = 0.0f;
+        result.Distortion.SetToIdentity();
+        return result;
+    }
+
+};
+
+
+//-----------------------------------------------------------------------------------
+
+// Stateless computation functions, in somewhat recommended execution order.
+// For examples on how to use many of them, see the StereoConfig::UpdateComputedState function.
+
+const float OVR_DEFAULT_EXTRA_EYE_ROTATION = 30.0f * MATH_FLOAT_DEGREETORADFACTOR;
+
+// Creates a dummy debug HMDInfo matching a particular HMD model.
+// Useful for development without an actual HMD attached.
+HMDInfo             CreateDebugHMDInfo(HmdTypeEnum hmdType);
+
+
+// profile may be NULL, in which case it uses the hard-coded defaults.
+// distortionType should be left at the default unless you require something specific for your distortion shaders.
+// eyeCupOverride can be EyeCup_LAST, in which case it uses the one in the profile.
+HmdRenderInfo       GenerateHmdRenderInfoFromHmdInfo ( HMDInfo const &hmdInfo,
+                                                       Profile const *profile = NULL,
+                                                       DistortionEqnType distortionType = Distortion_CatmullRom10,
+                                                       EyeCupType eyeCupOverride = EyeCup_LAST );
+
+LensConfig          GenerateLensConfigFromEyeRelief ( float eyeReliefInMeters, HmdRenderInfo const &hmd,
+                                                      DistortionEqnType distortionType = Distortion_CatmullRom10 );
+
+DistortionRenderDesc CalculateDistortionRenderDesc ( StereoEye eyeType, HmdRenderInfo const &hmd,
+                                                     LensConfig const *pLensOverride = NULL );
+
+FovPort             CalculateFovFromEyePosition ( float eyeReliefInMeters,
+                                                  float offsetToRightInMeters,
+                                                  float offsetDownwardsInMeters,
+                                                  float lensDiameterInMeters,
+                                                  float extraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION);
+
+FovPort             CalculateFovFromHmdInfo ( StereoEye eyeType,
+                                              DistortionRenderDesc const &distortion,
+                                              HmdRenderInfo const &hmd,
+                                              float extraEyeRotationInRadians = OVR_DEFAULT_EXTRA_EYE_ROTATION );
+
+FovPort             GetPhysicalScreenFov ( StereoEye eyeType, DistortionRenderDesc const &distortion );
+
+FovPort             ClampToPhysicalScreenFov ( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                               FovPort inputFovPort );
+
+Sizei               CalculateIdealPixelSize ( StereoEye eyeType, DistortionRenderDesc const &distortion,
+                                              FovPort fov, float pixelsPerDisplayPixel );
+
+Recti               GetFramebufferViewport ( StereoEye eyeType, HmdRenderInfo const &hmd );
+
+Matrix4f            CreateProjection ( bool rightHanded, FovPort fov,
+                                       float zNear = 0.01f, float zFar = 10000.0f );
+
+Matrix4f            CreateOrthoSubProjection ( bool rightHanded, StereoEye eyeType,
+                                               float tanHalfFovX, float tanHalfFovY,
+                                               float unitsX, float unitsY, float distanceFromCamera,
+                                               float interpupillaryDistance, Matrix4f const &projection,
+                                               float zNear = 0.0f, float zFar = 0.0f );
+
+ScaleAndOffset2D    CreateNDCScaleAndOffsetFromFov ( FovPort fov );
+
+ScaleAndOffset2D    CreateUVScaleAndOffsetfromNDCScaleandOffset ( ScaleAndOffset2D scaleAndOffsetNDC,
+                                                                  Recti renderedViewport,
+                                                                  Sizei renderTargetSize );
+
+
+//-----------------------------------------------------------------------------------
+// ***** StereoEyeParams
+
+// StereoEyeParams describes RenderDevice configuration needed to render
+// the scene for one eye. 
+struct StereoEyeParams
+{
+    StereoEye               Eye;
+    Matrix4f                ViewAdjust;             // Translation to be applied to view matrix.
+
+    // Distortion and the VP on the physical display - the thing to run the distortion shader on.
+    DistortionRenderDesc    Distortion;
+    Recti                   DistortionViewport;
+
+    // Projection and VP of a particular view (you could have multiple of these).
+    Recti                   RenderedViewport;       // Viewport that we render the standard scene to.
+    FovPort                 Fov;                    // The FOVs of this scene.
+    Matrix4f                RenderedProjection;     // Projection matrix used with this eye.
+    ScaleAndOffset2D        EyeToSourceNDC;         // Mapping from TanEyeAngle space to [-1,+1] on the rendered image.
+    ScaleAndOffset2D        EyeToSourceUV;          // Mapping from TanEyeAngle space to actual texture UV coords.
+};
+
+
+//-----------------------------------------------------------------------------------
+// A set of "forward-mapping" functions, mapping from framebuffer space to real-world and/or texture space.
+Vector2f TransformScreenNDCToTanFovSpace ( DistortionRenderDesc const &distortion,
+                                           const Vector2f &framebufferNDC );
+void TransformScreenNDCToTanFovSpaceChroma ( Vector2f *resultR, Vector2f *resultG, Vector2f *resultB, 
+                                             DistortionRenderDesc const &distortion,
+                                             const Vector2f &framebufferNDC );
+Vector2f TransformTanFovSpaceToRendertargetTexUV ( ScaleAndOffset2D const &eyeToSourceUV,
+                                                   Vector2f const &tanEyeAngle );
+Vector2f TransformTanFovSpaceToRendertargetNDC ( ScaleAndOffset2D const &eyeToSourceNDC,
+                                                 Vector2f const &tanEyeAngle );
+Vector2f TransformScreenPixelToScreenNDC( Recti const &distortionViewport,
+                                          Vector2f const &pixel );
+Vector2f TransformScreenPixelToTanFovSpace ( Recti const &distortionViewport,
+                                             DistortionRenderDesc const &distortion,
+                                             Vector2f const &pixel );
+Vector2f TransformScreenNDCToRendertargetTexUV( DistortionRenderDesc const &distortion,
+                                                StereoEyeParams const &eyeParams,
+                                                Vector2f const &pixel );
+Vector2f TransformScreenPixelToRendertargetTexUV( Recti const &distortionViewport,
+                                                  DistortionRenderDesc const &distortion,
+                                                  StereoEyeParams const &eyeParams,
+                                                  Vector2f const &pixel );
+
+// A set of "reverse-mapping" functions, mapping from real-world and/or texture space back to the framebuffer.
+// Be aware that many of these are significantly slower than their forward-mapping counterparts.
+Vector2f TransformTanFovSpaceToScreenNDC( DistortionRenderDesc const &distortion,
+                                          const Vector2f &tanEyeAngle, bool usePolyApprox = false );
+Vector2f TransformRendertargetNDCToTanFovSpace( const ScaleAndOffset2D &eyeToSourceNDC,
+                                                const Vector2f &textureNDC );
+
+// Handy wrappers.
+inline Vector2f TransformTanFovSpaceToRendertargetTexUV ( StereoEyeParams const &eyeParams,
+                                                          Vector2f const &tanEyeAngle )
+{
+    return TransformTanFovSpaceToRendertargetTexUV ( eyeParams.EyeToSourceUV, tanEyeAngle );
+}
+inline Vector2f TransformTanFovSpaceToRendertargetNDC ( StereoEyeParams const &eyeParams,
+                                                        Vector2f const &tanEyeAngle )
+{
+    return TransformTanFovSpaceToRendertargetNDC ( eyeParams.EyeToSourceNDC, tanEyeAngle );
+}
+
+} //namespace OVR
+
+#endif // OVR_Stereo_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Sensors/OVR_DeviceConstants.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Sensors/OVR_DeviceConstants.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,182 @@
+/************************************************************************************
+
+Filename    :   OVR_DeviceConstants.h
+Content     :   Device constants
+Created     :   February 5, 2013
+Authors     :   Lee Cooper
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_DeviceConstants_h
+#define OVR_DeviceConstants_h
+
+#include "../Kernel/OVR_Math.h"
+
+// CAPI forward declarations.
+struct ovrSensorData_;
+typedef struct ovrSensorData_ ovrSensorData;
+
+namespace OVR {
+
+
+//-------------------------------------------------------------------------------------
+// Different device types supported by OVR; this type is reported by DeviceBase::GetType.
+// 
+enum DeviceType
+{
+    Device_None,
+    Device_Manager,
+    Device_Sensor,
+    Device_LatencyTester,
+    Device_BootLoader,
+    Device_All              = 0xFF // Set for enumeration only, to enumerate all device types.
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// Different lens distortion types supported by devices.
+// 
+enum DistortionEqnType
+{
+    Distortion_No_Override  = -1,    
+	// These two are leagcy and deprecated.
+    Distortion_Poly4        = 0,    // scale = (K0 + K1*r^2 + K2*r^4 + K3*r^6)
+    Distortion_RecipPoly4   = 1,    // scale = 1/(K0 + K1*r^2 + K2*r^4 + K3*r^6)
+
+    // CatmullRom10 is the preferred distortion format.
+    Distortion_CatmullRom10 = 2,    // scale = Catmull-Rom spline through points (1.0, K[1]...K[9])
+
+    Distortion_LAST                 // For ease of enumeration.
+};
+
+
+//-------------------------------------------------------------------------------------
+// HMD types.
+//
+enum HmdTypeEnum
+{
+    HmdType_None,
+
+    HmdType_DKProto,            // First duct-tape model, never sold.
+    HmdType_DK1,                // DevKit1 - on sale to developers.
+    HmdType_DKHDProto,          // DKHD - shown at various shows, never sold.
+    HmdType_DKHD2Proto,         // DKHD2, 5.85-inch panel, never sold.
+    HmdType_DKHDProto566Mi,     // DKHD, 5.66-inch panel, never sold.
+    HmdType_CrystalCoveProto,   // Crystal Cove, 5.66-inch panel, shown at shows but never sold.
+    HmdType_DK2,
+
+    // Reminder - this header file is public - codenames only!
+
+    HmdType_Unknown,            // Used for unnamed HW lab experiments.
+
+    HmdType_LAST
+};
+
+
+//-------------------------------------------------------------------------------------
+// HMD shutter types.
+//
+enum HmdShutterTypeEnum
+{
+    HmdShutter_Global,
+    HmdShutter_RollingTopToBottom,
+    HmdShutter_RollingLeftToRight,
+    HmdShutter_RollingRightToLeft,
+    // TODO:
+    // color-sequential e.g. LCOS?
+    // alternate eyes?
+    // alternate columns?
+    // outside-in?
+
+    HmdShutter_LAST
+};
+
+
+
+//-------------------------------------------------------------------------------------
+// For headsets that use eye cups
+//
+enum EyeCupType
+{
+    // Public lenses
+    EyeCup_DK1A = 0,
+    EyeCup_DK1B = 1,
+    EyeCup_DK1C = 2,
+
+    EyeCup_DK2A = 3,
+
+    // Internal R&D codenames.
+    // Reminder - this header file is public - codenames only!
+    EyeCup_DKHD2A,
+    EyeCup_OrangeA,
+    EyeCup_RedA,
+    EyeCup_PinkA,
+    EyeCup_BlueA,
+    EyeCup_Delilah1A,
+    EyeCup_Delilah2A,
+    EyeCup_JamesA,
+    EyeCup_SunMandalaA,
+
+    EyeCup_LAST
+};
+
+
+//-----------------------------------------------------------------------------
+// BodyFrameState
+//
+#pragma pack(push, 8)
+
+class SensorDataType
+{
+public:
+
+    SensorDataType() : Temperature(0.0f), AbsoluteTimeSeconds(0.0) { }
+
+    // C-interop support
+    SensorDataType(const ovrSensorData& s);
+    operator ovrSensorData () const;
+
+    Vector3f Acceleration;     // in m/s^2
+    Vector3f RotationRate;     // in rad/s
+    Vector3f MagneticField;    // in Gauss
+
+    float    Temperature;      // in degrees Celsius
+
+    // The absolute time from the host computers perspective that the message should be
+    // interpreted as. This is based on incoming timestamp and processed by a filter
+    // that syncs the clocks while attempting to keep the distance between messages
+    // device clock matching.
+    //
+    // Integration should use TimeDelta, but prediction into the future should derive
+    // the delta time from PredictToSeconds - AbsoluteTimeSeconds.
+    //
+    // This value will generally be <= the return from a call to ovr_GetTimeInSeconds(),
+    // but could be greater by under 1 ms due to system time update interrupt delays.
+    //
+    double   AbsoluteTimeSeconds;
+};
+
+#pragma pack(pop)
+
+
+} // namespace OVR
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetClient.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,146 @@
+/************************************************************************************
+
+Filename    :   Service_NetClient.h
+Content     :   Client for service interface
+Created     :   June 12, 2014
+Authors     :   Michael Antonov, Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Service_NetClient_h
+#define OVR_Service_NetClient_h
+
+#include "../Net/OVR_NetworkTypes.h"
+#include "Service_NetSessionCommon.h"
+#include "../Kernel/OVR_System.h"
+#include "../OVR_CAPI.h"
+#include "../Util/Util_Render_Stereo.h"
+
+namespace OVR { namespace Service {
+
+using namespace OVR::Net;
+
+
+//-------------------------------------------------------------------------------------
+// NetClient
+
+class NetClient : public NetSessionCommon,
+                  public Net::Plugins::NetworkPlugin,
+                  public SystemSingletonBase<NetClient>
+{
+    OVR_DECLARE_SINGLETON(NetClient);
+    virtual void OnThreadDestroy();
+
+    // Status
+    bool          LatencyTesterAvailable;
+    int           HMDCount;
+    bool          EdgeTriggeredHMDCount;
+
+    virtual void OnReceive(Net::ReceivePayload* pPayload, Net::ListenerReceiveResult* lrrOut);
+    virtual void OnDisconnected(Net::Connection* conn);
+    virtual void OnConnected(Net::Connection* conn);
+
+    virtual int  Run();
+
+public:
+    bool         Connect(bool blocking);
+    bool         IsConnected(bool attemptReconnect, bool blockOnReconnect);
+    void         Disconnect();
+
+    void         GetLocalProtocolVersion(int& major, int& minor, int& patch);
+    // This function may fail if it is not connected
+    bool         GetRemoteProtocolVersion(int& major, int& minor, int& patch);
+
+    void         SetLastError(String str);
+
+public:
+    // Persistent key-value storage
+    const char*  GetStringValue(VirtualHmdId hmd, const char* key, const char* default_val);
+    bool         GetBoolValue(VirtualHmdId hmd, const char* key, bool default_val);
+    int          GetIntValue(VirtualHmdId hmd, const char* key, int default_val);
+    double       GetNumberValue(VirtualHmdId hmd, const char* key, double default_val);
+    int          GetNumberValues(VirtualHmdId hmd, const char* key, double* values, int num_vals);
+
+    bool         SetStringValue(VirtualHmdId hmd, const char* key, const char* val);
+    bool         SetBoolValue(VirtualHmdId hmd, const char* key, bool val);
+    bool         SetIntValue(VirtualHmdId hmd, const char* key, int val);
+    bool         SetNumberValue(VirtualHmdId hmd, const char* key, double val);
+    bool         SetNumberValues(VirtualHmdId hmd, const char* key, const double* vals, int num_vals);
+
+    bool         GetDriverMode(bool& driverInstalled, bool& compatMode, bool& hideDK1Mode);
+    bool         SetDriverMode(bool compatMode, bool hideDK1Mode);
+
+	int          Hmd_Detect();
+	bool         Hmd_Create(int index, HMDNetworkInfo* netInfo);
+	void         Hmd_Release(VirtualHmdId hmd);
+
+	// Last string is cached locally.
+	const char*  Hmd_GetLastError(VirtualHmdId hmd);
+
+	// TBD: Replace with a function to return internal, original HMDInfo?
+
+	// Fills in description about HMD; this is the same as filled in by ovrHmd_Create.
+	// The actual descriptor is a par
+	bool         Hmd_GetHmdInfo(VirtualHmdId hmd, HMDInfo* hmdInfo);
+
+	//-------------------------------------------------------------------------------------
+	unsigned int Hmd_GetEnabledCaps(VirtualHmdId hmd);
+	// Returns new caps after modification
+	unsigned int Hmd_SetEnabledCaps(VirtualHmdId hmd, unsigned int hmdCaps);
+
+    // Updates driver render target
+    bool         Hmd_AttachToWindow(VirtualHmdId hmd, void* hWindow);
+
+	//-------------------------------------------------------------------------------------
+	// *** Tracking Setup
+
+	bool         Hmd_ConfigureTracking(VirtualHmdId hmd, unsigned supportedCaps, unsigned requiredCaps);	
+	void         Hmd_ResetTracking(VirtualHmdId hmd);
+
+	// TBD: Camera frames
+    bool         LatencyUtil_ProcessInputs(double startTestSeconds, unsigned char rgbColorOut[3]);
+    const char*  LatencyUtil_GetResultsString();
+
+    bool         ShutdownServer();
+
+protected:
+    String       Hmd_GetLastError_Str;
+    String       LatencyUtil_GetResultsString_Str;
+    String       ProfileGetValue1_Str, ProfileGetValue3_Str;
+
+protected:
+    //// Push Notifications:
+
+    void registerRPC();
+
+    ObserverScope<Net::Plugins::RPCSlot> InitialServerStateScope;
+    void InitialServerState_1(BitStream* userData, ReceivePayload* pPayload);
+
+    ObserverScope<Net::Plugins::RPCSlot> LatencyTesterAvailableScope;
+    void LatencyTesterAvailable_1(BitStream* userData, ReceivePayload* pPayload);
+
+    ObserverScope<Net::Plugins::RPCSlot> HMDCountUpdateScope;
+    void HMDCountUpdate_1(BitStream* userData, ReceivePayload* pPayload);
+};
+
+
+}} // namespace OVR::Service
+
+#endif // OVR_Service_NetClient_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Service/Service_NetSessionCommon.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,142 @@
+/************************************************************************************
+
+Filename    :   Service_NetSessionCommon.h
+Content     :   Shared networking for service
+Created     :   June 12, 2014
+Authors     :   Kevin Jenkins, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+************************************************************************************/
+
+#ifndef OVR_Service_NetSessionCommon_h
+#define OVR_Service_NetSessionCommon_h
+
+#include "../OVR_CAPI.h"
+#include "../Net/OVR_RPC1.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Net/OVR_BitStream.h"
+#include "../Kernel/OVR_System.h"
+
+namespace OVR {
+
+class HMDInfo;
+
+namespace Service {
+
+
+//-----------------------------------------------------------------------------
+// VirtualHmdId
+
+// This is an identifier that is unique to each VirtualHmd object on the server
+// side.  The client side uses this to opaquely reference those objects.
+
+typedef int32_t VirtualHmdId;
+static const int32_t InvalidVirtualHmdId = -1;
+
+// Localhost-bound TCP port that the service listens on for VR apps
+static const int VRServicePort = 30322; // 0x7672 = "vr" little-endian
+
+// HMDInfo section related to networking
+struct HMDNetworkInfo
+{
+	HMDNetworkInfo() :
+		NetId(InvalidVirtualHmdId)
+	{
+	}
+
+	// Network identifier for HMD
+	VirtualHmdId NetId;
+
+	// Name of the shared memory object
+	String       SharedMemoryName;
+
+	void Serialize(Net::BitStream* bs)
+	{
+		bs->Write(NetId);
+		bs->Write(SharedMemoryName);
+	}
+	bool Deserialize(Net::BitStream* bs)
+	{
+		bs->Read(NetId);
+		return bs->Read(SharedMemoryName);
+	}
+};
+
+
+//-------------------------------------------------------------------------------------
+// ***** NetSessionCommon
+
+// Common part networking session/RPC implementation shared between client and server.
+
+class NetSessionCommon : public Thread
+{
+protected:
+    virtual void onSystemDestroy();
+    virtual void onThreadDestroy();
+
+public:
+    NetSessionCommon();
+    virtual ~NetSessionCommon();
+
+	Net::Plugins::RPC1* GetRPC1() const
+    {
+        return pRPC;
+    }
+	Net::Session* GetSession() const
+    {
+        return pSession;
+    }
+
+	static void SerializeHMDInfo(Net::BitStream* bitStream, HMDInfo* hmdInfo);
+	static bool DeserializeHMDInfo(Net::BitStream* bitStream, HMDInfo* hmdInfo);
+
+public:
+    // Getter/setter tools
+    enum EGetterSetters
+    {
+        // Note: If this enumeration changes, then the Servce_NetSessionCommon.cpp
+        // IsServiceProperty() function should be updated.
+
+        EGetStringValue,
+        EGetBoolValue,
+        EGetIntValue,
+        EGetNumberValue,
+        EGetNumberValues,
+        ESetStringValue,
+        ESetBoolValue,
+        ESetIntValue,
+        ESetNumberValue,
+        ESetNumberValues,
+
+        ENumTypes
+    };
+
+    static const char* FilterKeyPrefix(const char* key);
+    static bool IsServiceProperty(EGetterSetters e, const char* key);
+
+protected:
+    bool                Terminated; // Thread termination flag
+    Net::Session*       pSession;   // Networking session
+	Net::Plugins::RPC1* pRPC;       // Remote procedure calls object
+};
+
+
+}} // namespace OVR::Service
+
+#endif // OVR_Service_NetSessionCommon_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_PoseState.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_PoseState.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,125 @@
+/************************************************************************************
+
+Filename    :   Tracking_PoseState.h
+Content     :   Describes the complete pose at a point in time, including derivatives
+Created     :   May 13, 2014
+Authors     :   Dov Katz
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_PoseState_h
+#define Tracking_PoseState_h
+
+#include "../Kernel/OVR_Math.h"
+
+namespace OVR {
+
+// PoseState describes the complete pose, or a rigid body configuration, at a
+// point in time, including first and second derivatives. It is used to specify
+// instantaneous location and movement of the headset.
+// SensorState is returned as a part of the sensor state.
+
+template<class T>
+class PoseState
+{
+public:
+	typedef typename CompatibleTypes<Pose<T> >::Type CompatibleType;
+
+	PoseState() : TimeInSeconds(0.0) { }
+    PoseState(Pose<T> pose, double time) : ThePose(pose), TimeInSeconds(time) { }
+
+	// float <-> double conversion constructor.
+	explicit PoseState(const PoseState<typename Math<T>::OtherFloatType> &src)
+		: ThePose(src.ThePose),
+		AngularVelocity(src.AngularVelocity), LinearVelocity(src.LinearVelocity),
+		AngularAcceleration(src.AngularAcceleration), LinearAcceleration(src.LinearAcceleration),
+		TimeInSeconds(src.TimeInSeconds)
+	{ }
+
+	// C-interop support: PoseStatef <-> ovrPoseStatef
+	PoseState(const typename CompatibleTypes<PoseState<T> >::Type& src)
+		: ThePose(src.ThePose),
+		AngularVelocity(src.AngularVelocity), LinearVelocity(src.LinearVelocity),
+		AngularAcceleration(src.AngularAcceleration), LinearAcceleration(src.LinearAcceleration),
+		TimeInSeconds(src.TimeInSeconds)
+	{ }
+
+	operator typename CompatibleTypes<PoseState<T> >::Type() const
+	{
+		typename CompatibleTypes<PoseState<T> >::Type result;
+		result.ThePose = ThePose;
+		result.AngularVelocity = AngularVelocity;
+		result.LinearVelocity = LinearVelocity;
+		result.AngularAcceleration = AngularAcceleration;
+		result.LinearAcceleration = LinearAcceleration;
+		result.TimeInSeconds = TimeInSeconds;
+		return result;
+	}
+
+	Pose<T> ThePose;
+	Vector3<T>  AngularVelocity;
+	Vector3<T>  LinearVelocity;
+	Vector3<T>  AngularAcceleration;
+	Vector3<T>  LinearAcceleration;
+	// Absolute time of this state sample; always a double measured in seconds.
+	double      TimeInSeconds;
+
+	// ***** Helpers for Pose integration
+
+	// Stores and integrates gyro angular velocity reading for a given time step.
+	void StoreAndIntegrateGyro(Vector3d angVel, double dt);
+	// Stores and integrates position/velocity from accelerometer reading for a given time step.
+	void StoreAndIntegrateAccelerometer(Vector3d linearAccel, double dt);
+
+	// Performs integration of state by adding next state delta to it
+	// to produce a combined state change
+	void AdvanceByDelta(const PoseState<T>& delta);
+};
+
+
+template<class T>
+PoseState<T> operator*(const OVR::Pose<T>& trans, const PoseState<T>& poseState)
+{
+	PoseState<T> result;
+	result.ThePose = trans * poseState.ThePose;
+	result.LinearVelocity = trans.Rotate(poseState.LinearVelocity);
+	result.LinearAcceleration = trans.Rotate(poseState.LinearAcceleration);
+	result.AngularVelocity = trans.Rotate(poseState.AngularVelocity);
+	result.AngularAcceleration = trans.Rotate(poseState.AngularAcceleration);
+	return result;
+}
+
+
+// External API returns pose as float, but uses doubles internally for quaternion precision.
+typedef PoseState<float>  PoseStatef;
+typedef PoseState<double> PoseStated;
+
+
+} // namespace OVR::Vision
+
+
+namespace OVR {
+
+	template<> struct CompatibleTypes<OVR::PoseState<float> > { typedef ovrPoseStatef Type; };
+	template<> struct CompatibleTypes<OVR::PoseState<double> > { typedef ovrPoseStated Type; };
+
+}
+
+#endif // Tracking_PoseState_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorState.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorState.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,188 @@
+/************************************************************************************
+
+Filename    :   Tracking_SensorState.h
+Content     :   Sensor state information shared by tracking system with games
+Created     :   May 13, 2014
+Authors     :   Dov Katz, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License");
+you may not use the Oculus VR Rift SDK except in compliance with the License,
+which is provided at the time of installation or download, or which
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_SensorState_h
+#define Tracking_SensorState_h
+
+#include "Tracking_PoseState.h"
+#include "../Kernel/OVR_SharedMemory.h"
+#include "../Kernel/OVR_Lockless.h"
+#include "../Kernel/OVR_String.h"
+#include "../Util/Util_LatencyTest2State.h"
+#include "../Sensors/OVR_DeviceConstants.h"
+
+// CAPI forward declarations.
+struct ovrTrackingState_;
+typedef struct ovrTrackingState_ ovrTrackingState;
+struct ovrPoseStatef_;
+typedef struct ovrPoseStatef_ ovrPoseStatef;
+
+namespace OVR { namespace Tracking {
+
+
+//-------------------------------------------------------------------------------------
+// ***** Sensor State
+// These values are reported as compatible with C API.
+
+// Bit flags describing the current status of sensor tracking.
+enum StatusBits
+{
+    // Tracked bits: Toggled by SensorFusion
+	Status_OrientationTracked = 0x0001, // Orientation is currently tracked (connected and in use)
+	Status_PositionTracked    = 0x0002, // Position is currently tracked (false if out of range)
+    Status_CameraPoseTracked  = 0x0004, // Camera pose is currently tracked
+
+    // Connected bits: Toggled by TrackingManager
+    Status_PositionConnected  = 0x0020, // Position tracking HW is connected
+	Status_HMDConnected       = 0x0080, // HMD is available & connected
+
+    // Masks
+    Status_AllMask = 0xffff,
+    Status_TrackingMask = Status_PositionTracked | Status_OrientationTracked | Status_CameraPoseTracked,
+    Status_ConnectedMask = Status_PositionConnected | Status_HMDConnected,
+};
+
+
+// Full state of of the sensor reported by GetSensorState() at a given absolute time.
+class TrackingState
+{
+public:
+	TrackingState() : StatusFlags(0) { }
+
+	// C-interop support
+	TrackingState(const ovrTrackingState& s);
+	operator ovrTrackingState () const;
+
+	// HMD pose information for the requested time.
+	PoseStatef   HeadPose;
+
+    // Orientation and position of the external camera, if present.
+    Posef        CameraPose;
+    // Orientation and position of the camera after alignment with gravity 
+    Posef        LeveledCameraPose;
+
+    // Most recent sensor data received from the HMD
+    SensorDataType RawSensorData;
+
+    // Sensor status described by ovrStatusBits.
+	uint32_t     StatusFlags;
+
+    //// 0.4.1
+
+    // Time spent processing the last vision frame
+    double LastVisionProcessingTime;
+};
+
+
+// -----------------------------------------------
+
+#pragma pack(push, 8)
+
+struct LocklessSensorStatePadding;
+
+// State version stored in lockless updater "queue" and used for 
+// prediction by GetPoseAtTime/GetSensorStateAtTime
+struct LocklessSensorState
+{
+	PoseState<double> WorldFromImu;
+    SensorDataType    RawSensorData;
+    Pose<double>      WorldFromCamera;
+	uint32_t          StatusFlags;
+    uint32_t          _PAD_0_;
+
+	// ImuFromCpf for HMD pose tracking
+	Posed             ImuFromCpf;
+    double            LastVisionProcessingTime;
+
+	// Initialized to invalid state
+	LocklessSensorState() :
+		StatusFlags(0)
+	{
+	}
+
+    LocklessSensorState& operator = (const LocklessSensorStatePadding& rhs);
+};
+    
+// Padded out version stored in the updater slots
+// Designed to be a larger fixed size to allow the data to grow in the future
+// without breaking older compiled code.
+struct LocklessSensorStatePadding
+{
+    uint64_t words[64];
+
+    static const int DataWords = (sizeof(LocklessSensorState) + sizeof(uint64_t) - 1) / sizeof(uint64_t);
+
+    // Just copy the low data words
+    inline LocklessSensorStatePadding& operator=(const LocklessSensorState& rhs)
+    {
+        const uint64_t* src = (const uint64_t*)&rhs;
+
+        // if this fires off, then increase words' array size
+        OVR_ASSERT(sizeof(words) > sizeof(LocklessSensorState));
+
+        for (int i = 0; i < DataWords; ++i)
+        {
+            words[i] = src[i];
+        }
+
+        return *this;
+    }
+};
+
+// Just copy the low data words
+inline LocklessSensorState& LocklessSensorState::operator = (const LocklessSensorStatePadding& rhs)
+{
+    uint64_t* dest = (uint64_t*)this;
+
+    for (int i = 0; i < LocklessSensorStatePadding::DataWords; ++i)
+    {
+        dest[i] = rhs.words[i];
+    }
+
+    return *this;
+}
+
+#pragma pack(pop)
+
+// A lockless updater for sensor state
+typedef LocklessUpdater<LocklessSensorState, LocklessSensorStatePadding> SensorStateUpdater;
+
+
+//// Combined state
+
+struct CombinedSharedStateUpdater
+{
+    SensorStateUpdater         SharedSensorState;
+    Util::LockessRecordUpdater SharedLatencyTestState;
+};
+
+typedef SharedObjectWriter< CombinedSharedStateUpdater > CombinedSharedStateWriter;
+typedef SharedObjectReader< CombinedSharedStateUpdater > CombinedSharedStateReader;
+
+
+}} // namespace OVR::Tracking
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Tracking/Tracking_SensorStateReader.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,80 @@
+/************************************************************************************
+
+Filename    :   Tracking_SensorStateReader.h
+Content     :   Separate reader component that is able to recover sensor pose
+Created     :   June 4, 2014
+Authors     :   Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef Tracking_SensorStateReader_h
+#define Tracking_SensorStateReader_h
+
+#include "../Kernel/OVR_Lockless.h"
+#include "Tracking_SensorState.h"
+
+#include "../OVR_Profile.h"
+
+namespace OVR { namespace Tracking {
+
+
+//-----------------------------------------------------------------------------
+// SensorStateReader
+
+// User interface to retrieve pose from the sensor fusion subsystem
+class SensorStateReader : public NewOverrideBase
+{
+protected:
+	const CombinedSharedStateUpdater *Updater;
+
+
+    // Last latency warning time
+    mutable double LastLatWarnTime;
+
+    // Transform from real-world coordinates to centered coordinates
+    Posed CenteredFromWorld; 
+
+public:
+	SensorStateReader();
+
+	// Initialize the updater
+    void         SetUpdater(const CombinedSharedStateUpdater *updater);
+
+	// Re-centers on the current yaw (optionally pitch) and translation
+	void		 RecenterPose();
+
+	// Get the full dynamical system state of the CPF, which includes velocities and accelerations,
+	// predicted at a specified absolute point in time.
+	bool		 GetSensorStateAtTime(double absoluteTime, Tracking::TrackingState& state) const;
+
+	// Get the predicted pose (orientation, position) of the center pupil frame (CPF) at a specific point in time.
+	bool		 GetPoseAtTime(double absoluteTime, Posef& transform) const;
+
+	// Get the sensor status (same as GetSensorStateAtTime(...).Status)
+	uint32_t     GetStatus() const;
+
+    void LoadProfileCenteredFromWorld(Profile* profile);
+    void SaveProfileCenteredFromWorld(Profile* profile);
+};
+
+
+}} // namespace OVR::Tracking
+
+#endif // Tracking_SensorStateReader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_ImageWindow.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,201 @@
+/************************************************************************************
+
+Filename    :   Util_ImageWindow.h
+Content     :   An output object for windows that can display raw images for testing
+Created     :   March 13, 2014
+Authors     :   Dean Beeler
+
+Copyright   :   Copyright 2014 Oculus, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef UTIL_IMAGEWINDOW_H
+#define UTIL_IMAGEWINDOW_H
+
+#if defined(OVR_OS_WIN32)
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <d2d1.h>
+#include <dwrite.h>
+#endif
+
+#include "../Kernel/OVR_Hash.h"
+#include "../Kernel/OVR_Array.h"
+#include "../Kernel/OVR_Threads.h"
+#include "../Kernel/OVR_Deque.h"
+
+#include <stdint.h>
+
+namespace OVR { namespace Util {
+
+	typedef struct 
+	{
+		float x;
+		float y;
+		float radius;
+		float r;
+		float g;
+		float b;
+		bool  fill;
+	} CirclePlot;
+
+	typedef struct  
+	{
+		float x;
+		float y;
+		float r;
+		float g;
+		float b;
+	OVR::String text;
+	} TextPlot;
+
+class Frame : virtual public RefCountBaseV<Frame>
+	{
+public:
+
+	Frame( int frame ) :
+		frameNumber( frame ),
+		imageData( NULL ),
+		colorImageData( NULL ),
+		plots(),
+		textLines(),
+		width( 0 ),
+		height( 0 ),
+		colorPitch( 0 ),
+		ready( false )
+	{
+
+	}
+
+	~Frame()
+	{
+		if( imageData )
+			free( imageData );
+		if( colorImageData )
+			free( colorImageData );
+
+		plots.ClearAndRelease();
+		textLines.ClearAndRelease();
+	}
+
+	int						frameNumber;
+
+		Array<CirclePlot> plots;
+	Array<TextPlot>			textLines;
+		void*			  imageData;
+		void*			  colorImageData;
+		int				  width;
+		int				  height;
+		int				  colorPitch;
+		bool			  ready;
+};
+
+#if defined(OVR_OS_WIN32)
+class ImageWindow
+{
+	HWND hWindow;
+	ID2D1RenderTarget* pRT;
+	D2D1_SIZE_U resolution;
+
+	Mutex*						frontBufferMutex;
+
+	InPlaceMutableDeque< Ptr<Frame> >	frames;
+
+	ID2D1Bitmap*				greyBitmap;
+	ID2D1Bitmap*				colorBitmap;
+    
+public:
+	// constructors
+	ImageWindow();
+	ImageWindow( uint32_t width, uint32_t height );
+	virtual ~ImageWindow();
+
+	void GetResolution( size_t& width, size_t& height ) { width = resolution.width; height = resolution.height; }
+
+	void OnPaint(); // Called by Windows when it receives a WM_PAINT message
+
+	void UpdateImage( const uint8_t* imageData, uint32_t width, uint32_t height ) { UpdateImageBW( imageData, width, height ); }
+	void UpdateImageBW( const uint8_t* imageData, uint32_t width, uint32_t height );
+	void UpdateImageRGBA( const uint8_t* imageData, uint32_t width, uint32_t height, uint32_t pitch );
+	void Complete(); // Called by drawing thread to submit a frame
+
+	void Process(); // Called by rendering thread to do window processing
+
+	void AssociateSurface( void* surface );
+
+	void addCircle( float x , float y, float radius, float r, float g, float b, bool fill );
+	void addText( float x, float y, float r, float g, float b, OVR::String text );
+
+	static ImageWindow*			GlobalWindow( int window ) { return globalWindow[window]; }
+	static int					WindowCount() { return windowCount; }
+
+private:
+
+	Ptr<Frame>					lastUnreadyFrame();
+
+	static const int			MaxWindows = 4;
+	static ImageWindow*			globalWindow[MaxWindows];
+	static int					windowCount;
+	static ID2D1Factory*		pD2DFactory;
+	static IDWriteFactory*		pDWriteFactory;
+};
+
+#else
+
+class ImageWindow
+{
+public:
+	// constructors
+	ImageWindow() {}
+	ImageWindow( uint32_t width, uint32_t height ) { OVR_UNUSED( width ); OVR_UNUSED( height ); }
+	virtual ~ImageWindow() { }
+
+	void GetResolution( size_t& width, size_t& height ) { width = 0; height = 0; }
+
+	void OnPaint() { }
+
+	void UpdateImage( const uint8_t* imageData, uint32_t width, uint32_t height ) { UpdateImageBW( imageData, width, height ); }
+	void UpdateImageBW( const uint8_t* imageData, uint32_t width, uint32_t height ) { OVR_UNUSED( imageData ); OVR_UNUSED( width ); OVR_UNUSED( height ); }
+	void UpdateImageRGBA( const uint8_t* imageData, uint32_t width, uint32_t height, uint32_t pitch ) { OVR_UNUSED( imageData ); OVR_UNUSED( width ); OVR_UNUSED( height ); OVR_UNUSED( pitch ); }
+	void Complete() { }
+
+	void Process() { }
+
+	void AssociateSurface( void* surface ) { OVR_UNUSED(surface); }
+
+	void addCircle( float x , float y, float radius, float r, float g, float b, bool fill ) { OVR_UNUSED( x ); OVR_UNUSED( y ); OVR_UNUSED( radius ); OVR_UNUSED( r ); OVR_UNUSED( g ); OVR_UNUSED( b ); OVR_UNUSED( fill ); }
+	void addText( float x, float y, float r, float g, float b, OVR::String text ) { OVR_UNUSED( x ); OVR_UNUSED( y ); OVR_UNUSED( r ); OVR_UNUSED( g ); OVR_UNUSED( b ); OVR_UNUSED( text ); }
+
+	static ImageWindow*			GlobalWindow( int window ) { return globalWindow[window]; }
+	static int					WindowCount() { return windowCount; }
+
+private:
+
+	static const int			MaxWindows = 4;
+	static ImageWindow*			globalWindow[4];
+	static int					windowCount;
+};
+
+#endif
+
+}} // namespace OVR::Util
+
+
+#endif
\ No newline at end of file
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Interface.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,36 @@
+/************************************************************************************
+
+Filename    :   Util_Interface.h
+Content     :   Simple interface, utilised by internal demos,
+				with access to wider SDK as needed. 
+				Located in the body of the SDK to ensure updated
+				when new SDK features are added.
+Created     :   February 20, 2014
+Authors     :   Tom Heath
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_Interface_h
+#define OVR_Util_Interface_h
+#include "../OVR_CAPI.h"
+
+//Files left in to ease its possible return......
+
+#endif
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2Reader.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,63 @@
+/************************************************************************************
+
+Filename    :   Util_LatencyTest2Reader.h
+Content     :   Shared functionality for the DK2 latency tester
+Created     :   July 8, 2014
+Authors     :   Volga Aksoy, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_LatencyTest2Reader_h
+#define OVR_Util_LatencyTest2Reader_h
+
+#include "../Tracking/Tracking_SensorState.h"
+#include "Util_LatencyTest2State.h"
+
+namespace OVR { namespace Util {
+
+
+//-----------------------------------------------------------------------------
+// RecordStateReader
+
+// User interface to retrieve pose from the sensor fusion subsystem
+class RecordStateReader : public NewOverrideBase
+{
+protected:
+    const Tracking::CombinedSharedStateUpdater* Updater;
+
+public:
+    RecordStateReader()
+        : Updater(NULL)
+    {
+    }
+
+    // Initialize the updater
+    void SetUpdater(const Tracking::CombinedSharedStateUpdater *updater)
+    {
+        Updater = updater;
+    }
+
+    void GetRecordSet(FrameTimeRecordSet& recordset);
+};
+
+
+}} // namespace OVR::Util
+
+#endif // OVR_Util_LatencyTest2Reader_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2State.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_LatencyTest2State.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,96 @@
+/************************************************************************************
+
+Filename    :   Util_LatencyTest2Reader.h
+Content     :   Shared functionality for the DK2 latency tester
+Created     :   July 8, 2014
+Authors     :   Volga Aksoy, Chris Taylor
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_LatencyTest2_State_h
+#define OVR_Util_LatencyTest2_State_h
+
+#include "../Kernel/OVR_Lockless.h"
+
+namespace OVR { namespace Util {
+
+
+enum LatencyTester2Constants
+{
+    LT2_ColorIncrement                  = 32,
+    LT2_PixelTestThreshold              = LT2_ColorIncrement / 3,
+    LT2_IncrementCount                  = 256 / LT2_ColorIncrement,
+    LT2_TimeoutWaitingForColorDetected  = 1000  // 1 second
+};
+
+
+//-------------------------------------------------------------------------------------
+// FrameTimeRecord
+
+// Describes frame scan-out time used for latency testing.
+struct FrameTimeRecord
+{
+    int    ReadbackIndex;
+    double TimeSeconds;
+
+    // Utility functions to convert color to readBack indices and back.
+    // The purpose of ReadbackIndex is to allow direct comparison by value.
+
+    static bool ColorToReadbackIndex(int *readbackIndex, unsigned char color);
+    static unsigned char ReadbackIndexToColor(int readbackIndex);
+};
+
+
+//-----------------------------------------------------------------------------
+// FrameTimeRecordSet
+
+// FrameTimeRecordSet is a container holding multiple consecutive frame timing records
+// returned from the lock-less state. Used by FrameTimeManager. 
+struct FrameTimeRecordSet
+{
+    enum {
+        RecordCount = 4,
+        RecordMask  = RecordCount - 1
+    };
+    FrameTimeRecord Records[RecordCount];    
+    int             NextWriteIndex;
+
+    FrameTimeRecordSet();
+
+    void AddValue(int readValue, double timeSeconds);
+    // Matching should be done starting from NextWrite index 
+    // until wrap-around
+
+    const FrameTimeRecord& operator [] (int i) const;
+
+    const FrameTimeRecord& GetMostRecentFrame();
+
+    // Advances I to  absolute color index
+    bool FindReadbackIndex(int* i, int readbackIndex) const;
+
+    bool IsAllZeroes() const;
+};
+
+typedef LocklessUpdater<FrameTimeRecordSet, FrameTimeRecordSet> LockessRecordUpdater;
+
+
+}} // namespace OVR::Util
+
+#endif // OVR_Util_LatencyTest2_State_h
--- ../../../../UE4-QA/Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Engine/Source/ThirdParty/Oculus/LibOVR_04/Src/Util/Util_Render_Stereo.h	2014-09-03 00:33:48.000000000 -0400
@@ -0,0 +1,490 @@
+/************************************************************************************
+
+Filename    :   Util_Render_Stereo.h
+Content     :   Sample stereo rendering configuration classes.
+Created     :   October 22, 2012
+Authors     :   Michael Antonov, Tom Forsyth
+
+Copyright   :   Copyright 2014 Oculus VR, Inc. All Rights reserved.
+
+Licensed under the Oculus VR Rift SDK License Version 3.1 (the "License"); 
+you may not use the Oculus VR Rift SDK except in compliance with the License, 
+which is provided at the time of installation or download, or which 
+otherwise accompanies this software in either electronic or hard copy form.
+
+You may obtain a copy of the License at
+
+http://www.oculusvr.com/licenses/LICENSE-3.1 
+
+Unless required by applicable law or agreed to in writing, the Oculus VR SDK 
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*************************************************************************************/
+
+#ifndef OVR_Util_Render_Stereo_h
+#define OVR_Util_Render_Stereo_h
+
+#include "../OVR_Stereo.h"
+#include "../Tracking/Tracking_SensorStateReader.h"
+
+namespace OVR { namespace Util { namespace Render {
+
+
+
+//-----------------------------------------------------------------------------------
+// **** Useful debug functions.
+//
+// Purely for debugging - the results are not very end-user-friendly.
+char const* GetDebugNameEyeCupType ( EyeCupType eyeCupType );
+char const* GetDebugNameHmdType ( HmdTypeEnum hmdType );
+
+
+
+//-----------------------------------------------------------------------------------
+// **** Higher-level utility functions.
+
+Sizei CalculateRecommendedTextureSize    ( HmdRenderInfo const &hmd,
+                                           bool bRendertargetSharedByBothEyes,
+                                           float pixelDensityInCenter = 1.0f );
+
+FovPort CalculateRecommendedFov          ( HmdRenderInfo const &hmd,
+                                           StereoEye eyeType,
+                                           bool bMakeFovSymmetrical = false);
+
+StereoEyeParams CalculateStereoEyeParams ( HmdRenderInfo const &hmd,
+                                           StereoEye eyeType,
+                                           Sizei const &actualRendertargetSurfaceSize,
+                                           bool bRendertargetSharedByBothEyes,
+                                           bool bRightHanded = true,
+                                           float zNear = 0.01f, float zFar = 10000.0f,
+										   Sizei const *pOverrideRenderedPixelSize = NULL,
+                                           FovPort const *pOverrideFovport = NULL,
+                                           float zoomFactor = 1.0f );
+
+Vector3f CalculateEyeVirtualCameraOffset(HmdRenderInfo const &hmd,
+                                         StereoEye eyeType, bool bMonoRenderingMode );
+
+
+// These are two components from StereoEyeParams that can be changed
+// very easily without full recomputation of everything.
+struct ViewportScaleAndOffset
+{
+    Recti               RenderedViewport;
+    ScaleAndOffset2D    EyeToSourceUV;
+};
+
+// Three ways to override the size of the render view dynamically.
+// None of these require changing the distortion parameters or the regenerating the distortion mesh,
+// and can be called every frame if desired.
+ViewportScaleAndOffset ModifyRenderViewport ( StereoEyeParams const &params,
+                                              Sizei const &actualRendertargetSurfaceSize,
+                                              Recti const &renderViewport );
+
+ViewportScaleAndOffset ModifyRenderSize ( StereoEyeParams const &params,
+                                          Sizei const &actualRendertargetSurfaceSize,
+                                          Sizei const &requestedRenderSize,
+                                          bool bRendertargetSharedByBothEyes = false );
+
+ViewportScaleAndOffset ModifyRenderDensity ( StereoEyeParams const &params,
+                                             Sizei const &actualRendertargetSurfaceSize,
+                                             float pixelDensity = 1.0f,
+                                             bool bRendertargetSharedByBothEyes = false );
+
+
+//-----------------------------------------------------------------------------------
+// *****  StereoConfig
+
+// StereoConfig maintains a scene stereo state and allow switching between different
+// stereo rendering modes. To support rendering, StereoConfig keeps track of HMD
+// variables such as screen size, eye-to-screen distance and distortion, and computes
+// extra data such as FOV and distortion center offsets based on it. Rendering
+// parameters are returned though StereoEyeParams for each eye.
+//
+// Beyond regular 3D projection, this class supports rendering a 2D orthographic
+// surface for UI and text. The 2D surface will be defined by CreateOrthoSubProjection().
+// The (0,0) coordinate corresponds to eye center location.
+// 
+// Applications are not required to use this class, but they should be doing very
+// similar sequences of operations, and it may be useful to start with this class
+// and modify it.
+
+struct StereoEyeParamsWithOrtho
+{
+    StereoEyeParams         StereoEye;
+    Matrix4f                OrthoProjection;
+};
+
+struct ViewportScaleAndOffsetBothEyes
+{
+    ViewportScaleAndOffset  Left;
+    ViewportScaleAndOffset  Right;
+};
+
+class StereoConfig
+{
+public:
+
+    // StereoMode describes rendering modes that can be used by StereoConfig.
+    // These modes control whether stereo rendering is used or not (Stereo_None),
+    // and how it is implemented.
+    enum StereoMode
+    {
+        Stereo_None                     = 0,        // Single eye
+        Stereo_LeftRight_Multipass      = 1,        // One frustum per eye
+    };
+
+
+    StereoConfig(StereoMode mode = Stereo_LeftRight_Multipass);
+ 
+    //---------------------------------------------------------------------------------------------
+    // *** Core functions - every app MUST call these functions at least once.
+
+    // Sets HMD parameters; also initializes distortion coefficients.
+    void        SetHmdRenderInfo(const HmdRenderInfo& hmd);
+
+    // Set the physical size of the rendertarget surface the app created,
+    // and whether one RT is shared by both eyes, or each eye has its own RT:
+    // true: both eyes are rendered to the same RT. Left eye starts at top-left, right eye starts at top-middle.
+    // false: each eye is rendered to its own RT. Some GPU architectures prefer this arrangement.
+    // Typically, the app would call CalculateRecommendedTextureSize() to suggest the choice of RT size.
+    // This setting must be exactly the size of the actual RT created, or the UVs produced will be incorrect.
+    // If the app wants to render to a subsection of the RT, it should use SetRenderSize()
+    void        SetRendertargetSize (Size<int> const rendertargetSize,
+                                     bool rendertargetIsSharedByBothEyes );
+
+    // Returns full set of Stereo rendering parameters for the specified eye.
+    const StereoEyeParamsWithOrtho& GetEyeRenderParams(StereoEye eye);
+
+
+
+    //---------------------------------------------------------------------------------------------
+    // *** Optional functions - an app may call these to override default behaviours.
+
+    const HmdRenderInfo& GetHmdRenderInfo() const { return Hmd; }
+
+    // Returns the recommended size of rendertargets.
+    // If rendertargetIsSharedByBothEyes is true, this is the size of the combined buffer.
+    // If rendertargetIsSharedByBothEyes is false, this is the size of each individual buffer.
+    // pixelDensityInCenter may be set to any number - by default it will match the HMD resolution in the center of the image.
+    // After creating the rendertargets, the application MUST call SetRendertargetSize() with the actual size created
+    // (which can be larger or smaller as the app wishes, but StereoConfig needs to know either way)
+    Sizei       CalculateRecommendedTextureSize ( bool rendertargetSharedByBothEyes,
+                                                  float pixelDensityInCenter = 1.0f );
+
+    // Sets a stereo rendering mode and updates internal cached
+    // state (matrices, per-eye view) based on it.
+    void        SetStereoMode(StereoMode mode)  { Mode = mode; DirtyFlag = true; }
+    StereoMode  GetStereoMode() const           { return Mode; }
+
+    // Sets the fieldOfView that the 2D coordinate area stretches to.
+    void        Set2DAreaFov(float fovRadians);
+
+    // Really only for science experiments - no normal app should ever need to override
+    // the HMD's lens descriptors. Passing NULL removes the override.
+    // Supply both = set left and right.
+    // Supply just left = set both to the same.
+    // Supply neither = remove override.
+    void        SetLensOverride ( LensConfig const *pLensOverrideLeft  = NULL,
+                                  LensConfig const *pLensOverrideRight = NULL );
+ 
+    // Override the rendered FOV in various ways. All angles in tangent units.
+    // This is not clamped to the physical FOV of the display - you'll need to do that yourself!
+    // Supply both = set left and right.
+    // Supply just left = set both to the same.
+    // Supply neither = remove override.
+    void        SetFov ( FovPort const *pfovLeft  = NULL,
+					     FovPort const *pfovRight = NULL );
+    
+    void        SetFovPortRadians ( float horizontal, float vertical )
+    {
+        FovPort fov = FovPort::CreateFromRadians(horizontal, vertical);
+        SetFov( &fov, &fov );
+    }
+
+
+    // This forces a "zero IPD" mode where there is just a single render with an FOV that
+    //   is the union of the two calculated FOVs.
+    // The calculated render is for the left eye. Any size & FOV overrides for the right
+    //   eye will be ignored.
+    // If you query the right eye's size, you will get the same render
+    //   size & position as the left eye - you should not actually do the render of course!
+    //   The distortion values will be different, because it goes to a different place on the framebuffer.
+    // Note that if you do this, the rendertarget does not need to be twice the width of
+    //   the render size any more.
+    void        SetZeroVirtualIpdOverride ( bool enableOverride );
+
+    // Allows the app to specify near and far clip planes and the right/left-handedness of the projection matrix.
+    void        SetZClipPlanesAndHandedness ( float zNear = 0.01f, float zFar = 10000.0f,
+                                              bool rightHandedProjection = true );
+
+    // Allows the app to specify how much extra eye rotation to allow when determining the visible FOV.
+    void        SetExtraEyeRotation ( float extraEyeRotationInRadians = 0.0f );
+
+    // The dirty flag is set by any of the above calls. Just handy for the app to know
+    // if e.g. the distortion mesh needs regeneration.
+    void        SetDirty() { DirtyFlag = true; }
+    bool        IsDirty() { return DirtyFlag; }
+
+    // An app never needs to call this - GetEyeRenderParams will call it internally if
+    // the state is dirty. However apps can call this explicitly to control when and where
+    // computation is performed (e.g. not inside critical loops)
+    void        UpdateComputedState();
+
+    // This returns the projection matrix with a "zoom". Does not modify any internal state.
+    Matrix4f    GetProjectionWithZoom ( StereoEye eye, float fovZoom ) const;
+
+
+    //---------------------------------------------------------------------------------------------
+    // The SetRender* functions are special.
+    //
+    // They do not require a full recalculation of state, and they do not change anything but the
+    // ViewportScaleAndOffset data for the eyes (which they return), and do not set the dirty flag!
+    // This means they can be called without regenerating the distortion mesh, and thus 
+    // can happily be called every frame without causing performance problems. Dynamic rescaling 
+    // of the rendertarget can help keep framerate up in demanding VR applications.
+    // See the documentation for more details on their use.
+
+    // Specify a pixel density - how many rendered pixels per pixel in the physical display.
+    ViewportScaleAndOffsetBothEyes SetRenderDensity ( float pixelsPerDisplayPixel );
+
+    // Supply the size directly. Will be clamped to the physical rendertarget size.
+    ViewportScaleAndOffsetBothEyes SetRenderSize ( Sizei const &renderSizeLeft, Sizei const &renderSizeRight );
+
+    // Supply the viewport directly. This is not clamped to the physical rendertarget - careful now!
+    ViewportScaleAndOffsetBothEyes SetRenderViewport ( Recti const &renderViewportLeft, Recti const &renderViewportRight );
+
+private:
+
+    // *** Modifiable State
+
+    StereoMode         Mode;
+    HmdRenderInfo      Hmd;
+
+    float              Area2DFov;           // FOV range mapping to the 2D area.
+
+    // Only one of these three overrides can be true!
+    enum SetViewportModeEnum
+    {
+        SVPM_Density,
+        SVPM_Size,
+        SVPM_Viewport,
+    }                  SetViewportMode;
+    // ...and depending which it is, one of the following are used.
+    float              SetViewportPixelsPerDisplayPixel;
+    Sizei              SetViewportSize[2];
+    Recti           SetViewport[2];
+
+    // Other overrides.
+    bool               OverrideLens;
+    LensConfig         LensOverrideLeft;
+    LensConfig         LensOverrideRight;
+    Sizei              RendertargetSize;
+    bool               OverrideTanHalfFov;
+    FovPort            FovOverrideLeft;
+    FovPort            FovOverrideRight;
+    bool               OverrideZeroIpd;
+    float              ZNear;
+    float              ZFar;
+    float              ExtraEyeRotationInRadians;
+    bool               IsRendertargetSharedByBothEyes;
+    bool               RightHandedProjection;
+
+    bool               DirtyFlag;   // Set when any if the modifiable state changed. Does NOT get set by SetRender*()
+
+    // Utility function.
+    ViewportScaleAndOffsetBothEyes setupViewportScaleAndOffsets();
+
+    // *** Computed State
+
+public:     // Small hack for the config tool. Normal code should never read EyeRenderParams directly - use GetEyeRenderParams() instead.
+    // 0/1 = left/right main views.
+    StereoEyeParamsWithOrtho    EyeRenderParams[2];
+};
+
+
+//-----------------------------------------------------------------------------------
+// *****  Distortion Mesh Rendering
+//
+
+// Stores both texture UV coords, or tan(angle) values.
+// Use whichever set of data the specific distortion algorithm requires.
+// This struct *must* be binary compatible with CAPI ovrDistortionVertex.
+struct DistortionMeshVertexData
+{
+    // [-1,+1],[-1,+1] over the entire framebuffer.
+    Vector2f    ScreenPosNDC;
+    // [0.0-1.0] interpolation value for timewarping - see documentation for details.
+    float       TimewarpLerp;
+    // [0.0-1.0] fade-to-black at the edges to reduce peripheral vision noise.
+    float       Shade;        
+    // The red, green, and blue vectors in tan(angle) space.
+    // Scale and offset by the values in StereoEyeParams.EyeToSourceUV.Scale
+    // and StereoParams.EyeToSourceUV.Offset to get to real texture UV coords.
+    Vector2f    TanEyeAnglesR;
+    Vector2f    TanEyeAnglesG;
+    Vector2f    TanEyeAnglesB;    
+};
+
+
+void DistortionMeshCreate ( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                            int *pNumVertices, int *pNumTriangles,
+                            const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo );
+
+// Generate distortion mesh for a eye. This version requires less data then stereoParms, supporting
+// dynamic change in render target viewport.
+void DistortionMeshCreate( DistortionMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+                           int *pNumVertices, int *pNumTriangles,
+                           bool rightEye,
+                           const HmdRenderInfo &hmdRenderInfo, 
+                           const DistortionRenderDesc &distortion, const ScaleAndOffset2D &eyeToSourceNDC );
+
+void DistortionMeshDestroy ( DistortionMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices );
+
+
+//-----------------------------------------------------------------------------------
+// *****  Heightmap Mesh Rendering
+//
+
+// Stores both texture UV coords, or tan(angle) values.
+// This struct *must* be binary compatible with CAPI ovrHeightmapVertex.
+struct HeightmapMeshVertexData
+{
+    // [-1,+1],[-1,+1] over the entire framebuffer.
+    Vector2f    ScreenPosNDC;
+    // [0.0-1.0] interpolation value for timewarping - see documentation for details.
+    float       TimewarpLerp;
+    // The vectors in tan(angle) space.
+    // Scale and offset by the values in StereoEyeParams.EyeToSourceUV.Scale
+    // and StereoParams.EyeToSourceUV.Offset to get to real texture UV coords.
+    Vector2f    TanEyeAngles;    
+};
+
+
+void HeightmapMeshCreate ( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles,
+    const StereoEyeParams &stereoParams, const HmdRenderInfo &hmdRenderInfo );
+
+// Generate heightmap mesh for a eye. This version requires less data then stereoParms, supporting
+// dynamic change in render target viewport.
+void HeightmapMeshCreate( HeightmapMeshVertexData **ppVertices, uint16_t **ppTriangleListIndices,
+    int *pNumVertices, int *pNumTriangles, bool rightEye,
+    const HmdRenderInfo &hmdRenderInfo, const ScaleAndOffset2D &eyeToSourceNDC );
+
+void HeightmapMeshDestroy ( HeightmapMeshVertexData *pVertices, uint16_t *pTriangleMeshIndices );
+
+
+
+//-----------------------------------------------------------------------------------
+// ***** Prediction and timewarp.
+//
+
+struct PredictionValues
+{
+    // All values in seconds.
+    // These are the times in seconds from a present+flush to the relevant display element.
+    // The time is measured to the middle of that element's visibility window,
+    // e.g. if the device is a full-persistence display, the element will be visible for
+    // an entire frame, so the time measures to the middle of that period, i.e. half the frame time.
+    float PresentFlushToRenderedScene;        // To the overall rendered 3D scene being visible.
+    float PresentFlushToTimewarpStart;        // To when the first timewarped scanline will be visible.
+    float PresentFlushToTimewarpEnd;          // To when the last timewarped scanline will be visible.
+    float PresentFlushToPresentFlush;         // To the next present+flush, i.e. the ideal framerate.
+
+    bool  WithTimewarp;
+    bool  WithVsync;
+};
+
+// Calculates the values from the HMD info.
+PredictionValues PredictionGetDeviceValues ( const HmdRenderInfo &hmdRenderInfo,
+                                             bool withTimewarp = true,
+                                             bool withVsync = true );
+
+// Pass in an orientation used to render the scene, and then the predicted orientation
+// (which may have been computed later on, and thus is more accurate), and this
+// will return the matrix to pass to the timewarp distortion shader.
+// TODO: deal with different handedness?
+Matrix4f TimewarpComputePoseDelta ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust );
+Matrix4f TimewarpComputePoseDeltaPosition ( Matrix4f const &renderedViewFromWorld, Matrix4f const &predictedViewFromWorld, Matrix4f const&eyeViewAdjust );
+
+
+
+// TimewarpMachine helps keep track of rendered frame timing and
+// handles predictions for time-warp rendering.
+class TimewarpMachine
+{
+public:
+    TimewarpMachine();
+   
+    // Call this on and every time something about the setup changes.
+    void        Reset ( HmdRenderInfo& renderInfo, bool vsyncEnabled, double timeNow );
+
+    // The only reliable time in most engines is directly after the frame-present and GPU flush-and-wait.
+    // This call should be done right after that to give this system the timing info it needs.
+    void        AfterPresentAndFlush(double timeNow);
+
+    // The "average" time the rendered frame will show up,
+    // and the predicted pose of the HMD at that time.
+    // You usually only need to call one of these functions.
+    double      GetViewRenderPredictionTime();
+    bool        GetViewRenderPredictionPose(Tracking::SensorStateReader* reader, Posef& transform);
+
+
+    // Timewarp prediction functions. You usually only need to call one of these three sets of functions.
+
+    // The predicted times that the first and last pixel will be visible on-screen.
+    double      GetVisiblePixelTimeStart();
+    double      GetVisiblePixelTimeEnd();
+    // Predicted poses of the HMD at those first and last pixels.
+	bool        GetPredictedVisiblePixelPoseStart(Tracking::SensorStateReader* reader, Posef& transform);
+	bool        GetPredictedVisiblePixelPoseEnd(Tracking::SensorStateReader* reader, Posef& transform);
+    // The delta matrices to feed to the timewarp distortion code,
+    // given the pose that was used for rendering.
+    // (usually the one returned by GetViewRenderPredictionPose() earlier)
+	bool        GetTimewarpDeltaStart(Tracking::SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform);
+	bool        GetTimewarpDeltaEnd(Tracking::SensorStateReader* reader, Posef const &renderedPose, Matrix4f& transform);
+
+    // Just-In-Time distortion aims to delay the second sensor reading & distortion
+    // until the very last moment to improve prediction. However, it is a little scary,
+    // since the delay might wait too long and miss the vsync completely!
+    // Use of the JustInTime_* functions is entirely optional, and we advise allowing
+    // users to turn it off in their video options to cope with odd machine configurations.
+
+    // What time should the app wait until before starting distortion?
+    double      JustInTime_GetDistortionWaitUntilTime();
+
+    // Used to time the distortion rendering
+    bool        JustInTime_NeedDistortionTimeMeasurement() const;
+    void        JustInTime_BeforeDistortionTimeMeasurement(double timeNow);
+    void        JustInTime_AfterDistortionTimeMeasurement(double timeNow);
+
+private:
+    bool                VsyncEnabled;
+    HmdRenderInfo       RenderInfo;
+    PredictionValues    CurrentPredictionValues;
+
+    enum { NumDistortionTimes = 10 };
+    int                 DistortionTimeCount;
+    double              DistortionTimeCurrentStart;
+    float               DistortionTimes[NumDistortionTimes];
+    float               DistortionTimeAverage;
+
+    // Pose at which last time the eye was rendered.
+    Posef               EyeRenderPoses[2];
+
+    // Absolute time of the last present+flush
+    double              LastFramePresentFlushTime;
+    // Seconds between present+flushes
+    float               PresentFlushToPresentFlushSeconds;
+    // Predicted absolute time of the next present+flush
+    double              NextFramePresentFlushTime;
+
+};
+
+
+
+}}}  // OVR::Util::Render
+
+#endif
--- ../../../../UE4-QA/Engine/Config/BaseEngine.ini	2014-09-05 02:23:50.706348200 -0400
+++ ./Engine/Config/BaseEngine.ini	2014-08-26 15:35:37.860365700 -0400
@@ -219,6 +219,8 @@
 +ActiveClassRedirects=(OldClassName="PhysicsHingeActor",NewClassName="PhysicsConstraintActor")
 +ActiveClassRedirects=(OldClassName="PhysicsPrismaticActor",NewClassName="PhysicsConstraintActor")
 
++ActiveClassRedirects=(OldClassName="EMovementMode",NewClassName="/Script/Engine.EngineTypes:EMovementMode")
+
 +ActiveClassRedirects=(OldClassName="SensingComponent",NewClassName="PawnSensingComponent")
 +ActiveClassRedirects=(OldClassName="MovementComp_Character",NewClassName="CharacterMovementComponent")
 +ActiveClassRedirects=(OldClassName="MovementComp_Rotating",NewClassName="RotatingMovementComponent")
